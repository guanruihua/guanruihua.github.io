/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 16:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);
/* harmony import */ var _css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.au-form-item{margin-bottom:12px}.au-form-item-label{display:block;margin-right:4px;margin-bottom:8px}.au-form-item.au-form-item-error-status .au-form-item-control{border:none;padding:0;margin:0}.au-form-item.au-form-item-error-status .au-form-item-control>*{border-color:#eb2323;box-shadow:#eb2323 0 0 3px}.au-form-item.au-form-item-error-status .au-form-item-control>*:hover,.au-form-item.au-form-item-error-status .au-form-item-control>*:active{border-color:#eb2323;box-shadow:#eb2323 0 0 3px}.au-form-item.au-form-item-error-status .au-form-item-error-status-message{font-size:smaller;color:#eb2323}:root{--rc-drag-handle-size: 12px;--rc-drag-handle-mobile-size: 24px;--rc-drag-handle-bg-colour: rgba(0, 0, 0, .2);--rc-drag-bar-size: 6px;--rc-border-color: rgba(255, 255, 255, .7);--rc-focus-color: #0088ff}.ReactCrop{position:relative;display:inline-block;cursor:crosshair;max-width:100%}.ReactCrop *,.ReactCrop *:before,.ReactCrop *:after{box-sizing:border-box}.ReactCrop--disabled,.ReactCrop--locked{cursor:inherit}.ReactCrop__child-wrapper{overflow:hidden;max-height:inherit}.ReactCrop__child-wrapper>img,.ReactCrop__child-wrapper>video{display:block;max-width:100%;max-height:inherit}.ReactCrop:not(.ReactCrop--disabled) .ReactCrop__child-wrapper>img,.ReactCrop:not(.ReactCrop--disabled) .ReactCrop__child-wrapper>video{touch-action:none}.ReactCrop:not(.ReactCrop--disabled) .ReactCrop__crop-selection{touch-action:none}.ReactCrop__crop-mask{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.ReactCrop__crop-selection{position:absolute;top:0;left:0;transform:translateZ(0);cursor:move}.ReactCrop--disabled .ReactCrop__crop-selection{cursor:inherit}.ReactCrop--circular-crop .ReactCrop__crop-selection{border-radius:50%}.ReactCrop--circular-crop .ReactCrop__crop-selection:after{pointer-events:none;content:"";position:absolute;top:-1px;right:-1px;bottom:-1px;left:-1px;border:1px solid var(--rc-border-color);opacity:.3}.ReactCrop--no-animate .ReactCrop__crop-selection{outline:1px dashed white}.ReactCrop__crop-selection:not(.ReactCrop--no-animate .ReactCrop__crop-selection){animation:marching-ants 1s;background-image:linear-gradient(to right,#fff 50%,#444 50%),linear-gradient(to right,#fff 50%,#444 50%),linear-gradient(to bottom,#fff 50%,#444 50%),linear-gradient(to bottom,#fff 50%,#444 50%);background-size:10px 1px,10px 1px,1px 10px,1px 10px;background-position:0 0,0 100%,0 0,100% 0;background-repeat:repeat-x,repeat-x,repeat-y,repeat-y;color:#fff;animation-play-state:running;animation-timing-function:linear;animation-iteration-count:infinite}@keyframes marching-ants{0%{background-position:0 0,0 100%,0 0,100% 0}to{background-position:20px 0,-20px 100%,0 -20px,100% 20px}}.ReactCrop__crop-selection:focus{outline:2px solid var(--rc-focus-color);outline-offset:-1px}.ReactCrop--invisible-crop .ReactCrop__crop-mask,.ReactCrop--invisible-crop .ReactCrop__crop-selection{display:none}.ReactCrop__rule-of-thirds-vt:before,.ReactCrop__rule-of-thirds-vt:after,.ReactCrop__rule-of-thirds-hz:before,.ReactCrop__rule-of-thirds-hz:after{content:"";display:block;position:absolute;background-color:rgba(255,255,255,.4)}.ReactCrop__rule-of-thirds-vt:before,.ReactCrop__rule-of-thirds-vt:after{width:1px;height:100%}.ReactCrop__rule-of-thirds-vt:before{left:33.3333333333%}.ReactCrop__rule-of-thirds-vt:after{left:66.6666666667%}.ReactCrop__rule-of-thirds-hz:before,.ReactCrop__rule-of-thirds-hz:after{width:100%;height:1px}.ReactCrop__rule-of-thirds-hz:before{top:33.3333333333%}.ReactCrop__rule-of-thirds-hz:after{top:66.6666666667%}.ReactCrop__drag-handle{position:absolute;width:var(--rc-drag-handle-size);height:var(--rc-drag-handle-size);background-color:var(--rc-drag-handle-bg-colour);border:1px solid var(--rc-border-color)}.ReactCrop__drag-handle:focus{background:var(--rc-focus-color)}.ReactCrop .ord-nw{top:0;left:0;transform:translate(-50%,-50%);cursor:nw-resize}.ReactCrop .ord-n{top:0;left:50%;transform:translate(-50%,-50%);cursor:n-resize}.ReactCrop .ord-ne{top:0;right:0;transform:translate(50%,-50%);cursor:ne-resize}.ReactCrop .ord-e{top:50%;right:0;transform:translate(50%,-50%);cursor:e-resize}.ReactCrop .ord-se{bottom:0;right:0;transform:translate(50%,50%);cursor:se-resize}.ReactCrop .ord-s{bottom:0;left:50%;transform:translate(-50%,50%);cursor:s-resize}.ReactCrop .ord-sw{bottom:0;left:0;transform:translate(-50%,50%);cursor:sw-resize}.ReactCrop .ord-w{top:50%;left:0;transform:translate(-50%,-50%);cursor:w-resize}.ReactCrop__disabled .ReactCrop__drag-handle{cursor:inherit}.ReactCrop__drag-bar{position:absolute}.ReactCrop__drag-bar.ord-n{top:0;left:0;width:100%;height:var(--rc-drag-bar-size);transform:translateY(-50%)}.ReactCrop__drag-bar.ord-e{right:0;top:0;width:var(--rc-drag-bar-size);height:100%;transform:translate(50%)}.ReactCrop__drag-bar.ord-s{bottom:0;left:0;width:100%;height:var(--rc-drag-bar-size);transform:translateY(50%)}.ReactCrop__drag-bar.ord-w{top:0;left:0;width:var(--rc-drag-bar-size);height:100%;transform:translate(-50%)}.ReactCrop--new-crop .ReactCrop__drag-bar,.ReactCrop--new-crop .ReactCrop__drag-handle,.ReactCrop--fixed-aspect .ReactCrop__drag-bar,.ReactCrop--fixed-aspect .ReactCrop__drag-handle.ord-n,.ReactCrop--fixed-aspect .ReactCrop__drag-handle.ord-e,.ReactCrop--fixed-aspect .ReactCrop__drag-handle.ord-s,.ReactCrop--fixed-aspect .ReactCrop__drag-handle.ord-w{display:none}@media (pointer: coarse){.ReactCrop .ord-n,.ReactCrop .ord-e,.ReactCrop .ord-s,.ReactCrop .ord-w{display:none}.ReactCrop__drag-handle{width:var(--rc-drag-handle-mobile-size);height:var(--rc-drag-handle-mobile-size)}}.au-btn{position:relative;display:inline-flex;justify-content:center;align-items:center;height:32px;line-height:32px;margin:0;color:rgba(0,0,0,.85);font-size:14px;font-weight:500;text-align:center;white-space:nowrap;overflow:hidden;border-radius:2px;border:1px solid #d9d9d9;border-radius:var(--border-radius);background-image:none;background:#fff;transition:all .3s cubic-bezier(.645,.045,.355,1);user-select:none;touch-action:manipulation;cursor:pointer}.au-btn:active{animation:none}.au-btn>.content{border:none;padding:0 15px;background-color:transparent;z-index:10}.au-btn>.ripple{cursor:pointer;content:"";position:absolute;width:100%;padding-top:100%;background:transparent;border:none;border-radius:50%;left:50%;top:50%;transform:translate(-50%,-50%);z-index:1}.au-btn-primary{color:#fff;border:none;background:var(--color)}.au-btn-primary:active,.au-btn-primary:hover{background-color:var(--hover-color)}@keyframes ripple{0%{transform:translate(-50%,-50%) scale(.5);background:rgba(135,201,255,.44)}to{transform:translate(-50%,-50%) scale(1.25);background:transparent}}.au-btn-primary>.ripple{animation:ripple .5s}.au-btn-text{border:none;background:none}.au-btn-text:disabled,.au-btn-text:hover,.au-btn-text:active{background:transparent}.au-btn-text:active,.au-btn-text:hover{color:var(--color)}.au-btn-default:hover,.au-btn-default:active{color:var(--color);border-color:var(--color)}@keyframes ripple{0%{transform:translate(-50%,-50%) scale(.5);background:rgba(135,201,255,.19)}to{transform:translate(-50%,-50%) scale(1.25);background:transparent}}.au-btn-default>.ripple{animation:ripple .5s}.au-btn:disabled{cursor:not-allowed;color:var(--disabled-color);background:var(--disabled-bg-color);border-color:var(--disabled-border-color)}.au-btn:disabled>.content{cursor:not-allowed}.au-btn:disabled.au-btn-text{background-color:#fff}.au-checkbox{display:inline-block;min-height:32px;height:32px;width:auto;display:inline-flex;justify-content:"start";align-items:center;cursor:pointer}.au-checkbox .au-checkbox-icon{display:inline-flex;justify-content:center;align-items:center;width:16px;height:16px;border-radius:4px;margin-left:8px;margin-inline-start:8px;cursor:pointer;border:none;background:#fff;border:1px solid #d9d9d9;transition:all .2s ease-in-out}.au-checkbox .au-checkbox-icon.au-checkbox-select{background:#1890ff;border:none}.au-checkbox input[type=checkbox]{width:0;height:0;top:0;right:0;bottom:0;left:0;z-index:-1}.au-checkbox label{margin:0 8px;color:rgba(0,0,0,.88);cursor:pointer}.au-checkbox .au-checkbox-item.disabled,.au-checkbox .au-checkbox-item.disabled>span,.au-checkbox .au-checkbox-item.disabled>label{cursor:not-allowed;color:var(--disabled-color);border-color:var(--disabled-border-color)}.au-checkbox .au-checkbox-item.disabled.au-checkbox-select,.au-checkbox .au-checkbox-item.disabled>span.au-checkbox-select,.au-checkbox .au-checkbox-item.disabled>label.au-checkbox-select{background:var(--disabled-color);border:none}.au-rotate{animation:au-animation-rotate 1.2s infinite linear;-webkit-transform-origin:center center;-ms-transform-origin:center center;transform-origin:center center}@keyframes au-animation-rotate{0%{transform:rotate(0);-ms-transform:rotate(0deg);-webkit-transform:rotate(0deg)}to{transform:rotate(-360deg);-ms-transform:rotate(-360deg);-webkit-transform:rotate(-360deg)}}.au-input{display:inline-block;width:100%;min-width:0;height:32px;line-height:32px;margin:0 0 5px;padding:4px 8px;font-size:14px;border-radius:6px;border:1px solid #d9d9d9;text-overflow:ellipsis;background-image:none;outline:none;box-sizing:border-box;list-style:none;transition:all .2s}.au-input.isHover,.au-input:focus,.au-input:hover,.au-input:active{border-radius:8px;border-color:#4989e7;box-shadow:#4989e7 0 0 3px}.au-input-tags{display:inline-flex;align-items:center;flex-wrap:wrap;gap:4px 8px;width:100%;min-width:0;min-height:32px;margin:0 0 5px;padding:4px 8px;font-size:14px;border-radius:6px;border:1px solid #d9d9d9;text-overflow:ellipsis;background-image:none;outline:none;box-sizing:border-box;list-style:none;transition:all .2s}.au-input-tags.isHover,.au-input-tags:focus,.au-input-tags:hover,.au-input-tags:active{border-radius:8px;border-color:#4989e7;box-shadow:#4989e7 0 0 3px}.au-input-tags-item{display:flex;align-items:center;height:20px;line-height:20px;font-size:12px;padding:0 8px;margin:0;border-radius:6px;background-color:#eee}.au-input-tags-item svg{cursor:pointer;font-size:18px;color:rgba(0,0,0,.45)}.au-input-tags input{display:inline-block;flex-grow:1;height:20px;width:auto;min-width:20%;max-width:100%;outline:none;box-sizing:border-box;list-style:none;border:none;background:transparent}.au-input-number{display:inline-block;width:100%;min-width:0;height:32px;line-height:32px;margin:0 0 5px;padding:4px 0 4px 8px;font-size:14px;border-radius:6px;border:1px solid #d9d9d9;text-overflow:ellipsis;background-image:none;outline:none;box-sizing:border-box;list-style:none;transition:all .2s}.au-input-number::-webkit-inner-spin-button,.au-input-number::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.au-input-number.isHover,.au-input-number:focus,.au-input-number:hover,.au-input-number:active{border-radius:8px;border-color:#4989e7;box-shadow:#4989e7 0 0 3px}.au-radio{display:block;min-height:32px;height:32px;width:auto;cursor:pointer}.au-radio-item{display:inline-flex;justify-content:"start";align-items:center}.au-radio .au-radio-label,.au-radio .au-radio-icon{display:inline-flex;justify-content:center;align-items:center;cursor:pointer}.au-radio .au-radio-icon{width:16px;height:16px;border-radius:50%;margin-left:8px;margin-inline-start:8px;cursor:pointer;border:none;background:#fff;border:1px solid #d9d9d9;transition:all .2s ease-in-out}.au-radio .au-radio-icon.au-radio-select{border:5px solid #1890ff;transition:all .1s ease-in-out}.au-radio label{margin:0 8px;color:rgba(0,0,0,.88);cursor:pointer}.au-radio-button .au-radio-label{display:inline-block;margin:0 -1px 0 0;border:1px solid #d9d9d9;height:32px;padding-left:15px;padding-right:15px;z-index:9;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.au-radio-button .au-radio-label:hover,.au-radio-button .au-radio-label:active{color:#1890ff}.au-radio-button .au-radio-label.au-radio-select{color:#1890ff;border-color:#1890ff;z-index:10}.au-radio-button:first-child .au-radio-label{border-top-left-radius:8px;border-bottom-left-radius:8px}.au-radio-button:last-child .au-radio-label{border-top-right-radius:8px;border-bottom-right-radius:8px}.au-select{width:100%;position:relative;box-sizing:border-box}.au-select-input{width:100%;padding:4px 6px;border-radius:4px;border:1px solid #d9d9d9}.au-select-input input{background:transparent;display:inline-block;outline:none;border:none;text-overflow:ellipsis;box-sizing:border-box;margin:0;font-size:14px;line-height:1.6;list-style:none;width:100%;cursor:pointer}.au-select-input.isHover,.au-select-input:focus,.au-select-input:hover,.au-select-input:active{border-color:#4989e7;box-shadow:#4989e7 0 0 3px}.au-select-mult-input{max-width:100%;min-height:32px;padding:2px 6px;box-sizing:border-box}.au-select-mult-input .select-item{display:inline-flex}.au-select-mult-input>span{display:inline-block;padding:3px 0 3px 4.5px;margin:2px 6px 2px 2px;border:1px solid rgba(5,5,5,.06);border-radius:4px;background:rgba(0,0,0,.06);font-size:12px}.au-select-mult-input>span>.icon-close{margin-left:3px;color:#919191}.au-select-mult-input>input{width:auto;max-width:100%;padding:4px 0 4px 4.5px}.au-select-mult-input.isHover>input{margin-left:2px;min-width:40px;display:inline-block}.au-select-options{box-sizing:border-box;position:absolute;z-index:99;border:none;overflow-y:auto;max-height:300px;padding:6px;margin-top:4px;border-radius:4px;box-shadow:0 6px 16px #000,0 3px 6px -4px #000,0 9px 28px 8px #000;display:none;width:100%;transition:all 1s ease-in-out;background-color:#fff}.au-select-options::-webkit-scrollbar{height:10px;width:10px}.au-select-options::-webkit-scrollbar-corner{background-color:transparent}.au-select-options::-webkit-scrollbar-thumb{border-radius:12px;-webkit-box-shadow:inset 0 0 3px rgba(0,0,0,.2);background:#9e9e9e}.au-select-options::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 3px rgba(0,0,0,.2);border-radius:12px;background:transparent}.au-select-options-hover{display:block}.au-select-options-item{box-sizing:border-box;padding:8px;border-radius:4px;margin-bottom:3px;cursor:pointer}.au-select-options-item:hover,.au-select-options-item.selected{background-color:#c8e0fa}.au-select.hidden{background-color:#f5f5f5;cursor:not-allowed}.au-select.hidden>.au-select-input{border-color:#d9d9d9;cursor:not-allowed}.au-select.hidden>.au-select-input input{cursor:not-allowed}.au-select.hidden>.au-select-input.isHover,.au-select.hidden>.au-select-input:focus,.au-select.hidden>.au-select-input:hover,.au-select.hidden>.au-select-input:active{box-shadow:none}.au-textarea{display:grid;border-radius:8px}.au-textarea:after{content:attr(data-replicated-value) " ";white-space:pre-wrap;visibility:hidden}.au-textarea>textarea{outline:none;resize:none;overflow:hidden;border:none;border:1px solid #d9d9d9}.au-textarea>textarea.isHover,.au-textarea>textarea:focus,.au-textarea>textarea:hover,.au-textarea>textarea:active{border-radius:8px;border-color:#4989e7;box-shadow:#4989e7 0 0 3px}.au-textarea>textarea,.au-textarea:after{border-radius:9px;padding:.5rem;font:inherit;grid-area:.25}.row{display:grid}.au-flex{display:flex;gap:10px;flex-flow:row wrap}.au-grid{display:grid;border-radius:12px;gap:10px}.au-menu .au-next-menu-content{display:flex;justify-content:space-between;align-items:center;gap:8px;text-align:left;cursor:pointer;font-size:16px;height:38px;font-weight:700;text-transform:capitalize;padding:10px 8px}.au-menu .au-next-menu-content .icon{display:flex;align-items:center}.au-menu .au-next-menu-content .label{display:flex;align-items:center;gap:8px}.au-menu .au-next-menu-content-children{margin-left:10px;transition:height .6s ease-in-out;overflow:hidden}.au-card{border:1px solid #e9e9e9;border-radius:12px;transition:all .3s;margin:8px 0;box-shadow:0 1px 3px #000}.au-card>div{padding:24px;background:transparent}.au-card-header{font-weight:600;font-size:16px;border-bottom:1px solid #e9e9e9}.au-card-footer{border-top:1px solid #e9e9e9}.au-card:hover,.au-card:active{box-shadow:0 1px 6px #000;border-color:rgba(0,0,0,.2)}.au-space{display:flex;flex-direction:row;justify-content:flex-start;align-items:center;word-break:break-all;flex-wrap:wrap}.au-dialog{display:block;position:fixed;left:0;right:0;top:0;bottom:0;width:100%;height:100%;margin:auto;border:none;z-index:999998}.au-dialog-mask{position:absolute;left:0;right:0;top:0;bottom:0;margin:auto;width:100%;height:100%;background:rgba(0,0,0,.45)}.au-dialog-layout{display:block;width:auto;height:auto;position:absolute;left:50%;top:100px;transform:translate(-50%);margin:auto;border-radius:12px;z-index:99999;background-color:#fff;overflow:hidden;padding:20px 24px}.au-dialog-header{display:flex;flex-direction:row;justify-content:space-between;align-items:center;padding-bottom:24px}.au-dialog-header-label{font-size:16px;font-weight:500}.au-dialog-header-logo-close{color:#8c8c8c;cursor:pointer}.au-dialog-footer{display:flex;justify-content:end;padding-top:12px}.au-dialog-footer button{margin-left:8px}.au-popConfirm-box{position:relative;background:#eee}.au-popConfirm-box .au-popConfirm{position:absolute;width:120px;z-index:10;visibility:hidden}.au-popConfirm-box .au-popConfirm-inner{position:relative;padding:10px;border:none;border-radius:8px;background:#fff;box-shadow:inset 1px 1px rgba(255,255,255,.5),0 3px 12px #555a64;z-index:1000}.au-popConfirm-box .au-popConfirm-arrow{position:absolute;width:10px;height:10px;transform:rotate(45deg);background:#fff;z-index:2000;border:none}.au-message{--color-success: #52c41a;--color-warning: #faad14;--color-error: #ff4d4f;--color-info: #1677ff;position:fixed;left:0;right:0;top:30px;margin:auto;background-color:transparent;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:10px;z-index:9999998;pointer-events:none}.au-message-inner{background-color:#fff;border-radius:12px;padding:6px 16px 8px;box-shadow:0 6px 16px rgba(0,0,0,.08),0 3px 6px -4px rgba(0,0,0,.12),0 9px 28px 8px rgba(0,0,0,.05)}.au-message-inner>span{font-size:16px;line-height:16px;color:rgba(0,0,0,.88)}.au-message-inner>span:first-child{color:var(--color-info);margin-right:5px;vertical-align:middle}.au-message-inner>span:first-child.success{color:var(--color-success)}.au-message-inner>span:first-child.warning{color:var(--color-warning)}.au-message-inner>span:first-child.error{color:var(--color-error)}.au-message-inner>span:first-child.info{color:var(--color-info)}:root{--color: #108ee9;--hover-color: #40a9ff;--error-color: #ff4d4f;--border-radius: 8px;--disabled-color: #d9d9d9;--disabled-bg-color: #f5f5f5;--disabled-border-color: #d9d9d9;--border: 1px solid #e9e9e9;--control-border-radius: 8px;--background: rgb(250, 250, 250);--half-background: rgba(250, 250, 250, .5);--hover-background: rgba(250, 250, 250, .7);--au-border-radius: 8px;--au-primary-color: #ffffff;--au-primary-bg-color: #1890ff;--au-default-color: #1890ff;--au-primary-bg-color-hover: #40a9ff;--au-primary-color-active: #096dd9;--au-disabled-color: #f5f5f5;--size-small: 24px;--size-default: 32px;--size-large: 40px;--size-s: 100px;--size-m: 150px;--size-l: 200px;--size-xl: 400px;--size-xxl: 800px;--size-xxxl: 1200px;--au-primary-1: #e6f7ff;--au-primary-2: #bae7ff;--au-primary-3: #91d5ff;--au-primary-4: #69c0ff;--au-primary-5: #40a9ff;--au-primary-6: #1890ff;--au-primary-7: #096dd9;--au-primary-color-deprecated-l-35: #cbe6ff;--au-primary-color-deprecated-l-20: #7ec1ff;--au-primary-color-deprecated-t-20: #46a6ff;--au-primary-color-deprecated-t-50: #8cc8ff;--au-primary-color-deprecated-f-12: rgba(24, 144, 255, .12);--au-primary-color-active-deprecated-f-30: rgba(230, 247, 255, .3);--au-primary-color-active-deprecated-d-02: #dcf4ff;--au-success-color: #52c41a;--au-success-color-hover: #73d13d;--au-success-color-active: #389e0d;--au-success-color-outline: rgba(82, 196, 26, .2);--au-success-color-deprecated-bg: #f6ffed;--au-success-color-deprecated-border: #b7eb8f;--au-error-color: #ff4d4f;--au-error-color-hover: #ff7875;--au-error-color-active: #d9363e;--au-error-color-outline: rgba(255, 77, 79, .2);--au-error-color-deprecated-bg: #fff2f0;--au-error-color-deprecated-border: #ffccc7;--au-warning-color: #faad14;--au-warning-color-hover: #ffc53d;--au-warning-color-active: #d48806;--au-warning-color-outline: rgba(250, 173, 20, .2);--au-warning-color-deprecated-bg: #fffbe6;--au-warning-color-deprecated-border: #ffe58f;--au-info-color: #1890ff;--au-info-color-deprecated-bg: #e6f7ff;--au-info-color-deprecated-border: #91d5ff;--docsearch-primary-color: #5468ff;--docsearch-text-color: #1c1e21;--docsearch-spacing: 12px;--docsearch-icon-stroke-width: 1.4;--docsearch-highlight-color: var(--docsearch-primary-color);--docsearch-muted-color: #969faf;--docsearch-container-background: rgba(101, 108, 133, .8);--docsearch-logo-color: #5468ff;--docsearch-modal-width: 560px;--docsearch-modal-height: 600px;--docsearch-modal-background: #f5f6f7;--docsearch-modal-shadow: inset 1px 1px 0 0 hsla(0, 0%, 100%, .5), 0 3px 8px 0 #555a64;--docsearch-searchbox-height: 56px;--docsearch-searchbox-background: #ebedf0;--docsearch-searchbox-focus-background: #fff;--docsearch-searchbox-shadow: inset 0 0 0 2px var(--docsearch-primary-color);--docsearch-hit-height: 56px;--docsearch-hit-color: #444950;--docsearch-hit-active-color: #fff;--docsearch-hit-background: #fff;--docsearch-hit-shadow: 0 1px 3px 0 #d4d9e1;--docsearch-key-gradient: linear-gradient(-225deg, #d5dbe4, #f8f8f8);--docsearch-key-shadow: inset 0 -2px 0 0 #cdcde6, inset 0 0 1px 1px #fff, 0 1px 2px 1px rgba(30, 35, 90, .4);--docsearch-footer-height: 44px;--docsearch-footer-background: #fff;--docsearch-footer-shadow: 0 -1px 0 0 #e0e3e8, 0 -3px 6px 0 rgba(69, 98, 155, .12)}:where(.au-flow-chart){position:relative;display:grid;gap:0 0;overflow:hidden}:where(.au-flow-chart) .au-flow-chart-item-label{position:relative;display:flex;justify-content:center;align-items:center;padding:12px;background-color:#1677ff;color:#fff;width:100%;word-break:break-all;white-space:pre-wrap;z-index:99}:where(.au-flow-chart) svg{display:block;color:#878787}:where(.au-flow-chart) .au-flow-chart-status-empty{color:#000;text-align:left;justify-self:start;background:transparent}:where(.au-flow-chart) .au-flow-chart-status-operable{background:#862633}:where(.au-flow-chart) .au-flow-link-status-operable svg{color:#862633;background:transparent}:where(.au-flow-chart) .au-flow-chart-status-finish{background:#2fc22f}:where(.au-flow-chart) .au-flow-link-status-finish svg{color:#2fc22f;background:transparent}:where(.au-flow-chart) .au-flow-chart-status-error{background:#eb2323}:where(.au-flow-chart) .au-flow-link-status-error svg{color:#eb2323;background:transparent}:where(.au-flow-chart) .au-flow-chart-status-prohibit{background:#dadada}:where(.au-flow-chart) .au-flow-link-status-prohibit svg{color:#dadada;background:transparent}.au-tab .header{display:flex;gap:10px;color:#7e7e7e;padding-bottom:10px;margin-bottom:10px;border-bottom:1px solid #eee}.au-tab .header .select,.au-tab .header div:hover{color:var(--color)}*{box-sizing:border-box}.paging{padding:6px 8px;display:flex;justify-content:start;align-items:center}.paging .au-select-input{border:1px solid #d9d9d9}.paging>div{display:flex;justify-content:center;align-items:center;text-align:center;min-width:30px;height:30px;font-size:14px;border:1px solid #d9d9d9;background-color:#fff;border-radius:12px;margin-right:5px;cursor:pointer;user-select:none}.paging>div:last-child{margin-right:none}.paging>div.selected{color:#fff;background-color:#108ee9;border-color:#108ee9}.paging>div.jump-next,.paging>div.jump-prev{border:none}.paging>div.jump-next svg,.paging>div.jump-prev svg{display:block;width:100%;height:100%}.paging>div.jump-next{content:"•••";display:inline-block;letter-spacing:2px;color:rgba(0,0,0,.25);text-align:center}.paging .total{border:none}.paging .pageSize-select{border:none;height:30px;width:90px}.paging .pageSize-select>.select{margin:0}.paging .pageSize-select .select-input{border-radius:12px;border:1px solid #d9d9d9}.paging .pageSize-select .select-input>input{text-align:center}.paging .goto{border:none;height:30px;margin:0}.paging .goto div{display:block;margin-right:5px}.paging .goto>input{margin:0;display:block;border-radius:12px;border:1px solid #d9d9d9;height:30px;width:50px}.au-step{display:grid;padding:10px;gap:0}.au-step-item{display:inline-flex;justify-content:center;align-items:center;padding:10px}.au-step-item-icon{color:var(--color);margin-right:8px}.au-step-item-line{display:inline-flex;justify-content:center;align-items:center}.au-step-item-line:after{content:"";display:inline-block;width:100%;height:0;border:1px solid;border-color:gray}:where(.au-table){display:block;border:var(--border);border-radius:var(--border-radius);margin:0;box-sizing:border-box;padding:0}:where(.au-table) table{width:100%;border-collapse:collapse;letter-spacing:1px;border-color:transparent}:where(.au-table) td,:where(.au-table) th{border:var(--border);padding:16px 8px;text-align:center;background:none}:where(.au-table) td:first-child,:where(.au-table) th:first-child{border-left:none}:where(.au-table) td:last-child,:where(.au-table) th:last-child{border-right:none}:where(.au-table) tr:nth-child(2n+2){background:var(--half-background)}:where(.au-table) tr:hover{background:var(--hover-background)}:where(.au-table) thead{background:var(--background)}:where(.au-table) thead th{border-top:none}:where(.au-table) thead tr th:first-child{border-top-left-radius:var(--border-radius)}:where(.au-table) thead tr th:last-child{border-top-right-radius:var(--border-radius)}:where(.au-table) tbody tr:last-child td{border-bottom:none}:where(.au-table) tbody tr:last-child tr:first-child{border-bottom-left-radius:var(--border-radius)}:where(.au-table) tbody tr:last-child tr:last-child{border-bottom-right-radius:var(--border-radius)}.order{width:30px;width:auto;padding:5px}.au-number-scroll{display:grid;gap:5px}.au-simple-scroll{position:relative;width:30px;height:30px;overflow:hidden;background-color:#000;border-radius:8px}.au-simple-scroll-item{position:absolute;width:30px;height:30px;line-height:30px;text-align:center;font-weight:700;transition:top .6s}*{margin:0;padding:0;box-sizing:border-box}:root{--height: 32px}
`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 444:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(181), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `* {
  margin: 0;
  padding: 0;
  letter-spacing: 1px;
  box-sizing: border-box;
  color: #fff;
  text-shadow: 0px 2px 9px rgba(0, 0, 0, 0.95);
}
body {
  background: #000;
  position: relative;
}
body::before {
  content: '';
  position: fixed;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
  z-index: -1;
  background: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
  filter: opacity(60%) blur(3px);
  background-position: center center;
  background-size: cover;
  background-repeat: no-repeat;
}
.root {
  min-height: 100vh;
  min-width: 100vw;
}
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-thumb {
  border-radius: 8px;
  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.2);
  background: rgba(0, 0, 0, 0.2);
}
::-webkit-scrollbar-track {
  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  background: rgba(0, 0, 0, 0.1);
}
`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 434:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.home .layout {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 24px;
  min-height: 100vh;
}
.home .card {
  position: relative;
  width: 300px;
  height: 120px;
  border: none;
  box-shadow: 0 0 2px rgba(255, 255, 255, 0.9);
  background-color: rgba(255, 255, 255, 0.3);
  border-radius: 12px;
  padding: 16px 18px;
  font-size: large;
  font-weight: bold;
  cursor: pointer;
}
.home .card .logo {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 48px;
  height: 48px;
  font-size: 32px;
  padding: 8px;
  box-shadow: 0 0 2px rgba(255, 255, 255, 0.9);
  background-color: rgba(255, 255, 255, 0.3);
  border-radius: 12px;
}
.home .card .name {
  position: absolute;
  bottom: 12px;
  right: 12px;
}
`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 709:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.container {
  height: 100vh;
  min-height: 100vh;
  max-height: 100vh;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: 20vh 80vh;
  gap: 0;
}
.container .query {
  display: grid;
  grid-template-rows: 2fr 3fr;
  width: 100%;
  text-align: center;
}
.container .query input {
  outline: none;
  background: transparent;
  border-radius: 8px;
  width: 500px;
  min-width: 300px;
  max-width: 500px;
  max-width: 95%;
  height: 32px;
  margin: 0px auto;
  padding: 0 8px;
}
.container .query .tags {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100vw;
  text-align: center;
  white-space: nowrap;
  overflow-x: auto;
  overflow-y: hidden;
}
.container .query .tags div {
  color: rgba(255, 255, 255, 0.2);
  display: inline-block;
  border-radius: 12px;
  font-weight: bold;
  cursor: pointer;
  padding: 10px 10px;
  font-size: 12px;
}
.container .query .tags div.isSelect {
  color: #ffffff;
}
.container .query .tags div:hover {
  color: #fff;
}
.container .note {
  overflow-y: hidden;
  overflow-x: auto;
  max-width: 100vw;
  padding: 0 3vw;
}
.container .tag {
  display: inline-block;
  width: fit-content;
  text-align: start;
  padding: 0 10px;
  border: none;
  border-left: 1px solid rgba(255, 255, 255, 0.5);
}
.container .tag.isRoot {
  width: 100%;
  max-width: 100vw;
  display: grid;
  border: none;
  grid-auto-flow: column;
  gap: 0;
}
.container .name {
  display: block;
  overflow: hidden;
  max-width: 160px;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: pointer;
  padding: 5px 0;
  position: sticky;
  top: 5px;
  text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.95);
}
.container .item {
  height: 100%;
  font-size: 14px;
  font-weight: bold;
  margin: 0;
  padding: 0;
  text-align: start;
  vertical-align: text-top;
}
.container .item .next {
  display: inline-block;
  max-height: 70vh;
  overflow: hidden auto;
}
.container .item .last {
  display: inline-block;
  color: rgba(175, 250, 255, 0.7);
  height: fit-content;
  padding: 2px 4px;
  border-radius: 4px;
}
.container .item .last:hover {
  color: #66f5ff;
}
`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 759:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_store_css_loader_6_11_0_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.package {
  display: flex;
  justify-content: center;
}
.package .layout {
  column-count: 5;
  overflow: auto;
  padding: 24px;
  column-gap: 10px;
}
.package .layout > .card {
  page-break-inside: avoid;
  -webkit-column-break-inside: avoid;
  margin-bottom: 10px;
}
.package .logo-layout {
  display: inline-block;
}
.package .logo-layout > span {
  width: 20px;
  height: 20px;
  margin: auto;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  font-size: 22px;
  padding: 4px;
  box-shadow: 0 0 2px rgba(255, 255, 255, 0.2);
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: 12px;
}
.package .logo-layout img {
  width: 20px;
  height: 20px;
  border: none;
}
.package .logo-layout .hidden {
  width: 0 !important;
  height: 0 !important;
  padding: 0 !important;
  visibility: hidden;
}
.package .card {
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 20px 10px;
  width: 350px;
  border: none;
  box-shadow: 0 0 2px rgba(255, 255, 255, 0.9);
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  padding: 16px 18px;
  font-size: large;
  font-weight: bold;
}
.package .card .header {
  cursor: pointer;
  letter-spacing: 1.4px;
}
.package .card .desc {
  font-size: 12px;
  word-spacing: 1px;
  letter-spacing: 1.4px;
}
.package .card .logo {
  display: inline-block;
}
.package .card .label {
  display: inline-block;
  margin-left: 10px;
}
.package .card .install .au-tab .header {
  font-size: 12px;
}
.package .card .install .cmd {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 14px;
  background-color: rgba(255, 255, 255, 0.1);
  padding: 6px 8px;
  border-radius: 8px;
}
.package .card .shields {
  display: flex;
  flex-wrap: wrap;
  gap: 0 5px;
  zoom: 0.9;
}
.package .card .shields span {
  height: 22px;
  line-height: 22px;
  padding: 0 8px;
  font-size: 11px;
  background: #5C5C5C;
  border-radius: 4px;
}
.package .card .shields span.Non-Open-Source {
  background: #EE7F3B;
}
.package .card .shields img {
  min-height: 22px;
}
.package .card .tags {
  display: flex;
  flex-wrap: wrap;
  gap: 8px 10px;
  zoom: 0.8;
}
.package .card .tags .tag {
  color: rgba(255, 255, 255, 0.65);
  box-shadow: 0 0 2px rgba(0, 0, 0, 0.15);
  background-color: rgba(0, 0, 0, 0.15);
  border-radius: 6px;
  padding: 0 8px;
  font-size: 12px;
  font-weight: bold;
  letter-spacing: 1.5px;
  line-height: 22px;
  height: 22px;
}
`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 63:
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 38:
/***/ ((module) => {



module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ 678:
/***/ ((module) => {



module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ 492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(296),ca=__webpack_require__(194);function p(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+"Capture",b)}
function ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}
var ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la=
{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function qa(a,b,c,d){if(null===b||"undefined"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});
["checked","multiple","muted","selected"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(ra,
sa);z[b]=new v(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});
z.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});
function ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}
var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");
var Ia=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var Ja=Symbol.iterator;function Ka(a){if(null===a||"object"!==typeof a)return null;a=Ja&&a[Ja]||a["@@iterator"];return"function"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);La=b&&b[1]||""}return"\n"+La+a}var Na=!1;
function Oa(a,b){if(!a||Na)return"";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\n"),
f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Ma(a):""}
function Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return""}}
function Qa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||"Context")+".Consumer";case Ba:return(a._context.displayName||"Context")+".Provider";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||
b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||"Memo";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}
function Ra(a){var b=a.type;switch(a.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(b);case 8:return b===za?"StrictMode":"Mode";case 22:return"Offscreen";
case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return""}}
function Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
function Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,"checked",b,!1)}
function bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?cb(a,b.type,c):b.hasOwnProperty("defaultValue")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function db(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function cb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var eb=Array.isArray;
function fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}
function ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}
function lb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?kb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var mb,nb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{mb=mb||document.createElement("div");mb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,
zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(""+b).trim():b+"px"}
function sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p(62));}}
function vb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;
function Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}
function Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==
typeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}});window.addEventListener("test",Mb,Mb);window.removeEventListener("test",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}
function Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}
function Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===
c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}
var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&"function"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}
var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;
function tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;
default:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}
function vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}
function wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}
function Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}
function Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a,b){switch(a){case "focusin":case "focusout":Lc=null;break;case "dragenter":case "dragleave":Mc=null;break;case "mouseover":case "mouseout":Nc=null;break;case "pointerover":case "pointerout":Oc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Pc.delete(b.pointerId)}}
function Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
function Uc(a,b,c,d,e){switch(b){case "focusin":return Lc=Tc(Lc,a,b,c,d,e),!0;case "dragenter":return Mc=Tc(Mc,a,b,c,d,e),!0;case "mouseover":return Nc=Tc(Nc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}
function Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}
function Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}
function ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}
function bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;
function ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}
function fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;
function Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}
function jd(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;
case "message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}
function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}
function rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}
var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
a)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",
Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}
var Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;
function ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}
function ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}
var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}
function ve(a,b){if("change"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}
function Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge;
function Ie(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
function Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,
d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}
var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;
function Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}
function Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};
ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);
ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}
function se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}
function D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+"__bubble";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){"selectionchange"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf("selectionchange",!1,b))}}
function pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}
function hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];
a:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":n="focus";k=Fd;break;case "focusout":n="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
Dd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var t=0!==(b&4),J=!t&&"scroll"===a,x=t?null!==h?h+"Capture":null:h;t=[];for(var w=d,u;null!==
w;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==
n&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F="onMouseLeave";x="onMouseEnter";w="mouse";if("pointerout"===a||"pointerover"===a)t=Td,F="onPointerLeave",x="onPointerEnter",w="pointer";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+"leave",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+"enter",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=
vf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);"focusout"===a&&(xa=h._wrapperState)&&
xa.controlled&&"number"===h.type&&cb(h,"number",h.value)}xa=d?ue(d):window;switch(a){case "focusin":if(me(xa)||"true"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case "compositionstart":var ba="onCompositionStart";break b;case "compositionend":ba="onCompositionEnd";
break b;case "compositionupdate":ba="onCompositionUpdate";break b}ba=void 0}else ie?ge(a,c)&&(ba="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ba="onCompositionStart");ba&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==ba?"onCompositionEnd"===ba&&ie&&($a=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),
0<d.length&&(e=new Ld("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
function wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(a){return("string"===typeof a?a:""+a).replace(xf,"\n").replace(yf,"")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}
var Cf=null,Df=null;function Ef(a,b){return"textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
var Ff="function"===typeof setTimeout?setTimeout:void 0,Gf="function"===typeof clearTimeout?clearTimeout:void 0,Hf="function"===typeof Promise?Promise:void 0,Jf="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}
function Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else"$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}
function Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;
function Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}
function E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}
function Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||"Unknown",e));return A({},c,d)}
function cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}
function jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}
function ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;
function Ag(a,b){var c=Bg(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}
function Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=
null,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}
function Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}yg=
null}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;
function Lg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}
function Mg(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function Ng(a){var b=a._init;return b(a._payload)}
function Og(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Pg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&
null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Qg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ha&&Ng(f)===b.type))return d=e(b,c.props),d.ref=Lg(a,b,c),d.return=a,d;d=Rg(c.type,c.key,c.props,null,a.mode,d);d.ref=Lg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||
b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=Sg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Tg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=Qg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=Rg(b.type,b.key,b.props,null,a.mode,c),
c.ref=Lg(a,null,b),c.return=a,c;case wa:return b=Sg(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Tg(b,a.mode,c,null),b.return=a,b;Mg(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,
b,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);Mg(a,c)}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);Mg(b,d)}return null}
function n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===
x.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if("function"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,
m),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=
f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ha&&Ng(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=Lg(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Tg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Rg(f.type,f.key,f.props,null,a.mode,h),h.ref=Lg(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==
d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=Sg(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);Mg(a,f)}return"string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):
(c(a,d),d=Qg(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(a){var b=Wg.current;E(Wg);a._currentValue=b}function bh(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}
function ch(a,b){Xg=a;Zg=Yg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(dh=!0),a.firstContext=null)}function eh(a){var b=a._currentValue;if(Zg!==a)if(a={context:a,memoizedValue:b,next:null},null===Yg){if(null===Xg)throw Error(p(308));Yg=a;Xg.dependencies={lanes:0,firstContext:a}}else Yg=Yg.next=a;return b}var fh=null;function gh(a){null===fh?fh=[a]:fh.push(a)}
function hh(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,gh(b)):(c.next=e.next,e.next=c);b.interleaved=c;return ih(a,d)}function ih(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var jh=!1;function kh(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}
function lh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function mh(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}
function nh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return ih(a,c)}e=d.interleaved;null===e?(b.next=b,gh(d)):(b.next=e.next,e.next=b);d.interleaved=b;return ih(a,c)}function oh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}
function ph(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
b;c.lastBaseUpdate=b}
function qh(a,b,c,d){var e=a.updateQueue;jh=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,
next:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if("function"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r="function"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:jh=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;
h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);rh|=g;a.lanes=g;a.memoizedState=q}}
function sh(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p(191,e));e.call(d)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(a){if(a===th)throw Error(p(174));return a}
function yh(a,b){G(wh,b);G(vh,a);G(uh,th);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(uh);G(uh,b)}function zh(){E(uh);E(vh);E(wh)}function Ah(a){xh(wh.current);var b=xh(uh.current);var c=lb(b,a.type);b!==c&&(G(vh,a),G(uh,c))}function Bh(a){vh.current===a&&(E(uh),E(vh))}var L=Uf(0);
function Ch(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Dh=[];
function Eh(){for(var a=0;a<Dh.length;a++)Dh[a]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua.ReactCurrentDispatcher,Gh=ua.ReactCurrentBatchConfig,Hh=0,M=null,N=null,O=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P(){throw Error(p(321));}function Mh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}
function Nh(a,b,c,d,e,f){Hh=f;M=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Fh.current=null===a||null===a.memoizedState?Oh:Ph;a=c(d,e);if(Jh){f=0;do{Jh=!1;Kh=0;if(25<=f)throw Error(p(301));f+=1;O=N=null;b.updateQueue=null;Fh.current=Qh;a=c(d,e)}while(Jh)}Fh.current=Rh;b=null!==N&&null!==N.next;Hh=0;O=N=M=null;Ih=!1;if(b)throw Error(p(300));return a}function Sh(){var a=0!==Kh;Kh=0;return a}
function Th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===O?M.memoizedState=O=a:O=O.next=a;return O}function Uh(){if(null===N){var a=M.alternate;a=null!==a?a.memoizedState:null}else a=N.next;var b=null===O?M.memoizedState:O.next;if(null!==b)O=b,N=a;else{if(null===a)throw Error(p(310));N=a;a={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null};null===O?M.memoizedState=O=a:O=O.next=a}return O}
function Vh(a,b){return"function"===typeof b?b(a):b}
function Wh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=N,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Hh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,
eagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;M.lanes|=m;rh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(dh=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,M.lanes|=f,rh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}
function Xh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(dh=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function Yh(){}
function Zh(a,b){var c=M,d=Uh(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,dh=!0);d=d.queue;$h(ai.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==O&&O.memoizedState.tag&1){c.flags|=2048;bi(9,ci.bind(null,c,d,e,b),void 0,null);if(null===Q)throw Error(p(349));0!==(Hh&30)||di(c,b,e)}return e}function di(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=M.updateQueue;null===b?(b={lastEffect:null,stores:null},M.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}
function ci(a,b,c,d){b.value=c;b.getSnapshot=d;ei(b)&&fi(a)}function ai(a,b,c){return c(function(){ei(b)&&fi(a)})}function ei(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function fi(a){var b=ih(a,1);null!==b&&gi(b,a,1,-1)}
function hi(a){var b=Th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:a};b.queue=a;a=a.dispatch=ii.bind(null,M,a);return[b.memoizedState,a]}
function bi(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=M.updateQueue;null===b?(b={lastEffect:null,stores:null},M.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function ji(){return Uh().memoizedState}function ki(a,b,c,d){var e=Th();M.flags|=a;e.memoizedState=bi(1|b,c,void 0,void 0===d?null:d)}
function li(a,b,c,d){var e=Uh();d=void 0===d?null:d;var f=void 0;if(null!==N){var g=N.memoizedState;f=g.destroy;if(null!==d&&Mh(d,g.deps)){e.memoizedState=bi(b,c,f,d);return}}M.flags|=a;e.memoizedState=bi(1|b,c,f,d)}function mi(a,b){return ki(8390656,8,a,b)}function $h(a,b){return li(2048,8,a,b)}function ni(a,b){return li(4,2,a,b)}function oi(a,b){return li(4,4,a,b)}
function pi(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function qi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return li(4,4,pi.bind(null,b,a),c)}function ri(){}function si(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function ti(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function ui(a,b,c){if(0===(Hh&21))return a.baseState&&(a.baseState=!1,dh=!0),a.memoizedState=c;He(c,b)||(c=yc(),M.lanes|=c,rh|=c,a.baseState=!0);return b}function vi(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Gh.transition;Gh.transition={};try{a(!1),b()}finally{C=c,Gh.transition=d}}function wi(){return Uh().memoizedState}
function xi(a,b,c){var d=yi(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(b,c);else if(c=hh(a,b,c,d),null!==c){var e=R();gi(c,a,d,e);Bi(c,b,d)}}
function ii(a,b,c){var d=yi(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,gh(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=hh(a,b,e,d);null!==c&&(e=R(),gi(c,a,d,e),Bi(c,b,d))}}
function zi(a){var b=a.alternate;return a===M||null!==b&&b===M}function Ai(a,b){Jh=Ih=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Bi(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}
var Rh={readContext:eh,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useInsertionEffect:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useDeferredValue:P,useTransition:P,useMutableSource:P,useSyncExternalStore:P,useId:P,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(a,b){Th().memoizedState=[a,void 0===b?null:b];return a},useContext:eh,useEffect:mi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ki(4194308,
4,pi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ki(4194308,4,a,b)},useInsertionEffect:function(a,b){return ki(4,2,a,b)},useMemo:function(a,b){var c=Th();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=xi.bind(null,M,a);return[d.memoizedState,a]},useRef:function(a){var b=
Th();a={current:a};return b.memoizedState=a},useState:hi,useDebugValue:ri,useDeferredValue:function(a){return Th().memoizedState=a},useTransition:function(){var a=hi(!1),b=a[0];a=vi.bind(null,a[1]);Th().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=M,e=Th();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===Q)throw Error(p(349));0!==(Hh&30)||di(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;mi(ai.bind(null,d,
f,a),[a]);d.flags|=2048;bi(9,ci.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Th(),b=Q.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Kh++;0<c&&(b+="H"+c.toString(32));b+=":"}else c=Lh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Wh,useRef:ji,useState:function(){return Wh(Vh)},
useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return ui(b,N.memoizedState,a)},useTransition:function(){var a=Wh(Vh)[0],b=Uh().memoizedState;return[a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Xh,useRef:ji,useState:function(){return Xh(Vh)},useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return null===
N?b.memoizedState=a:ui(b,N.memoizedState,a)},useTransition:function(){var a=Xh(Vh)[0],b=Uh().memoizedState;return[a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}function Di(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}
var Ei={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=R(),e=yi(a),f=mh(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=R(),e=yi(a),f=mh(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=R(),d=
yi(a),e=mh(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=nh(a,e,d);null!==b&&(gi(b,a,d,c),oh(b,a,d))}};function Fi(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}
function Gi(a,b,c){var d=!1,e=Vf;var f=b.contextType;"object"===typeof f&&null!==f?f=eh(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Ei;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function Hi(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Ei.enqueueReplaceState(b,b.state,null)}
function Ii(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs={};kh(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=eh(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Di(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,
"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Ei.enqueueReplaceState(e,e.state,null),qh(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308)}function Ji(a,b){try{var c="",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack}return{value:a,source:b,stack:e,digest:null}}
function Ki(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}function Li(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Mi="function"===typeof WeakMap?WeakMap:Map;function Ni(a,b,c){c=mh(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Oi||(Oi=!0,Pi=d);Li(a,b)};return c}
function Qi(a,b,c){c=mh(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Li(a,b)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Li(a,b);"function"!==typeof d&&(null===Ri?Ri=new Set([this]):Ri.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
function Si(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Mi;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ti.bind(null,a,b,c),b.then(a,a))}function Ui(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}
function Vi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=mh(-1,1),b.tag=2,nh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Wi=ua.ReactCurrentOwner,dh=!1;function Xi(a,b,c,d){b.child=null===a?Vg(b,null,c,d):Ug(b,a.child,c,d)}
function Yi(a,b,c,d,e){c=c.render;var f=b.ref;ch(b,e);d=Nh(a,b,c,d,f,e);c=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I&&c&&vg(b);b.flags|=1;Xi(a,b,d,e);return b.child}
function $i(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!aj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,bj(a,b,f,d,e);a=Rg(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return Zi(a,b,e)}b.flags|=1;a=Pg(f,d);a.ref=b.ref;a.return=b;return b.child=a}
function bj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(dh=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(dh=!0);else return b.lanes=a.lanes,Zi(a,b,e)}return cj(a,b,c,d,e)}
function dj(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(ej,fj),fj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(ej,fj),fj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(ej,fj);fj|=d}else null!==
f?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(ej,fj),fj|=d;Xi(a,b,e,c);return b.child}function gj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function cj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);ch(b,e);c=Nh(a,b,c,d,f,e);d=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I&&d&&vg(b);b.flags|=1;Xi(a,b,c,e);return b.child}
function hj(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;ch(b,e);if(null===b.stateNode)ij(a,b),Gi(b,c,d),Ii(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=eh(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;q||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||
(h!==d||k!==l)&&Hi(b,g,d,l);jh=!1;var r=b.memoizedState;g.state=r;qh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||jh?("function"===typeof m&&(Di(b,c,m,d),k=b.memoizedState),(h=jh||Fi(b,c,h,d,r,k,l))?(q||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):
("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;lh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Ci(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=eh(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m="function"===typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||
"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&Hi(b,g,d,k);jh=!1;r=b.memoizedState;g.state=r;qh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||jh?("function"===typeof y&&(Di(b,c,y,d),n=b.memoizedState),(l=jh||Fi(b,c,l,d,r,n,k)||!1)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&
g.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===
a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return jj(a,b,c,d,f,e)}
function jj(a,b,c,d,e,f){gj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),Zi(a,b,f);d=b.stateNode;Wi.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Ug(b,a.child,null,f),b.child=Ug(b,null,h,f)):Xi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function kj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);yh(a,b.containerInfo)}
function lj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Xi(a,b,c,d);return b.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(a){return{baseLanes:a,cachePool:null,transitions:null}}
function oj(a,b,c){var d=b.pendingProps,e=L.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(L,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=
g):f=pj(g,d,0,null),a=Tg(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=nj(c),b.memoizedState=mj,a):qj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return rj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=Pg(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=Pg(h,f):(f=Tg(f,g,c,null),f.flags|=2);f.return=
b;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?nj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=mj;return d}f=a.child;a=f.sibling;d=Pg(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}
function qj(a,b){b=pj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function sj(a,b,c,d){null!==d&&Jg(d);Ug(b,a.child,null,c);a=qj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}
function rj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Ki(Error(p(422))),sj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=pj({mode:"visible",children:d.children},e,0,null);f=Tg(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Ug(b,a.child,null,g);b.child.memoizedState=nj(g);b.memoizedState=mj;return f}if(0===(b.mode&1))return sj(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;
if(d)var h=d.dgst;d=h;f=Error(p(419));d=Ki(f,d,void 0);return sj(a,b,g,d)}h=0!==(g&a.childLanes);if(dh||h){d=Q;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;
0!==e&&e!==f.retryLane&&(f.retryLane=e,ih(a,e),gi(d,a,e,-1))}tj();d=Ki(Error(p(421)));return sj(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=uj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=qj(b,d.children);b.flags|=4096;return b}function vj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);bh(a.return,b,c)}
function wj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}
function xj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Xi(a,b,d.children,c);d=L.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&vj(a,c,b);else if(19===a.tag)vj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(L,d);if(0===(b.mode&1))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Ch(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);wj(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Ch(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}wj(b,!0,c,null,f);break;case "together":wj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}
function ij(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function Zi(a,b,c){null!==a&&(b.dependencies=a.dependencies);rh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=Pg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Pg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function yj(a,b,c){switch(b.tag){case 3:kj(b);Ig();break;case 5:Ah(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:yh(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Wg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(L,L.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return oj(a,b,c);G(L,L.current&1);a=Zi(a,b,c);return null!==a?a.sibling:null}G(L,L.current&1);break;case 19:d=0!==(c&
b.childLanes);if(0!==(a.flags&128)){if(d)return xj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(L,L.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,dj(a,b,c)}return Zi(a,b,c)}var zj,Aj,Bj,Cj;
zj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Aj=function(){};
Bj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;xh(uh.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "select":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&
(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,
c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Cj=function(a,b,c,d){c!==d&&(b.flags|=4)};
function Dj(a,b){if(!I)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}
function Ej(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;zh();E(Wf);E(H);Eh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Fj(zg),zg=null));Aj(a,b);S(b);return null;case 5:Bh(b);var e=xh(wh.current);
c=b.type;if(null!==a&&null!=b.stateNode)Bj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case "dialog":D("cancel",d);D("close",d);break;case "iframe":case "object":case "embed":D("load",d);break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],d);break;case "source":D("error",d);break;case "img":case "image":case "link":D("error",
d);D("load",d);break;case "details":D("toggle",d);break;case "input":Za(d,f);D("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D("invalid",d);break;case "textarea":hb(d,f),D("invalid",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,
h,a),e=["children",""+h]):ea.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D("scroll",d)}switch(c){case "input":Va(d);db(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=kb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):
"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;zj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case "dialog":D("cancel",a);D("close",a);e=d;break;case "iframe":case "object":case "embed":D("load",a);e=d;break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case "source":D("error",a);e=d;break;case "img":case "image":case "link":D("error",
a);D("load",a);e=d;break;case "details":D("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);D("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D("invalid",a);break;case "textarea":hb(a,d);e=gb(a,d);D("invalid",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?sb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):"children"===f?"string"===typeof k?("textarea"!==
c||""!==k)&&ob(a,k):"number"===typeof k&&ob(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D("scroll",a):null!=k&&ta(a,f,k,g))}switch(c){case "input":Va(a);db(a,d,!1);break;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,
!0);break;default:"function"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Cj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(p(166));c=xh(wh.current);xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=
xg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(L);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===
a){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Fj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(L.current&1)?0===T&&(T=3):tj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return zh(),
Aj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return ah(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(L);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Dj(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Ch(a);if(null!==g){b.flags|=128;Dj(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,
g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(L,L.current&1|2);return b.child}a=
a.sibling}null!==f.tail&&B()>Gj&&(b.flags|=128,d=!0,Dj(f,!1),b.lanes=4194304)}else{if(!d)if(a=Ch(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Dj(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Gj&&1073741824!==c&&(b.flags|=128,d=!0,Dj(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=
b,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=L.current,G(L,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Hj(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(fj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}
function Ij(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return zh(),E(Wf),E(H),Eh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Bh(b),null;case 13:E(L);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(L),null;case 4:return zh(),null;case 10:return ah(b.type._context),null;case 22:case 23:return Hj(),
null;case 24:return null;default:return null}}var Jj=!1,U=!1,Kj="function"===typeof WeakSet?WeakSet:Set,V=null;function Lj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Mj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Nj=!1;
function Oj(a,b){Cf=dd;a=Me();if(Ne(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=
q.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;
case 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Ci(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent="":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Nj;Nj=!1;return n}
function Pj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Mj(b,c,f)}e=e.next}while(e!==d)}}function Qj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Rj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}"function"===typeof b?b(a):b.current=a}}
function Sj(a){var b=a.alternate;null!==b&&(a.alternate=null,Sj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Tj(a){return 5===a.tag||3===a.tag||4===a.tag}
function Uj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Tj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}
function Vj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Vj(a,b,c),a=a.sibling;null!==a;)Vj(a,b,c),a=a.sibling}
function Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}var X=null,Xj=!1;function Yj(a,b,c){for(c=c.child;null!==c;)Zj(a,b,c),c=c.sibling}
function Zj(a,b,c){if(lc&&"function"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Lj(c,b);case 6:var d=X,e=Xj;X=null;Yj(a,b,c);X=d;Xj=e;null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Xj;X=c.stateNode.containerInfo;Xj=!0;
Yj(a,b,c);X=d;Xj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Mj(c,b,g):0!==(f&4)&&Mj(c,b,g));e=e.next}while(e!==d)}Yj(a,b,c);break;case 1:if(!U&&(Lj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Yj(a,b,c);break;case 21:Yj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==
c.memoizedState,Yj(a,b,c),U=d):Yj(a,b,c);break;default:Yj(a,b,c)}}function ak(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Kj);b.forEach(function(b){var d=bk.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}
function ck(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Xj=!1;break a;case 3:X=h.stateNode.containerInfo;Xj=!0;break a;case 4:X=h.stateNode.containerInfo;Xj=!0;break a}h=h.return}if(null===X)throw Error(p(160));Zj(f,g,e);X=null;Xj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)dk(b,a),b=b.sibling}
function dk(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:ck(b,a);ek(a);if(d&4){try{Pj(3,a,a.return),Qj(3,a)}catch(t){W(a,a.return,t)}try{Pj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);break;case 5:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,"")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;
a.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];"style"===m?sb(e,q):"dangerouslySetInnerHTML"===m?nb(e,q):"children"===m?ob(e,q):ta(e,m,q,l)}switch(h){case "input":bb(e,f);break;case "textarea":ib(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,
f.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:"",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:ck(b,a);ek(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:ck(b,a);ek(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:ck(b,a);ek(a);break;case 13:ck(b,a);ek(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||
null!==e.alternate&&null!==e.alternate.memoizedState||(fk=B()));d&4&&ak(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,ck(b,a),U=l):ck(b,a);ek(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Pj(4,r,r.return);break;case 1:Lj(r,r.return);var n=r.stateNode;if("function"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=
b.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Lj(r,r.return);break;case 22:if(null!==r.memoizedState){gk(q);continue}}null!==y?(y.return=r,V=y):gk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=
rb("display",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?"":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:ck(b,a);ek(a);d&4&&ak(a);break;case 21:break;default:ck(b,
a),ek(a)}}function ek(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Tj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,""),d.flags&=-33);var f=Uj(a);Wj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Uj(a);Vj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function hk(a,b,c){V=a;ik(a,b,c)}
function ik(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Jj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Jj;var l=U;Jj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?jk(e):null!==k?(k.return=g,V=k):jk(e);for(;null!==f;)V=f,ik(f,b,c),f=f.sibling;V=e;Jj=h;U=l}kk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):kk(a,b,c)}}
function kk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Qj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Ci(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&sh(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=
b.child.stateNode;break;case 1:c=b.child.stateNode}sh(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;
default:throw Error(p(163));}U||b.flags&512&&Rj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function gk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}
function jk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Qj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Rj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Rj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}
var lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K=0,Q=null,Y=null,Z=0,fj=0,ej=Uf(0),T=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=Infinity,uk=null,Oi=!1,Pi=null,Ri=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R(){return 0!==(K&6)?B():-1!==Ak?Ak:Ak=B()}
function yi(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Bk&&(Bk=yc()),Bk;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function gi(a,b,c,d){if(50<yk)throw yk=0,zk=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==Q)a===Q&&(0===(K&2)&&(qk|=c),4===T&&Ck(a,Z)),Dk(a,d),1===c&&0===K&&0===(b.mode&1)&&(Gj=B()+500,fg&&jg())}
function Dk(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===Q?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Ek.bind(null,a)):hg(Ek.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Fk(c,Gk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}
function Gk(a,b){Ak=-1;Bk=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Hk()&&a.callbackNode!==c)return null;var d=uc(a,a===Q?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Ik(a,d);else{b=d;var e=K;K|=2;var f=Jk();if(Q!==a||Z!==b)uk=null,Gj=B()+500,Kk(a,b);do try{Lk();break}catch(h){Mk(a,h)}while(1);$g();mk.current=f;K=e;null!==Y?b=0:(Q=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Nk(a,e)));if(1===b)throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B()),c;if(6===b)Ck(a,d);
else{e=a.current.alternate;if(0===(d&30)&&!Ok(e)&&(b=Ik(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Nk(a,f))),1===b))throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Pk(a,tk,uk);break;case 3:Ck(a,d);if((d&130023424)===d&&(b=fk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){R();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),b);break}Pk(a,tk,uk);break;case 4:Ck(a,d);if((d&4194240)===
d)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*lk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),d);break}Pk(a,tk,uk);break;case 5:Pk(a,tk,uk);break;default:throw Error(p(329));}}}Dk(a,B());return a.callbackNode===c?Gk.bind(null,a):null}
function Nk(a,b){var c=sk;a.current.memoizedState.isDehydrated&&(Kk(a,b).flags|=256);a=Ik(a,b);2!==a&&(b=tk,tk=c,null!==b&&Fj(b));return a}function Fj(a){null===tk?tk=a:tk.push.apply(tk,a)}
function Ok(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}
function Ck(a,b){b&=~rk;b&=~qk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Ek(a){if(0!==(K&6))throw Error(p(327));Hk();var b=uc(a,0);if(0===(b&1))return Dk(a,B()),null;var c=Ik(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Nk(a,d))}if(1===c)throw c=pk,Kk(a,0),Ck(a,b),Dk(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Pk(a,tk,uk);Dk(a,B());return null}
function Qk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Gj=B()+500,fg&&jg())}}function Rk(a){null!==wk&&0===wk.tag&&0===(K&6)&&Hk();var b=K;K|=1;var c=ok.transition,d=C;try{if(ok.transition=null,C=1,a)return a()}finally{C=d,ok.transition=c,K=b,0===(K&6)&&jg()}}function Hj(){fj=ej.current;E(ej)}
function Kk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:zh();E(Wf);E(H);Eh();break;case 5:Bh(d);break;case 4:zh();break;case 13:E(L);break;case 19:E(L);break;case 10:ah(d.type._context);break;case 22:case 23:Hj()}c=c.return}Q=a;Y=a=Pg(a.current,null);Z=fj=b;T=0;pk=null;rk=qk=rh=0;tk=sk=null;if(null!==fh){for(b=
0;b<fh.length;b++)if(c=fh[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}fh=null}return a}
function Mk(a,b){do{var c=Y;try{$g();Fh.current=Rh;if(Ih){for(var d=M.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Ih=!1}Hh=0;O=N=M=null;Jh=!1;Kh=0;nk.current=null;if(null===c||null===c.return){T=1;pk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,
m.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Ui(g);if(null!==y){y.flags&=-257;Vi(y,g,h,f,b);y.mode&1&&Si(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Si(f,l,b);tj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Ui(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Vi(J,g,h,f,b);Jg(Ji(k,h));break a}}f=k=Ji(k,h);4!==T&&(T=2);null===sk?sk=[f]:sk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;
b&=-b;f.lanes|=b;var x=Ni(f,k,b);ph(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&("function"===typeof w.getDerivedStateFromError||null!==u&&"function"===typeof u.componentDidCatch&&(null===Ri||!Ri.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Qi(f,h,b);ph(f,F);break a}}f=f.return}while(null!==f)}Sk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Jk(){var a=mk.current;mk.current=Rh;return null===a?Rh:a}
function tj(){if(0===T||3===T||2===T)T=4;null===Q||0===(rh&268435455)&&0===(qk&268435455)||Ck(Q,Z)}function Ik(a,b){var c=K;K|=2;var d=Jk();if(Q!==a||Z!==b)uk=null,Kk(a,b);do try{Tk();break}catch(e){Mk(a,e)}while(1);$g();K=c;mk.current=d;if(null!==Y)throw Error(p(261));Q=null;Z=0;return T}function Tk(){for(;null!==Y;)Uk(Y)}function Lk(){for(;null!==Y&&!cc();)Uk(Y)}function Uk(a){var b=Vk(a.alternate,a,fj);a.memoizedProps=a.pendingProps;null===b?Sk(a):Y=b;nk.current=null}
function Sk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Ej(c,b,fj),null!==c){Y=c;return}}else{c=Ij(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Pk(a,b,c){var d=C,e=ok.transition;try{ok.transition=null,C=1,Wk(a,b,c,d)}finally{ok.transition=e,C=d}return null}
function Wk(a,b,c,d){do Hk();while(null!==wk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===Q&&(Y=Q=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||vk||(vk=!0,Fk(hc,function(){Hk();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=ok.transition;ok.transition=null;
var g=C;C=1;var h=K;K|=4;nk.current=null;Oj(a,c);dk(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;hk(c,a,e);dc();K=h;C=g;ok.transition=f}else a.current=c;vk&&(vk=!1,wk=a,xk=e);f=a.pendingLanes;0===f&&(Ri=null);mc(c.stateNode,d);Dk(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Oi)throw Oi=!1,a=Pi,Pi=null,a;0!==(xk&1)&&0!==a.tag&&Hk();f=a.pendingLanes;0!==(f&1)?a===zk?yk++:(yk=0,zk=a):yk=0;jg();return null}
function Hk(){if(null!==wk){var a=Dc(xk),b=ok.transition,c=C;try{ok.transition=null;C=16>a?16:a;if(null===wk)var d=!1;else{a=wk;wk=null;xk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Pj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Sj(m);if(m===
l){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Pj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==
u)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Qj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&"function"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,ok.transition=b}}return!1}function Xk(a,b,c){b=Ji(c,b);b=Ni(a,b,1);a=nh(a,b,1);b=R();null!==a&&(Ac(a,1,b),Dk(a,b))}
function W(a,b,c){if(3===a.tag)Xk(a,a,c);else for(;null!==b;){if(3===b.tag){Xk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ri||!Ri.has(d))){a=Ji(c,a);a=Qi(b,a,1);b=nh(b,a,1);a=R();null!==b&&(Ac(b,1,a),Dk(b,a));break}}b=b.return}}
function Ti(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=R();a.pingedLanes|=a.suspendedLanes&c;Q===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-fk?Kk(a,0):rk|=c);Dk(a,b)}function Yk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=R();a=ih(a,b);null!==a&&(Ac(a,b,c),Dk(a,c))}function uj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Yk(a,c)}
function bk(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Yk(a,c)}var Vk;
Vk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)dh=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return dh=!1,yj(a,b,c);dh=0!==(a.flags&131072)?!0:!1}else dh=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;ij(a,b);a=b.pendingProps;var e=Yf(b,H.current);ch(b,c);e=Nh(null,b,d,a,e,c);var f=Sh();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=
null,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,kh(b),e.updater=Ei,b.stateNode=e,e._reactInternals=b,Ii(b,d,a,c),b=jj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Xi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{ij(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Zk(d);a=Ci(d,a);switch(e){case 0:b=cj(null,b,d,a,c);break a;case 1:b=hj(null,b,d,a,c);break a;case 11:b=Yi(null,b,d,a,c);break a;case 14:b=$i(null,b,d,Ci(d.type,a),c);break a}throw Error(p(306,
d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),cj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),hj(a,b,d,e,c);case 3:a:{kj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;lh(a,b);qh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=
f,b.memoizedState=f,b.flags&256){e=Ji(Error(p(423)),b);b=lj(a,b,d,c,e);break a}else if(d!==e){e=Ji(Error(p(424)),b);b=lj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Vg(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=Zi(a,b,c);break a}Xi(a,b,d,c)}b=b.child}return b;case 5:return Ah(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),
gj(a,b),Xi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return oj(a,b,c);case 4:return yh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Ug(b,null,d,c):Xi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),Yi(a,b,d,e,c);case 7:return Xi(a,b,b.pendingProps,c),b.child;case 8:return Xi(a,b,b.pendingProps.children,c),b.child;case 12:return Xi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;
g=e.value;G(Wg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=Zi(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=mh(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);bh(f.return,
c,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);bh(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Xi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,ch(b,c),e=eh(e),d=d(e),b.flags|=1,Xi(a,b,d,c),
b.child;case 14:return d=b.type,e=Ci(d,b.pendingProps),e=Ci(d.type,e),$i(a,b,d,e,c);case 15:return bj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),ij(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,ch(b,c),Gi(b,d,e),Ii(b,d,e,c),jj(null,b,d,!0,a,c);case 19:return xj(a,b,c);case 22:return dj(a,b,c)}throw Error(p(156,b.tag));};function Fk(a,b){return ac(a,b)}
function $k(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new $k(a,b,c,d)}function aj(a){a=a.prototype;return!(!a||!a.isReactComponent)}
function Zk(a){if("function"===typeof a)return aj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}
function Pg(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function Rg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)aj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ya:return Tg(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return pj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;
break a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,""));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Tg(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function pj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function Qg(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}
function Sg(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function al(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=
null}function bl(a,b,c,d,e,f,g,h,k){a=new al(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};kh(f);return a}function cl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
function dl(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}
function el(a,b,c,d,e,f,g,h,k){a=bl(c,d,!0,a,e,f,g,h,k);a.context=dl(null);c=a.current;d=R();e=yi(c);f=mh(d,e);f.callback=void 0!==b&&null!==b?b:null;nh(c,f,e);a.current.lanes=e;Ac(a,e,d);Dk(a,d);return a}function fl(a,b,c,d){var e=b.current,f=R(),g=yi(e);c=dl(c);null===b.context?b.context=c:b.pendingContext=c;b=mh(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=nh(e,b,g);null!==a&&(gi(a,e,g,f),oh(a,e,g));return g}
function gl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function hl(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function il(a,b){hl(a,b);(a=a.alternate)&&hl(a,b)}function jl(){return null}var kl="function"===typeof reportError?reportError:function(a){console.error(a)};function ll(a){this._internalRoot=a}
ml.prototype.render=ll.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));fl(a,b,null,null)};ml.prototype.unmount=ll.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Rk(function(){fl(null,a,null,null)});b[uf]=null}};function ml(a){this._internalRoot=a}
ml.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function nl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function pl(){}
function ql(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=gl(g);f.call(a)}}var g=el(b,d,a,0,null,!1,!1,"",pl);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Rk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=gl(k);h.call(a)}}var k=bl(a,0,!1,null,null,!1,!1,"",pl);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Rk(function(){fl(b,k,c,d)});return k}
function rl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=gl(g);h.call(a)}}fl(b,g,a,e)}else g=ql(c,b,a,e,d);return gl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Dk(b,B()),0===(K&6)&&(Gj=B()+500,jg()))}break;case 13:Rk(function(){var b=ih(a,1);if(null!==b){var c=R();gi(b,a,1,c)}}),il(a,1)}};
Fc=function(a){if(13===a.tag){var b=ih(a,134217728);if(null!==b){var c=R();gi(b,a,134217728,c)}il(a,134217728)}};Gc=function(a){if(13===a.tag){var b=yi(a),c=ih(a,b);if(null!==c){var d=R();gi(c,a,b,d)}il(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};
yb=function(a,b,c){switch(b){case "input":bb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Qk;Hb=Rk;
var sl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"};
var ul={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||
jl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var vl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl.isDisabled&&vl.supportsFiber)try{kc=vl.inject(ul),lc=vl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl;
exports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!nl(b))throw Error(p(200));return cl(a,b,null,c)};exports.createRoot=function(a,b){if(!nl(a))throw Error(p(299));var c=!1,d="",e=kl;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=bl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ll(b)};
exports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(",");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Rk(a)};exports.hydrate=function(a,b,c){if(!ol(b))throw Error(p(200));return rl(null,a,b,!0,c)};
exports.hydrateRoot=function(a,b,c){if(!nl(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=kl;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=el(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,
e);return new ml(b)};exports.render=function(a,b,c){if(!ol(b))throw Error(p(200));return rl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!ol(a))throw Error(p(40));return a._reactRootContainer?(Rk(function(){rl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Qk;
exports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!ol(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return rl(a,b,c,!1,d)};exports.version="18.3.1-next-f1338f8080-20240426";


/***/ }),

/***/ 917:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;


var m = __webpack_require__(684);
if (true) {
  exports.H = m.createRoot;
  __webpack_unused_export__ = m.hydrateRoot;
} else { var i; }


/***/ }),

/***/ 684:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(492);
} else {}


/***/ }),

/***/ 915:
/***/ ((__unused_webpack_module, exports) => {

/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return"function"===typeof a?a:null}
var B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};
E.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;
H.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}
function N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g;function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
function R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=
a[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
function S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}
var U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};function X(){throw Error("act(...) is not supported in production builds of React.");}
exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};exports.Component=E;exports.Fragment=p;exports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;exports.act=X;
exports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};
exports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=X;exports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};
exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};exports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};
exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};exports.useTransition=function(){return U.current.useTransition()};exports.version="18.3.1";


/***/ }),

/***/ 296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (true) {
  module.exports = __webpack_require__(915);
} else {}


/***/ }),

/***/ 827:
/***/ ((__unused_webpack_module, exports) => {

/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}
function g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;
"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}
function J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;
function M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if("function"===typeof F)S=function(){F(R)};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}
exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};
exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};
exports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};
exports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};


/***/ }),

/***/ 194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (true) {
  module.exports = __webpack_require__(827);
} else {}


/***/ }),

/***/ 597:
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 578:
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 753:
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 138:
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 238:
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 181:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "img/bg.jpeg";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			792: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};

// EXTERNAL MODULE: ./node_modules/.store/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__(296);
var react_namespaceObject = /*#__PURE__*/__webpack_require__.t(react, 2);
// EXTERNAL MODULE: ./node_modules/.store/react-dom@18.3.1/node_modules/react-dom/client.js
var client = __webpack_require__(917);
// EXTERNAL MODULE: ./node_modules/.store/style-loader@3.3.4/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(597);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/.store/style-loader@3.3.4/node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(138);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/.store/style-loader@3.3.4/node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(578);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/.store/style-loader@3.3.4/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(229);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/.store/style-loader@3.3.4/node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(753);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/.store/style-loader@3.3.4/node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(238);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/.store/css-loader@6.11.0/node_modules/css-loader/dist/cjs.js!./node_modules/.store/less-loader@11.1.4/node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/views/note/index.less
var note = __webpack_require__(709);
;// CONCATENATED MODULE: ./src/views/note/index.less

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(note/* default */.A, options);




       /* harmony default export */ const views_note = (note/* default */.A && note/* default */.A.locals ? note/* default */.A.locals : undefined);

;// CONCATENATED MODULE: ./src/util/index.ts
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const get = (url) => __async(void 0, null, function* () {
  const xhr = new XMLHttpRequest();
  return new Promise((rs) => {
    xhr.open("GET", url, true);
    xhr.onload = function() {
      if (xhr.status >= 200 && xhr.status < 400) {
        const responseData = JSON.parse(xhr.responseText);
        rs({ code: 200, data: responseData });
      } else {
        rs({ code: xhr.status, data: null });
      }
    };
    xhr.onerror = function() {
      rs({ code: -1, data: null });
    };
    xhr.send();
  });
});

;// CONCATENATED MODULE: ./node_modules/.store/asura-eye@0.8.0/node_modules/asura-eye/lib/index.esm.js
/**
 * @title isEmpty
 * @description 是无效值 undefined , null, NaN
 * @param value {unknown} 待值
 * @returns {boolean}
 */
function isEmpty(value) {
    return value === undefined || value === null || value !== value;
}
/**
 * @title isNoEmpty<T>
 * @description 不是是无效值 undefined , null, NaN
 * @param {unknown} value
 * @returns {boolean}
 * @version 0.3.0
 */
function isNoEmpty(value) {
    return value !== undefined && value !== null && value === value;
}
/**
 * @title isNull
 * @param {unknown} value
 * @returns {boolean}
 */
function isNull(value) {
    return value === null;
}
/**
 * @title isNoNull<T>
 * @param {unknown} value
 * @returns {boolean}
 */
function isNoNull(value) {
    return value !== null;
}
/**
 * @title isUndefined
 * @param {unknown} value
 * @returns {boolean}
 */
function isUndefined(value) {
    return value === undefined;
}
/**
 * @title isNoUndefined<T>
 * @param {unknown} value
 * @returns {boolean}
 */
function isNoUndefined(value) {
    return value !== undefined;
}
/**
 * @title isNaN
 * @param {unknown} value
 * @returns {boolean}
 */
const isNaN$1 = Number.isNaN;

/**
 * @title isIterator
 * @description 是iterator
 * @param {unknown} value
 * @returns {boolean}
 */
function isIterator(value) {
    if (typeof value !== 'object' || isEmpty(value))
        return false;
    return /Iterator\]$/.test(value.toString());
}
/**
 * @title isArrayIterator
 * @description 是 Array Iterator
 * @param {unknown} value
 * @returns {boolean}
 */
function isArrayIterator(value) {
    if (typeof value !== 'object' || isEmpty(value))
        return false;
    return value.toString() === '[object Array Iterator]';
}
/**
 * @title isMapIterator
 * @description 是 Map Iterator
 * @param {unknown} value
 * @returns {boolean}
 */
function isMapIterator(value) {
    if (typeof value !== 'object' || isEmpty(value))
        return false;
    return value.toString() === '[object Map Iterator]';
}
/**
 * @title isSetIterator
 * @description 是 Set Iterator
 * @param {unknown} value
 * @returns {boolean}
 */
function isSetIterator(value) {
    if (typeof value !== 'object' || isEmpty(value))
        return false;
    return value.toString() === '[object Set Iterator]';
}

function type(param) {
    try {
        if (isIterator(param))
            return 'Iterator';
        const result = Object.prototype.toString
            .call(param)
            .match(/\[object (\w+)\]/)[1];
        if (result === 'Number' && isNaN(param))
            return 'NaN';
        return result;
    }
    catch (error) {
        return 'Undefined';
    }
}
/**
 * @title types
 * @description 获取类型数组
 * @param {unknown[]} params 待判断的参数列表
 * @param {boolean} [hasRepeat=false] 保留重复类型
 * @return {string[]} 类型名称
 */
function types(params, hasRepeat = false) {
    if (!Array.isArray(params))
        return [];
    const result = params.map(i => type(i)) || [];
    return hasRepeat ? result : [...new Set(result)];
}

const MAX_VALUES_NUMBER = 1.7976931348623157e+308;
const MIN_VALUES_NUMBER = (/* unused pure expression or super */ null && (-1.7976931348623157e+308));
const INFINITY = (/* unused pure expression or super */ null && (Infinity)); // 无限
/**
 * @description 空值(undefined, null, NaN)
 */
const EMPTY = [undefined, null, NaN];

/**
 * @title isObject
 * @description 是Object
 * @param {unknown} value
 * @returns {boolean}
 */
function isObject(value) {
    return value !== null && typeof value === 'object' && type(value) === 'Object';
}
/**
 * @title isEmptyObject
 * @description 是空Object
 * @param {unknown} value
 * @returns {boolean}
 */
function isEmptyObject(value) {
    if (isEmpty(value))
        return false;
    return isObject(value) && Reflect.ownKeys(value).length === 0;
}
/**
 * @title isEffectObject
 * @description 是有效Object(非空)
 * @param {unknown} value
 * @returns {boolean}
 */
function isEffectObject(value) {
    if (isEmpty(value))
        return false;
    return isObject(value) && Reflect.ownKeys(value).length !== 0;
}

/**
 * @title isString
 * @description 是字符串
 * @param {unknown} value
 * @returns {boolean}
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * @title isJsonString<T>
 * @description 是json字符串, 若是并返回处理后的对象
 * @param {unknown} val 待判断字符串
 * @returns {boolean}
 */
function isJsonString(val) {
    if (!isString(val))
        return false;
    try {
        const obj = JSON.parse(val);
        return isObject(obj);
    }
    catch (e) {
        return false;
    }
}

/**
 * @title isNumber
 * @description 是数字
 * @param {unknown} value
 * @returns {boolean}
 */
const isNumber = (value) => {
    return typeof value === 'number' && type(value) === 'Number';
};
/**
 * @title isEffectNumber
 * @description 是js的有效区间的数, 非number类型都为false
 * @param {unknown} value
 * @returns {boolean}
 */
function isEffectNumber(value) {
    if (type(value) === 'Number') {
        if (value === INFINITY || value === -INFINITY)
            return false;
        return true;
    }
    return false;
}
/**
 * @title isFloat
 * @description 判断数是浮点型
 * @param {unknown} value 待检测的数据类型
 * @returns {boolean}
 */
function isFloat(value) {
    if (!isNumber(value))
        return false;
    return (value % 1) !== 0;
}
/**
 * @title isInteger
 * @description 判断数是整型
 * @param {unknown} value 待检测的数据类型
 * @returns {boolean}
 */
function isInteger(value) {
    if (!isNumber(value))
        return false;
    return (value % 1) === 0;
}
/**
 * @title isBigInt
 * @description 是bigInt类型
 * @param {unknown} value 待检测的数据类型
 * @returns {boolean}
 */
const isBigInt = (value) => type(value) === 'BigInt';
/**
 * @title likeNumber
 * @description 是数字/数字字符串
 * @support: Number, NumberString
 * @unsupported: Infinity, Function
 * @param {unknown} value
 * @returns {boolean}
 * @version 0.1.0
 */
function likeNumber(value) {
    if (isNumber(value))
        return true;
    if (isString(value))
        value = value.trim();
    if (isEmpty(value)
        || value === '')
        return false;
    if (Number.isNaN(Number(value)) === false) {
        return true;
    }
    return false;
}

/**
 * @title isArray
 * @description 是数组
 * @param {unknown} list
 * @returns {boolean}
 */
function isArray(list) {
    return Array.isArray(list);
}
// export const isArray = Array.isArray
/**
 * @title isNumberArray
 * @description 是数字数组
 * @param {unknown} list
 * @returns {boolean}
 */
function isNumberArray(list) {
    if (!isArray(list)) {
        return false;
    }
    for (let i = 0; i < list.length; i++) {
        if (isNumber(list[i])) {
            continue;
        }
        return false;
    }
    return true;
}
/**
 * @title isEmptyArray
 * @description 是空数组
 * @param {unknown} list
 * @returns {boolean}
 */
function isEmptyArray(list) {
    if (isEmpty(list))
        return false;
    return isArray(list) && list.length === 0;
}
/**
 * @title isEffectArray
 * @description 是有效数组
 * @param {unknown} list
 * @returns {boolean}
 */
function isEffectArray(list) {
    if (isEmpty(list))
        return false;
    return isArray(list) && list.length > 0;
}

/**
 * @title isFunction
 * @description 是函数
 * @param {unknown} value
 * @param {boolean} [strict=false] 严格模式
 * @returns {boolean}
 */
function isFunction(value, strict = false) {
    if (strict) {
        return typeof value === 'function';
    }
    return type(value) === 'Function';
}
/**
 * @title isAsyncFunction
 * @description 是异步函数
 * @param {unknown} value
 * @returns {boolean}
 */
function isAsyncFunction(value) {
    return type(value) === 'AsyncFunction';
}
/**
 * @title likeFunction
 * @description 是函数
 * @param {unknown} value
 * @returns {boolean}
 * @version 0.4.0
 */
function likeFunction(value) {
    return type(value) === 'Function' || type(value) === 'AsyncFunction';
}
/**
 * @title isEmptyFunction
 * @description 是空方法
 * @param {unknown} value
 * @returns {boolean}
 * @version 0.4.0
 */
function isEmptyFunction(value) {
    if (isEmpty(value))
        return false;
    return isFunction(value) && /\{\}$/.test(value.toString().replaceAll(' ', ''));
}
/**
 * @title isEffectFunction
 * @description 是有效方法(非空方法)
 * @param {unknown} value
 * @returns {boolean}
 * @version 0.4.0
 */
function isEffectFunction(value) {
    if (isEmpty(value))
        return false;
    return isFunction(value) && /\{.+\}$/.test(value.toString().replaceAll(' ', ''));
}

/**
 * @title isDate
 * @description 检查日期是否有效
 * @param {unknown} date 待判断日期
 * @returns {boolean}
 * @version 0.1.0
 */
function isDate(date) {
    return type(date) === 'Date';
}
/**
 * @title likeDate
 * @description 检查日期是否有效, 时间戳也为有效时间(13位/10位)
 * @param {unknown} date
 * @returns {boolean}
 */
function likeDate(date) {
    if (isDate(date))
        return true;
    if ((isString(date) && isNumber(Number(date)))
        || isNumber(date)) {
        if (date.toString().length === 13)
            return true;
        if (date.toString().length === 10)
            return true;
    }
    return false;
}
/**
 * @title isTime
 * @description 检查日期是否有效, 时间戳也为有效时间(13位/10位)
 * @param {unknown} time 待判断日期
 * @returns {boolean}
 * @version 0.1.0
 */
function isTime(time) {
    if (isNumber(time)) {
        if (time.toString().length === 13)
            return true;
        if (time.toString().length === 10)
            return true;
    }
    return time instanceof Date && !isNaN(time.getTime());
}
// 该方法用于检测给出的日期是否有效：
// const isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf());
// isDateValid("December 17, 1995 03:24:00");  // true

/**
 * @title FileTypeMap
 * @description 文件类型映射
 * @version 0.1.0
 */
const FileTypeMap = new Map([
    ['Image', ['png', 'jpeg', 'jpg', 'png', 'bmp']],
    ['Video', ['mp4', 'webm', 'ogg']],
    ['PDF', ['pdf']],
    ['Word', ['doc', 'docx']],
    ['Excel', ['.xlsx', '.xls', '.csv']],
]);
/**
 * @title isFileExtension
 * @description 是指定字符串结尾
 * @param {string} fileName 文件名
 * @param {string[]} list 文件拓展名数组
 * @returns boolean
 * @version 0.1.0
 */
function isFileExtension(fileName, list = []) {
    if (typeof fileName !== 'string')
        return false;
    if (/\.[a-zA-Z0-9]{1,}/.exec(fileName) === null)
        return false;
    if (list.length === 0)
        return true;
    const name = fileName.toLowerCase();
    return list.some(i => name.endsWith(i) === true);
}
/**
 * @title isFile
 * @param {string} fileName
 * @param {FileType} type
 * @returns {boolean}
 * @version 0.1.0
 */
function isFile(fileName, type) {
    return isFileExtension(fileName, FileTypeMap.get(type));
}
/**
 * @title isImageFile
 * @param {string} fileName
 * @returns {boolean}
 * @version 0.1.0
 */
function isImageFile(fileName) {
    return isFileExtension(fileName, FileTypeMap.get('Image'));
}
/**
 * @title isVideoFile
 * @param {string} fileName
 * @returns {boolean}
 * @version 0.1.0
 */
function isVideoFile(fileName) {
    return isFileExtension(fileName, FileTypeMap.get('Video'));
}
/**
 * @title isPdfFile
 * @param {string} fileName
 * @returns {boolean}
 * @version 0.1.0
 */
function isPdfFile(fileName) {
    return isFileExtension(fileName, FileTypeMap.get('PDF'));
}
/**
 * @title isWordFile
 * @param {string} fileName
 * @returns {boolean}
 * @version 0.1.0
 */
function isWordFile(fileName) {
    return isFileExtension(fileName, FileTypeMap.get('Word'));
}
/**
 * @title isExcelFile
 * @param {string} fileName
 * @returns {boolean}
 * @version 0.1.0
 */
function isExcelFile(fileName) {
    return isFileExtension(fileName, FileTypeMap.get('Excel'));
}
/**
 * @title isClient
 * @description 是否为客户端
 */
const isClient = typeof window !== 'undefined';
/**
 * @title isBoolean
 * @description 是布尔值
 * @param {unknown} val
 * @returns {boolean}
 */
const isBoolean = (val) => typeof val === 'boolean';
/**
 * @title isWindow
 * @description 是否为window端
 * @param {unknown} val
 * @returns {boolean}
 */
const isWindow = (val) => typeof window !== 'undefined' && toString.call(val) === '[object Window]';
/**
 * @title isIOS
 * @returns {boolean}
 */
const isIOS =  isClient && window?.navigator?.userAgent && /iP(ad|hone|od)/.test(window.navigator.userAgent);
/**
 * @title hasOwn
 * @param {object} val
 * @param {string} key
 * @returns {boolean}
 */
const hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);

/**
 * @title isHexColor
 * @description 是颜色字符串或数字
 * @param {string} hex 三位/六位的十六进制的颜色
 * @returns {boolean}
 */
function isHexColor(hex) {
    if (hex.length === 3) {
        hex += hex;
    }
    return (type(hex) === 'String')
        && hex.length === 6 && !isNaN(Number('0x' + hex));
}

/**
 * @title isRegExp
 * @description 判断是否为正则表达式
 * @param {unknown} value
 * @returns {boolean}
 */
function isRegExp(value) {
    return type(value) === 'RegExp';
}

/**
 * @title isSymbol
 * @param {unknown} value
 * @returns {boolean}
 */
function isSymbol(value) {
    return typeof value === 'symbol';
}

/**
 * @title isError
 * @param {unknown} value
 * @returns {boolean}
 */
function isError(value) {
    return type(value) === 'Error' || value instanceof Error;
}

/**
 * @title isSet
 * @param {unknown} value
 * @returns {boolean}
 */
function isSet(value) {
    return type(value) === 'Set';
}
/**
 * @title isEmptySet
 * @param {unknown} value
 * @returns {boolean}
 */
function isEmptySet(value) {
    return isSet(value) && value.size === 0;
}
/**
 * @title isEffectSet
 * @param {unknown} value
 * @returns {boolean}
 */
function isEffectSet(value) {
    return isSet(value) && value.size > 0;
}

/**
 * @title isMap
 * @param {unknown} value
 * @returns {boolean}
 */
function isMap(value) {
    return type(value) === 'Map';
}
/**
 * @title isEmptyMap
 * @description 是空Map
 * @param {unknown} value
 * @returns {boolean}
 */
function isEmptyMap(value) {
    if (isEmpty(value))
        return false;
    return isMap(value) && isUndefined(value.keys().next().value);
}
/**
 * @title isEffectMap
 * @description 是有效Map
 * @param {unknown} value
 * @returns {boolean}
 */
function isEffectMap(value) {
    if (isEmpty(value))
        return false;
    return isMap(value) && !isEmpty(value.keys().next().value);
}

/**
 * @title isPromise
 * @param {unknown} value
 * @returns {boolean}
 */
function isPromise(value) {
    return type(value) === 'Promise';
}

/**
 * @title isInstance
 * @param {unknown} value
 * @param {unknown} InStance
 * @returns {boolean}
 */
function isInstance(value, InStance) {
    if (!value)
        return false;
    if (!value.__proto__)
        return false;
    if (!InStance.prototype)
        return false;
    while (value) {
        if (value.__proto__ === InStance.prototype)
            return true;
        else
            value = value.__proto__;
    }
    return false;
}

function IS(type$1) {
    if (isString(type$1)) {
        type$1 = type$1.replace(/ |\n|\t/gi, '');
        // object string
        if (/^{(.+)}$/.test(type$1)) {
            const typeObject = JSON.parse(type$1.replace(/(\w+)/gi, `"$&"`));
            return (value) => {
                if (!isObject(value))
                    return false;
                if (Object.keys(value).length !== Object.keys(typeObject).length)
                    return false;
                for (const key in typeObject) {
                    if (type(value[key]) !== typeObject[key]
                        && !IS(typeObject[key])(value[key])) {
                        return false;
                    }
                }
                return true;
            };
        }
        // array string
        if (/^\[(.+)\]$/.test(type$1)) {
            const [, newType] = /\[(.+)\]$/.exec(type$1) || [undefined, undefined];
            const newTypes = isString(newType) ? newType.split(',') : [];
            return (value) => {
                if (!isArray(value))
                    return false;
                if (newTypes.length !== value.length)
                    return false;
                for (let i = 0; i < value.length; i++)
                    if (type(value[i]) !== newTypes[i])
                        return false;
                return true;
            };
        }
        // type array
        if (/\[\]$/.test(type$1)) {
            const [, newType] = /(.+)\[\]$/.exec(type$1) || [undefined, undefined];
            return (value) => {
                if (!isArray(value))
                    return false;
                for (let i = 0; i < value.length; i++)
                    if (type(value[i]) !== newType
                        && !IS(newType)(value[i])) {
                        return false;
                    }
                return true;
            };
        }
        // mult type
        if (type$1.indexOf('|') > -1) {
            const newTypes = type$1.split('|');
            return (value) => {
                return newTypes.includes((type(value)));
            };
        }
    }
    if (isObject(type$1)) {
        return (value) => {
            if (!isObject(value))
                return false;
            for (const key in type$1) {
                if (type(value[key]) !== type$1[key]
                    && !IS(type$1[key])(value[key])) {
                    return false;
                }
            }
            return true;
        };
    }
    if (isArray(type$1)) {
        return (value) => {
            if (!isArray(value) || value.length !== type$1.length)
                return false;
            for (let i = 0; i < value.length; i++) {
                if (type(value[i]) !== type$1[i]
                    && !IS(type$1[i])(value[i])) {
                    return false;
                }
            }
            return true;
        };
    }
    return (value) => {
        return type$1 === type(value);
    };
}


//# sourceMappingURL=index.esm.js.map

;// CONCATENATED MODULE: ./node_modules/.store/0hook@1.5.0/node_modules/0hook/lib/index.esm.js


/**
 * @title isEmpty
 * @description 是无效值 undefined , null, NaN
 * @param value {unknown} 待值
 * @returns {boolean}
 */
function isEmpty$1(value) {
    return value === undefined || value === null || value !== value;
}

/**
 * @title isIterator
 * @description 是iterator
 * @param {unknown} value
 * @returns {boolean}
 */
function isIterator$1(value) {
    if (typeof value !== 'object' || isEmpty$1(value))
        return false;
    return /Iterator\]$/.test(value.toString());
}

function type$1(param) {
    try {
        if (isIterator$1(param))
            return 'Iterator';
        const result = Object.prototype.toString
            .call(param)
            .match(/\[object (\w+)\]/)[1];
        if (result === 'Number' && isNaN(param))
            return 'NaN';
        return result;
    }
    catch (error) {
        return 'Undefined';
    }
}

/**
 * @title isString
 * @description 是字符串
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isString(value) {
    return typeof value === 'string';
}

/**
 * @title isNumber
 * @description 是数字
 * @param {unknown} value
 * @returns {boolean}
 */
const index_esm_isNumber = (value) => {
    return typeof value === 'number' && type$1(value) === 'Number';
};

/**
 * @title isArray
 * @description 是数组
 * @param {unknown} list
 * @returns {boolean}
 */
function isArray$1(list) {
    return Array.isArray(list);
}
/**
 * @title isEffectArray
 * @description 是有效数组
 * @param {unknown} list
 * @returns {boolean}
 */
function index_esm_isEffectArray(list) {
    if (isEmpty$1(list))
        return false;
    return isArray$1(list) && list.length > 0;
}
/**
 * @title isClient
 * @description 是否为客户端
 */
const index_esm_isClient = typeof window !== 'undefined';
/**
 * @title isBoolean
 * @description 是布尔值
 * @param {unknown} val
 * @returns {boolean}
 */
const index_esm_isBoolean = (val) => typeof val === 'boolean';
/**
 * @title isIOS
 * @returns {boolean}
 */
index_esm_isClient &&
    window?.navigator?.userAgent &&
    /iP(ad|hone|od)/.test(window.navigator.userAgent);

/**
 * @title useBoolean
 * @description 布尔值切换
 * @param initialState {boolean=true}
 * @returns [boolean, ()=>void]
 */
function useBoolean(initialState = true) {
    const [state, setState] = useState(initialState);
    return [
        state,
        useCallback((value) => setState(state => index_esm_isBoolean(value) ? value : !state), [])
    ];
}

function getTargetValue(val, options = {}) {
    const { min = 0, max = Infinity } = options;
    let target = val;
    if (index_esm_isNumber(max)) {
        target = Math.min(max, target);
    }
    if (index_esm_isNumber(min)) {
        target = Math.max(min, target);
    }
    return target;
}
/**
 * @title useCount
 * @description 计数
 * @param initialState {number=0}
 * @param options {min?:number,max?:number}
 * @returns [number, (value?:number)=>void]
 */
function useCount(initialState = 0, options = {}) {
    const [state, setStateTemp] = useState(getTargetValue(initialState, options));
    const setState = (value) => {
        if (isEmpty$1(value)) {
            const result = getTargetValue(state + 1, options);
            if (result !== state)
                setStateTemp(result);
            return;
        }
        setStateTemp(getTargetValue(value, options));
        return;
    };
    return [state, setState];
}

/**
 * @title isEmpty
 * @description 是无效值 undefined , null, NaN
 * @param value {unknown} 待值
 * @returns {boolean}
 */
function index_esm_isEmpty(value) {
    return value === undefined || value === null || value !== value;
}

/**
 * @title isArray
 * @description 是数组
 * @param value {unknown}
 * @returns {boolean}
 */
function index_esm_isArray(list) {
    return Array.isArray(list);
}

/**
 * @title isIterator
 * @description 是iterator
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isIterator(value) {
    if (typeof value !== 'object' || index_esm_isEmpty(value))
        return false;
    return /Iterator\]$/.test(value.toString());
}

function index_esm_type(param) {
    try {
        if (index_esm_isIterator(param))
            return 'Iterator';
        const result = Object.prototype.toString
            .call(param)
            .match(/\[object (\w+)\]/)[1];
        if (result === 'Number' && isNaN(param))
            return 'NaN';
        return result;
    }
    catch (error) {
        return 'Undefined';
    }
}

/**
 * @title isObject
 * @description 是Object
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isObject(value) {
    return value !== null && typeof value === 'object' && index_esm_type(value) === 'Object';
}

/**
 * @title isDate
 * @description 检查日期是否有效
 * @param {unknown} date 待判断日期
 * @returns {boolean}
 * @version 0.1.0
 */
function index_esm_isDate(date) {
    return index_esm_type(date) === 'Date';
}

/**
 * @title isSet
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isSet(value) {
    return index_esm_type(value) === 'Set';
}

/**
 * @title isMap
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isMap(value) {
    return index_esm_type(value) === 'Map';
}

/**
 * @title equalHelper
 * @description 比较是否值和类型是否相等, 不支持WeakMap, WeakSet
 * @param {unknown} compareValue
 * @param {unknown} beCompareValue
 * @returns {boolean}
 */
function equalHelper(compareValue, beCompareValue) {
    const compareValueType = index_esm_type(compareValue);
    const beCompareValueType = index_esm_type(beCompareValue);
    if (compareValue !== beCompareValueType || compareValueType === 'Symbol')
        return false;
    return compareValue === beCompareValue;
}

/**
 * @title equalMap
 * @param {MapType} compareMap
 * @param {MapType} beCompareMap
 * @returns {boolean}
 */
function equalMap(compareMap, beCompareMap, equal = equalHelper) {
    if (!index_esm_isMap(compareMap) ||
        !index_esm_isMap(beCompareMap) ||
        compareMap.size !== beCompareMap.size)
        return false;
    for (const [key, value] of compareMap) {
        const beCompareMapTempValue = beCompareMap.get(key);
        if (equal(value, beCompareMapTempValue)) {
            continue;
        }
        return false;
    }
    return true;
}

/**
 * @title equalSet
 * @param {SetType} compareSet
 * @param {SetType} beCompareSet
 * @returns {boolean}
 */
function equalSet(compareSet, beCompareSet, equal = equalHelper) {
    if (!index_esm_isSet(compareSet) ||
        !index_esm_isSet(beCompareSet) ||
        compareSet.size !== beCompareSet.size)
        return false;
    const list = [...compareSet];
    const beList = [...beCompareSet];
    for (let i = 0; i < list.length; i++) {
        if (equal(list[i], beList[i])) {
            continue;
        }
        return false;
    }
    // for (const value of compareSet) {
    //   if (beCompareSet.has(value)) continue
    //   return false
    // }
    return true;
}

/**
 * @title equalArray
 * @param {unknown|any[]} compare
 * @param {unknown|any[]} beCompare
 * @returns {boolean}
 */
function equalArray(compare, beCompare, equal = equalHelper) {
    if (index_esm_isArray(compare) &&
        index_esm_isArray(beCompare) &&
        compare.length === beCompare.length) {
        for (let i = 0; i < compare.length; i++) {
            const item = compare[i];
            if (equal(item, beCompare[i])) {
                continue;
            }
            return false;
        }
        return true;
    }
    return false;
}

function equalObject(compare, beCompare, equal = equalHelper) {
    if (!index_esm_isObject(compare) || !index_esm_isObject(beCompare))
        return false;
    const compareValueKeys = Object.keys(compare);
    const beCompareValueKeys = Object.keys(beCompare);
    if (compareValueKeys.length !== beCompareValueKeys.length)
        return false;
    for (let i = 0; i < compareValueKeys.length; i++) {
        const key = compareValueKeys[i];
        if (equal(compare[key], beCompare[key]))
            continue;
        return false;
    }
    return true;
}

/**
 * @title equal
 * @description 比较是否值和类型是否相等/相同, 不支持类型由`===`来比较
 * @supported 基础数据类型, Object, Array, Map, Set, Date
 * @notSupported WeakMap, WeakSet
 * @param {unknown} compareValue
 * @param {unknown} beCompareValue
 * @returns {boolean}
 * @version 2.4.4
 * @lastUpdate 3.8.0
 */
function equal(compareValue, beCompareValue) {
    const compareValueType = index_esm_type(compareValue);
    const beCompareValueType = index_esm_type(beCompareValue);
    if (compareValueType !== beCompareValueType)
        return false;
    if (compareValueType === 'Object')
        return equalObject(compareValue, beCompareValue, equal);
    if (compareValueType === 'Array')
        return equalArray(compareValue, beCompareValue, equal);
    if (compareValueType === 'Map')
        return equalMap(compareValue, beCompareValue, equal);
    if (compareValueType === 'Set')
        return equalSet(compareValue, beCompareValue, equal);
    if (Number.isNaN(compareValue))
        return Number.isNaN(beCompareValue);
    if (index_esm_isDate(compareValue) && index_esm_isDate(beCompareValue))
        return compareValue.getTime() === beCompareValue.getTime();
    return compareValue === beCompareValue;
}

/**
 * @title useMap<Key,Value>
 * @description Map数据管理
 * @param initialValue {Map}
 * @returns {[Map, Actions]}
 */
function useMap(initialValue) {
    const getInitialValue = () => initialValue === undefined ? new Map() : new Map(initialValue);
    const [map, setMap] = useState(() => getInitialValue());
    const set = (key, value, force = false) => {
        if (equal(map.get(key), value) && !force) {
            return;
        }
        setMap((prev) => {
            const temp = new Map(prev);
            temp.set(key, value);
            return temp;
        });
    };
    const setAll = (newMap) => {
        setMap(new Map(newMap));
    };
    const remove = (key) => {
        setMap((prev) => {
            const temp = new Map(prev);
            temp.delete(key);
            return temp;
        });
    };
    const reset = () => setMap(getInitialValue());
    const get = (key) => map.get(key);
    const keys = () => Array.from(map.keys());
    return [map, {
            keys,
            set,
            setAll,
            remove,
            reset,
            get,
        }];
}

/**
 * @title useObject<Object>
 * @description 管理对象状态
 * @param initialValue {?Object}
 * @returns [object, Actions<Object>]
 */
function useObject(initialValue) {
    const getInitialValue = () => initialValue || {};
    const [state, setState] = useState(() => getInitialValue());
    const setObject = (record) => {
        if (!equal(record, state))
            setState(record);
    };
    const set = (key, value, force = false) => {
        if (!force && equal(value, state[key]))
            return;
        const tempState = { ...state };
        tempState[key] = value;
        setState(tempState);
    };
    const remove = (key) => {
        if (Object.keys(state).includes(key)) {
            const tempState = { ...state };
            delete tempState[key];
            setState(tempState);
        }
    };
    const reset = (force = false) => {
        if (!force && equal(state, getInitialValue()))
            return;
        setState(getInitialValue());
    };
    return [state,
        {
            set,
            remove,
            reset,
            setObject
        }
    ];
}

/**
 * @title useSetState<T>
 * @description 类似 setState 的使用
 * @param initialState {T} 默认值
 * @returns {UseSetState}
 */
function useSetState(initialState = {}) {
    const [state, setState] = (0,react.useState)(initialState);
    return [
        state,
        (patch, cover = false) => {
            const coverState = typeof patch === 'function' ? patch(state) : patch;
            if (cover) {
                setState(coverState);
            }
            else {
                setState({ ...state, ...coverState });
            }
        },
        (props) => {
            if (index_esm_isEffectArray(props)) {
                const newState = { ...state };
                props.forEach((prop) => {
                    if (index_esm_isString(prop) || index_esm_isNumber(prop))
                        newState[prop] = initialState[prop];
                });
                setState(newState);
                return;
            }
            setState(initialState);
        }
    ];
}

function useStorage(key, initialValue, options = {}) {
    const { storage = sessionStorage } = options;
    const getDefaultValue = () => isEmpty$1(storage.getItem(key)) ? initialValue : storage.getItem(key);
    const [value, _setValue] = React.useState(getDefaultValue() || null);
    const setValue = (value) => {
        _setValue(value);
        if (index_esm_isString(value)) {
            storage.setItem(key, value);
        }
        else {
            storage.setItem(key, JSON.stringify(value));
        }
    };
    React.useEffect(() => {
        const tmpValue = storage.getItem(key);
        if (isEmpty$1(tmpValue))
            return;
        if (tmpValue !== value) {
            setValue(tmpValue);
        }
    }, [key, setValue, storage]);
    return [value, setValue];
}
const useLocalStorage = (key, initialValue) => useStorage(key, initialValue, { storage: localStorage });
const useSessionStorage = (key, initialValue) => useStorage(key, initialValue, { storage: sessionStorage });

/**
 * @title useUpdate
 * @description 通过 点击事件刷新组件
 * @returns {()=>void}
 */
const useUpdate = () => {
    const [, setState] = useState(1);
    return useCallback(() => setState(1), []);
};

/**
 * @title useInterval
 * @description useEffect 和 setInterval 的使用, 主要解决React this指向问题
 * @param callback {()=>void}
 * @param delay {number|null}
 * @returns {NodeJS.Timer|null}
 */
function useInterval(callback, delay) {
    const savedCallback = React.useRef(() => {
        return;
    });
    savedCallback.current = callback;
    const [myTimer, setMyTimer] = React.useState(null);
    React.useEffect(() => {
        if (delay !== null) {
            const handler = () => savedCallback.current();
            const timer = setInterval(handler, delay);
            setMyTimer(timer);
            return () => timer && clearInterval(timer);
        }
    }, [delay]);
    return myTimer;
}

/**
 * @title useSetTimeout
 * @description useEffect 和 setTimeout 的使用, 主要解决React this指向问题
 * @param callback {()=>void}
 * @param delay {number|null}
 */
function useSetTimeout(callback, delay) {
    const savedCallback = React.useRef(() => { return; });
    savedCallback.current = callback;
    React.useEffect(() => {
        if (delay !== null) {
            const handler = () => savedCallback.current();
            const timer = setTimeout(handler, delay);
            return () => clearInterval(timer);
        }
    }, [delay]);
}

function useDebounceEffect(fn, waitTime, deps) {
    useEffect(() => {
        let cb = null;
        const t = setTimeout(async () => {
            const result = fn && (await fn());
            if (result)
                cb = result;
        }, waitTime);
        return () => {
            clearTimeout(t);
            cb && cb();
        };
    }, deps);
}


//# sourceMappingURL=index.esm.js.map

;// CONCATENATED MODULE: ./node_modules/.store/abandonjs@3.8.1/node_modules/abandonjs/lib/index.esm.js
/**
 * @title isEmpty
 * @description 是无效值 undefined , null, NaN
 * @param value {unknown} 待值
 * @returns {boolean}
 */
function lib_index_esm_isEmpty(value) {
    return value === undefined || value === null || value !== value;
}
/**
 * @title isNoEmpty<T>
 * @description 不是是无效值 undefined , null, NaN
 * @param {unknown} value
 * @returns {boolean}
 * @version 0.3.0
 */
function index_esm_isNoEmpty(value) {
    return value !== undefined && value !== null && value === value;
}
/**
 * @title isNaN
 * @param {unknown} value
 * @returns {boolean}
 */
const index_esm_isNaN$1 = Number.isNaN;

/**
 * @title isArray
 * @description 是数组
 * @param value {unknown}
 * @returns {boolean}
 */
function lib_index_esm_isArray(list) {
    return Array.isArray(list);
}
/**
 * @title isEffectArray
 * @description 是有效数组
 * @param list {unknown}
 * @returns {boolean}
 */
function lib_index_esm_isEffectArray(list) {
    if (lib_index_esm_isEmpty(list))
        return false;
    return lib_index_esm_isArray(list) && list.length > 0;
}

/**
 * @title isIterator
 * @description 是iterator
 * @param {unknown} value
 * @returns {boolean}
 */
function lib_index_esm_isIterator(value) {
    if (typeof value !== 'object' || lib_index_esm_isEmpty(value))
        return false;
    return /Iterator\]$/.test(value.toString());
}

function lib_index_esm_type(param) {
    try {
        if (lib_index_esm_isIterator(param))
            return 'Iterator';
        const result = Object.prototype.toString
            .call(param)
            .match(/\[object (\w+)\]/)[1];
        if (result === 'Number' && isNaN(param))
            return 'NaN';
        return result;
    }
    catch (error) {
        return 'Undefined';
    }
}

/**
 * @title isFunction
 * @description 是函数
 * @param {unknown} value
 * @param {boolean} [strict=false] 严格模式
 * @returns {boolean}
 */
function index_esm_isFunction(value, strict = false) {
    if (strict) {
        return typeof value === 'function';
    }
    return lib_index_esm_type(value) === 'Function';
}
/**
 * @title isAsyncFunction
 * @description 是异步函数
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isAsyncFunction(value) {
    return lib_index_esm_type(value) === 'AsyncFunction';
}
const INFINITY$1 = (/* unused pure expression or super */ null && (Infinity)); // 无限

/**
 * @title isObject
 * @description 是Object
 * @param {unknown} value
 * @returns {boolean}
 */
function lib_index_esm_isObject(value) {
    return value !== null && typeof value === 'object' && lib_index_esm_type(value) === 'Object';
}
/**
 * @title isEffectObject
 * @description 是有效Object(非空)
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isEffectObject(value) {
    if (lib_index_esm_isEmpty(value))
        return false;
    return lib_index_esm_isObject(value) && Reflect.ownKeys(value).length !== 0;
}

/**
 * @title isString
 * @description 是字符串
 * @param {unknown} value
 * @returns {boolean}
 */
function lib_index_esm_isString(value) {
    return typeof value === 'string';
}

/**
 * @title isNumber
 * @description 是数字
 * @param {unknown} value
 * @returns {boolean}
 */
const lib_index_esm_isNumber = (value) => {
    return typeof value === 'number' && lib_index_esm_type(value) === 'Number';
};
/**
 * @title isEffectNumber
 * @description 是js的有效区间的数, 非number类型都为false
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isEffectNumber(value) {
    if (lib_index_esm_type(value) === 'Number') {
        if (value === INFINITY$1 || value === -INFINITY$1)
            return false;
        return true;
    }
    return false;
}
/**
 * @title isFloat
 * @description 判断数是浮点型
 * @param {unknown} value 待检测的数据类型
 * @returns {boolean}
 */
function isFloat$1(value) {
    if (!lib_index_esm_isNumber(value))
        return false;
    return (value % 1) !== 0;
}
/**
 * @title likeNumber
 * @description 是数字/数字字符串
 * @support: Number, NumberString
 * @unsupported: Infinity, Function
 * @param {unknown} value
 * @returns {boolean}
 * @version 0.1.0
 */
function index_esm_likeNumber(value) {
    if (lib_index_esm_isNumber(value))
        return true;
    if (lib_index_esm_isString(value))
        value = value.trim();
    if (lib_index_esm_isEmpty(value)
        || lib_index_esm_isArray(value)
        || value === '')
        return false;
    if (Number.isNaN(Number(value)) === false) {
        return true;
    }
    return false;
}

/**
 * @title isDate
 * @description 检查日期是否有效
 * @param {unknown} date 待判断日期
 * @returns {boolean}
 * @version 0.1.0
 */
function lib_index_esm_isDate(date) {
    return lib_index_esm_type(date) === 'Date';
}
/**
 * @title isTime
 * @description 检查日期是否有效, 时间戳也为有效时间(13位/10位)
 * @param {unknown} time 待判断日期
 * @returns {boolean}
 * @version 0.1.0
 */
function index_esm_isTime(time) {
    if (lib_index_esm_isNumber(time)) {
        if (time.toString().length === 13)
            return true;
        if (time.toString().length === 10)
            return true;
    }
    return time instanceof Date && !isNaN(time.getTime());
}
/**
 * @title isBoolean
 * @description 是布尔值
 * @param {unknown} val
 * @returns {boolean}
 */
const lib_index_esm_isBoolean = (val) => typeof val === 'boolean';

/**
 * @title isRegExp
 * @description 判断是否为正则表达式
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isRegExp(value) {
    return lib_index_esm_type(value) === 'RegExp';
}

/**
 * @title isSymbol
 * @param {unknown} value
 * @returns {boolean}
 */
function index_esm_isSymbol(value) {
    return typeof value === 'symbol';
}

/**
 * @title isSet
 * @param {unknown} value
 * @returns {boolean}
 */
function lib_index_esm_isSet(value) {
    return lib_index_esm_type(value) === 'Set';
}

/**
 * @title isMap
 * @param {unknown} value
 * @returns {boolean}
 */
function lib_index_esm_isMap(value) {
    return lib_index_esm_type(value) === 'Map';
}

const index_esm_MAX_VALUES_NUMBER = 1.7976931348623157e+308;
const index_esm_MIN_VALUES_NUMBER = (/* unused pure expression or super */ null && (-1.7976931348623157e+308));
const index_esm_INFINITY = (/* unused pure expression or super */ null && (Infinity)); // 无限

/**
 * @title toNumber
 * @description 将值转换为Number, 不可以正确装换的值, 均返回0
 * @param {unknown} num 待转换的数值
 * @returns {number}
 */
function toNumber(num) {
    if (lib_index_esm_isString(num) || lib_index_esm_isNumber(num)) {
        const value = lib_index_esm_isString(num) ? Number(num) : num;
        if (index_esm_isEffectNumber(value)) {
            if (value === index_esm_INFINITY)
                return index_esm_MAX_VALUES_NUMBER;
            if (value === -index_esm_INFINITY)
                return index_esm_MIN_VALUES_NUMBER;
            return value;
        }
    }
    return 0;
}
/**
 * @title toFloat
 * @description 转换为指定位数的浮点数
 * @param {number} num 数字
 * @param {number} fixed 小数点位数
 * @returns {number}
 */
function toFloat$1(num, fixed = 1) {
    return Number(num.toFixed(fixed));
}
/**
 * @title toThousands
 * @description 数字每千位加逗号
 * @param {string|number} num
 * @returns {string}
 */
function toThousands(num) {
    return num.toString().replace(/(\d)(?=(\d{3})+$)/g, '$1,');
}

/**
 * @title spLength
 * @description 指定长度
 * @param {number|string} value
 * @param {number} [min=0]
 * @param {number} max
 * @returns {string}
 */
function spLength(value, min = 0, max) {
    const tmpValue = lib_index_esm_isNumber(value) ? value.toString() : value;
    if (!/^[0-9]*$/.test(tmpValue))
        return new Array(min).fill(0).join('');
    const len = tmpValue.length;
    if (len > max)
        return tmpValue.slice(len - max);
    if (len < min)
        return new Array(min - len).fill(0).join('') + tmpValue;
    return tmpValue;
}
/**
 * @title getDecimal
 * @description 获取小数点位数
 * @param {number} num
 * @returns {number}
 */
function getDecimal(num) {
    if (!isFloat$1(num))
        return 0;
    return num.toString().split('.')[1].length;
}
/**
 * @title clamp
 * @description 限制在lower和upper之间
 * @param {number} num 待限制的值
 * @param {number} lower 下限
 * @param {number} upper 上限
 * @returns 返回被限制的值
 */
function clamp(num, lower = -index_esm_INFINITY, upper = index_esm_INFINITY) {
    if (num < lower)
        return lower;
    if (num > upper)
        return upper;
    return num;
}
/**
 * @title inRange
 * @description 判断是否在该范围
 * @param {number} num 要检查的值
 * @param {number} start=0 开始范围
 * @param {number} end 结束范围(包含该值)
 * @returns {boolean}
 */
function inRange(num, start = 0, end = index_esm_MAX_VALUES_NUMBER) {
    if (end < start)
        return false;
    if (num > end)
        return false;
    if (num < start)
        return false;
    return true;
}
/**
 * @title between
 * @description 判断值是否在两值之间
 * @param {number} num 待判断值
 * @param {number} start=0 起始值
 * @param {number} [end] 结束值(不包含该值)
 * @returns {boolean}
 */
function between(num, start = 0, end = index_esm_MAX_VALUES_NUMBER) {
    if (end < start)
        return false;
    if (num >= end)
        return false;
    if (num < start)
        return false;
    return true;
}

/**
 * @title padNumber
 * @description 填充数字
 * @param {number|string} value 推荐使用字符串，数字小数点最后的零可能会导致结果不符合预期
 * @param {number|`${number|''}.${number|''}`} length length>0 表整数位保留部分， length<0 表小数点保留位： '2.3': 表2位整数， 3位小数
 * @returns {string}
 */
function padNumber(value, length, strict = false) {
    const target = lib_index_esm_isNumber(value) ? String(value) : value;
    const [leftNum, rightNum] = target.split('.');
    const len = leftNum ? leftNum.length : 0;
    if (lib_index_esm_isNumber(length)) {
        if (length > 0) {
            if (length > len) {
                return new Array(length + 1 - len).join('0') + target;
            }
            if (strict) {
                return new Array(length + 1).join('9');
            }
            return target;
        }
        if (length < 0) {
            return Number(target).toFixed(-length);
        }
        return target;
    }
    if (lib_index_esm_isString(length)) {
        const [left, right] = length.split('.').map((v) => Math.abs(Number(v)));
        let newTarget = leftNum;
        if (!index_esm_isNaN$1(left) && left > 0) {
            if (left > len) {
                newTarget = new Array(left + 1 - len).join('0') + leftNum;
            }
            else if (strict) {
                newTarget = new Array(left + 1).join('9');
            }
        }
        if (!index_esm_isNaN$1(right) && right > 0) {
            if (strict || !rightNum || right > rightNum.length) {
                newTarget =
                    newTarget +
                        Number(rightNum || 0)
                            .toFixed(right)
                            .toString()
                            .slice(1);
            }
            else {
                newTarget = newTarget + '.' + rightNum;
            }
        }
        return newTarget;
    }
    return target;
}

/**
 * @title reverseString
 * @description 反转字符串
 * @param {string} target
 * @return {string}
 */
function reverseString(target) {
    return target.split('').reverse().join('');
}

/**
 * @title toString
 * @description 任意类型均可转换为string
 * @param {unknown} value
 * @returns {string}
 * @lastUpdate: 2.2.1
 */
function index_esm_toString(value) {
    if (lib_index_esm_isString(value))
        return value;
    if (lib_index_esm_isEmpty(value))
        return '';
    if ([
        'Function', 'AsyncFunction', 'GeneratorFunction',
        'Symbol', 'RegExp', 'Promise', 'Date',
        'Map', 'Set', 'WeakMap', 'WeakSet', 'BigInt'
    ].includes(lib_index_esm_type(value)))
        return value.toString();
    if (value === Infinity)
        return 'Infinity';
    if (value === -Infinity)
        return '-Infinity';
    return JSON.stringify(value);
}
/**
 * @title toStrings
 * @description 转换为字符串数组, 即数组的的项转换为数组
 * @param {unknown[]} values
 * @returns {string[]}
 */
function toStrings(values) {
    return values.map(i => index_esm_toString(i));
}

/**
 * @title stringify
 * @description JSON.stringify 的二次封装, 原本很多类型返回undefined等值, 都会返回各有意义的值, value 为字符串类型不会再加多一对双引号
 * @param {unknown} value
 * @param {(number|string)[]|(this:any,key:string,value:any)=>any}[replacer]
 * @param {string|number} [space]
 * @returns {string}
 * @lastUpdate 2.2.1
 */
function stringify(value, replacer, space) {
    if (lib_index_esm_isEmpty(value)) {
        return String(value);
    }
    if (lib_index_esm_isObject(value) || lib_index_esm_isArray(value)) {
        return JSON.stringify(value, replacer, space);
    }
    if (index_esm_isSymbol(value))
        return value.toString();
    return JSON.stringify(index_esm_toString(value), replacer, space).replace(/^(")+|(")+$/g, '');
}
function parse(value, defaultValue) {
    try {
        if (lib_index_esm_isString(value)) {
            return JSON.parse(value);
        }
        return defaultValue;
    }
    catch (error) {
        return defaultValue;
    }
}

/**
 * @title hide
 * @description 隐藏指定位置的字符
 * @param {string} target 待替换子串
 * @param {number} [start=0] 开始位置
 * @param {number} [end=target.length] 结束位置
 * @returns {string}
 * @lastUpdate 2.2.1
 */
function hide(target, start = 0, end) {
    if (lib_index_esm_isEmpty(target))
        return '';
    if (lib_index_esm_type(target) !== 'String') {
        target = index_esm_toString(target);
    }
    if (start <= 0)
        start = 0;
    if (!end || (end > target.length)) {
        end = target.length;
        if (start === 0)
            return target.replace(/./gi, '*');
    }
    const center_len = end - start;
    const end_len = (target.length - end) || 0;
    const reg = new RegExp(`(.{${start}})(.{${center_len}})(.{${end_len}})`, 'g');
    const result = reg.exec(target);
    if (result?.length === 4) {
        result[2] = result[2].replace(/./gi, '*');
        delete result[0];
        return result.join('');
    }
    return target.replace(/./gi, '*');
}

/**
 * @title vid
 * @description 获取虚拟id (时间戳)
 * @returns {string}
 */
const vid = () => {
    return new Date().getTime().toString();
};

/**
 * @title compareString
 * @description 比较字符串大小
 * @param {string} compare
 * @param {string} compared
 * @returns {boolean}
 */
function compareString(compare, compared) {
    if (lib_index_esm_isString(compare) && lib_index_esm_isString(compared)) {
        if (compare.length !== compared.length) {
            return compare.length > compared.length;
        }
        for (let i = 0; i < compare.length; i++) {
            if (compare.charCodeAt(i) > compared.charCodeAt(i)) {
                return true;
            }
            if (compare.charCodeAt(i) < compared.charCodeAt(i)) {
                return false;
            }
        }
    }
    return false;
}

/**
 * @title replaces
 * @description 同时定义多个replace的规则使用
 * @param {string} target
 * @param {{reg:RegExp|string,value:string}[]} regs
 * @returns {string}
 */
function replaces(target = '', regs = []) {
    for (let i = 0; i < regs.length; i++) {
        const { reg, value } = regs[i];
        target = target.replace(reg, value);
    }
    return target;
}

function pad(value) { }
function padStart(value) { }
function padEnd(value) { }

/**
 * @title toDate
 * @description 字符串装换成Date对象
 * @param {string} value 可以转换成时间的字符串
 * @returns {Date}
 */
function toDate(value) {
    // ios 不支持 YYYY-MM-DD hh:mm:ss
    if (/\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}/.test(value)) {
        value.replaceAll('-', '/');
    }
    return new Date(value);
}

/**
 * @title deadline
 * @description 倒计时
 * @param {Date} target {Date} 目标时间
 * @param {'year'|'mouth'|'day'|'hour'|'minute'|'second'|'timeStamp'} [timeKey]   指定倒计时单位
 * @param {Date} [now=new Date()] 起始时间
 * @returns {number}
 */
function deadline(target, timeKey = 'day', now = new Date()) {
    const surplusTimeStamp = target.getTime() - now.getTime();
    const surplusDay = Math.ceil(surplusTimeStamp / 86400000);
    switch (timeKey) {
        case 'year': return target.getFullYear() - now.getFullYear();
        case 'mouth': return (target.getFullYear() - now.getFullYear()) * 12 + (target.getDate() - now.getDate());
        case 'day': return surplusDay;
        case 'hour': return surplusDay * 24;
        case 'minute': return surplusDay * 1440;
        case 'second': return surplusDay * 8640086400;
        case 'timeStamp': return surplusDay;
        default: return surplusTimeStamp;
    }
}

const getOffsetToTimezone = (date, format = 'Z') => {
    const offsetMinutes = date.getTimezoneOffset();
    const offsetHours = offsetMinutes / 60;
    const sign = offsetHours > 0 ? '-' : '+';
    const absOffsetHours = Math.abs(offsetHours);
    const hours = Math.floor(absOffsetHours);
    const minutes = Math.floor((absOffsetHours - hours) * 60);
    if (format === 'ZZ')
        return sign + padNumber(hours, 2) + padNumber(minutes, 2);
    return sign + padNumber(hours, 2) + ':' + padNumber(minutes, 2);
};
/**
 * @title format
 * @description 时间格式化
 * @param {number|string|Date} [time=new Date()]  时间
 * @param {string} [pattern='YYYY-MM-DD'] 格式
 * @returns {string} 格式化后的数据
 * @eg | 符号 | 结果| 描述 |
|:----|:----|:----|
| YYYY	| 2022	| 4位数字的年份 |
| YY	|  1-14	| 2 位数字的年份 |
| M  MM |	1-12 |	月份数字 |
| D  DD |	1-31 |	日数(忽略大小写) |
| d |	0-6 |	一周的第几天， 0：星期天 |
| H  HH	| 0-23 |  24 小时制 |
| h  hh	| 1-12 |	12 小时制 |
| m  mm | 0-59 |	分钟|
| s  ss	| 0-59 |	秒钟|
| S |	0-9 |	毫秒，一位数
| SS |	00-99 |	毫秒，两位数
| SSS |	000-999 |	毫秒，三位数
| A | AM PM	|
| a | am pm |
| Z |	+05:00 |	UTC 的偏移量，±HH:mm
| ZZ |+0500	| UTC 的偏移量，±HHmm
 */
function format(time = new Date(), pattern = 'YYYY-MM-DD') {
    if (lib_index_esm_type(time) === 'Number') {
        if (time.toString().length === 10)
            time += '000';
    }
    const date = new Date(time);
    const year = date.getFullYear();
    // eslint-disable-next-line
    if (index_esm_isNaN$1(year)) {
        return 'Invalid Date';
    }
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const week = date.getDay();
    const hour = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    const milliseconds = date.getMilliseconds();
    const reg = /Y{4}|\[Y{4}\]|YY|\[YY\]|[DMHhmsZ]{1,2}|\[[DMHhmsZ]{1,2}\]|SSS|\[SSS\]|[AaXxd]|\[[AaXxd]\]|./gi;
    const patterns = pattern.match(reg) || [];
    const result = patterns
        .map((item) => {
        if (!item.match(reg))
            return item;
        if (item.match(/^\[.*?\]$/))
            return item.replace(/\[|\]/gi, '');
        if (item === 'YYYY')
            return padNumber(year, 4);
        if (item === 'YY')
            return padNumber(year % 100, 2);
        if (item === 'MM')
            return padNumber(month, 2);
        if (item === 'M')
            return month;
        if (item === 'DD')
            return padNumber(day, 2);
        if (item === 'D')
            return day;
        if (item === 'D')
            return week;
        if (item === 'HH')
            return padNumber(hour, 2);
        if (item === 'H')
            return hour;
        if (item === 'hh')
            return padNumber(hour % 12, 2);
        if (item === 'h')
            return hour % 12;
        if (item === 'mm')
            return padNumber(minutes, 2);
        if (item === 'm')
            return minutes;
        if (item === 'A')
            return hour >= 12 ? 'PM' : 'AM';
        if (item === 'a')
            return hour >= 12 ? 'pm' : 'am';
        if (item === 'ss')
            return padNumber(seconds, 2);
        if (item === 's')
            return seconds;
        if (item === 'SSS')
            return padNumber(milliseconds, 3);
        if (item === 'SS')
            return padNumber(Math.floor(milliseconds / 10), 2);
        if (item === 'S')
            return padNumber(Math.floor(milliseconds / 100), 1);
        if (item === 'ZZ')
            return getOffsetToTimezone(date, 'ZZ');
        if (item === 'Z')
            return getOffsetToTimezone(date);
        return item;
    })
        .join('');
    return result;
}

/**
 * @title timezone
 * @description 指定时区时间偏移量, 转换为目标时间
 * @param {LikeNumber} originOffset 当前时间的时区(number:时间偏移量|string:时区)
 * @param {LikeNumber} targetOffset 目标时间的时区(number:时间偏移量|string:时区)
 * @returns {(data:Date)=>Date}
 * @eg ```js
 const oDate = new Date('2022-12-11T07:58:07.945Z')
 const tDate = new Date('2022-12-11T15:58:07.945Z')
 timezone('1', 9 * 3600000)(oDate) ==> tDate
 ```
 */
function timezone(originOffset, targetOffset) {
    const originOffsetNum = lib_index_esm_isString(originOffset) ? toNumber(originOffset) * 3600000 : originOffset;
    const targetOffsetNum = lib_index_esm_isString(targetOffset) ? toNumber(targetOffset) * 3600000 : targetOffset;
    const offset = targetOffsetNum - originOffsetNum;
    return (date) => new Date(date.getTime() + offset);
}

/**
 * @title isSameDate
 * @description 时间是否相同, 时间类型支持isDate的类型
 * @param {Time} timeA 比较时间
 * @param {Time} timeB 被比较时间
 * @returns {boolean}
 * @version 2.4.0
 */
function isSameDate(timeA, timeB) {
    if (!index_esm_isTime(timeA) || !index_esm_isTime(timeB))
        return false;
    if (timeA.toString() === timeB.toString())
        return true;
    if (new Date(timeA).getTime() === new Date(timeB).getTime())
        return true;
    return false;
}

/**
 * @title intervalDate
 * @description 两个日期间隔天数
 * @param {Date} startDate
 * @param {Date} endDate
 * @returns {number}
 * @version 2.4.0
 */
const intervalDate = (startDate, endDate) => Math.ceil(Math.abs(startDate.getTime() - endDate.getTime()) / 86400000);

/**
 * @title dayOfYear
 * @description 指定日期位于今年的第几天
 * @param {Date} date
 * @returns {number}
 */
const dayOfYear = (date = new Date()) => Math.floor((date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 1000 / 60 / 60 / 24);

/* eslint-disable*/
const s = 1000;
const m = 6_0000;
const h = 3600_000;
const d = 86400_000;
function cron(expression, date = new Date()) {
    const expressions = expression.split(' ');
    const [second, min, hour, day, month, week, year] = expressions;
    const time = {
        year: date.getFullYear(),
        week: date.getDay(),
        month: date.getMonth() + 1,
        day: date.getDate(),
        hour: date.getHours(),
        minute: date.getMinutes(),
        second: date.getSeconds(),
        date,
        gap: 0,
    };
    let gap = 0;
    if (day !== '*') {
        const [start = '0', iGap] = day.split('/');
        // 需要边界校验
        date.setDate(Number(start));
        iGap && (gap += Number(iGap) * d);
        time.day = Number(start);
    }
    if (hour !== '*') {
        const [start = '0', iGap] = hour.split('/');
        date.setHours(Number(start));
        iGap && (gap += Number(iGap) * h);
        time.hour = Number(start);
    }
    if (min !== '*') {
        const [start = '0', iGap] = min.split('/');
        date.setMinutes(Number(start) * m);
        iGap && (gap += Number(iGap) * m);
        time.minute = Number(start);
    }
    if (second !== '*') {
        const [start = '0', iGap] = second.split('/');
        date.setSeconds(Number(start));
        iGap && (gap += Number(iGap) * s);
        time.second = Number(start);
    }
    if (gap === 0) {
        gap = 1000;
    }
    const getDate = () => {
        return new Date(time.year, time.month, time.day, time.hour, time.minute, time.second);
    };
    const newDate = getDate();
    const timestamp = newDate.getTime();
    return {
        next: (count = 1) => {
            return new Date(timestamp + gap * count);
        },
        pre: (count = 1) => {
            return new Date(timestamp - gap * count);
        },
    };
}

function cronToText(cronExpression) {
    const cronParts = cronExpression.split(' ');
    const minute = cronParts[0];
    const hour = cronParts[1];
    const dayOfMonth = cronParts[2];
    const month = cronParts[3];
    const dayOfWeek = cronParts[4];
    let text = '';
    // 解析分钟
    if (minute === '0') {
        text += 'every minute';
    }
    else {
        text += `every ${minute} minutes`;
    }
    // 解析小时
    if (hour !== '0') {
        text += ` past ${hour}`;
    }
    // 解析日期
    if (dayOfMonth !== '*') {
        text += ` on the ${dayOfMonth}th`;
    }
    // 解析月份
    if (month !== '*') {
        text += ` of ${month}`;
    }
    // 解析星期几
    if (dayOfWeek !== '*') {
        text += ` on ${dayOfWeek}`;
    }
    return text;
}
function cronToChinese(cronExpression) {
    const cronParts = cronExpression.split(' ');
    const minute = cronParts[0];
    const hour = cronParts[1];
    const dayOfMonth = cronParts[2];
    const month = cronParts[3];
    const dayOfWeek = cronParts[4];
    let text = '';
    // 解析分钟
    if (minute === '0') {
        text += '每分钟';
    }
    else {
        text += `每隔${minute}分钟`;
    }
    // 解析小时
    if (hour !== '0') {
        text += `，从${hour}点开始`;
    }
    // 解析日期
    if (dayOfMonth !== '*') {
        text += `，每月${dayOfMonth}号`;
    }
    // 解析月份
    if (month !== '*') {
        text += `，在${month}月`;
    }
    // 解析星期几
    if (dayOfWeek !== '*') {
        text += `，星期${dayOfWeek}`;
    }
    return text;
}

/**
 * @title logGroup
 * @description 分组打印(简化console.groupCollapsed)
 * @param {string} name 分组名称
 * @param {unknown[]} ...args 需要分组打印的结果
 * @example logGroup(name[, ...args])
 */
function logGroup(name = '', ...args) {
    console.groupCollapsed(`--- ${name} ---`);
    args.forEach((item) => {
        console.log(item);
    });
    console.groupEnd();
}

/**
 * @title toPathValue
 * @description 通过path 来获取值
 * @param val 待取值
 * @param {string|number} path string 路径 (若路径有`.` 可用`\\.`代替)
 * @returns 通过路径获取对应值
 */
function toPathValue(val, path) {
    if (lib_index_esm_isEmpty(path)) {
        return val;
    }
    if (index_esm_likeNumber(path)) {
        if (lib_index_esm_isArray(val)) {
            return val[Number(path)];
        }
        else if (lib_index_esm_isString(val) || lib_index_esm_isObject(val))
            return val[path];
        else {
            return undefined;
        }
    }
    if (!lib_index_esm_isString(path))
        return undefined;
    const paths = path.split(/(?<!\\)\./);
    let tmpValue = val;
    for (let i = 0; i < paths.length; i++) {
        const item = paths[i].replaceAll('\\.', '.');
        if (lib_index_esm_isObject(tmpValue)) {
            tmpValue = tmpValue[item];
        }
        else if (lib_index_esm_isArray(tmpValue) && index_esm_likeNumber(item)) {
            tmpValue = tmpValue[Number(item)];
        }
        else {
            return undefined;
        }
    }
    return tmpValue;
}

/**
 * @title equalHelper
 * @description 比较是否值和类型是否相等, 不支持WeakMap, WeakSet
 * @param {unknown} compareValue
 * @param {unknown} beCompareValue
 * @returns {boolean}
 */
function index_esm_equalHelper(compareValue, beCompareValue) {
    const compareValueType = lib_index_esm_type(compareValue);
    const beCompareValueType = lib_index_esm_type(beCompareValue);
    if (compareValue !== beCompareValueType || compareValueType === 'Symbol')
        return false;
    return compareValue === beCompareValue;
}

/**
 * @title equalMap
 * @param {MapType} compareMap
 * @param {MapType} beCompareMap
 * @returns {boolean}
 */
function index_esm_equalMap(compareMap, beCompareMap, equal = index_esm_equalHelper) {
    if (!lib_index_esm_isMap(compareMap) ||
        !lib_index_esm_isMap(beCompareMap) ||
        compareMap.size !== beCompareMap.size)
        return false;
    for (const [key, value] of compareMap) {
        const beCompareMapTempValue = beCompareMap.get(key);
        if (equal(value, beCompareMapTempValue)) {
            continue;
        }
        return false;
    }
    return true;
}

/**
 * @title equalSet
 * @param {SetType} compareSet
 * @param {SetType} beCompareSet
 * @returns {boolean}
 */
function index_esm_equalSet(compareSet, beCompareSet, equal = index_esm_equalHelper) {
    if (!lib_index_esm_isSet(compareSet) ||
        !lib_index_esm_isSet(beCompareSet) ||
        compareSet.size !== beCompareSet.size)
        return false;
    const list = [...compareSet];
    const beList = [...beCompareSet];
    for (let i = 0; i < list.length; i++) {
        if (equal(list[i], beList[i])) {
            continue;
        }
        return false;
    }
    // for (const value of compareSet) {
    //   if (beCompareSet.has(value)) continue
    //   return false
    // }
    return true;
}
/**
 * @title equalSet2
 * @param {SetType} compareSet
 * @param {SetType} beCompareSet
 * @returns {boolean}
 */
function equalSet2(compareSet, beCompareSet, equal = index_esm_equalHelper) {
    if (!lib_index_esm_isSet(compareSet) ||
        !lib_index_esm_isSet(beCompareSet) ||
        compareSet.size !== beCompareSet.size)
        return false;
    const list = [...compareSet];
    const beList = [...beCompareSet];
    for (let i = 0; i < list.length; i++) {
        let flag = false;
        for (let j = 0; j < beList.length; j++) {
            if (equal(list[i], beList[j])) {
                flag = true;
                break;
            }
        }
        if (!flag) {
            return false;
        }
    }
    return true;
    // for (let i = 0; i < list.length; i++) {
    //   if (equal(list[i], beList[i])) {
    //     continue
    //   }
    //   return false
    // }
    // for (const value of compareSet) {
    //   if (beCompareSet.has(value)) continue
    //   return false
    // }
}

/**
 * @title equalArray
 * @param {unknown|any[]} compare
 * @param {unknown|any[]} beCompare
 * @returns {boolean}
 */
function index_esm_equalArray(compare, beCompare, equal = index_esm_equalHelper) {
    if (lib_index_esm_isArray(compare) &&
        lib_index_esm_isArray(beCompare) &&
        compare.length === beCompare.length) {
        for (let i = 0; i < compare.length; i++) {
            const item = compare[i];
            if (equal(item, beCompare[i])) {
                continue;
            }
            return false;
        }
        return true;
    }
    return false;
}
/**
 * @title equalArray2
 * @param {unknown|any[]} compare
 * @param {unknown|any[]} beCompare
 * @returns {boolean}
 */
function equalArray2(compare, beCompare, equal = index_esm_equalHelper) {
    if (lib_index_esm_isArray(compare) &&
        lib_index_esm_isArray(beCompare) &&
        compare.length === beCompare.length) {
        for (let i = 0; i < compare.length; i++) {
            let flag = false;
            for (let j = 0; j < beCompare.length; j++) {
                if (equal(compare[i], beCompare[j])) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                return false;
            }
        }
        return true;
    }
    return false;
}

function index_esm_equalObject(compare, beCompare, equal = index_esm_equalHelper) {
    if (!lib_index_esm_isObject(compare) || !lib_index_esm_isObject(beCompare))
        return false;
    const compareValueKeys = Object.keys(compare);
    const beCompareValueKeys = Object.keys(beCompare);
    if (compareValueKeys.length !== beCompareValueKeys.length)
        return false;
    for (let i = 0; i < compareValueKeys.length; i++) {
        const key = compareValueKeys[i];
        if (equal(compare[key], beCompare[key]))
            continue;
        return false;
    }
    return true;
}

/**
 * @title equal
 * @description 比较是否值和类型是否相等/相同, 不支持类型由`===`来比较
 * @supported 基础数据类型, Object, Array, Map, Set, Date
 * @notSupported WeakMap, WeakSet
 * @param {unknown} compareValue
 * @param {unknown} beCompareValue
 * @returns {boolean}
 * @version 2.4.4
 * @lastUpdate 3.8.0
 */
function index_esm_equal(compareValue, beCompareValue) {
    const compareValueType = lib_index_esm_type(compareValue);
    const beCompareValueType = lib_index_esm_type(beCompareValue);
    if (compareValueType !== beCompareValueType)
        return false;
    if (compareValueType === 'Object')
        return index_esm_equalObject(compareValue, beCompareValue, index_esm_equal);
    if (compareValueType === 'Array')
        return index_esm_equalArray(compareValue, beCompareValue, index_esm_equal);
    if (compareValueType === 'Map')
        return index_esm_equalMap(compareValue, beCompareValue, index_esm_equal);
    if (compareValueType === 'Set')
        return index_esm_equalSet(compareValue, beCompareValue, index_esm_equal);
    if (Number.isNaN(compareValue))
        return Number.isNaN(beCompareValue);
    if (lib_index_esm_isDate(compareValue) && lib_index_esm_isDate(beCompareValue))
        return compareValue.getTime() === beCompareValue.getTime();
    return compareValue === beCompareValue;
}

/**
 * @title like
 * @description 比较是否值和类型是否相等/相同, 不支持类型由`===`来比较 或 转字符串后比对
 * @supported 基础数据类型, Object, Array, Map, Set, Date
 * @notSupported WeakMap, WeakSet
 * @param {unknown} compareValue
 * @param {unknown} beCompareValue
 * @returns {boolean}
 * @version 3.8.0
 */
function like(compareValue, beCompareValue) {
    if (compareValue === beCompareValue) {
        return true;
    }
    if ((lib_index_esm_isEmpty(compareValue) || compareValue === '') &&
        (lib_index_esm_isEmpty(beCompareValue) || beCompareValue === '')) {
        return true;
    }
    const compareValueType = lib_index_esm_type(compareValue);
    // const beCompareValueType = type(beCompareValue)
    if (compareValueType === 'Object')
        return index_esm_equalObject(compareValue, beCompareValue, like);
    if (compareValueType === 'Array')
        return equalArray2(compareValue, beCompareValue, like);
    if (compareValueType === 'Set')
        return equalSet2(compareValue, beCompareValue, like);
    if (compareValueType === 'Map')
        return index_esm_equalMap(compareValue, beCompareValue, like);
    if (Number.isNaN(compareValue))
        return Number.isNaN(beCompareValue);
    if (lib_index_esm_isDate(compareValue) && lib_index_esm_isDate(beCompareValue))
        return compareValue.getTime() === beCompareValue.getTime();
    const compareValueStr = stringify(compareValue).replace(/'|"|\s/gi, '');
    const beCompareValueStr = stringify(beCompareValue).replace(/'|"|\s/gi, '');
    return compareValueStr === beCompareValueStr;
}

/**
 * @title compareNumber
 * @param {number} val 被比较值
 * @param {number|string} valer 比较值 / 可为正则 / [number, number] / 字符串(=number,<=number...)
 * @returns {boolean}
 * @lastUpdate @3.2.0
 */
function compareNumber(val, valer) {
    const valType = lib_index_esm_type(val);
    const valerType = lib_index_esm_type(valer);
    if (valerType === 'RegExp') {
        return valer.test(String(val));
    }
    if (valType !== 'Number') {
        return false;
    }
    if (val === valer) {
        return true;
    }
    if (lib_index_esm_isArray(valer) && valer.length > 0) {
        let min = -Infinity;
        let max = Infinity;
        if (!lib_index_esm_isEmpty(valer[0])) {
            min = Number(valer[0]);
        }
        if (valer.length > 1 && !lib_index_esm_isEmpty(valer[1])) {
            max = Number(valer[1]);
        }
        return val > min && val < max;
    }
    if (valerType === 'String') {
        const [matNum, Sym = '='] = /(?<=([<>=!]+))[0-9]+/gi.exec(valer) || [];
        switch (Sym) {
            case '=': return val === Number(matNum);
            case '>': return val > Number(matNum);
            case '>=': return val >= Number(matNum);
            case '<': return val < Number(matNum);
            case '<=': return val <= Number(matNum);
            case '<>':
            case '!=': return val != Number(matNum);
        }
    }
    return false;
}
/**
 * @title compareValue
 * @param {Val} val 被比较值
 * @param {Valer} valer 比较值 / 可为正则
 * @param {string} [path] 值的路径 用逗号隔开
 * @returns {boolean}
 */
function compareValue(val, valer, path) {
    if (path) {
        val = toPathValue(val, path);
    }
    if (index_esm_equal(val, valer))
        return true;
    if (index_esm_isRegExp(valer))
        return valer.test(String(val));
    if (lib_index_esm_isNumber(val))
        return compareNumber(val, valer);
    if (lib_index_esm_isNumber(Number(val)))
        return compareNumber(Number(val), valer);
    return false;
}

function deepClonePredicate(value) {
    switch (lib_index_esm_type(value)) {
        case 'RegExp':
            return new RegExp(value);
        case 'Array':
        case 'Object': {
            const cloneObj = new value.constructor();
            for (const key in value) {
                if (value.hasOwnProperty(key)) {
                    cloneObj[key] = deepClonePredicate(value[key]); // 递归拷贝  
                }
            }
            return cloneObj;
        }
        case 'Date': {
            return new Date(value);
        }
    }
    return value;
}
/**
 * @title deepClone
 * @description 深拷贝
 * @param {unknown} value
 * @returns {Result}
 * @version 2.4.1
 */
function deepClone(value) {
    return deepClonePredicate(value);
}

/**
 * @title toFirstUpperCase
 * @description 首字母大写
 */
const toFirstUpperCase = (value) => value.replace(/\b.*/g, (word) => word.substring(0, 1).toUpperCase() + word.substring(1));
/**
 * @title toFirstLowerCase
 * @description 首字母小写
 */
const toFirstLowerCase = (value) => value.replace(/\b.*/g, (word) => word.substring(0, 1).toLowerCase() + word.substring(1));
/**
 * @title toUpperCase
 * @description 全部大写
 */
const toUpperCase = (value) => value.toUpperCase();
/**
 * @title toLowerCase
 * @description 全部小写
 */
const toLowerCase = (value) => value.toLowerCase();

/**
 * @title guard
 * @param {Function} func
 * @param {unknown} errorReturnValue
 * @returns {(...args:unknown[])=>unknown}
 */
function guard(func, errorReturnValue) {
    return (...args) => {
        try {
            if (index_esm_isFunction(func))
                return func(...args);
            return errorReturnValue;
        }
        catch (error) {
            return errorReturnValue;
        }
    };
}
/**
 * @title asyncGuard
 * @param {Function} func
 * @param {unknown} errorReturnValue
 * @returns {(...args:unknown[])=>unknown}
 */
function asyncGuard(func, errorReturnValue) {
    return async (...args) => {
        try {
            if (index_esm_isAsyncFunction(func))
                return await func(...args);
            if (index_esm_isFunction(func))
                return func(...args);
            return errorReturnValue;
        }
        catch (error) {
            return errorReturnValue;
        }
    };
}

/**
 * @title has
 * @description beComparedValue 包含 comparedValue 的值, 模糊匹配, 忽略换行和空格
 * @param {number|string|ObjectType} beComparedValue 被比较的值(大)
 * @param {number|string|ObjectType} compareValue 比较的值(小)
 * @example has('1223', '123') => true
 * @returns {boolean}
 */
function has(beComparedValue, compareValue) {
    if (compareValue === beComparedValue &&
        lib_index_esm_type(compareValue) === lib_index_esm_type(beComparedValue)) {
        return true;
    }
    const newBeComparedValue = stringify(beComparedValue).replace(/'|"|\s/gi, '');
    const newCompareValue = stringify(compareValue).replace(/'|"|\s/gi, '');
    if (newBeComparedValue.includes(newCompareValue)) {
        return true;
    }
    const compareValues = newCompareValue.split('');
    let newBeValue = newBeComparedValue;
    for (let i = 0; i < compareValues.length; i++) {
        const item = compareValues[i];
        if (!newBeValue.includes(item)) {
            return false;
        }
        newBeValue = newBeValue.replace(item, '');
    }
    return newBeValue.length >= 0;
}

/**
 * @title filter<T>
 * @description 单层过滤
 * @param {T[]} list 待过滤数组
 * @param {FilterCondition<T>} filterCondition 过滤条件
 * @param {boolean} [retainNotObject=false] 是否保留非对象项
 * @returns {T[]}
 * @version 2.3.1
 */
function filter(list, filterCondition, retainNotObject = false) {
    if (!lib_index_esm_isArray(list))
        return [];
    if (!filterCondition || !list || list.length === 0)
        return list;
    if (index_esm_isFunction(filterCondition)) {
        return list.filter(filterCondition);
    }
    if (index_esm_isEffectObject(filterCondition))
        return list.filter((item) => {
            if (!lib_index_esm_isObject(item))
                return retainNotObject;
            for (const key in filterCondition) {
                const unit = filterCondition[key];
                const originValue = item[key];
                if (originValue === unit)
                    break;
                if (index_esm_isRegExp(unit)) {
                    const val = lib_index_esm_isString(originValue) ? originValue : stringify(originValue);
                    if (!unit.test(val))
                        return false;
                    break;
                }
                return false;
            }
            return true;
        });
    return list;
}

/**
 * @title isFloat
 * @description 判断数是否为浮点型
 * @param num 待检测的数据类型
 * @returns boolean
 */
function index_esm_isFloat(num) {
    return (num % 1) !== 0;
}
/**
 * @title toFloat
 * @description 转换为指定位数的浮点数
 * @param num { number } 数字
 * @param fixed { number } 小数点位数
 * @returns { number }
 */
// eslint-disable-next-line @typescript-eslint/no-inferrable-types
function toFloat(num, fixed = 1) {
    return Number(num.toFixed(fixed));
}

/**
 * @title random
 * @description 随机数
 * @param lower { number } 下限
 * @param upper { number } 上限
 * @param floating { number = 0 } 是否返回浮点数(位数), 0: 整数
 */
function random(lower = 0, upper = 1, floating = 0) {
    if (lower === 0 && upper === 1) {
        return Math.random();
    }
    if (index_esm_isFloat(upper) || index_esm_isFloat(lower)) {
        const len = upper > lower ? upper : lower;
        if (floating === 0) {
            floating = len;
        }
    }
    const result = lower + Math.random() * (upper - lower);
    if (floating)
        return toFloat(result, floating);
    return Math.ceil(result);
}

/**
 * @title selects<T>
 * @description 指定范围 来随机选择数组元素
 * @param {T[]} list
 * @param {number} [min=0] 最小值(包括)
 * @param {number} [max=list.length-1] 最大值(包括)
 * @returns {T[]}
 */
function selects(list, min = 0, max = list.length - 1) {
    if (max > list.length)
        max = list.length - 1;
    let len = random(min, max);
    const result = [];
    let index = 0;
    while (len--) {
        index = ~~(Math.random() * list.length);
        result.push(list[index]);
        list.splice(index, 1);
    }
    return result;
}
/**
 * @title select<T>
 * @description 选择数组其中一项, 不指定就随机选一
 * @param {T[]} list 待选择数组
 * @param {?number} index  指定选择索引(可为负数)
 * @returns {T|null} 选择项
 */
function index_esm_select(list = [], index) {
    if (lib_index_esm_isArray(list)) {
        const len = list.length;
        if (len === 0)
            return null;
        if (!index && index !== 0)
            return list[~~(Math.random() * list.length)];
        if (index > len)
            return list[index % len];
        if (index > -1)
            return list[index];
        if (index < 0)
            return list[list.length + (index % len)];
    }
    return null;
}

/**
 * @title toArray<T>
 * @description 将非数组转换为数组, 对象会转换成 Array([key,value])
 * @param {T|T[]} value
 * @returns {T[]}
 * @lastUpdate 3.3.0
 */
function toArray(value) {
    if (Array.isArray(value))
        return value;
    if (lib_index_esm_isEmpty(value))
        return [];
    if (lib_index_esm_isSet(value))
        return [...value];
    if (lib_index_esm_isMap(value)) {
        return Array.from(value);
    }
    if (lib_index_esm_isObject(value)) {
        return Object.keys(value).map(key => {
            return [key, value[key]];
        });
    }
    return [value];
}

/**
 * @title chunk<T>
 * @description 通过 size 切割数组
 * @param {T[]} list
 * @param {number} size 切割点索引
 * @returns {T[][]} [ [切割点前数据], [切割点后数据] ]
 */
function chunk(list, size) {
    return [list.slice(0, size), list.slice(size)];
}

/**
 * @title zip<T>
 * @description: 每个数组同样的下标组成一个新数组
 * @param {...T[]} ...arrays
 * @returns {T[][]}
 * @version 2.1.11
 * @eg ```ts
 zip(['fred', 'barney'], [30, 40], [true, false])
 => [['fred', 30, true], ['barney', 40, false]]
 ```
 */
function zip(...arrays) {
    const result = [];
    const length = arrays.length;
    let index = 0;
    while (index < length - 1) {
        const item = arrays.map(item => {
            return item[index];
        });
        result.push(item);
        index++;
    }
    return result;
}
/**
 * @title zipObject<Value>
 * @description: 第一个数组是对象的key, 第二个数组是对象的value
 * @param {(string|number)[]} keys
 * @param {Value[]} values
 * @returns {ObjectType<Value>}
 * @version 2.1.11
 * @eg ```ts
 zipObject(['a', 'b'], [1, 2])
 => { 'a': 1, 'b': 2 }
 ```
 */
function zipObject(keys, values) {
    const record = {};
    keys.forEach((key, index) => {
        record[key] = values[index];
    });
    return record;
}

/**
 * @title flat<T>
 * @description 数组扁平化
 * @param {T[]} list
 * @param {number} [depth=1] 深度
 * @returns {T[]}
 * @version: 2.2.0
 * @lastUpdate 3.4.0
 */
function flat(list, depth = 1) {
    if (!Array.isArray(list))
        return toArray(list);
    if (list.length === 0 || depth < 1)
        return [];
    if (depth === 1)
        return list.flatMap(i => i);
    return list.flat(depth);
}

/**
 * @title drop<T>
 * @description 去除前n个元素(影响原数据)
 * @param {T[]} list 数组
 * @param {number} n=0 要去除元素个数
 * @returns {T[]} 剩余切片
 */
function drop(list = [], n = 0) {
    if (!lib_index_esm_isArray(list))
        return toArray(list);
    while (n--) {
        if (list.length < 1)
            return [];
        if (list.length > 0)
            list.shift();
    }
    return list;
}
/**
 * @title dropRight<T>
 * @description 从右往左删除的指定个数
 * @param {T[]} list 要处理的数组
 * @param {number} [n=1] 需要删除的元素数量
 * @returns {T[]}
 */
function dropRight(list, n = 1) {
    return list.splice(0, list.length - n);
}

/**
 * @title unique<T>
 * @description 去除数组重复项
 * @param {T[]} list 待过滤数组
 * @returns {T[]}
 */
function unique(list) {
    return [...new Set(list)];
}

/**
 * @title fill<T>
 * @description 在原有数组上改变, 修改指定位置的值
 * @param {T[]} array {T[]} 待填充改变的数组
 * @param {T|(index:number)=>T} value 填充值
 * @param {number} [num=0] 填充个数
 * @returns
 */
function fill(array, value, num = 0) {
    while (num--) {
        array.push(index_esm_isFunction(value)
            ? value(array.length)
            : value);
    }
    return array;
}

function getSortNum(value, sortIndex) {
    if (lib_index_esm_isNumber(value))
        return value;
    if (lib_index_esm_isString(value)) {
        const num = Number(value);
        return lib_index_esm_isNumber(num) ? num : value;
    }
    if (lib_index_esm_isEmpty(sortIndex))
        return 0;
    if (lib_index_esm_isObject(value)) {
        const newValue = toPathValue(value, sortIndex);
        if (lib_index_esm_isString(newValue)) {
            const num = Number(newValue);
            return lib_index_esm_isNumber(num) ? num : newValue;
        }
        if (lib_index_esm_isNumber(newValue)) {
            return newValue;
        }
    }
    return 0;
}
/**
 * @title descSort<T=object>
 * @description 降序排序(从大到小排序)
 * @param {T[]} list
 * @param {string|number} [sortIndex] 索引路径, 参考`toPathValue`的路径
 * @returns {T[]}
 * @create 3.3.0
 * @lastUpdate 3.3.0
 */
function descSort(list, sortIndex) {
    const handler = (before, after) => {
        const newAfter = getSortNum(after, sortIndex);
        const newBefore = getSortNum(before, sortIndex);
        if (lib_index_esm_isString(newAfter) && lib_index_esm_isString(newBefore))
            return compareString(newAfter, newBefore) ? 1 : -1;
        if (lib_index_esm_isNumber(newAfter) && lib_index_esm_isNumber(newBefore))
            return newAfter - newBefore;
        return 0;
    };
    if (lib_index_esm_isEffectArray(list)) {
        return list.sort(handler);
    }
    return [];
}
/**
 * @title ascSort<T=object>
 * @description 升序排序(从小到大排序)
 * @param {T[]} list
 * @param {string|number} sortIndex 索引路径, 参考toPathValue的路径
 * @returns {T[]}
 * @create 3.3.0
 * @lastUpdate 3.3.0
 */
function ascSort(list, sortIndex) {
    const handler = (before, after) => {
        const newAfter = getSortNum(after, sortIndex);
        const newBefore = getSortNum(before, sortIndex);
        if (lib_index_esm_isString(newAfter) && lib_index_esm_isString(newBefore))
            return compareString(newAfter, newBefore) ? -1 : 1;
        if (lib_index_esm_isNumber(newAfter) && lib_index_esm_isNumber(newBefore))
            return newBefore - newAfter;
        return 0;
    };
    if (lib_index_esm_isEffectArray(list)) {
        return list.sort(handler);
    }
    return [];
}

/**
 * @title pageQuery
 * @description 对数组进行分页查询以及管理
 * @param {PageQueryProps} props
 * @returns
 */
function pageQuery(originDataSource = [], props = {}) {
    const { uniqueIndex = 'id', noRangeFields, keepFields, handleValue, fields, } = props;
    // 原始数据
    let dataSource = [...originDataSource];
    const getValue = (record, key) => {
        let value = record[key];
        if (fields && index_esm_isFunction(fields[key])) {
            return fields[key](value, key);
        }
        else if (handleValue) {
            return handleValue(value, key);
        }
        if (lib_index_esm_isEmpty(value))
            return '';
        if (lib_index_esm_isEffectArray(keepFields) && keepFields.includes(key)) {
            return value;
        }
        if (lib_index_esm_isString(value)) {
            return value.trim().toUpperCase();
        }
        if (lib_index_esm_isNumber(value)) {
            return stringify(value);
        }
        return value;
    };
    const isEqual = (item, params, key) => {
        const value = getValue(item, key);
        const beValue = getValue(params, key);
        if (!(lib_index_esm_isEffectArray(noRangeFields) &&
            noRangeFields.includes(key)) &&
            index_esm_likeNumber(value) &&
            lib_index_esm_isEffectArray(beValue) &&
            beValue.length === 2) {
            const [min, max] = beValue;
            if (index_esm_likeNumber(min) && index_esm_likeNumber(max)) {
                return Number(value) >= Number(min) &&
                    Number(value) <= Number(max);
            }
            return false;
        }
        if (lib_index_esm_isString(value) && lib_index_esm_isString(beValue)) {
            return value.indexOf(beValue) > -1;
        }
        return index_esm_equal(value, beValue);
    };
    const getDataSource = (params, config) => {
        let newDataSource = [...dataSource];
        if (index_esm_isEffectObject(config)) {
            const { sortBy } = config;
            if (index_esm_isEffectObject(sortBy)) {
                for (const key in sortBy) {
                    const sortIndex = sortBy[key];
                    if (sortIndex === 'desc') {
                        newDataSource = descSort(newDataSource, key);
                    }
                    if (sortIndex === 'asc') {
                        newDataSource = ascSort(newDataSource, key);
                    }
                }
            }
        }
        if (index_esm_isEffectObject(params)) {
            newDataSource = newDataSource.filter(item => {
                for (let key in params) {
                    if (!isEqual(item, params, key))
                        return false;
                }
                return true;
            });
        }
        return newDataSource;
    };
    /**
     * @title getPage
     * @description 获取分页数据
     * 1,params[key]. 若值为[number, number], 且被查询值为数字或数字字符串, [number, number]当做范围, 若不想这样子指定, 需要在 pageQuery 指定
     * @param {Object} params 查询条件
     * @param {Pagination} pagination 分页信息
     * @returns {dataSource: DataSource, pagination: Pagination}
     */
    const getPage = (params, pagination = {}) => {
        const { pageNo = 1, pageSize = 10, sortBy } = pagination;
        const newDataSource = getDataSource(params, { sortBy });
        return {
            dataSource: newDataSource.slice((pageNo - 1) * pageSize, pageNo * pageSize),
            pagination: {
                pageNo,
                pageSize,
                total: newDataSource.length
            }
        };
    };
    const del = (indexes) => {
        if (lib_index_esm_isEffectArray(indexes)) {
            dataSource = getDataSource()
                .filter(item => !indexes.includes(item[uniqueIndex]));
            return;
        }
        if (lib_index_esm_isString(indexes)) {
            dataSource = getDataSource()
                .filter(item => item[uniqueIndex] !== indexes);
            return;
        }
    };
    const add = (record) => {
        if (lib_index_esm_isObject(record)) {
            if (lib_index_esm_isEmpty(record[uniqueIndex])) {
                record[uniqueIndex] = '__vid__' + vid();
            }
            dataSource.unshift(record);
            return;
        }
        if (lib_index_esm_isEffectArray(record)) {
            record.forEach(add);
            return;
        }
    };
    return {
        dataSource,
        getPage,
        getDataSource,
        del,
        add,
    };
}

/**
 * @title existKeys
 * @description 判断对象是否拥有指定keys
 * @param obj object
 * @param keys string[] | string
 * @returns boolean
 */
function existKeys(obj, keys) {
    const objKeys = Object.keys(obj);
    keys = toArray(keys);
    for (let i = 0; i < keys.length; i++) {
        if (objKeys.includes(keys[i]))
            return true;
    }
    return false;
}

/**
 * @title omit<T extends ObjectType>
 * @description 去除集合属性
 * @param {T|Map} collection
 * @param {CollectionKey[]} propertys
 * @returns {T|Map}
 */
function omit(collection, propertys = []) {
    if (lib_index_esm_isMap(collection)) {
        const newMap = new Map(collection);
        propertys.forEach(property => {
            newMap.delete(property);
        });
        return newMap;
    }
    if (lib_index_esm_isObject(collection)) {
        const newRecord = { ...collection };
        const keys = Object.keys(collection);
        propertys.forEach(property => {
            lib_index_esm_isString(property)
                && keys.includes(property)
                && delete newRecord[property];
        });
        return newRecord;
    }
    return {};
}

/**
 * @title serialize
 * @description 序列化对象
 * @param query object
 * @param encode boolean = false
 * @returns string
 */
function serialize(query, encode = false) {
    if (lib_index_esm_isObject(query))
        return Object.keys(query)
            .map((key) => {
            const value = query[key];
            if (lib_index_esm_isString(value)
                || lib_index_esm_isNumber(value)
                || lib_index_esm_isBoolean(value))
                return `${key}=${encode
                    ? encodeURIComponent(value)
                    : value}`;
        })
            .join('&');
    return '';
}

function ObjectEntity(target = {}, config) {
    const { defaultValue, defaultKey } = config || {};
    const keys = Object.keys(target);
    const values = Object.values(target);
    const get = (key) => keys.includes(key) ? target[key] : defaultValue;
    const getKey = (value) => {
        if (values.includes(value)) {
            for (let i = 0; i < keys.length; i++)
                if (index_esm_equal(target[keys[i]], value))
                    return keys[i];
        }
        return defaultKey;
    };
    const list = (keyName = 'key', valueName = 'value', keyValueReverse = false) => {
        return Object.entries(target)
            .map(([key, value]) => {
            if (keyValueReverse) {
                return {
                    [valueName]: key,
                    [keyName]: value,
                };
            }
            return {
                [keyName]: key,
                [valueName]: value
            };
        });
    };
    return {
        target,
        keys,
        values,
        get,
        getKey,
        list,
    };
}

/**
 * @title delay<Params,Result>
 * @param func 指定函数
 * @param {number} [delayTime=0] 延迟时间
 * @param {Params} ...args 传输参数
 * @returns {Promise<Result>} func执行结果(Promise)
 */
function delay(func, delayTime = 0, ...args) {
    return new Promise((resolve) => {
        setTimeout(() => {
            if (index_esm_isFunction(func)) {
                resolve(func(...args));
            }
            else {
                resolve(undefined);
            }
        }, delayTime);
    });
}

/**
 * @title getLength
 * @description 获取集合长度(大小)
 * @param {Collection} collection
 * @returns {number}
 */
function getLength(collection) {
    if (lib_index_esm_isArray(collection)
        || lib_index_esm_isString(collection))
        return collection.length;
    if (lib_index_esm_isObject(collection))
        return Object.keys(collection).length;
    if (lib_index_esm_isSet(collection)
        || lib_index_esm_isMap(collection))
        return collection.size;
    return 0;
}
/**
 * @title getIndex
 * @description 获取集合key
 * @param {Collection} collection
 * @param {CollectionKey} key
 * @returns {CollectionKey|undefined}
 */
function getIndex(collection, key) {
    if (lib_index_esm_isArray(collection)
        || lib_index_esm_isString(collection)
        || lib_index_esm_isSet(collection)) {
        const len = getLength(collection);
        let newIndex = lib_index_esm_isNumber(key) ? key : Number(key);
        if (lib_index_esm_isEmpty(newIndex) || !lib_index_esm_isNumber(newIndex))
            return undefined;
        if (len === 0)
            return 0;
        if (newIndex > len)
            return len - 1;
        if (newIndex < 0)
            return len + newIndex;
        return newIndex;
    }
    if (lib_index_esm_isMap(collection) &&
        collection.has(key))
        return key;
    if (index_esm_isEffectObject(collection)) {
        const newKey = lib_index_esm_isString(key) ? key : stringify(key);
        if (Object.keys(collection).includes(newKey))
            return newKey;
    }
    return undefined;
}

/**
 * @title at
 * @description 通过下标获取值
 * @param {Collection} collection
 * @param {CollectionKey} [index=0] 可为负数
 * @returns {CollectionValue}
 * @version 2.6.0
 */
function at(collection, index = 0) {
    if (lib_index_esm_isEmpty(collection))
        return undefined;
    const len = getLength(collection);
    if (len === 0)
        return undefined;
    const newIndex = getIndex(collection, index);
    if (lib_index_esm_isEmpty(newIndex))
        return undefined;
    if (lib_index_esm_isNumber(newIndex) &&
        (lib_index_esm_isString(collection) || lib_index_esm_isArray(collection)))
        return collection[newIndex];
    if (lib_index_esm_isObject(collection) &&
        (lib_index_esm_isNumber(newIndex) || lib_index_esm_isString(newIndex)))
        return collection[newIndex];
    if (lib_index_esm_isMap(collection))
        return collection.get(newIndex);
    let i = -1;
    if (lib_index_esm_isSet(collection))
        for (const value of collection)
            if (++i === newIndex)
                return value;
}

/**
 * @title nth
 * @description 通过指定规则回去集合参数
 * @param {Collection} collection
 * @param {string|number} [index] : 可以输入下标/2n+1 这种格式
 * @return {Collection|CollectionValue}
 */
function nth(collection, index) {
    if (lib_index_esm_isEmpty(index) || lib_index_esm_isEmpty(collection) || index === 'n') {
        return collection;
    }
    if (lib_index_esm_isString(index) &&
        index.includes('n') &&
        /\d?n[+-]?\d?/.exec(index) &&
        (lib_index_esm_isArray(collection) || lib_index_esm_isString(collection))) {
        const params = /([-+]?\d)?n([+-]?\d)?/.exec(index);
        if (lib_index_esm_isArray(params) && params.length === 3) {
            const mult = Number(params[1]);
            const gap = Number(params[2]);
            const getNewIndex = (num) => {
                if (lib_index_esm_isNumber(mult)) {
                    num = num * mult;
                }
                if (lib_index_esm_isNumber(gap)) {
                    num = num + gap;
                }
                return num;
            };
            let i = 0;
            let j = 0;
            const len = collection.length;
            const result = [];
            while (j < len && i < len) {
                j = getNewIndex(i) + 1;
                if (j >= len)
                    break;
                result.push(at(collection, j));
                i++;
            }
            return result;
        }
    }
    return at(collection, index);
}

/**
 * @title includes
 * @description 检查 value(值) 是否在 collection(集合); 如果指定 fromIndex 是负数，那么从 collection(集合) 的结尾开始检索
 * @param {Array|Object|string} collection 要检索的集合
 * @param {number|string} value 要检索的值
 * @param {number|string} [fromIndex=0] 要检索的索引
 * @returns {boolean}
 */
function includes(collection, value, fromIndex = 0) {
    const newIndex = getIndex(collection, fromIndex);
    if (lib_index_esm_isString(collection) && lib_index_esm_isNumber(newIndex)) {
        const newCollection = collection.substring(newIndex);
        const newValue = lib_index_esm_isString(value) ? value : stringify(value);
        return newCollection.indexOf(newValue) > -1;
    }
    if (lib_index_esm_isArray(collection)) {
        if (fromIndex === 0)
            return collection.includes(value);
        if (lib_index_esm_isNumber(newIndex)) {
            for (let i = newIndex; i < collection.length; i++)
                if (index_esm_equal(collection[i], value))
                    return true;
            return false;
        }
    }
    if (lib_index_esm_isObject(collection)) {
        if (fromIndex === 0)
            return Object.values(collection).includes(value);
        if (lib_index_esm_isString(newIndex)) {
            return index_esm_equal(collection[newIndex], value);
        }
    }
    return false;
}

/**
 * @title concat<T>
 * @description 连接多个数组
 * @param {...unknown[]} ...list 多个数组
 * @returns {T[]}
 * @lastUpdate 2.6.0
 */
function concat(...list) {
    if (!list || list.length === 0)
        return [];
    const result = [];
    const len = list.length;
    let i = -1;
    while (++i < len) {
        const item = list[i];
        if (lib_index_esm_isArray(item)) {
            item.forEach(unit => result.push(unit));
            continue;
        }
        if (lib_index_esm_isSet(item)) {
            item.forEach(unit => result.push(unit));
            continue;
        }
        result.push(item);
    }
    return result;
}

/**
 * @title copyWithin<T>
 * @description 浅复制数组或子串的一部分到同一数组中的另一个位置，并返回它，不会改变原数组/字串的长度
 * @param {string|T[]} value 代复制子串/数组
 * @param {number} target 复制结果目标下标
 * @param {number} [start=0] 被复制起点
 * @param {number} end 被复制终点, 不指定及复制最后
 * @returns {string|T[]}
 * @version 2.6.0
 */
function copyWithin(value, target, start = 0, end) {
    if (value.length === 0)
        return [];
    if (lib_index_esm_isString(value)) {
        return value.split('').copyWithin(target, start, end).join('');
    }
    return [...value].copyWithin(target, start, end);
}

/**
 * @title entries
 * @description 返回一个数组迭代对象
 * @param {string|T[]} value
 * @returns
 */
function entries(value) {
    if (lib_index_esm_isString(value)) {
        return value.split('').entries();
    }
    return value.entries();
}

/**
 * @title indexOf
 * @description 拓展原生 Array.prototype.indexOf | String.prototype.indexOf 的适用方法, 拓展 Map, Set
 * @param {Collection} collection
 * @param {CollectionValue} value
 * @returns {CollectionKey}
 */
function indexOf(collection, value) {
    if (lib_index_esm_isString(collection))
        return collection.indexOf(value);
    if (lib_index_esm_isArray(collection)) {
        return collection.indexOf(value);
    }
    if (lib_index_esm_isObject(collection)) {
        const keys = Object.keys(collection);
        if (keys.length === 0)
            return undefined;
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (index_esm_equal(collection[key], value))
                return key;
        }
        return undefined;
    }
    if (lib_index_esm_isMap(collection)) {
        const mapCollection = collection;
        if (mapCollection.size === 0)
            return undefined;
        for (const [key, mapValue] of mapCollection)
            if (index_esm_equal(mapValue, value))
                return key;
        return undefined;
    }
    if (lib_index_esm_isSet(collection)) {
        const setCollection = collection;
        let index = -1;
        if (setCollection.size === 0)
            return -1;
        for (const setValue of setCollection) {
            ++index;
            if (index_esm_equal(setValue, value))
                return index;
        }
        return -1;
    }
    return undefined;
}

/**
 * @title pipe<Params,Result>
 * @description 管道函数, 链接前函数的值为下一个函数的参
 * @param {Function[]} ...funcs 函数数组
 * @returns {(...args: Params)=>Result}
 */
function pipe(...funcs) {
    return function (...args) {
        let params = args;
        for (let i = 0; i < funcs.length; i++) {
            const item = funcs[i];
            if (index_esm_isFunction(item)) {
                params = toArray(item(...params));
                continue;
            }
        }
        return at(params);
    };
}

/**
 * @title memoize<Params,Result>
 * @description 缓存方法结果, 若参数相同, 会返回相同结果
 * @param {Function} func
 * @returns {(...args: Params)=>Result}
 */
function memoize(func) {
    const cache = new Map();
    return function (...args) {
        if (!index_esm_isFunction(func)) {
            return undefined;
        }
        const key = stringify(args);
        if (cache.has(key)) {
            return cache.get(key);
        }
        const result = func.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

/**
 * @title once<Params,Result>
 * @description  fn 方法只会执行一次, 多次执行返回值为第一次的返回值
 * @param {Function} func 指定值运行一次的方法
 * @returns {Function} 返回封装后的方法
 */
function once(func) {
    let returnValue = undefined;
    let canRun = true;
    return function (...args) {
        if (canRun) {
            returnValue = func.apply(this, args);
            canRun = false;
        }
        return returnValue;
    };
}

/**
 * @title runFunc
 * @description 运行函数, 支持普通函数和async函数, 否则返回func
 * @param func
 * @param ...args
 * @returns
 */
function runFunc(func, ...args) {
    if (lib_index_esm_type(func) === 'Function' || lib_index_esm_type(func) === 'AsyncFunction') {
        return func(...args);
    }
}

function loopCore(target, callback, index = 0, values = [], indexes = []) {
    if (index < target.length) {
        const nowTarget = target[index];
        if (lib_index_esm_isArray(nowTarget)) {
            for (let i = 0; i < nowTarget.length; i++) {
                const newValues = values.concat(nowTarget[i]);
                const newIndexes = indexes.concat(i);
                loopCore(target, callback, index + 1, newValues, newIndexes);
            }
        }
        else {
            const newValues = values.concat(nowTarget);
            const newIndexes = indexes.concat(0);
            return loopCore(target, callback, index + 1, newValues, newIndexes);
        }
    }
    else {
        callback(values, indexes);
    }
}
/**
 * @title loop<T>
 * @description: 指定数组遍历遍历
 * @param {T[][]} target
 * @param {(values?:T[],indexes?:number[])=>void} callback
 * @update 3.5.0
 */
function loop(target, callback) {
    if (lib_index_esm_isEmpty(callback))
        return;
    loopCore(target, callback);
    return;
}

/**
 * @title throttle<Params>
 * @description 节流: 用于限制函数触发频率, 每个delay时间间隔，最多只能执行函数一次
 * @param {Function} fn 待处理函数
 * @param {number} interval number 间隔
 * @returns {(...args: Params)=>void}
 */
function throttle(fn, interval) {
    let lastTime = 0;
    return function (...args) {
        const timeSinceLastExecution = Date.now() - lastTime;
        if (!lastTime || timeSinceLastExecution >= interval) {
            fn.apply(this, ...args);
            lastTime = Date.now();
        }
    };
}

/**
 * @title debounce<Params>
 * @description
 * -- 防抖:  时间内只会执行一次 可以减少函数触发的频率
 * -- 当函数触发时，使用一个定时器延迟执行操作。
 * -- 当函数被再次触发时，清除已设置的定时器，重新设置定时器。
 * -- 如果上一次的延迟操作还未执行，则会被清除。
 * @param {Function} fn
 * @param {number} interval
 * @returns {Func<Params>}
 */
function debounce(fn, interval) {
    let timer = 0;
    const debounced = (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, interval);
    };
    return debounced;
}

/**
 * @title curry<Params,Result>
 * @description 柯里化
 * @param {Function} func 待柯里化函数
 * @param {number} [len=1] 待柯里化参数个数
 * @returns 柯里化函数
 */
function curry(func, len = 1) {
    if (!index_esm_isFunction(func)) {
        return undefined;
    }
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    let _args = [];
    const _resFn = function (...args) {
        _args = _args.concat(args);
        if (_args.length < len) {
            return _resFn;
        }
        return func(..._args);
    };
    return _resFn;
}

/**
 * @title bind<Params,Result>
 * @description thisArg绑定func的this，并且func会接收partials附加参数
 * @param {Function} func 绑定的函数
 * @param {Params} partials 附加的部分参数
 * @returns 新的绑定函数
 */
function bind(func, ...partials) {
    return function (...args) {
        if (func)
            return func.call(this, ...[...partials, ...args]);
        return undefined;
    };
}

/**
 * @title EventEmitter<T, U>
 * @description 简易观察者模式
 * @property $cache {Record<string,T[]>} 事件缓存
 * @property $on {(name:string,fn:T)=>void} 绑定事件
 * @property $off {(name: string)=>boolean} 移除事件的名称
 * @property $once {<Params extends any[] = any[]>(name: string, ...args: Params)=>U[]} 触发后就移除当前事件
 * @property $emit {<Params extends any[] = any[]>(name: string, ...args: Params)=> U[]} 触发事件
 * @eg ```js
 const ev = new EventEmitter()
 ev.$on('fn1', ()=>console.log(1))
 ev.$on('fn2', ()=>console.log(2))
 ev.$emit('fn1')
 // 1
 ev.$emit('fn2')
 // 2
 ```
 */
class EventEmitter {
    /**
    * @description 事件缓存
    */
    $cache = {};
    /**
      * @description 绑定事件
      * @param name 事件name
      * @param fn 待触发事件
      */
    $on(name, fn) {
        if (this.$cache[name]) {
            if (Array.isArray(this.$cache[name])) {
                this.$cache[name].push(fn);
            }
            else {
                this.$cache[name] = [fn];
            }
            return;
        }
        this.$cache[name] = [fn];
    }
    /**
      * @param name 移除事件的名称
      */
    $off(name) {
        if (!this.$cache[name])
            return false;
        delete this.$cache[name];
        return true;
    }
    /**
       * @description 触发后就移除当前事件
       * @param name 待触发事件name
       * @param args 触发事件的参数
       */
    $once(name, ...args) {
        if (this.$cache && this.$cache[name]) {
            const result = this.$cache[name].map((i) => runFunc(i, ...args));
            delete this.$cache[name];
            return result;
        }
        return [];
    }
    /**
     * @param name 待触发事件name
     * @param args 触发事件的参数
     */
    $emit(name, ...args) {
        // 创建副本，如果回调函数内继续注册相同事件，会造成死循环
        if (!this.$cache[name])
            return [];
        return this.$cache[name].map((i) => runFunc(i, ...args));
    }
}

/**
 * @title ProxyObject<T extends object>
 * @description 代理object的属性, 结合 Proxy 和 Object 用法
 * @param object {T} 代理的object
 * @param props {?ProxyObjectProp[]} object 属性配置
 * @param handler {?ProxyHandler<T>}
 * @returns {Proxy<T>}
 */
function ProxyObject(object, props, handler = {}) {
    if (lib_index_esm_isEffectArray(props) && lib_index_esm_isObject(object)) {
        const propsConfig = {};
        const supplyConfigs = {};
        for (let i = 0; i < props.length; i++) {
            const prop = props[i];
            const propName = prop.name;
            const supplyConfig = prop;
            if (lib_index_esm_isEmpty(propName))
                continue;
            let defaultValue = prop.default || undefined;
            const types = new Array(0).concat(prop.type).map((item) => item && item.toUpperCase()).filter(Boolean);
            if (lib_index_esm_isEffectArray(types) && !types.includes(lib_index_esm_type(prop.default || undefined).toUpperCase())) {
                defaultValue = undefined;
            }
            supplyConfig.assignCount = 0;
            supplyConfig.default = defaultValue;
            supplyConfig.types = types;
            if (prop.initProp)
                object[propName] = defaultValue;
            if (index_esm_isNoEmpty(prop.default) && lib_index_esm_isEmpty(object[propName]))
                object[propName] = defaultValue;
            const propConfig = {};
            if (index_esm_isNoEmpty(prop.configurable))
                propConfig.configurable = prop.configurable;
            if (index_esm_isNoEmpty(prop.enumerable))
                propConfig.enumerable = prop.enumerable;
            if (index_esm_isNoEmpty(prop.writable))
                propConfig.writable = prop.writable;
            if (index_esm_isEffectObject(propConfig))
                propsConfig[propName] = propConfig;
            supplyConfigs[propName] = supplyConfig;
        }
        Object.defineProperties(object, propsConfig);
        const { set, ...rest } = handler;
        return new Proxy(object, {
            set(target, prop, newValue, receiver) {
                const supplyConfig = supplyConfigs[prop];
                const newValueType = lib_index_esm_type(newValue).toUpperCase();
                if (set)
                    return set(target, prop, newValue, receiver);
                if ((lib_index_esm_isEffectArray(supplyConfig.types) && !supplyConfig.types.includes(newValueType))
                    || (supplyConfig.required === true && lib_index_esm_isEmpty(newValue))
                    || (supplyConfig.once && supplyConfig.assignCount++ > 0)) {
                    return Reflect.set(target, prop, target[prop], receiver);
                }
                return Reflect.set(target, prop, newValue, receiver);
            },
            ...rest
        });
    }
    return object;
}

/**
 * @title arrayToTree
 * @description 数组转树
 * @param {object[]} array
 * @param {string} id
 * @param {string} pid
 * @returns {object[]}
 * @version 2.4.1
 */
function arrayToTree(array, id = 'id', pid = 'pid', child = 'children') {
    const list = deepClone(array);
    const result = [];
    const temp = {};
    // 先把全部id对应项 用temp 存起来
    for (let i = 0; i < list.length; i++)
        temp[list[i][id]] = list[i];
    for (let k = 0; k < list.length; k++) {
        if (temp[list[k][pid]] && list[k][id] !== list[k][pid]) {
            if (!temp[list[k][pid]][child]) {
                temp[list[k][pid]][child] = [];
            }
            temp[list[k][pid]][child].push(list[k]);
        }
        else
            result.push(list[k]);
    }
    return result;
}


//# sourceMappingURL=index.esm.js.map

;// CONCATENATED MODULE: ./src/views/note/hook.tsx
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var hook_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





const key = "__cache_queryParams__";
const filterTree = (tree, params) => {
  const { find = "", tags = [] } = params;
  const newFind = find.toUpperCase();
  const filterTreeCore = (list, lv = 0) => {
    const newList = [];
    list.forEach((item) => {
      const { name, children, content = "" } = item;
      const newName = name.toUpperCase();
      const newContent = name.toUpperCase();
      const newItem = __spreadValues({}, item);
      if (lv === 0 && tags.length && !tags.includes(name)) {
        return;
      }
      if (newFind && stringify(item).toUpperCase().indexOf(newFind) === -1) {
        return;
      }
      if (children && children.length) {
        newItem.children = filterTreeCore(newItem.children, lv + 1);
        newList.push(newItem);
        return;
      }
      if (newFind && (newName.indexOf(newFind) === -1 || newContent && newContent.indexOf(newFind) === -1)) {
        return;
      }
      newList.push(newItem);
    });
    return newList;
  };
  return filterTreeCore(tree);
};
const useHook = () => {
  const [queryParams, _setQueryParams] = useSetState({
    find: "",
    tags: ["CSS", "JavaScript", "HTML", "React", "vue", "Data", "TypeScript"]
    // tags: []
  });
  const [originTree, setOriginTree] = react.useState([]);
  const [tree, setTree] = react.useState([]);
  const [maxTree, setMaxTree] = react.useState([]);
  const setQueryParams = (record) => {
    const newRecord = __spreadValues(__spreadValues({}, queryParams), record);
    _setQueryParams(newRecord);
    localStorage.setItem(key, stringify(newRecord));
    if (maxTree.length) {
      setTree(filterTree(maxTree, newRecord));
    } else {
      setTree(filterTree(originTree, newRecord));
    }
  };
  const select = (root, path) => {
    if (!root || !path) return;
    const newUrl = `https://ruihuag-note.github.io/${root}/index.html#${path.replace(
      "/" + root,
      ""
    )}`;
    window.open(newUrl);
  };
  const init = () => hook_async(void 0, null, function* () {
    const initMax = (res) => {
      if (res.data && isArray(res.data.path)) {
        setMaxTree(res.data.path);
      }
    };
    get("https://unpkg.com/ruihuag-note/sidebar.all.json").then(
      initMax
    );
    get("https://cdn.jsdelivr.net/npm/ruihuag-note/sidebar.all.json").then(
      initMax
    );
    const init2 = (res) => {
      const { path } = res.data || {};
      const params = localStorage.getItem(key);
      if (isArray(path)) {
        const newPath = path.filter((_) => !_.name.match(/^(\.|_)/));
        setOriginTree(newPath);
        if (params) {
          const newParams = JSON.parse(params);
          _setQueryParams(newParams);
          setTree(filterTree(newPath, newParams));
        } else {
          setTree(filterTree(newPath, queryParams));
        }
      }
    };
    get("https://unpkg.com/ruihuag-note/sidebar.json").then(init2);
    get("https://cdn.jsdelivr.net/npm/ruihuag-note/sidebar.json").then(init2);
  });
  react.useEffect(() => {
    init();
  }, []);
  return {
    queryParams,
    setQueryParams,
    tree,
    originTree,
    setTree,
    select
  };
};

;// CONCATENATED MODULE: ./node_modules/.store/harpe@0.1.2/node_modules/harpe/lib/index.esm.js
function e(e){return"object"==typeof e&&!function(e){return null==e||e!=e}(e)&&/Iterator\]$/.test(e.toString())}function t(t){try{if(e(t))return"Iterator";const n=Object.prototype.toString.call(t).match(/\[object (\w+)\]/)[1];return"Number"===n&&isNaN(t)?"NaN":n}catch(t){return"Undefined"}}function n(e,n,r){return["Object","Array"].includes(t(e))?JSON.stringify(e,n,r):JSON.stringify(function(e){return"String"===t(e)?e:["Function","AsyncFunction","GeneratorFunction","Symbol","RegExp","Promise","Date","NaN","Map","Set","WeakMap","WeakSet","BigInt"].includes(t(e))?e.toString():e===1/0?"Infinity":e===-1/0?"-Infinity":void 0===e?"undefined":null===e?"null":JSON.stringify(e)}(e),n,r).replace(/^(")+|(")+$/g,"")}function r(e){return null==e||e!=e}const o=Array.isArray;function i(e){return!r(e)&&(o(e)&&e.length>0)}function c(e){try{if("object"==typeof(t=e)&&!r(t)&&/Iterator\]$/.test(t.toString()))return"Iterator";const n=Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1];return"Number"===n&&isNaN(e)?"NaN":n}catch(e){return"Undefined"}var t}function u(e,t=!1){return t?"function"==typeof e:"Function"===c(e)}function index_esm_s(e){return null!==e&&"object"==typeof e&&"Object"===c(e)}function a(e){return"string"==typeof e}const l=e=>"number"==typeof e&&"Number"===c(e),index_esm_d=()=>document.cookie.split(";").forEach((e=>document.cookie=e.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date(0).toUTCString()};path=/`)));function f(e){if(r(document.cookie))return;const t=RegExp("(^|; )"+encodeURIComponent(e)+"=([^;]*)").exec(document.cookie);if(i(t)&&t.length>1){const e=t[2],n=/(.+)(<[a-zA-Z]+>)/.exec(e);if(i(n)&&n.length>1){const e=n[1],t=n[2]||"String";if("<Number>"===t)return Number(e);if(["<Array>","<Object>"].includes(t))try{return JSON.parse(e)}catch(t){return e}return e}return e}}function index_esm_m(e,t,r){const{expiryDays:o,domain:i,path:u}=r||{},s=o||10,a=new Date;a.setTime(a.getTime()+24*s*60*60*1e3);let l=`${e}=${n(t)}<${c(t)}>;expires=${a.toUTCString()}`;i&&(l+=";domain="+i),u&&(l+=";path="+u),document.cookie=l}function b(e){const t=window.clipboardData;if(navigator.clipboard)return navigator.clipboard.writeText(e),!0;if(t)return t.clearData(),t.setData("Text",e),!0;if(document.execCommand){const t=document.createElement("textarea");return t.value=e,t.setAttribute("readonly",""),t.style.position="absolute",t.style.left="-9999px",document.body.appendChild(t),t.select(),document.execCommand("copy"),document.body.removeChild(t),!0}return!1}function p(){["contextmenu","selectstart","copy"].forEach((function(e){document.addEventListener(e,(function(e){return e.returnValue=!1}))}))}function w(){["contextmenu","selectstart","copy"].forEach((function(e){document.addEventListener(e,(function(e){return e.returnValue=!0}))}))}function g(e=3e3){const t=setInterval((function(){!function(){try{!function e(t){(function(){}).constructor("debugger")(),e()}()}catch(e){console.error(e)}}()}),e);window.__ban__console__timer__=t}function index_esm_h(){delete window.__ban__console__timer__}function y(e){try{return JSON.parse(`{"${decodeURI(e.split("?")[1]).replace(/"/g,'\\"').replace(/&/g,'","').replace(/=/g,'":"')}"}`)}catch(e){return{}}}function S(e){return new URLSearchParams(e)}const F=function(e){if(r(e))return;const t=document.createElement("a");t.href=e,t.click()};function x(){return window.getSelection().toString()}function N(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||function(e,t=1e3){return setTimeout(e,t)}}const k=e=>location.href=e;function O(e=window.location.href){const t="?"===e[0]?e:e.substring(e.lastIndexOf("?")),n={};return t.replace(/([^?&=]+)=([^&]+)/g,((e,t,r)=>n[t]=decodeURIComponent(r))),n}function E(e=window.location.href,t){const n=new RegExp("(^|&)"+t+"=([^&]*)(&|$)?","i"),r=e.substr(1).match(n);return null!==r?decodeURI(r[2]):null}function v(e){const t=window.location.href.split("?")[1];if(r(t))return null;const n=new RegExp(`(^|&)${e}=([^&]*)(&|$)`),o=t.match(n);return null!=o?decodeURIComponent(o[2]):null}function R(e,t,n=!1){if(!o(t))return new RegExp("(^|\\s)"+t+"(\\s|$)").test(e.className);for(let r=0;r<t.length;r++){if(new RegExp("(^|\\s)"+t[r]+"(\\s|$)").test(e.className))return!0;if(n)return!1}return!1}function I(e,t){try{if(R(e,t))return!1;const n=e.className.split(" ");return n.concat(t),e.className=n.join(" "),!0}catch(e){return!1}}function C(e,t){if(!R(e,t))return!1;try{if(o(t))return e.className=e.className.split(" ").filter((e=>!t.includes(e))).join(" "),!0;const n=new RegExp("(^|\\s)"+t+"(\\s|$)","g");return e.className=e.className.replace(n," "),!0}catch(e){return!1}}function q(e){try{if(e.className)return e.className="",!0}catch(e){return!1}return!1}function index_esm_A(...e){const t=new Set,n={};function r(e,n){!1===e&&t.has(n)&&t.delete(n),!0!==e||t.has(n)||t.add(n)}!function e(o){o.forEach((o=>{if(o){if(Array.isArray(o))return e(o);if("string"!=typeof o&&"number"!=typeof o)if("Object"!==c(o));else for(const e in o){const t=!!o[e];n[e]=t,r(t,e)}else t.add(o)}}))}(e);for(const e in n)r(n[e],e);return[...t].join(" ")}const _=e=>e===document.activeElement;function j(){const e=navigator.userAgent.toLowerCase();let t=(e.match(/firefox|chrome|safari|opera/g)||"other")[0];(e.match(/msie|trident/g)||[])[0]&&(t="msie");let n="",r="",o="";switch(n="ontouchstart"in window||-1!==e.indexOf("touch")||-1!==e.indexOf("mobile")?-1!==e.indexOf("ipad")?"pad":-1!==e.indexOf("mobile")?"mobile":-1!==e.indexOf("android")?"androidPad":"pc":"pc",t){case"chrome":case"safari":case"mobile":default:r="webkit";break;case"msie":r="ms";break;case"firefox":r="Moz";break;case"opera":r="O"}return o=e.indexOf("android")>0?"android":navigator.platform.toLowerCase(),{version:(e.match(/[\s\S]+(?:rv|it|ra|ie)[/: ]([\d.]+)/)||[])[1],plat:o,type:t,pc:n,prefix:r,isMobile:"pc"!=n}}function z(){return!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)}function $(){return"IntersectionObserver"in window&&"IntersectionObserverEntry"in window&&"intersectionRatio"in window.IntersectionObserverEntry.prototype}const V=/ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()),M=/android/.test(navigator.userAgent.toLowerCase());function T(){return 0===document.createElement("canvas").toDataURL("image/webp").indexOf("data:image/webp")}function P(){const e=navigator.userAgent,t=["android","iphone","ipod","ipad","windows phone","mqqbrowser"];if(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(e))return!0;let n=!1;if((e.indexOf("Windows NT")<0||e.indexOf("Windows NT")>=0&&e.indexOf("compatible; MSIE 9.0;")>=0)&&e.indexOf("Windows NT")<0&&e.indexOf("Macintosh")<0)for(const r of t)if(e.indexOf(r)>=0){n=!0;break}return n}const U=()=>window.print(),D=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,J=()=>!document.hidden;function L(e,t={},n={}){const r=new Notification(e,t);for(const e in n)r[e]=n[e]}function B(e,t={},n={}){if(!("Notification"in window))return console.error("This browser does not support desktop notification");"granted"===Notification.permission?L(e,t,n):"denied"!==Notification.permission&&Notification.requestPermission().then((function(r){"granted"===r&&L(e,t,n)}))}function W(){const e=document.body;e.webkitRequestFullScreen?e.webkitRequestFullScreen():e.mozRequestFullScreen?e.mozRequestFullScreen():e.msRequestFullscreen?e.msRequestFullscreen():e.requestFullScreen?e.requestFullScreen():console.error("浏览器不支持全屏")}function index_esm_G(){document.exitFullScreen?document.exitFullScreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.msExitFullscreen&&document.msExitFullscreen()}function K(e){const t=e.document;t.webkitCancelFullScreen?t.webkitCancelFullScreen():t.mozCancelFullScreen?t.mozCancelFullScreen():t.cancelFullScreen?t.cancelFullScreen():t.msExitFullscreen?t.msExitFullscreen():t.exitFullscreen?t.exitFullscreen():console.error("切换失败,可尝试Esc退出")}function Z(e=document.body){e.requestFullscreen?e.requestFullscreen():e.mozRequestFullScreen?e.mozRequestFullScreen():e.webkitRequestFullscreen?e.webkitRequestFullscreen():e.msRequestFullscreen&&e.msRequestFullscreen()}function H(){return document.fullscreenElement||document.mozFullScreenElement||document.msFullScreenElement||document.webkitFullscreenElement||null}function Q(){return!!(document.fullscreen||document.mozFullScreen||document.webkitIsFullScreen||document.webkitFullScreen||document.msFullScreen)}function X(){return document.fullscreenEnabled||document.mozFullScreenEnabled||document.webkitFullscreenEnabled||document.msFullscreenEnabled}class Y{length;storage;defaultValue;setCallback;getCallback;constructor(e,t){this.storage=e,this.length=e.length;const{defaultValue:n=null,getCallback:r,setCallback:o}=t||{};this.defaultValue=n,u(r)&&(this.getCallback=r),u(o)&&(this.setCallback=o)}getItem(e){return this.storage.getItem(e)}get(e,t=this.defaultValue){const n=this.storage.getItem(e);return u(this.getCallback)?this.getCallback(e,n,t):r(n)?t:n}getNumber(e,t=(l(this.defaultValue)?this.defaultValue:0)){const n=Number(this.get(e));return l(n)?n:t}getString(e,t=(a(this.defaultValue)?this.defaultValue:"")){const n=this.get(e);return a(n)?n:t}getObject(e,t=(index_esm_s(this.defaultValue)?this.defaultValue:{})){try{const n=JSON.parse(this.get(e)||"{}");return index_esm_s(n)?n:t}catch(e){return t}}getArray(e,t=(o(this.defaultValue)?this.defaultValue:[])){try{const n=JSON.parse(this.get(e)||"{}");return o(n)?n:t}catch(e){return t}}setItem(e,t){a(t)?this.storage.setItem(e,t):this.storage.setItem(e,JSON.stringify(t))}key(e){return this.storage.key(e)}removeItem(e){return this.storage.removeItem(e)}clear(){return this.storage.clear()}}const ee=new Y(localStorage),te=new Y(sessionStorage);function ne(){window.scrollTo({top:0,behavior:"smooth"})}function re(){}const oe=(e=window)=>({}),ie={observe:(e,t)=>{},unobserve:e=>{},disconnect:()=>{},takeRecords:()=>[]};function ce(e,t,n={attributes:!0}){if(null===e)return ie;const o=new MutationObserver((function(e,n){if(u(t))return t(e,n);if(!r(o=t)&&index_esm_s(o)&&0!==Reflect.ownKeys(o).length)for(const r of e){const o=r.type;t[o]&&u(t[o])&&t[o](e,n)}var o}));return o.observe(e,n),o}function ue(e,t,n){if(null===e)return ie;const r=new ResizeObserver(t);return r.observe(e,n),r}function se(e,t){const n=new PerformanceObserver(e);return n.observe(t),n}function ae(e,t,n){if(null===e)return ie;const r=new IntersectionObserver(t,n);return r.observe(e),r}
//# sourceMappingURL=index.esm.js.map

;// CONCATENATED MODULE: ./src/views/note/component/tag/index.tsx
var tag_defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var tag_getOwnPropSymbols = Object.getOwnPropertySymbols;
var tag_hasOwnProp = Object.prototype.hasOwnProperty;
var tag_propIsEnum = Object.prototype.propertyIsEnumerable;
var tag_defNormalProp = (obj, key, value) => key in obj ? tag_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var tag_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (tag_hasOwnProp.call(b, prop))
      tag_defNormalProp(a, prop, b[prop]);
  if (tag_getOwnPropSymbols)
    for (var prop of tag_getOwnPropSymbols(b)) {
      if (tag_propIsEnum.call(b, prop))
        tag_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));




function Tag(props) {
  const { tree, root = "", path = "", lv = 0, click } = props;
  const [nextStyle, setNextStyle] = useSetState({});
  return /* @__PURE__ */ react.createElement(
    "div",
    {
      className: index_esm_A("tag", {
        isRoot: !root
      })
    },
    tree.map((item, index) => {
      const { name, children } = item;
      const newRoot = root || name;
      const newPath = path + "/" + name;
      if (isArray(children) && children.length === 1 && children[0].name === "index") {
        const newPath2 = path + "/" + name + "/index";
        return /* @__PURE__ */ react.createElement("div", { className: "item", key: name + index }, /* @__PURE__ */ react.createElement(
          "div",
          {
            className: index_esm_A("name", "last"),
            onClick: () => {
              click && click(newRoot, newPath2);
            }
          },
          name
        ));
      }
      return /* @__PURE__ */ react.createElement("div", { className: "item", key: name + index }, /* @__PURE__ */ react.createElement(
        "div",
        {
          className: index_esm_A("name", {
            last: !children || !children.length
          }),
          style: {
            zIndex: 99999 - lv
          },
          onClick: () => {
            if (children && children.length) {
              if (Object.keys(nextStyle[name] || {}).length) {
                setNextStyle({ [name]: {} });
              } else {
                setNextStyle({ [name]: { display: "none" } });
              }
            } else {
              click && click(newRoot, newPath);
            }
          },
          title: name
        },
        name
      ), item.children && /* @__PURE__ */ react.createElement("div", { className: index_esm_A("next"), style: nextStyle[name] }, /* @__PURE__ */ react.createElement(
        Tag,
        __spreadProps(tag_spreadValues({}, props), {
          path: newPath,
          root: newRoot,
          tree: children,
          lv: lv + 1
        })
      )));
    })
  );
}

;// CONCATENATED MODULE: ./src/views/note/component/index.ts


;// CONCATENATED MODULE: ./src/views/note/index.tsx





function Note() {
  const h = useHook();
  return /* @__PURE__ */ react.createElement("div", { className: "container" }, /* @__PURE__ */ react.createElement("div", { className: "query" }, /* @__PURE__ */ react.createElement("div", { className: "tags" }, h.originTree.map((item) => {
    const { name } = item;
    const newTags = h.queryParams.tags || [];
    const isSelect = newTags.includes(name);
    return /* @__PURE__ */ react.createElement(
      "div",
      {
        className: index_esm_A({ isSelect }),
        key: name,
        onClick: () => {
          h.setQueryParams({
            tags: isSelect ? newTags.filter((v) => v !== name) : [...newTags, name]
          });
        }
      },
      name
    );
  })), /* @__PURE__ */ react.createElement(
    "input",
    {
      value: h.queryParams.find,
      onChange: (e) => {
        h.setQueryParams({ find: e.target.value || "" });
      }
    }
  )), /* @__PURE__ */ react.createElement("div", { className: "note" }, /* @__PURE__ */ react.createElement(Tag, { tree: h.tree, click: h.select })));
}

;// CONCATENATED MODULE: ./src/views/index.ts


// EXTERNAL MODULE: ./node_modules/.store/react-dom@18.3.1/node_modules/react-dom/index.js
var react_dom = __webpack_require__(684);
var react_dom_namespaceObject = /*#__PURE__*/__webpack_require__.t(react_dom, 2);
;// CONCATENATED MODULE: ./node_modules/.store/@remix-run+router@1.18.0/node_modules/@remix-run/router/dist/router.js
/**
 * @remix-run/router v1.18.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////
/**
 * Actions represent the type of change to a location value.
 */
var Action;
(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */
  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */
  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */
function router_createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation
  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = Action.Pop;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }
  function createHref(to) {
    return typeof to === "string" ? to : router_createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = Action.Pop;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */
function router_createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : router_createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */
function router_createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));
    // Hash URL should always have a leading / just like window.location.pathname
    // does, so if an app ends up at a route like /#something then we add a
    // leading slash so all of our path-matching behaves the same as if it would
    // in a browser router.  This is particularly important when there exists a
    // root splat route (<Route path="*">) since that matches internally against
    // "/*" and we'd expect /#something to 404 in a hash router app.
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : router_createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience, so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message);
      // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */
function router_createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  // Index should only be null when we initialize. If not, it's because the
  // user called history.pushState or history.replaceState directly, in which
  // case we should log a warning as it will result in bugs.
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    // try...catch because iOS limits us to 100 pushState calls :/
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // If the exception is because `state` can't be serialized, let that throw
      // outwards just like a replace call would so the dev knows the cause
      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps
      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    // window.location.origin is "null" (the literal string value) in Firefox
    // under certain conditions, notably when serving from a local HTML file
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    let href = typeof to === "string" ? to : router_createPath(to);
    // Treating this as a full URL will strip any trailing spaces so we need to
    // pre-encode them since they might be part of a matching splat param from
    // an ancestor route
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window, to);
    },
    createURL,
    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}
//#endregion

var ResultType;
(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
// Walk the route tree generating unique IDs where necessary, so we are working
// solely with AgnosticDataRouteObject's within the Router
function convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index) => {
    let treePath = [...parentPath, String(index)];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id], "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, mapRouteProperties(route), {
        id
      });
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {
        id,
        children: undefined
      });
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = router_stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i], decoded, allowPartial);
  }
  return matches;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = router_joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    // Add the children before adding this route to the array, so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.
    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  // Optional path segments are denoted by a trailing `?`
  let isOptional = first.endsWith("?");
  // Compute the corresponding required segment: `foo?` -> `foo`
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  // All child paths with the prefix.  Do this for all children before the
  // optional version for all children, so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explode _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue
  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/")));
  // Then, if this is an optional value, add all child versions without
  if (isOptional) {
    result.push(...restExploded);
  }
  // for absolute paths, ensure `/` instead of empty segment
  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname, allowPartial) {
  if (allowPartial === void 0) {
    allowPartial = false;
  }
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = router_matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = router_matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end: false
      }, remainingPathname);
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: router_joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(router_joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = router_joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */
function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  }
  // ensure `/` is added at the beginning if the path is absolute
  const prefix = path.startsWith("/") ? "/" : "";
  const stringify = p => p == null ? "" : typeof p === "string" ? p : String(p);
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1;
    // only apply the splat if it's the last segment
    if (isLastSegment && segment === "*") {
      const star = "*";
      // Apply the splat
      return stringify(params[star]);
    }
    const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      invariant(optional === "?" || param != null, "Missing \":" + key + "\" param");
      return stringify(param);
    }
    // Remove any optional markers from optional static segments
    return segment.replace(/\?$/g, "");
  })
  // Remove empty segments
  .filter(segment => !!segment);
  return prefix + segments.join("/");
}
/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */
function router_matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo, _ref, index) => {
    let {
      paramName,
      isOptional
    } = _ref;
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo[paramName] = undefined;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^${}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex, so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map(v => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */
function router_stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
// Return the array of pathnames for the current route matches - used to
// generate the routePathnames input for resolveTo()
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf
  // match so we include splat values for "." links.  See:
  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map(match => match.pathnameBase);
}
/**
 * @private
 */
function router_resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    // With relative="route" (the default), each leading .. segment means
    // "go up one route" instead of "go up one URL segment".  This is a key
    // difference from how <a href> works and a major reason we call this a
    // "to" value instead of a "href".
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  // Ensure the pathname has a trailing slash if the original "to" had one
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  // Or if this was a link to the current path which has a trailing slash
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
/**
 * @private
 */
function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
/**
 * @private
 */
const router_joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */
const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */
const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */
const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */
const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data, responseInit) {
    this.pendingKeysSet = new Set();
    this.subscribers = new Set();
    this.deferredKeys = [];
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects");
    // Set up an AbortController + Promise we can race against to exit early
    // cancellation
    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
    if (this.done) {
      // All incoming values were resolved
      this.unlistenAbortSignal();
    }
    this.init = responseInit;
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.deferredKeys.push(key);
    this.pendingKeysSet.add(key);
    // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject
    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));
    // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values
    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeysSet.delete(key);
    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }
    // If the promise was resolved/rejected with undefined, we'll throw an error as you
    // should always resolve with a value or null
    if (error === undefined && data === undefined) {
      let undefinedError = new Error("Deferred data for key \"" + key + "\" resolved/rejected with `undefined`, " + "you must resolve/reject with a value or `null`.");
      Object.defineProperty(promise, "_error", {
        get: () => undefinedError
      });
      this.emit(false, key);
      return Promise.reject(undefinedError);
    }
    if (data === undefined) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      this.emit(false, key);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    this.emit(false, key);
    return data;
  }
  emit(aborted, settledKey) {
    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  }
  subscribe(fn) {
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }
  cancel() {
    this.controller.abort();
    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
    this.emit(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);
          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref3) => {
      let [key, value] = _ref3;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
const defer = function defer(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  return new DeferredData(data, responseInit);
};
/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};
/**
 * A redirect response that will force a document reload to the new location.
 * Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirectDocument = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Reload-Document", "true");
  return response;
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 *
 * We don't export the class for public use since it's an implementation
 * detail, but we export the interface above so folks can build their own
 * abstractions around instances via isRouteErrorResponse()
 */
class ErrorResponseImpl {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 */
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
  json: undefined,
  text: undefined
};
const router_IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
  json: undefined,
  text: undefined
};
const router_IDLE_BLOCKER = {
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const defaultMapRouteProperties = route => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////
/**
 * Create a router and listen to history POP navigations
 */
function router_createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : undefined;
  const isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer = !isBrowser;
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties;
  if (init.mapRouteProperties) {
    mapRouteProperties = init.mapRouteProperties;
  } else if (init.detectErrorBoundary) {
    // If they are still using the deprecated version, wrap it with the new API
    let detectErrorBoundary = init.detectErrorBoundary;
    mapRouteProperties = route => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties = defaultMapRouteProperties;
  }
  // Routes keyed by ID
  let manifest = {};
  // Routes in tree format for matching
  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  let dataStrategyImpl = init.unstable_dataStrategy || defaultDataStrategy;
  let patchRoutesOnMissImpl = init.unstable_patchRoutesOnMiss;
  // Config driven behavior flags
  let future = _extends({
    v7_fetcherPersist: false,
    v7_normalizeFormMethod: false,
    v7_partialHydration: false,
    v7_prependBasename: false,
    v7_relativeSplatPath: false,
    v7_skipActionErrorRevalidation: false
  }, init.future);
  // Cleanup function for history
  let unlistenHistory = null;
  // Externally-provided functions to call on all state changes
  let subscribers = new Set();
  // Externally-provided object to hold scroll restoration locations during routing
  let savedScrollPositions = null;
  // Externally-provided function to get scroll restoration keys
  let getScrollRestorationKey = null;
  // Externally-provided function to get current scroll position
  let getScrollPosition = null;
  // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialErrors = null;
  if (initialMatches == null && !patchRoutesOnMissImpl) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  // In SPA apps, if the user provided a patchRoutesOnMiss implementation and
  // our initial match is a splat route, clear them out so we run through lazy
  // discovery on hydration in case there's a more accurate lazy route match.
  // In SSR apps (with `hydrationData`), we expect that the server will send
  // up the proper matched routes so we don't want to run lazy discovery on
  // initial hydration and want to hydrate into the splat route.
  if (initialMatches && patchRoutesOnMissImpl && !init.hydrationData) {
    let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);
    if (fogOfWar.active) {
      initialMatches = null;
    }
  }
  let initialized;
  if (!initialMatches) {
    // We need to run patchRoutesOnMiss in initialize()
    initialized = false;
    initialMatches = [];
  } else if (initialMatches.some(m => m.route.lazy)) {
    // All initialMatches need to be loaded before we're ready.  If we have lazy
    // functions around still then we'll need to run them in initialize()
    initialized = false;
  } else if (!initialMatches.some(m => m.route.loader)) {
    // If we've got no loaders to run, then we're good to go
    initialized = true;
  } else if (future.v7_partialHydration) {
    // If partial hydration is enabled, we're initialized so long as we were
    // provided with hydrationData for every route with a loader, and no loaders
    // were marked for explicit hydration
    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
    let errors = init.hydrationData ? init.hydrationData.errors : null;
    let isRouteInitialized = m => {
      // No loader, nothing to initialize
      if (!m.route.loader) {
        return true;
      }
      // Explicitly opting-in to running on hydration
      if (typeof m.route.loader === "function" && m.route.loader.hydrate === true) {
        return false;
      }
      // Otherwise, initialized if hydrated with data or an error
      return loaderData && loaderData[m.route.id] !== undefined || errors && errors[m.route.id] !== undefined;
    };
    // If errors exist, don't consider routes below the boundary
    if (errors) {
      let idx = initialMatches.findIndex(m => errors[m.route.id] !== undefined);
      initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);
    } else {
      initialized = initialMatches.every(isRouteInitialized);
    }
  } else {
    // Without partial hydration - we're initialized if we were provided any
    // hydrationData - which is expected to be complete
    initialized = init.hydrationData != null;
  }
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map(),
    blockers: new Map()
  };
  // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)
  let pendingAction = Action.Pop;
  // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?
  let pendingPreventScrollReset = false;
  // AbortController for the active navigation
  let pendingNavigationController;
  // Should the current navigation enable document.startViewTransition?
  let pendingViewTransitionEnabled = false;
  // Store applied view transitions so we can apply them on POP
  let appliedViewTransitions = new Map();
  // Cleanup function for persisting applied transitions to sessionStorage
  let removePageHideEventListener = null;
  // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted
  let isUninterruptedRevalidation = false;
  // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidator()
  //  - X-Remix-Revalidate (from redirect)
  let isRevalidationRequired = false;
  // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission
  let cancelledDeferredRoutes = [];
  // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation
  let cancelledFetcherLoads = [];
  // AbortControllers for any in-flight fetchers
  let fetchControllers = new Map();
  // Track loads based on the order in which they started
  let incrementingLoadId = 0;
  // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation
  let pendingNavigationLoadId = -1;
  // Fetchers that triggered data reloads as a result of their actions
  let fetchReloadIds = new Map();
  // Fetchers that triggered redirect navigations
  let fetchRedirectIds = new Set();
  // Most recent href/match for fetcher.load calls for fetchers
  let fetchLoadMatches = new Map();
  // Ref-count mounted fetchers so we know when it's ok to clean them up
  let activeFetchers = new Map();
  // Fetchers that have requested a delete when using v7_fetcherPersist,
  // they'll be officially removed after they return to idle
  let deletedFetchers = new Set();
  // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.
  let activeDeferreds = new Map();
  // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change
  let blockerFunctions = new Map();
  // Map of pending patchRoutesOnMiss() promises (keyed by path/matches) so
  // that we only kick them off once for a given combo
  let pendingPatchRoutes = new Map();
  // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state
  let ignoreNextHistoryUpdate = false;
  // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();
  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      // Ignore this event if it was just us resetting the URL from a
      // blocked POP navigation
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        // Restore the URL to match the current UI, but don't update router state
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1);
        // Put the blocker into a blocked state
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location
            });
            // Re-do the same POP navigation we just blocked
            init.history.go(delta);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, router_IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (isBrowser) {
      // FIXME: This feels gross.  How can we cleanup the lines between
      // scrollRestoration/appliedTransitions persistance?
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    // Kick off initial data load if needed.  Use Pop to avoid modifying history
    // Note we don't do any handling of lazy here.  For SPA's it'll get handled
    // in the normal navigation flow.  For SSR it's expected that lazy modules are
    // resolved prior to router creation since we can't go into a fallbackElement
    // UI for SSR'd apps
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location, {
        initialHydration: true
      });
    }
    return router;
  }
  // Clean up a router and it's side effects
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  }
  // Subscribe to state updates for the router
  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  // Update our state and notify the calling context of the change
  function updateState(newState, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state = _extends({}, state, newState);
    // Prep fetcher cleanup so we can tell the UI which fetcher data entries
    // can be removed
    let completedFetchers = [];
    let deletedFetchersKeys = [];
    if (future.v7_fetcherPersist) {
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (deletedFetchers.has(key)) {
            // Unmounted from the UI and can be totally removed
            deletedFetchersKeys.push(key);
          } else {
            // Returned to idle but still mounted in the UI, so semi-remains for
            // revalidations and such
            completedFetchers.push(key);
          }
        }
      });
    }
    // Iterate over a local copy so that if flushSync is used and we end up
    // removing and adding a new subscriber due to the useCallback dependencies,
    // we don't get ourselves into a loop calling the new subscriber immediately
    [...subscribers].forEach(subscriber => subscriber(state, {
      deletedFetchers: deletedFetchersKeys,
      unstable_viewTransitionOpts: opts.viewTransitionOpts,
      unstable_flushSync: opts.flushSync === true
    }));
    // Remove idle fetchers from state since we only care about in-flight fetchers.
    if (future.v7_fetcherPersist) {
      completedFetchers.forEach(key => state.fetchers.delete(key));
      deletedFetchersKeys.forEach(key => deleteFetcher(key));
    }
  }
  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState
  function completeNavigation(location, newState, _temp) {
    var _location$state, _location$state2;
    let {
      flushSync
    } = _temp === void 0 ? {} : _temp;
    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    }
    // Always preserve any existing loaderData from re-used routes
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    // On a successful navigation we can assume we got through all blockers
    // so we can start fresh
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_, k) => blockers.set(k, router_IDLE_BLOCKER));
    }
    // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    // Commit any in-flight routes at the end of the HMR revalidation "navigation"
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = undefined;
    }
    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location, location.state);
    }
    let viewTransitionOpts;
    // On POP, enable transitions if they were enabled on the original navigation
    if (pendingAction === Action.Pop) {
      // Forward takes precedence so they behave like the original navigation
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        // If we don't have a previous forward nav, assume we're popping back to
        // the new location and enable if that location previously enabled
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      // Store the applied transition on PUSH/REPLACE
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(_extends({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }), {
      viewTransitionOpts,
      flushSync: flushSync === true
    });
    // Reset stateful navigation vars
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  }
  // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history
    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation
          });
          // Send the same navigation through
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, router_IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.unstable_viewTransition,
      flushSync
    });
  }
  // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders
    if (state.navigation.state === "submitting") {
      return;
    }
    // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  }
  // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation
  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, basename);
    let flushSync = (opts && opts.flushSync) === true;
    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    // Short circuit with a 404 on the root error boundary if we match nothing
    if (!matches) {
      let {
        error,
        notFoundMatches,
        route
      } = handleNavigational404(location.pathname);
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      }, {
        flushSync
      });
      return;
    }
    // Short circuit if it's only a hash change and not a revalidation or
    // mutation submission.
    //
    // Ignore on initial page loads because since the initial load will always
    // be "same hash".  For example, on /page#hash and submit a <Form method="post">
    // which will default to a navigation to /page
    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      }, {
        flushSync
      });
      return;
    }
    // Create a controller/Request for this navigation
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionResult;
    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingActionResult = [findNearestBoundary(matches).route.id, {
        type: ResultType.error,
        error: opts.pendingError
      }];
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionResult = await handleAction(request, location, opts.submission, matches, fogOfWar.active, {
        replace: opts.replace,
        flushSync
      });
      if (actionResult.shortCircuited) {
        return;
      }
      // If we received a 404 from handleAction, it's because we couldn't lazily
      // discover the destination route so we don't want to call loaders
      if (actionResult.pendingActionResult) {
        let [routeId, result] = actionResult.pendingActionResult;
        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
          pendingNavigationController = null;
          completeNavigation(location, {
            matches: actionResult.matches,
            loaderData: {},
            errors: {
              [routeId]: result.error
            }
          });
          return;
        }
      }
      matches = actionResult.matches || matches;
      pendingActionResult = actionResult.pendingActionResult;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync = false;
      // No need to do fog of war matching again on loader execution
      fogOfWar.active = false;
      // Create a GET request for the loaders
      request = createClientSideRequest(init.history, request.url, request.signal);
    }
    // Call loaders
    let {
      shortCircuited,
      matches: updatedMatches,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);
    if (shortCircuited) {
      return;
    }
    // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation
    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches: updatedMatches || matches
    }, getActionDataForCommit(pendingActionResult), {
      loaderData,
      errors
    }));
  }
  // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors
  async function handleAction(request, location, submission, matches, isFogOfWar, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();
    // Put us in a submitting state
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    }, {
      flushSync: opts.flushSync === true
    });
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);
      if (discoverResult.type === "aborted") {
        return {
          shortCircuited: true
        };
      } else if (discoverResult.type === "error") {
        let {
          boundaryId,
          error
        } = handleDiscoverRouteError(location.pathname, discoverResult);
        return {
          matches: discoverResult.partialMatches,
          pendingActionResult: [boundaryId, {
            type: ResultType.error,
            error
          }]
        };
      } else if (!discoverResult.matches) {
        let {
          notFoundMatches,
          error,
          route
        } = handleNavigational404(location.pathname);
        return {
          matches: notFoundMatches,
          pendingActionResult: [route.id, {
            type: ResultType.error,
            error
          }]
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    // Call our action and get the result
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      let results = await callDataStrategy("action", request, [actionMatch], matches);
      result = results[0];
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        let location = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request.url), basename);
        replace = location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(request, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      // By default, all submissions to the current location are REPLACE
      // navigations, but if the action threw an error that'll be rendered in
      // an errorElement, we fall back to PUSH so that the user can use the
      // back button to get back to the pre-submission form location to try
      // again
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        matches,
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      matches,
      pendingActionResult: [actionMatch.route.id, result]
    };
  }
  // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.
  async function handleLoaders(request, location, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionResult) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)
    // If we have partialHydration enabled, then don't update the state for the
    // initial data load since it's not a "navigation"
    let shouldUpdateNavigationState = !isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration);
    // When fog of war is enabled, we enter our `loading` state earlier so we
    // can discover new routes during the `loading` state.  We skip this if
    // we've already run actions since we would have done our matching already.
    // If the children() function threw then, we want to proceed with the
    // partial matches it discovered.
    if (isFogOfWar) {
      if (shouldUpdateNavigationState) {
        let actionData = getUpdatedActionData(pendingActionResult);
        updateState(_extends({
          navigation: loadingNavigation
        }, actionData !== undefined ? {
          actionData
        } : {}), {
          flushSync
        });
      }
      let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);
      if (discoverResult.type === "aborted") {
        return {
          shortCircuited: true
        };
      } else if (discoverResult.type === "error") {
        let {
          boundaryId,
          error
        } = handleDiscoverRouteError(location.pathname, discoverResult);
        return {
          matches: discoverResult.partialMatches,
          loaderData: {},
          errors: {
            [boundaryId]: error
          }
        };
      } else if (!discoverResult.matches) {
        let {
          error,
          notFoundMatches,
          route
        } = handleNavigational404(location.pathname);
        return {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error
          }
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);
    // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op
    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;
    // Short circuit if we have no loaders to run
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers = markFetchRedirectsDone();
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null
      }, getActionDataForCommit(pendingActionResult), updatedFetchers ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
      return {
        shortCircuited: true
      };
    }
    if (shouldUpdateNavigationState) {
      let updates = {};
      if (!isFogOfWar) {
        // Only update navigation/actionNData if we didn't already do it above
        updates.navigation = loadingNavigation;
        let actionData = getUpdatedActionData(pendingActionResult);
        if (actionData !== undefined) {
          updates.actionData = actionData;
        }
      }
      if (revalidatingFetchers.length > 0) {
        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
      }
      updateState(updates, {
        flushSync
      });
    }
    revalidatingFetchers.forEach(rf => {
      if (fetchControllers.has(rf.key)) {
        abortFetcher(rf.key);
      }
      if (rf.controller) {
        // Fetchers use an independent AbortController so that aborting a fetcher
        // (via deleteFetcher) does not abort the triggering navigation that
        // triggered the revalidation
        fetchControllers.set(rf.key, rf.controller);
      }
    });
    // Proxy navigation abort through to revalidation fetchers
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));
    // If any loaders returned a redirect Response, start a new REPLACE navigation
    let redirect = findRedirect([...loaderResults, ...fetcherResults]);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        // If this redirect came from a fetcher make sure we mark it in
        // fetchRedirectIds so it doesn't get revalidated on the next set of
        // loader executions
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      await startRedirectNavigation(request, redirect.result, {
        replace
      });
      return {
        shortCircuited: true
      };
    }
    // Process and commit output from loaders
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);
    // Wire up subscribers to update loaderData as promises settle
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    // During partial hydration, preserve SSR errors for routes that don't re-run
    if (future.v7_partialHydration && initialHydration && state.errors) {
      Object.entries(state.errors).filter(_ref2 => {
        let [id] = _ref2;
        return !matchesToLoad.some(m => m.route.id === id);
      }).forEach(_ref3 => {
        let [routeId, error] = _ref3;
        errors = Object.assign(errors || {}, {
          [routeId]: error
        });
      });
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends({
      matches,
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getUpdatedActionData(pendingActionResult) {
    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
      // This is cast to `any` currently because `RouteData`uses any and it
      // would be a breaking change to use any.
      // TODO: v7 - change `RouteData` to use `unknown` instead of `any`
      return {
        [pendingActionResult[0]]: pendingActionResult[1].data
      };
    } else if (state.actionData) {
      if (Object.keys(state.actionData).length === 0) {
        return null;
      } else {
        return state.actionData;
      }
    }
  }
  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
    revalidatingFetchers.forEach(rf => {
      let fetcher = state.fetchers.get(rf.key);
      let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);
      state.fetchers.set(rf.key, revalidatingFetcher);
    });
    return new Map(state.fetchers);
  }
  // Trigger a fetcher load/submit for the given fetcher key
  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key)) abortFetcher(key);
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync
      });
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, fogOfWar.active, flushSync, submission);
      return;
    }
    // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match, matches, fogOfWar.active, flushSync, submission);
  }
  // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation
  async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    function detectAndHandle405Error(m) {
      if (!m.route.action && !m.route.lazy) {
        let error = getInternalRouterError(405, {
          method: submission.formMethod,
          pathname: path,
          routeId: routeId
        });
        setFetcherError(key, routeId, error, {
          flushSync
        });
        return true;
      }
      return false;
    }
    if (!isFogOfWar && detectAndHandle405Error(match)) {
      return;
    }
    // Put this fetcher into it's submitting state
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(requestMatches, path, fetchRequest.signal);
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        let {
          error
        } = handleDiscoverRouteError(path, discoverResult);
        setFetcherError(key, routeId, error, {
          flushSync
        });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync
        });
        return;
      } else {
        requestMatches = discoverResult.matches;
        match = getTargetMatch(requestMatches, path);
        if (detectAndHandle405Error(match)) {
          return;
        }
      }
    }
    // Call the action for the fetcher
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResults = await callDataStrategy("action", fetchRequest, [match], requestMatches);
    let actionResult = actionResults[0];
    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI
    // or redirects processed for unmounted fetchers so we just revert them to
    // idle
    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(undefined));
        return;
      }
      // Let SuccessResult's fall through for revalidation
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          // A new navigation was kicked off after our action started, so that
          // should take precedence over this redirect navigation.  We already
          // set isRevalidationRequired so all loaders for the new route should
          // fire unless opted out via shouldRevalidate
          updateFetcherState(key, getDoneFetcher(undefined));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(fetchRequest, actionResult, {
            fetcherSubmission: submission
          });
        }
      }
      // Process any non-redirect errors thrown
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);
    // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data
    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);
      state.fetchers.set(staleKey, revalidatingFetcher);
      if (fetchControllers.has(staleKey)) {
        abortFetcher(staleKey);
      }
      if (rf.controller) {
        fetchControllers.set(staleKey, rf.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect = findRedirect([...loaderResults, ...fetcherResults]);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        // If this redirect came from a fetcher make sure we mark it in
        // fetchRedirectIds so it doesn't get revalidated on the next set of
        // loader executions
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      return startRedirectNavigation(revalidationRequest, redirect.result);
    }
    // Process and commit output from loaders
    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
    // Since we let revalidations complete even if the submitting fetcher was
    // deleted, only put it back to idle if it hasn't been deleted
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.
  async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches, path, fetchRequest.signal);
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        let {
          error
        } = handleDiscoverRouteError(path, discoverResult);
        setFetcherError(key, routeId, error, {
          flushSync
        });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync
        });
        return;
      } else {
        matches = discoverResult.matches;
        match = getTargetMatch(matches, path);
      }
    }
    // Call the loader for this fetcher route match
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let results = await callDataStrategy("loader", fetchRequest, [match], matches);
    let result = results[0];
    // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens
    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    }
    // We can delete this so long as we weren't aborted by our our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    // We don't want errors bubbling up or redirects followed for unmounted
    // fetchers, so short circuit here if it was removed from the UI
    if (deletedFetchers.has(key)) {
      updateFetcherState(key, getDoneFetcher(undefined));
      return;
    }
    // If the loader threw a redirect Response, start a new REPLACE navigation
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        // A new navigation was kicked off after our loader started, so that
        // should take precedence over this redirect navigation
        updateFetcherState(key, getDoneFetcher(undefined));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(fetchRequest, result);
        return;
      }
    }
    // Process any non-redirect errors thrown
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
    // Put the fetcher back into an idle state
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */
  async function startRedirectNavigation(request, redirect, _temp2) {
    let {
      submission,
      fetcherSubmission,
      replace
    } = _temp2 === void 0 ? {} : _temp2;
    if (redirect.response.headers.has("X-Remix-Revalidate")) {
      isRevalidationRequired = true;
    }
    let location = redirect.response.headers.get("Location");
    invariant(location, "Expected a Location header on the redirect Response");
    location = normalizeRedirectLocation(location, new URL(request.url), basename);
    let redirectLocation = createLocation(state.location, location, {
      _isRedirect: true
    });
    if (isBrowser) {
      let isDocumentReload = false;
      if (redirect.response.headers.has("X-Remix-Reload-Document")) {
        // Hard reload if the response contained X-Remix-Reload-Document
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(location)) {
        const url = init.history.createURL(location);
        isDocumentReload =
        // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin ||
        // Hard reload if it's an absolute URL that does not match our basename
        router_stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace) {
          routerWindow.location.replace(location);
        } else {
          routerWindow.location.assign(location);
        }
        return;
      }
    }
    // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled
    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;
    // Use the incoming submission if provided, fallback on the active one in
    // state.navigation
    let {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, activeSubmission, {
          formAction: location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      // If we have a navigation submission, we will preserve it through the
      // redirect navigation
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  // Utility wrapper for calling dataStrategy client-side without having to
  // pass around the manifest, mapRouteProperties, etc.
  async function callDataStrategy(type, request, matchesToLoad, matches) {
    try {
      let results = await callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, manifest, mapRouteProperties);
      return await Promise.all(results.map((result, i) => {
        if (isRedirectHandlerResult(result)) {
          let response = result.result;
          return {
            type: ResultType.redirect,
            response: normalizeRelativeRoutingRedirectResponse(response, request, matchesToLoad[i].route.id, matches, basename, future.v7_relativeSplatPath)
          };
        }
        return convertHandlerResultToDataResult(result);
      }));
    } catch (e) {
      // If the outer dataStrategy method throws, just return the error for all
      // matches - and it'll naturally bubble to the root
      return matchesToLoad.map(() => ({
        type: ResultType.error,
        error: e
      }));
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    let [loaderResults, ...fetcherResults] = await Promise.all([matchesToLoad.length ? callDataStrategy("loader", request, matchesToLoad, matches) : [], ...fetchersToLoad.map(f => {
      if (f.matches && f.match && f.controller) {
        let fetcherRequest = createClientSideRequest(init.history, f.path, f.controller.signal);
        return callDataStrategy("loader", fetcherRequest, [f.match], f.matches).then(r => r[0]);
      } else {
        return Promise.resolve({
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f.path
          })
        });
      }
    })]);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);
    return {
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true;
    // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    // Abort in-flight fetcher loads
    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function updateFetcherState(key, fetcher, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function setFetcherError(key, routeId, error, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function getFetcher(key) {
    if (future.v7_fetcherPersist) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      // If this fetcher was previously marked for deletion, unmark it since we
      // have a new instance
      if (deletedFetchers.has(key)) {
        deletedFetchers.delete(key);
      }
    }
    return state.fetchers.get(key) || router_IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    // Don't abort the controller if this is a deletion of a fetcher.submit()
    // in it's loading phase since - we don't want to abort the corresponding
    // revalidation and want them to complete and land
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    deletedFetchers.delete(key);
    state.fetchers.delete(key);
  }
  function deleteFetcherAndUpdateState(key) {
    if (future.v7_fetcherPersist) {
      let count = (activeFetchers.get(key) || 0) - 1;
      if (count <= 0) {
        activeFetchers.delete(key);
        deletedFetchers.add(key);
      } else {
        activeFetchers.set(key, count);
      }
    } else {
      deleteFetcher(key);
    }
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || router_IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  // Utility function to update blockers, ensuring valid state transitions
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || router_IDLE_BLOCKER;
    // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref4) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref4;
    if (blockerFunctions.size === 0) {
      return;
    }
    // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
    }
    // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function handleNavigational404(pathname) {
    let error = getInternalRouterError(404, {
      pathname
    });
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let {
      matches,
      route
    } = getShortCircuitMatches(routesToUse);
    // Cancel all pending deferred on 404s since we don't keep any routes
    cancelActiveDeferreds();
    return {
      notFoundMatches: matches,
      route,
      error
    };
  }
  function handleDiscoverRouteError(pathname, discoverResult) {
    return {
      boundaryId: findNearestBoundary(discoverResult.partialMatches).route.id,
      error: getInternalRouterError(400, {
        type: "route-discovery",
        pathname,
        message: discoverResult.error != null && "message" in discoverResult.error ? discoverResult.error : String(discoverResult.error)
      })
    };
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || null;
    // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions) {
      let key = getScrollKey(location, matches);
      let y = savedScrollPositions[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function checkFogOfWar(matches, routesToUse, pathname) {
    if (patchRoutesOnMissImpl) {
      if (!matches) {
        let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
        return {
          active: true,
          matches: fogMatches || []
        };
      } else {
        let leafRoute = matches[matches.length - 1].route;
        if (leafRoute.path && (leafRoute.path === "*" || leafRoute.path.endsWith("/*"))) {
          // If we matched a splat, it might only be because we haven't yet fetched
          // the children that would match with a higher score, so let's fetch
          // around and find out
          let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
          return {
            active: true,
            matches: partialMatches
          };
        }
      }
    }
    return {
      active: false,
      matches: null
    };
  }
  async function discoverRoutes(matches, pathname, signal) {
    let partialMatches = matches;
    let route = partialMatches.length > 0 ? partialMatches[partialMatches.length - 1].route : null;
    while (true) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      try {
        await loadLazyRouteChildren(patchRoutesOnMissImpl, pathname, partialMatches, routesToUse, manifest, mapRouteProperties, pendingPatchRoutes, signal);
      } catch (e) {
        return {
          type: "error",
          error: e,
          partialMatches
        };
      } finally {
        // If we are not in the middle of an HMR revalidation and we changed the
        // routes, provide a new identity so when we `updateState` at the end of
        // this navigation/fetch `router.routes` will be a new identity and
        // trigger a re-run of memoized `router.routes` dependencies.
        // HMR will already update the identity and reflow when it lands
        // `inFlightDataRoutes` in `completeNavigation`
        if (isNonHMR) {
          dataRoutes = [...dataRoutes];
        }
      }
      if (signal.aborted) {
        return {
          type: "aborted"
        };
      }
      let newMatches = matchRoutes(routesToUse, pathname, basename);
      let matchedSplat = false;
      if (newMatches) {
        let leafRoute = newMatches[newMatches.length - 1].route;
        if (leafRoute.index) {
          // If we found an index route, we can stop
          return {
            type: "success",
            matches: newMatches
          };
        }
        if (leafRoute.path && leafRoute.path.length > 0) {
          if (leafRoute.path === "*") {
            // If we found a splat route, we can't be sure there's not a
            // higher-scoring route down some partial matches trail so we need
            // to check that out
            matchedSplat = true;
          } else {
            // If we found a non-splat route, we can stop
            return {
              type: "success",
              matches: newMatches
            };
          }
        }
      }
      let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
      // If we are no longer partially matching anything, this was either a
      // legit splat match above, or it's a 404.  Also avoid loops if the
      // second pass results in the same partial matches
      if (!newPartialMatches || partialMatches.map(m => m.route.id).join("-") === newPartialMatches.map(m => m.route.id).join("-")) {
        return {
          type: "success",
          matches: matchedSplat ? newMatches : null
        };
      }
      partialMatches = newPartialMatches;
      route = partialMatches[partialMatches.length - 1].route;
      if (route.path === "*") {
        // The splat is still our most accurate partial, so run with it
        return {
          type: "success",
          matches: partialMatches
        };
      }
    }
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);
  }
  function patchRoutes(routeId, children) {
    let isNonHMR = inFlightDataRoutes == null;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties);
    // If we are not in the middle of an HMR revalidation and we changed the
    // routes, provide a new identity and trigger a reflow via `updateState`
    // to re-run memoized `router.routes` dependencies.
    // HMR will already update the identity and reflow when it lands
    // `inFlightDataRoutes` in `completeNavigation`
    if (isNonHMR) {
      dataRoutes = [...dataRoutes];
      updateState({});
    }
  }
  router = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: deleteFetcherAndUpdateState,
    dispose,
    getBlocker,
    deleteBlocker,
    patchRoutes,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////
const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {};
  let basename = (opts ? opts.basename : null) || "/";
  let mapRouteProperties;
  if (opts != null && opts.mapRouteProperties) {
    mapRouteProperties = opts.mapRouteProperties;
  } else if (opts != null && opts.detectErrorBoundary) {
    // If they are still using the deprecated version, wrap it with the new API
    let detectErrorBoundary = opts.detectErrorBoundary;
    mapRouteProperties = route => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties = defaultMapRouteProperties;
  }
  // Config driven behavior flags
  let future = _extends({
    v7_relativeSplatPath: false,
    v7_throwAbortReason: false
  }, opts ? opts.future : null);
  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);
  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   *
   * - `opts.requestContext` is an optional server context that will be passed
   *   to actions/loaders in the `context` parameter
   * - `opts.skipLoaderErrorBubbling` is an optional parameter that will prevent
   *   the bubbling of errors which allows single-fetch-type implementations
   *   where the client will handle the bubbling and we may need to return data
   *   for the handling route
   */
  async function query(request, _temp3) {
    let {
      requestContext,
      skipLoaderErrorBubbling,
      unstable_dataStrategy
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", router_createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request, location, matches, requestContext, unstable_dataStrategy || null, skipLoaderErrorBubbling === true, null);
    if (isResponse(result)) {
      return result;
    }
    // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location
    return _extends({
      location,
      basename
    }, result);
  }
  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   *
   * - `opts.routeId` allows you to specify the specific route handler to call.
   *   If not provided the handler will determine the proper route by matching
   *   against `request.url`
   * - `opts.requestContext` is an optional server context that will be passed
   *    to actions/loaders in the `context` parameter
   */
  async function queryRoute(request, _temp4) {
    let {
      routeId,
      requestContext,
      unstable_dataStrategy
    } = _temp4 === void 0 ? {} : _temp4;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", router_createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let result = await queryImpl(request, location, matches, requestContext, unstable_dataStrategy || null, false, match);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    }
    // Pick off the right state value to return
    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      var _result$activeDeferre;
      let data = Object.values(result.loaderData)[0];
      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      }
      return data;
    }
    return undefined;
  }
  async function queryImpl(request, location, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch != null);
        return result;
      }
      let result = await loadRouteData(request, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction for a
      // `queryRoute` call, we throw the `HandlerResult` to bail out early
      // and then return or throw the raw Response here accordingly
      if (isHandlerResult(e) && isResponse(e.result)) {
        if (e.type === ResultType.error) {
          throw e.result;
        }
        return e.result;
      }
      // Redirects are always returned since they don't propagate to catch
      // boundaries
      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    } else {
      let results = await callDataStrategy("action", request, [actionMatch], matches, isRouteRequest, requestContext, unstable_dataStrategy);
      result = results[0];
      if (request.signal.aborted) {
        throwStaticHandlerAbortedError(request, isRouteRequest, future);
      }
    }
    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.response.status,
        headers: {
          Location: result.response.headers.get("Location")
        }
      });
    }
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    // Create a GET request for the loaders
    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(loaderRequest, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, null, [boundaryMatch.route.id, result]);
      // action status codes take precedence over loader status codes
      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    }
    let context = await loadRouteData(loaderRequest, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, null);
    return _extends({}, context, {
      actionData: {
        [actionMatch.route.id]: result.data
      }
    }, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionHeaders: result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {}
    });
  }
  async function loadRouteData(request, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {
    let isRouteRequest = routeMatch != null;
    // Short circuit if we have no loaders to run (queryRoute())
    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;
    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);
    // Short circuit if we have no loaders to run (query())
    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    }
    let results = await callDataStrategy("loader", request, matchesToLoad, matches, isRouteRequest, requestContext, unstable_dataStrategy);
    if (request.signal.aborted) {
      throwStaticHandlerAbortedError(request, isRouteRequest, future);
    }
    // Process and commit output from loaders
    let activeDeferreds = new Map();
    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling);
    // Add a null for any non-loader matches for proper revalidation on the client
    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  // Utility wrapper for calling dataStrategy server-side without having to
  // pass around the manifest, mapRouteProperties, etc.
  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, unstable_dataStrategy) {
    let results = await callDataStrategyImpl(unstable_dataStrategy || defaultDataStrategy, type, request, matchesToLoad, matches, manifest, mapRouteProperties, requestContext);
    return await Promise.all(results.map((result, i) => {
      if (isRedirectHandlerResult(result)) {
        let response = result.result;
        // Throw redirects and let the server handle them with an HTTP redirect
        throw normalizeRelativeRoutingRedirectResponse(response, request, matchesToLoad[i].route.id, matches, basename, future.v7_relativeSplatPath);
      }
      if (isResponse(result.result) && isRouteRequest) {
        // For SSR single-route requests, we want to hand Responses back
        // directly without unwrapping
        throw result;
      }
      return convertHandlerResultToDataResult(result);
    }));
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////
/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */
function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: isRouteErrorResponse(error) ? error.status : 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });
  return newContext;
}
function throwStaticHandlerAbortedError(request, isRouteRequest, future) {
  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {
    throw request.signal.reason;
  }
  let method = isRouteRequest ? "queryRoute" : "query";
  throw new Error(method + "() call aborted: " + request.method + " " + request.url);
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== undefined);
}
function normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    // Grab matches up to the calling route so our route-relative logic is
    // relative to the correct source route
    contextualMatches = [];
    for (let match of matches) {
      contextualMatches.push(match);
      if (match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  // Resolve the relative path
  let path = router_resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), router_stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  // When `to` is not specified we inherit search/hash from the current
  // location, unlike when to="." and we just inherit the path.
  // See https://github.com/remix-run/remix/issues/927
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  // Add an ?index param for matched index routes if we don't already have one
  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  // If we're operating within a basename, prepend it to the pathname.  If
  // this is a root navigation, then just use the raw basename which allows
  // the basename to have full control over the presence of a trailing slash
  // on root actions
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : router_joinPaths([basename, path.pathname]);
  }
  return router_createPath(path);
}
// Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  // Return location verbatim on non-submission navigations
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });
  // Create a Submission on non-GET navigations
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== undefined) {
    if (opts.formEncType === "text/plain") {
      // text only support POST/PUT/PATCH/DELETE submissions
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?
      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
      Array.from(opts.body.entries()).reduce((acc, _ref5) => {
        let [name, value] = _ref5;
        return "" + acc + name + "=" + value + "\n";
      }, "") : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: undefined,
          json: undefined,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      // json only supports POST/PUT/PATCH/DELETE submissions
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: undefined,
            json,
            text: undefined
          }
        };
      } catch (e) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: undefined,
    text: undefined
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  // Flatten submission onto URLSearchParams for GET submissions
  let parsedPath = parsePath(path);
  // On GET navigation submissions we can drop the ?index param from the
  // resulting location since all loaders will run.  But fetcher GET submissions
  // only run a single loader so we need to preserve any incoming ?index params
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: router_createPath(parsedPath),
    submission
  };
}
// Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);
    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : undefined;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  // Pick navigation matches that are net-new or qualify for revalidation
  let boundaryId = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[0] : undefined;
  let boundaryMatches = boundaryId ? getLoaderMatchesUntilBoundary(matches, boundaryId) : matches;
  // Don't revalidate loaders by default after action 4xx/5xx responses
  // when the flag is enabled.  They can still opt-into revalidation via
  // `shouldRevalidate` via `actionResult`
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : undefined;
  let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;
  let navigationMatches = boundaryMatches.filter((match, index) => {
    let {
      route
    } = match;
    if (route.lazy) {
      // We haven't loaded this route yet so we don't know if it's got a loader!
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (isInitialLoad) {
      if (typeof route.loader !== "function" || route.loader.hydrate) {
        return true;
      }
      return state.loaderData[route.id] === undefined && (
      // Don't re-run if the loader ran and threw an error
      !state.errors || state.errors[route.id] === undefined);
    }
    // Always call the loader on new route instances and pending defer cancellations
    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
      return true;
    }
    // This is the default implementation for when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases
    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? false :
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||
      // Search params affect all loaders
      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  });
  // Pick fetcher.loads that need to be revalidated
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    // Don't revalidate:
    //  - on initial load (shouldn't be any fetchers then anyway)
    //  - if fetcher won't be present in the subsequent render
    //    - no longer matches the URL (v7_fetcherPersist=false)
    //    - was unmounted but persisted due to v7_fetcherPersist=true
    if (isInitialLoad || !matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
    // If the fetcher path no longer matches, push it in with null matches so
    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is
    // currently only a use-case for Remix HMR where the route tree can change
    // at runtime and remove a route previously loaded via a fetcher
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    // Revalidating fetchers are decoupled from the route matches since they
    // load from a static href.  They revalidate based on explicit revalidation
    // (submission, useRevalidator, or X-Remix-Revalidate)
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      // Never trigger a revalidation of an actively redirecting fetcher
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.includes(key)) {
      // Always revalidate if the fetcher was cancelled
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === undefined) {
      // If the fetcher hasn't ever completed loading yet, then this isn't a
      // revalidation, it would just be a brand new load if an explicit
      // revalidation is required
      shouldRevalidate = isRevalidationRequired;
    } else {
      // Otherwise fall back on any user-defined shouldRevalidate, defaulting
      // to explicit revalidations only
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id;
  // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred
  let isMissingData = currentLoaderData[match.route.id] === undefined;
  // Always load if this is a net-new route or we don't yet have data
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
/**
 * Idempotent utility to execute patchRoutesOnMiss() to lazily load route
 * definitions and update the routes/routeManifest
 */
async function loadLazyRouteChildren(patchRoutesOnMissImpl, path, matches, routes, manifest, mapRouteProperties, pendingRouteChildren, signal) {
  let key = [path, ...matches.map(m => m.route.id)].join("-");
  try {
    let pending = pendingRouteChildren.get(key);
    if (!pending) {
      pending = patchRoutesOnMissImpl({
        path,
        matches,
        patch: (routeId, children) => {
          if (!signal.aborted) {
            patchRoutesImpl(routeId, children, routes, manifest, mapRouteProperties);
          }
        }
      });
      pendingRouteChildren.set(key, pending);
    }
    if (pending && router_isPromise(pending)) {
      await pending;
    }
  } finally {
    pendingRouteChildren.delete(key);
  }
}
function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties) {
  if (routeId) {
    var _route$children;
    let route = manifest[routeId];
    invariant(route, "No route found to patch children into: routeId = " + routeId);
    let dataChildren = convertRoutesToDataRoutes(children, mapRouteProperties, [routeId, "patch", String(((_route$children = route.children) == null ? void 0 : _route$children.length) || "0")], manifest);
    if (route.children) {
      route.children.push(...dataChildren);
    } else {
      route.children = dataChildren;
    }
  } else {
    let dataChildren = convertRoutesToDataRoutes(children, mapRouteProperties, ["patch", String(routesToUse.length || "0")], manifest);
    routesToUse.push(...dataChildren);
  }
}
/**
 * Execute route.lazy() methods to lazily load route modules (loader, action,
 * shouldRevalidate) and update the routeManifest in place which shares objects
 * with dataRoutes so those get updated as well.
 */
async function loadLazyRouteModule(route, mapRouteProperties, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  // If the lazy route function was executed and removed by another parallel
  // call then we can return - first lazy() to finish wins because the return
  // value of lazy is expected to be static
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  // Update the route in place.  This should be safe because there's no way
  // we could yet be sitting on this route as we can't get there without
  // resolving lazy() first.
  //
  // This is different than the HMR "update" use-case where we may actively be
  // on the route being updated.  The main concern boils down to "does this
  // mutation affect any ongoing navigations or any current state.matches
  // values?".  If not, it should be safe to update in place.
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&
    // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, "Route \"" + routeToUpdate.id + "\" has a static property \"" + lazyRouteProperty + "\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \"" + lazyRouteProperty + "\" will be ignored."));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  // Mutate the route with the provided updates.  Do this first so we pass
  // the updated version to mapRouteProperties
  Object.assign(routeToUpdate, routeUpdates);
  // Mutate the `hasErrorBoundary` property on the route based on the route
  // updates and remove the `lazy` function so we don't resolve the lazy
  // route again.
  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {
    lazy: undefined
  }));
}
// Default implementation of `dataStrategy` which fetches all loaders in parallel
function defaultDataStrategy(opts) {
  return Promise.all(opts.matches.map(m => m.resolve()));
}
async function callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, manifest, mapRouteProperties, requestContext) {
  let routeIdsToLoad = matchesToLoad.reduce((acc, m) => acc.add(m.route.id), new Set());
  let loadedMatches = new Set();
  // Send all matches here to allow for a middleware-type implementation.
  // handler will be a no-op for unneeded routes and we filter those results
  // back out below.
  let results = await dataStrategyImpl({
    matches: matches.map(match => {
      let shouldLoad = routeIdsToLoad.has(match.route.id);
      // `resolve` encapsulates the route.lazy, executing the
      // loader/action, and mapping return values/thrown errors to a
      // HandlerResult.  Users can pass a callback to take fine-grained control
      // over the execution of the loader/action
      let resolve = handlerOverride => {
        loadedMatches.add(match.route.id);
        return shouldLoad ? callLoaderOrAction(type, request, match, manifest, mapRouteProperties, handlerOverride, requestContext) : Promise.resolve({
          type: ResultType.data,
          result: undefined
        });
      };
      return _extends({}, match, {
        shouldLoad,
        resolve
      });
    }),
    request,
    params: matches[0].params,
    context: requestContext
  });
  // Throw if any loadRoute implementations not called since they are what
  // ensures a route is fully loaded
  matches.forEach(m => invariant(loadedMatches.has(m.route.id), "`match.resolve()` was not called for route id \"" + m.route.id + "\". " + "You must call `match.resolve()` on every match passed to " + "`dataStrategy` to ensure all routes are properly loaded."));
  // Filter out any middleware-only matches for which we didn't need to run handlers
  return results.filter((_, i) => routeIdsToLoad.has(matches[i].route.id));
}
// Default logic for calling a loader/action is the user has no specified a dataStrategy
async function callLoaderOrAction(type, request, match, manifest, mapRouteProperties, handlerOverride, staticContext) {
  let result;
  let onReject;
  let runHandler = handler => {
    // Setup a promise we can race against so that abort signals short circuit
    let reject;
    // This will never resolve so safe to type it as Promise<HandlerResult> to
    // satisfy the function return value
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    let actualHandler = ctx => {
      if (typeof handler !== "function") {
        return Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ("\"" + type + "\" [routeId: " + match.route.id + "]")));
      }
      return handler({
        request,
        params: match.params,
        context: staticContext
      }, ...(ctx !== undefined ? [ctx] : []));
    };
    let handlerPromise;
    if (handlerOverride) {
      handlerPromise = handlerOverride(ctx => actualHandler(ctx));
    } else {
      handlerPromise = (async () => {
        try {
          let val = await actualHandler();
          return {
            type: "data",
            result: val
          };
        } catch (e) {
          return {
            type: "error",
            result: e
          };
        }
      })();
    }
    return Promise.race([handlerPromise, abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (match.route.lazy) {
      if (handler) {
        // Run statically defined handler in parallel with lazy()
        let handlerError;
        let [value] = await Promise.all([
        // If the handler throws, don't let it immediately bubble out,
        // since we need to let the lazy() execution finish so we know if this
        // route has a boundary that can handle the error
        runHandler(handler).catch(e => {
          handlerError = e;
        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);
        if (handlerError !== undefined) {
          throw handlerError;
        }
        result = value;
      } else {
        // Load lazy route module, then run any returned handler
        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);
        handler = match.route[type];
        if (handler) {
          // Handler still runs even if we got interrupted to maintain consistency
          // with un-abortable behavior of handler execution on non-lazy or
          // previously-lazy-loaded routes
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match.route.id
          });
        } else {
          // lazy() route has no loader to run.  Short circuit here so we don't
          // hit the invariant below that errors on returning undefined.
          return {
            type: ResultType.data,
            result: undefined
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant(result.result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    // We should already be catching and converting normal handler executions to
    // HandlerResults and returning them, so anything that throws here is an
    // unexpected error we still need to wrap
    return {
      type: ResultType.error,
      result: e
    };
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  return result;
}
async function convertHandlerResultToDataResult(handlerResult) {
  let {
    result,
    type,
    status
  } = handlerResult;
  if (isResponse(result)) {
    let data;
    try {
      let contentType = result.headers.get("Content-Type");
      // Check between word boundaries instead of startsWith() due to the last
      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data = null;
        } else {
          data = await result.json();
        }
      } else {
        data = await result.text();
      }
    } catch (e) {
      return {
        type: ResultType.error,
        error: e
      };
    }
    if (type === ResultType.error) {
      return {
        type: ResultType.error,
        error: new ErrorResponseImpl(result.status, result.statusText, data),
        statusCode: result.status,
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === ResultType.error) {
    return {
      type: ResultType.error,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : status
    };
  }
  if (isDeferredData(result)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result,
    statusCode: status
  };
}
// Support relative routing in internal redirects
function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {
  let location = response.headers.get("Location");
  invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
  if (!ABSOLUTE_URL_REGEX.test(location)) {
    let trimmedMatches = matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1);
    location = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location, v7_relativeSplatPath);
    response.headers.set("Location", location);
  }
  return response;
}
function normalizeRedirectLocation(location, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX.test(location)) {
    // Strip off the protocol+origin for same-origin + same-basename absolute redirects
    let normalizedLocation = location;
    let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
    let isSameBasename = router_stripBasename(url.pathname, basename) != null;
    if (url.origin === currentUrl.origin && isSameBasename) {
      return url.pathname + url.search + url.hash;
    }
  }
  return location;
}
// Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    // Didn't think we needed this but it turns out unlike other methods, patch
    // won't be properly normalized to uppercase and results in a 405 error.
    // See: https://fetch.spec.whatwg.org/#concept-method
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({
        "Content-Type": formEncType
      });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = submission.formData;
    }
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : undefined;
  // Process loader results into state.loaderData/state.errors
  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let error = result.error;
      // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed
      if (pendingError !== undefined) {
        error = pendingError;
        pendingError = undefined;
      }
      errors = errors || {};
      if (skipLoaderErrorBubbling) {
        errors[id] = error;
      } else {
        // Look upwards from the matched route for the closest ancestor error
        // boundary, defaulting to the root match.  Prefer higher error values
        // if lower errors bubble to the same boundary
        let boundaryMatch = findNearestBoundary(matches, id);
        if (errors[boundaryMatch.route.id] == null) {
          errors[boundaryMatch.route.id] = error;
        }
      }
      // Clear our any prior loaderData for the throwing route
      loaderData[id] = undefined;
      // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
        // Error status codes always override success status codes, but if all
        // loaders are successful we take the deepest status code.
        if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      } else {
        loaderData[id] = result.data;
        // Error status codes always override success status codes, but if all
        // loaders are successful we take the deepest status code.
        if (result.statusCode && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      }
    }
  });
  // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route
  if (pendingError !== undefined && pendingActionResult) {
    errors = {
      [pendingActionResult[0]]: pendingError
    };
    loaderData[pendingActionResult[0]] = undefined;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, false // This method is only called client side so we always want to bubble
  );
  // Process results from our revalidating fetchers
  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      match,
      controller
    } = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index];
    // Process fetcher non-redirect errors
    if (controller && controller.signal.aborted) {
      // Nothing to do for aborted fetchers
      continue;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined && match.route.loader) {
      // Preserve existing keys not included in newLoaderData and where a loader
      // wasn't removed by HMR
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }
  return mergedLoaderData;
}
function getActionDataForCommit(pendingActionResult) {
  if (!pendingActionResult) {
    return {};
  }
  return isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  };
}
// Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp5) {
  let {
    pathname,
    routeId,
    method,
    type,
    message
  } = _temp5 === void 0 ? {} : _temp5;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (type === "route-discovery") {
      errorMessage = "Unable to match URL \"" + pathname + "\" - the `unstable_patchRoutesOnMiss()` " + ("function threw the following error:\n" + message);
    } else if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }
  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
}
// Find any returned redirect errors, starting from the lowest match
function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return {
        result,
        idx: i
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return router_createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  if (a.pathname !== b.pathname || a.search !== b.search) {
    return false;
  }
  if (a.hash === "") {
    // /page -> /page#hash
    return b.hash !== "";
  } else if (a.hash === b.hash) {
    // /page#hash -> /page#hash
    return true;
  } else if (b.hash !== "") {
    // /page#hash -> /page#other
    return true;
  }
  // If the hash is removed the browser will re-perform a request to the server
  // /page#hash -> /page
  return false;
}
function router_isPromise(val) {
  return typeof val === "object" && val != null && "then" in val;
}
function isHandlerResult(result) {
  return result != null && typeof result === "object" && "type" in result && "result" in result && (result.type === ResultType.data || result.type === ResultType.error);
}
function isRedirectHandlerResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }
  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index];
    // If we don't have a match, then we can have a deferred result to do
    // anything with.  This is for revalidating fetchers where the route was
    // removed during HMR
    if (!match) {
      continue;
    }
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      let signal = signals[index];
      invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  }
  // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: undefined,
      json: undefined,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: undefined,
      text: undefined
    };
  } else if (json !== undefined) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: undefined,
      json,
      text: undefined
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      json: undefined,
      text: undefined
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      json: undefined,
      text: undefined,
      data
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : undefined
  };
  return fetcher;
}
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: undefined,
    formAction: undefined,
    formEncType: undefined,
    formData: undefined,
    json: undefined,
    text: undefined,
    data
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k, v] of Object.entries(json || {})) {
        if (v && Array.isArray(v)) {
          transitions.set(k, new Set(v || []));
        }
      }
    }
  } catch (e) {
    // no-op, use default empty object
  }
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k, v] of transitions) {
      json[k] = [...v];
    }
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));
    } catch (error) {
      warning(false, "Failed to save applied view transitions in sessionStorage (" + error + ").");
    }
  }
}
//#endregion


//# sourceMappingURL=router.js.map

;// CONCATENATED MODULE: ./node_modules/.store/react-router@6.25.1/node_modules/react-router/dist/index.js
/**
 * React Router v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */




function dist_extends() {
  dist_extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return dist_extends.apply(this, arguments);
}

// Create react-specific types from the agnostic types in @remix-run/router to
// export from react-router
const DataRouterContext = /*#__PURE__*/react.createContext(null);
if (false) {}
const DataRouterStateContext = /*#__PURE__*/react.createContext(null);
if (false) {}
const AwaitContext = /*#__PURE__*/react.createContext(null);
if (false) {}

/**
 * A Navigator is a "location changer"; it's how you get to different locations.
 *
 * Every history instance conforms to the Navigator interface, but the
 * distinction is useful primarily when it comes to the low-level `<Router>` API
 * where both the location and a navigator must be provided separately in order
 * to avoid "tearing" that may occur in a suspense-enabled app if the action
 * and/or location were to be read directly from the history instance.
 */

const NavigationContext = /*#__PURE__*/react.createContext(null);
if (false) {}
const LocationContext = /*#__PURE__*/react.createContext(null);
if (false) {}
const RouteContext = /*#__PURE__*/react.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
if (false) {}
const RouteErrorContext = /*#__PURE__*/react.createContext(null);
if (false) {}

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/hooks/use-href
 */
function dist_useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  let {
    basename,
    navigator
  } = React.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = dist_useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;

  // If we're operating within a basename, prepend it to the pathname prior
  // to creating the href.  If this is a root navigation, then just use the raw
  // basename which allows the basename to have full control over the presence
  // of a trailing slash on root links
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}

/**
 * Returns true if this component is a descendant of a `<Router>`.
 *
 * @see https://reactrouter.com/hooks/use-in-router-context
 */
function useInRouterContext() {
  return react.useContext(LocationContext) != null;
}

/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/hooks/use-location
 */
function dist_useLocation() {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  return react.useContext(LocationContext).location;
}

/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/hooks/use-navigation-type
 */
function useNavigationType() {
  return React.useContext(LocationContext).navigationType;
}

/**
 * Returns a PathMatch object if the given pattern matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * `<NavLink>`.
 *
 * @see https://reactrouter.com/hooks/use-match
 */
function useMatch(pattern) {
  !useInRouterContext() ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  let {
    pathname
  } = dist_useLocation();
  return React.useMemo(() => matchPath(pattern, UNSAFE_decodePath(pathname)), [pathname, pattern]);
}

/**
 * The interface for the navigate() function returned from useNavigate().
 */

const navigateEffectWarning = (/* unused pure expression or super */ null && ("You should call navigate() in a React.useEffect(), not when " + "your component is first rendered."));

// Mute warnings for calls to useNavigate in SSR environments
function useIsomorphicLayoutEffect(cb) {
  let isStatic = react.useContext(NavigationContext).static;
  if (!isStatic) {
    // We should be able to get rid of this once react 18.3 is released
    // See: https://github.com/facebook/react/pull/26395
    // eslint-disable-next-line react-hooks/rules-of-hooks
    react.useLayoutEffect(cb);
  }
}

/**
 * Returns an imperative method for changing the location. Used by `<Link>`s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/hooks/use-navigate
 */
function dist_useNavigate() {
  let {
    isDataRoute
  } = react.useContext(RouteContext);
  // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let dataRouterContext = react.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator
  } = react.useContext(NavigationContext);
  let {
    matches
  } = react.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = dist_useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = react.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }
     false ? 0 : void 0;

    // Short circuit here since if this happens on first render the navigate
    // is useless because we haven't wired up our history listener yet
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = router_resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");

    // If we're operating within a basename, prepend it to the pathname prior
    // to handing off to history (but only if we're not in a data router,
    // otherwise it'll prepend the basename inside of the router).
    // If this is a root navigation, then we navigate to the raw basename
    // which allows the basename to have full control over the presence of a
    // trailing slash on root links
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : router_joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
const OutletContext = /*#__PURE__*/react.createContext(null);

/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/hooks/use-outlet-context
 */
function useOutletContext() {
  return React.useContext(OutletContext);
}

/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by `<Outlet>` to render child routes.
 *
 * @see https://reactrouter.com/hooks/use-outlet
 */
function useOutlet(context) {
  let outlet = react.useContext(RouteContext).outlet;
  if (outlet) {
    return /*#__PURE__*/react.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}

/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/hooks/use-params
 */
function useParams() {
  let {
    matches
  } = React.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}

/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/hooks/use-resolved-path
 */
function dist_useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = React.useContext(NavigationContext);
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = dist_useLocation();
  let routePathnamesJson = JSON.stringify(UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));
  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}

/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an `<Outlet>` to render their child route's
 * element.
 *
 * @see https://reactrouter.com/hooks/use-routes
 */
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}

// Internal implementation with accept optional param for RouterProvider usage
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    navigator
  } = react.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = react.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (false) {}
  let locationFromContext = dist_useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  false ? 0 : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    // Determine the remaining pathname by removing the # of URL segments the
    // parentPathnameBase has, instead of removing based on character count.
    // This is because we can't guarantee that incoming/outgoing encodings/
    // decodings will match exactly.
    // We decode paths before matching on a per-segment basis with
    // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they
    // match what `window.location.pathname` would reflect.  Those don't 100%
    // align when it comes to encoded URI characters such as % and &.
    //
    // So we may end up with:
    //   pathname:           "/descendant/a%25b/match"
    //   parentPathnameBase: "/descendant/a%b"
    //
    // And the direct substring removal approach won't work :/
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  if (false) {}
  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: router_joinPaths([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : router_joinPaths([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
  })), parentMatches, dataRouterState, future);

  // When a user passes in a `locationArg`, the associated routes need to
  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`
  // to use the scoped location instead of the global location.
  if (locationArg && renderedMatches) {
    return /*#__PURE__*/react.createElement(LocationContext.Provider, {
      value: {
        location: dist_extends({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (false) {}
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("h2", null, "Unexpected Application Error!"), /*#__PURE__*/react.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /*#__PURE__*/react.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /*#__PURE__*/react.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends react.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error: error
    };
  }
  static getDerivedStateFromProps(props, state) {
    // When we get into an error state, the user will likely click "back" to the
    // previous page that didn't have an error. Because this wraps the entire
    // application, that will have no effect--the error page continues to display.
    // This gives us a mechanism to recover from the error when the location changes.
    //
    // Whether we're in an error state or not, we update the location in state
    // so that when we are in an error state, it gets reset when a new location
    // comes in and the user recovers from the error.
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }

    // If we're not changing locations, preserve the location but still surface
    // any new errors that may come through. We retain the existing error, we do
    // this because the error provided from the app state may be cleared without
    // the location changing.
    return {
      error: props.error !== undefined ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== undefined ? /*#__PURE__*/react.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /*#__PURE__*/react.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = react.useContext(DataRouterContext);

  // Track how deep we got in our render pass to emulate SSR componentDidCatch
  // in a DataStaticRouter
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /*#__PURE__*/react.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      // Don't bail if we have data router errors so we can render them in the
      // boundary.  Use the pre-matched (or shimmed) matches
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;

  // If we have data errors, trim matches to the highest error boundary
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== undefined);
    !(errorIndex >= 0) ?  false ? 0 : invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }

  // If we're in a partial hydration mode, detect if we need to render down to
  // a given HydrateFallback while we load the rest of the hydration data
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      // Track the deepest fallback up until the first route without data
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);
        if (match.route.lazy || needsToRunLoader) {
          // We found the first route that's not ready to render (waiting on
          // lazy, or has a loader that hasn't run yet).  Flag that we need to
          // render a fallback and render up until the appropriate fallback
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    // Only data routers handle errors/fallbacks
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : undefined;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        // Note: This is a de-optimized path since React won't re-use the
        // ReactElement since it's identity changes with each new
        // React.createElement call.  We keep this so folks can use
        // `<Route Component={...}>` in `<Routes>` but generally `Component`
        // usage is only advised in `RouterProvider` when we can convert it to
        // `element` ahead of time.
        children = /*#__PURE__*/react.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /*#__PURE__*/react.createElement(RenderedRoute, {
        match: match,
        routeContext: {
          outlet,
          matches,
          isDataRoute: dataRouterState != null
        },
        children: children
      });
    };
    // Only wrap in an error boundary within data router usages when we have an
    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to
    // an ancestor ErrorBoundary/errorElement
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/react.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error: error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {
  DataRouterHook["UseBlocker"] = "useBlocker";
  DataRouterHook["UseRevalidator"] = "useRevalidator";
  DataRouterHook["UseNavigateStable"] = "useNavigate";
  return DataRouterHook;
}(DataRouterHook || {});
var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {
  DataRouterStateHook["UseBlocker"] = "useBlocker";
  DataRouterStateHook["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook["UseActionData"] = "useActionData";
  DataRouterStateHook["UseRouteError"] = "useRouteError";
  DataRouterStateHook["UseNavigation"] = "useNavigation";
  DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook["UseMatches"] = "useMatches";
  DataRouterStateHook["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook["UseRouteId"] = "useRouteId";
  return DataRouterStateHook;
}(DataRouterStateHook || {});
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = react.useContext(DataRouterContext);
  !ctx ?  false ? 0 : invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react.useContext(DataRouterStateContext);
  !state ?  false ? 0 : invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = react.useContext(RouteContext);
  !route ?  false ? 0 : invariant(false) : void 0;
  return route;
}

// Internal version with hookName-aware debugging
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ?  false ? 0 : invariant(false) : void 0;
  return thisRoute.route.id;
}

/**
 * Returns the ID for the nearest contextual route
 */
function useRouteId() {
  return useCurrentRouteId(DataRouterStateHook.UseRouteId);
}

/**
 * Returns the current navigation, defaulting to an "idle" navigation when
 * no navigation is in progress
 */
function dist_useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}

/**
 * Returns a revalidate function for manually triggering revalidation, as well
 * as the current state of any manual revalidations
 */
function useRevalidator() {
  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);
  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);
  return React.useMemo(() => ({
    revalidate: dataRouterContext.router.revalidate,
    state: state.revalidation
  }), [dataRouterContext.router.revalidate, state.revalidation]);
}

/**
 * Returns the active route matches, useful for accessing loaderData for
 * parent/child routes or the route "handle" property
 */
function dist_useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return React.useMemo(() => matches.map(m => UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);
}

/**
 * Returns the loader data for the nearest ancestor Route loader
 */
function useLoaderData() {
  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  if (state.errors && state.errors[routeId] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
    return undefined;
  }
  return state.loaderData[routeId];
}

/**
 * Returns the loaderData for the given routeId
 */
function useRouteLoaderData(routeId) {
  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);
  return state.loaderData[routeId];
}

/**
 * Returns the action data for the nearest ancestor Route action
 */
function useActionData() {
  let state = useDataRouterState(DataRouterStateHook.UseActionData);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  return state.actionData ? state.actionData[routeId] : undefined;
}

/**
 * Returns the nearest ancestor Route error, which could be a loader/action
 * error or a render error.  This is intended to be called from your
 * ErrorBoundary/errorElement to display a proper error message.
 */
function useRouteError() {
  var _state$errors;
  let error = react.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);

  // If this was a render error, we put it in a RouteError context inside
  // of RenderErrorBoundary
  if (error !== undefined) {
    return error;
  }

  // Otherwise look for errors from our data router state
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}

/**
 * Returns the happy-path data from the nearest ancestor `<Await />` value
 */
function useAsyncValue() {
  let value = React.useContext(AwaitContext);
  return value == null ? void 0 : value._data;
}

/**
 * Returns the error from the nearest ancestor `<Await />` value
 */
function useAsyncError() {
  let value = React.useContext(AwaitContext);
  return value == null ? void 0 : value._error;
}
let blockerId = 0;

/**
 * Allow the application to block navigations within the SPA and present the
 * user a confirmation dialog to confirm the navigation.  Mostly used to avoid
 * using half-filled form data.  This does not handle hard-reloads or
 * cross-origin navigations.
 */
function dist_useBlocker(shouldBlock) {
  let {
    router,
    basename
  } = useDataRouterContext(DataRouterHook.UseBlocker);
  let state = useDataRouterState(DataRouterStateHook.UseBlocker);
  let [blockerKey, setBlockerKey] = React.useState("");
  let blockerFunction = React.useCallback(arg => {
    if (typeof shouldBlock !== "function") {
      return !!shouldBlock;
    }
    if (basename === "/") {
      return shouldBlock(arg);
    }

    // If they provided us a function and we've got an active basename, strip
    // it from the locations we expose to the user to match the behavior of
    // useLocation
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = arg;
    return shouldBlock({
      currentLocation: dist_extends({}, currentLocation, {
        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
      }),
      nextLocation: dist_extends({}, nextLocation, {
        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
      }),
      historyAction
    });
  }, [basename, shouldBlock]);

  // This effect is in charge of blocker key assignment and deletion (which is
  // tightly coupled to the key)
  React.useEffect(() => {
    let key = String(++blockerId);
    setBlockerKey(key);
    return () => router.deleteBlocker(key);
  }, [router]);

  // This effect handles assigning the blockerFunction.  This is to handle
  // unstable blocker function identities, and happens only after the prior
  // effect so we don't get an orphaned blockerFunction in the router with a
  // key of "".  Until then we just have the IDLE_BLOCKER.
  React.useEffect(() => {
    if (blockerKey !== "") {
      router.getBlocker(blockerKey, blockerFunction);
    }
  }, [router, blockerKey, blockerFunction]);

  // Prefer the blocker from `state` not `router.state` since DataRouterContext
  // is memoized so this ensures we update on blocker state updates
  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;
}

/**
 * Stable version of useNavigate that is used when we are in the context of
 * a RouterProvider.
 */
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseNavigateStable);
  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);
  let activeRef = react.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }
     false ? 0 : void 0;

    // Short circuit here since if this happens on first render the navigate
    // is useless because we haven't wired up our router subscriber yet
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, dist_extends({
        fromRouteId: id
      }, options));
    }
  }, [router, id]);
  return navigate;
}
const alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     false ? 0 : void 0;
  }
}

/**
  Webpack + React 17 fails to compile on any of the following because webpack
  complains that `startTransition` doesn't exist in `React`:
  * import { startTransition } from "react"
  * import * as React from from "react";
    "startTransition" in React ? React.startTransition(() => setState()) : setState()
  * import * as React from from "react";
    "startTransition" in React ? React["startTransition"](() => setState()) : setState()

  Moving it to a constant such as the following solves the Webpack/React 17 issue:
  * import * as React from from "react";
    const START_TRANSITION = "startTransition";
    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()

  However, that introduces webpack/terser minification issues in production builds
  in React 18 where minification/obfuscation ends up removing the call of
  React.startTransition entirely from the first half of the ternary.  Grabbing
  this exported reference once up front resolves that issue.

  See https://github.com/remix-run/react-router/issues/10579
*/
const START_TRANSITION = "startTransition";
const startTransitionImpl = react_namespaceObject[START_TRANSITION];

/**
 * Given a Remix Router instance, render the appropriate UI
 */
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router,
    future
  } = _ref;
  let [state, setStateImpl] = React.useState(router.state);
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    if (v7_startTransition && startTransitionImpl) {
      startTransitionImpl(() => setStateImpl(newState));
    } else {
      setStateImpl(newState);
    }
  }, [setStateImpl, v7_startTransition]);

  // Need to use a layout effect here so we are subscribed early enough to
  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)
  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  React.useEffect(() => {
     false ? 0 : void 0;
    // Only log this once on initial mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  let navigator = React.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state, opts) => router.navigate(to, {
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state, opts) => router.navigate(to, {
        replace: true,
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = React.useMemo(() => ({
    router,
    navigator,
    static: false,
    basename
  }), [router, navigator, basename]);

  // The fragment and {null} here are important!  We need them to keep React 18's
  // useId happy when we are server-rendering since we may have a <script> here
  // containing the hydrated server-side staticContext (from StaticRouterProvider).
  // useId relies on the component tree structure to generate deterministic id's
  // so we need to ensure it remains the same on the client even though
  // we don't need the <script> tag
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /*#__PURE__*/React.createElement(dist_Router, {
    basename: basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator,
    future: {
      v7_relativeSplatPath: router.future.v7_relativeSplatPath
    }
  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/React.createElement(DataRoutes, {
    routes: router.routes,
    future: router.future,
    state: state
  }) : fallbackElement))), null);
}
function DataRoutes(_ref2) {
  let {
    routes,
    future,
    state
  } = _ref2;
  return useRoutesImpl(routes, undefined, state, future);
}
/**
 * A `<Router>` that stores all entries in memory.
 *
 * @see https://reactrouter.com/router-components/memory-router
 */
function MemoryRouter(_ref3) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex,
    future
  } = _ref3;
  let historyRef = React.useRef();
  if (historyRef.current == null) {
    historyRef.current = createMemoryHistory({
      initialEntries,
      initialIndex,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = React.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /*#__PURE__*/React.createElement(dist_Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future
  });
}
/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/components/navigate
 */
function Navigate(_ref4) {
  let {
    to,
    replace,
    state,
    relative
  } = _ref4;
  !useInRouterContext() ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  let {
    future,
    static: isStatic
  } = React.useContext(NavigationContext);
   false ? 0 : void 0;
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = dist_useLocation();
  let navigate = dist_useNavigate();

  // Resolve the path outside of the effect so that when effects run twice in
  // StrictMode they navigate to the same place
  let path = resolveTo(to, UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  React.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace,
    state,
    relative
  }), [navigate, jsonPath, relative, replace, state]);
  return null;
}
/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/components/outlet
 */
function Outlet(props) {
  return useOutlet(props.context);
}
/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/components/route
 */
function Route(_props) {
   false ? 0 : UNSAFE_invariant(false) ;
}
/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a `<Router>` directly. Instead, you'll render a
 * router that is more specific to your environment such as a `<BrowserRouter>`
 * in web browsers or a `<StaticRouter>` for server rendering.
 *
 * @see https://reactrouter.com/router-components/router
 */
function dist_Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ?  false ? 0 : invariant(false) : void 0;

  // Preserve trailing slashes on basename, so we can let the user control
  // the enforcement of trailing slashes throughout the app
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react.useMemo(() => ({
    basename,
    navigator,
    static: staticProp,
    future: dist_extends({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = react.useMemo(() => {
    let trailingPathname = router_stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
   false ? 0 : void 0;
  if (locationContext == null) {
    return null;
  }
  return /*#__PURE__*/react.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/react.createElement(LocationContext.Provider, {
    children: children,
    value: locationContext
  }));
}
/**
 * A container for a nested tree of `<Route>` elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/components/routes
 */
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
/**
 * Component to use for rendering lazily loaded data from returning defer()
 * in a loader function
 */
function Await(_ref7) {
  let {
    children,
    errorElement,
    resolve
  } = _ref7;
  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {
    resolve: resolve,
    errorElement: errorElement
  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));
}
var AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {
  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
  return AwaitRenderStatus;
}(AwaitRenderStatus || {});
const neverSettledPromise = new Promise(() => {});
class AwaitErrorBoundary extends react.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("<Await> caught the following error during render", error, errorInfo);
  }
  render() {
    let {
      children,
      errorElement,
      resolve
    } = this.props;
    let promise = null;
    let status = AwaitRenderStatus.pending;
    if (!(resolve instanceof Promise)) {
      // Didn't get a promise - provide as a resolved promise
      status = AwaitRenderStatus.success;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_data", {
        get: () => resolve
      });
    } else if (this.state.error) {
      // Caught a render error, provide it as a rejected promise
      status = AwaitRenderStatus.error;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_error", {
        get: () => renderError
      });
    } else if (resolve._tracked) {
      // Already tracked promise - check contents
      promise = resolve;
      status = "_error" in promise ? AwaitRenderStatus.error : "_data" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending;
    } else {
      // Raw (untracked) promise - track it
      status = AwaitRenderStatus.pending;
      Object.defineProperty(resolve, "_tracked", {
        get: () => true
      });
      promise = resolve.then(data => Object.defineProperty(resolve, "_data", {
        get: () => data
      }), error => Object.defineProperty(resolve, "_error", {
        get: () => error
      }));
    }
    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {
      // Freeze the UI by throwing a never resolved promise
      throw neverSettledPromise;
    }
    if (status === AwaitRenderStatus.error && !errorElement) {
      // No errorElement, throw to the nearest route-level error boundary
      throw promise._error;
    }
    if (status === AwaitRenderStatus.error) {
      // Render via our errorElement
      return /*#__PURE__*/react.createElement(AwaitContext.Provider, {
        value: promise,
        children: errorElement
      });
    }
    if (status === AwaitRenderStatus.success) {
      // Render children with resolved value
      return /*#__PURE__*/react.createElement(AwaitContext.Provider, {
        value: promise,
        children: children
      });
    }

    // Throw to the suspense boundary
    throw promise;
  }
}

/**
 * @private
 * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`
 */
function ResolveAwait(_ref8) {
  let {
    children
  } = _ref8;
  let data = useAsyncValue();
  let toRender = typeof children === "function" ? children(data) : children;
  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);
}

///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/utils/create-routes-from-children
 */
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  React.Children.forEach(children, (element, index) => {
    if (! /*#__PURE__*/React.isValidElement(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === React.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ?  false ? 0 : UNSAFE_invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ?  false ? 0 : UNSAFE_invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}

/**
 * Renders the result of `matchRoutes()` into a React element.
 */
function renderMatches(matches) {
  return _renderMatches(matches);
}

function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    if (false) {}
    Object.assign(updates, {
      element: /*#__PURE__*/react.createElement(route.Component),
      Component: undefined
    });
  }
  if (route.HydrateFallback) {
    if (false) {}
    Object.assign(updates, {
      hydrateFallbackElement: /*#__PURE__*/react.createElement(route.HydrateFallback),
      HydrateFallback: undefined
    });
  }
  if (route.ErrorBoundary) {
    if (false) {}
    Object.assign(updates, {
      errorElement: /*#__PURE__*/react.createElement(route.ErrorBoundary),
      ErrorBoundary: undefined
    });
  }
  return updates;
}
function createMemoryRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: dist_extends({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createMemoryHistory({
      initialEntries: opts == null ? void 0 : opts.initialEntries,
      initialIndex: opts == null ? void 0 : opts.initialIndex
    }),
    hydrationData: opts == null ? void 0 : opts.hydrationData,
    routes,
    mapRouteProperties,
    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,
    unstable_patchRoutesOnMiss: opts == null ? void 0 : opts.unstable_patchRoutesOnMiss
  }).initialize();
}


//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/.store/react-router-dom@6.25.1/node_modules/react-router-dom/dist/index.js
/**
 * React Router DOM v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */







function react_router_dom_dist_extends() {
  react_router_dom_dist_extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return react_router_dom_dist_extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

const defaultMethod = "get";
const defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (
  // Ignore everything but left clicks
  !target || target === "_self") &&
  // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event) // Ignore clicks with modifier keys
  ;
}
/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    // Use `defaultSearchParams.forEach(...)` here instead of iterating of
    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to
    // web extensions. Relevant Bugzilla tickets:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984
    defaultSearchParams.forEach((_, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach(value => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
// One-time check for submitter support
let _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(document.createElement("form"),
      // @ts-expect-error if FormData supports the submitter parameter, this will throw
      0);
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
const supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
     false ? 0 : void 0;
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    // When grabbing the action from the element, it will have had the basename
    // prefixed to ensure non-JS scenarios work, so strip it since we'll
    // re-prefix in the router
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
    }
    // <button>/<input type="submit"> may override attributes of <form>
    // When grabbing the action from the element, it will have had the basename
    // prefixed to ensure non-JS scenarios work, so strip it since we'll
    // re-prefix in the router
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    // Build a FormData object populated from a form and submitter
    formData = new FormData(form, target);
    // If this browser doesn't support the `FormData(el, submitter)` format,
    // then tack on the submitter value at the end.  This is a lightweight
    // solution that is not 100% spec compliant.  For complete support in older
    // browsers, consider using the `formdata-submitter-polyfill` package
    if (!isFormDataSubmitterSupported()) {
      let {
        name,
        type,
        value
      } = target;
      if (type === "image") {
        let prefix = name ? name + "." : "";
        formData.append(prefix + "x", "0");
        formData.append(prefix + "y", "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  // Send body for <Form encType="text/plain" so we encode it into text
  if (formData && encType === "text/plain") {
    body = formData;
    formData = undefined;
  }
  return {
    action,
    method: method.toLowerCase(),
    encType,
    formData,
    body
  };
}

const _excluded = (/* unused pure expression or super */ null && (["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"])),
  _excluded2 = (/* unused pure expression or super */ null && (["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"])),
  _excluded3 = (/* unused pure expression or super */ null && (["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"]));
// HEY YOU! DON'T TOUCH THIS VARIABLE!
//
// It is replaced with the proper version at build time via a babel plugin in
// the rollup config.
//
// Export a global property onto the window for React Router detection by the
// Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`
// to detect and properly classify live websites as being built with React Router:
// https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e) {
  // no-op
}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: react_router_dom_dist_extends({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createBrowserHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes,
    mapRouteProperties: UNSAFE_mapRouteProperties,
    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,
    unstable_patchRoutesOnMiss: opts == null ? void 0 : opts.unstable_patchRoutesOnMiss,
    window: opts == null ? void 0 : opts.window
  }).initialize();
}
function createHashRouter(routes, opts) {
  return router_createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: react_router_dom_dist_extends({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: router_createHashHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes,
    mapRouteProperties: mapRouteProperties,
    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,
    unstable_patchRoutesOnMiss: opts == null ? void 0 : opts.unstable_patchRoutesOnMiss,
    window: opts == null ? void 0 : opts.window
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = react_router_dom_dist_extends({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    // Hey you!  If you change this, please change the corresponding logic in
    // serializeErrors in react-router-dom/server.tsx :)
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            // @ts-expect-error
            let error = new ErrorConstructor(val.message);
            // Wipe away the client-side stack trace.  Nothing to fill it in with
            // because we don't serialize SSR stack traces for security reasons
            error.stack = "";
            serialized[key] = error;
          } catch (e) {
            // no-op - fall through and create a normal Error
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        // Wipe away the client-side stack trace.  Nothing to fill it in with
        // because we don't serialize SSR stack traces for security reasons
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
const ViewTransitionContext = /*#__PURE__*/react.createContext({
  isTransitioning: false
});
if (false) {}
const FetchersContext = /*#__PURE__*/react.createContext(new Map());
if (false) {}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Components
////////////////////////////////////////////////////////////////////////////////
/**
  Webpack + React 17 fails to compile on any of the following because webpack
  complains that `startTransition` doesn't exist in `React`:
  * import { startTransition } from "react"
  * import * as React from from "react";
    "startTransition" in React ? React.startTransition(() => setState()) : setState()
  * import * as React from from "react";
    "startTransition" in React ? React["startTransition"](() => setState()) : setState()

  Moving it to a constant such as the following solves the Webpack/React 17 issue:
  * import * as React from from "react";
    const START_TRANSITION = "startTransition";
    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()

  However, that introduces webpack/terser minification issues in production builds
  in React 18 where minification/obfuscation ends up removing the call of
  React.startTransition entirely from the first half of the ternary.  Grabbing
  this exported reference once up front resolves that issue.

  See https://github.com/remix-run/react-router/issues/10579
*/
const dist_START_TRANSITION = "startTransition";
const dist_startTransitionImpl = react_namespaceObject[dist_START_TRANSITION];
const FLUSH_SYNC = "flushSync";
const flushSyncImpl = react_dom_namespaceObject[FLUSH_SYNC];
const USE_ID = "useId";
const useIdImpl = react_namespaceObject[USE_ID];
function startTransitionSafe(cb) {
  if (dist_startTransitionImpl) {
    dist_startTransitionImpl(cb);
  } else {
    cb();
  }
}
function flushSyncSafe(cb) {
  if (flushSyncImpl) {
    flushSyncImpl(cb);
  } else {
    cb();
  }
}
class Deferred {
  constructor() {
    this.status = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolve = value => {
        if (this.status === "pending") {
          this.status = "resolved";
          resolve(value);
        }
      };
      this.reject = reason => {
        if (this.status === "pending") {
          this.status = "rejected";
          reject(reason);
        }
      };
    });
  }
}
/**
 * Given a Remix Router instance, render the appropriate UI
 */
function dist_RouterProvider(_ref) {
  let {
    fallbackElement,
    router,
    future
  } = _ref;
  let [state, setStateImpl] = react.useState(router.state);
  let [pendingState, setPendingState] = react.useState();
  let [vtContext, setVtContext] = react.useState({
    isTransitioning: false
  });
  let [renderDfd, setRenderDfd] = react.useState();
  let [transition, setTransition] = react.useState();
  let [interruption, setInterruption] = react.useState();
  let fetcherData = react.useRef(new Map());
  let {
    v7_startTransition
  } = future || {};
  let optInStartTransition = react.useCallback(cb => {
    if (v7_startTransition) {
      startTransitionSafe(cb);
    } else {
      cb();
    }
  }, [v7_startTransition]);
  let setState = react.useCallback((newState, _ref2) => {
    let {
      deletedFetchers,
      unstable_flushSync: flushSync,
      unstable_viewTransitionOpts: viewTransitionOpts
    } = _ref2;
    deletedFetchers.forEach(key => fetcherData.current.delete(key));
    newState.fetchers.forEach((fetcher, key) => {
      if (fetcher.data !== undefined) {
        fetcherData.current.set(key, fetcher.data);
      }
    });
    let isViewTransitionUnavailable = router.window == null || router.window.document == null || typeof router.window.document.startViewTransition !== "function";
    // If this isn't a view transition or it's not available in this browser,
    // just update and be done with it
    if (!viewTransitionOpts || isViewTransitionUnavailable) {
      if (flushSync) {
        flushSyncSafe(() => setStateImpl(newState));
      } else {
        optInStartTransition(() => setStateImpl(newState));
      }
      return;
    }
    // flushSync + startViewTransition
    if (flushSync) {
      // Flush through the context to mark DOM elements as transition=ing
      flushSyncSafe(() => {
        // Cancel any pending transitions
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
        }
        setVtContext({
          isTransitioning: true,
          flushSync: true,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      });
      // Update the DOM
      let t = router.window.document.startViewTransition(() => {
        flushSyncSafe(() => setStateImpl(newState));
      });
      // Clean up after the animation completes
      t.finished.finally(() => {
        flushSyncSafe(() => {
          setRenderDfd(undefined);
          setTransition(undefined);
          setPendingState(undefined);
          setVtContext({
            isTransitioning: false
          });
        });
      });
      flushSyncSafe(() => setTransition(t));
      return;
    }
    // startTransition + startViewTransition
    if (transition) {
      // Interrupting an in-progress transition, cancel and let everything flush
      // out, and then kick off a new transition from the interruption state
      renderDfd && renderDfd.resolve();
      transition.skipTransition();
      setInterruption({
        state: newState,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    } else {
      // Completed navigation update with opted-in view transitions, let 'er rip
      setPendingState(newState);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    }
  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);
  // Need to use a layout effect here so we are subscribed early enough to
  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)
  react.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  // When we start a view transition, create a Deferred we can use for the
  // eventual "completed" render
  react.useEffect(() => {
    if (vtContext.isTransitioning && !vtContext.flushSync) {
      setRenderDfd(new Deferred());
    }
  }, [vtContext]);
  // Once the deferred is created, kick off startViewTransition() to update the
  // DOM and then wait on the Deferred to resolve (indicating the DOM update has
  // happened)
  react.useEffect(() => {
    if (renderDfd && pendingState && router.window) {
      let newState = pendingState;
      let renderPromise = renderDfd.promise;
      let transition = router.window.document.startViewTransition(async () => {
        optInStartTransition(() => setStateImpl(newState));
        await renderPromise;
      });
      transition.finished.finally(() => {
        setRenderDfd(undefined);
        setTransition(undefined);
        setPendingState(undefined);
        setVtContext({
          isTransitioning: false
        });
      });
      setTransition(transition);
    }
  }, [optInStartTransition, pendingState, renderDfd, router.window]);
  // When the new location finally renders and is committed to the DOM, this
  // effect will run to resolve the transition
  react.useEffect(() => {
    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
      renderDfd.resolve();
    }
  }, [renderDfd, transition, state.location, pendingState]);
  // If we get interrupted with a new navigation during a transition, we skip
  // the active transition, let it cleanup, then kick it off again here
  react.useEffect(() => {
    if (!vtContext.isTransitioning && interruption) {
      setPendingState(interruption.state);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: interruption.currentLocation,
        nextLocation: interruption.nextLocation
      });
      setInterruption(undefined);
    }
  }, [vtContext.isTransitioning, interruption]);
  react.useEffect(() => {
     false ? 0 : void 0;
    // Only log this once on initial mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  let navigator = react.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state, opts) => router.navigate(to, {
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state, opts) => router.navigate(to, {
        replace: true,
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = react.useMemo(() => ({
    router,
    navigator,
    static: false,
    basename
  }), [router, navigator, basename]);
  let routerFuture = react.useMemo(() => ({
    v7_relativeSplatPath: router.future.v7_relativeSplatPath
  }), [router.future.v7_relativeSplatPath]);
  // The fragment and {null} here are important!  We need them to keep React 18's
  // useId happy when we are server-rendering since we may have a <script> here
  // containing the hydrated server-side staticContext (from StaticRouterProvider).
  // useId relies on the component tree structure to generate deterministic id's
  // so we need to ensure it remains the same on the client even though
  // we don't need the <script> tag
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /*#__PURE__*/react.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /*#__PURE__*/react.createElement(FetchersContext.Provider, {
    value: fetcherData.current
  }, /*#__PURE__*/react.createElement(ViewTransitionContext.Provider, {
    value: vtContext
  }, /*#__PURE__*/react.createElement(dist_Router, {
    basename: basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator,
    future: routerFuture
  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/react.createElement(MemoizedDataRoutes, {
    routes: router.routes,
    future: router.future,
    state: state
  }) : fallbackElement))))), null);
}
// Memoize to avoid re-renders when updating `ViewTransitionContext`
const MemoizedDataRoutes = /*#__PURE__*/react.memo(dist_DataRoutes);
function dist_DataRoutes(_ref3) {
  let {
    routes,
    future,
    state
  } = _ref3;
  return useRoutesImpl(routes, undefined, state, future);
}
/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window
  } = _ref4;
  let historyRef = React.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = React.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    v7_startTransition && dist_startTransitionImpl ? dist_startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /*#__PURE__*/React.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future
  });
}
/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */
function HashRouter(_ref5) {
  let {
    basename,
    children,
    future,
    window
  } = _ref5;
  let historyRef = React.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = React.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    v7_startTransition && dist_startTransitionImpl ? dist_startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /*#__PURE__*/React.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future
  });
}
/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */
function HistoryRouter(_ref6) {
  let {
    basename,
    children,
    future,
    history
  } = _ref6;
  let [state, setStateImpl] = React.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    v7_startTransition && dist_startTransitionImpl ? dist_startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /*#__PURE__*/React.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future
  });
}
if (false) {}
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const dist_ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
/**
 * The public API for rendering a history-aware `<a>`.
 */
const Link = /*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef(function LinkWithRef(_ref7, ref) {
  let {
      onClick,
      relative,
      reloadDocument,
      replace,
      state,
      target,
      to,
      preventScrollReset,
      unstable_viewTransition
    } = _ref7,
    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);
  let {
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  // Rendered into <a href> for absolute URLs
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && dist_ABSOLUTE_URL_REGEX.test(to)) {
    // Render the absolute href server- and client-side
    absoluteHref = to;
    // Only check for external origins client-side
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          // Strip the protocol/origin/basename for same-origin absolute URLs
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e) {
        // We can't do external URL detection without a valid URL
         false ? 0 : void 0;
      }
    }
  }
  // Rendered into <a href> for relative URLs
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative,
    unstable_viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    React.createElement("a", react_router_dom_dist_extends({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref: ref,
      target: target
    }))
  );
})));
if (false) {}
/**
 * A `<Link>` wrapper that knows if it's "active" or not.
 */
const NavLink = /*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef(function NavLinkWithRef(_ref8, ref) {
  let {
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      unstable_viewTransition,
      children
    } = _ref8,
    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = React.useContext(UNSAFE_DataRouterStateContext);
  let {
    navigator,
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  let isTransitioning = routerState != null &&
  // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(path) && unstable_viewTransition === true;
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename) {
    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
  }
  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,
  // we're looking for a slash _after_ what's in `to`.  For example:
  //
  // <NavLink to="/users"> and <NavLink to="/users/">
  // both want to look for a / at index 6 to match URL `/users/matt`
  const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let renderProps = {
    isActive,
    isPending,
    isTransitioning
  };
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps);
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
  return /*#__PURE__*/React.createElement(Link, react_router_dom_dist_extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to,
    unstable_viewTransition: unstable_viewTransition
  }), typeof children === "function" ? children(renderProps) : children);
})));
if (false) {}
/**
 * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
 * that the interaction with the server is with `fetch` instead of new document
 * requests, allowing components to add nicer UX to the page as the form is
 * submitted and returns with data.
 */
const Form = /*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef((_ref9, forwardedRef) => {
  let {
      fetcherKey,
      navigate,
      reloadDocument,
      replace,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      unstable_viewTransition
    } = _ref9,
    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);
  let submit = useSubmit();
  let formAction = useFormAction(action, {
    relative
  });
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let submitHandler = event => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      fetcherKey,
      method: submitMethod,
      navigate,
      replace,
      state,
      relative,
      preventScrollReset,
      unstable_viewTransition
    });
  };
  return /*#__PURE__*/React.createElement("form", react_router_dom_dist_extends({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
})));
if (false) {}
/**
 * This component will emulate the browser's scroll restoration on location
 * changes.
 */
function ScrollRestoration(_ref10) {
  let {
    getKey,
    storageKey
  } = _ref10;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (false) {}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Hooks
////////////////////////////////////////////////////////////////////////////////
var dist_DataRouterHook;
(function (DataRouterHook) {
  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook["UseSubmit"] = "useSubmit";
  DataRouterHook["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook["UseFetcher"] = "useFetcher";
  DataRouterHook["useViewTransitionState"] = "useViewTransitionState";
})(dist_DataRouterHook || (dist_DataRouterHook = {}));
var dist_DataRouterStateHook;
(function (DataRouterStateHook) {
  DataRouterStateHook["UseFetcher"] = "useFetcher";
  DataRouterStateHook["UseFetchers"] = "useFetchers";
  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
})(dist_DataRouterStateHook || (dist_DataRouterStateHook = {}));
// Internal hooks
function dist_getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function dist_useDataRouterContext(hookName) {
  let ctx = React.useContext(UNSAFE_DataRouterContext);
  !ctx ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  return ctx;
}
function dist_useDataRouterState(hookName) {
  let state = React.useContext(UNSAFE_DataRouterStateContext);
  !state ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  return state;
}
// External hooks
/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    unstable_viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return React.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here unless the replace prop is explicitly set
      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative,
        unstable_viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */
function useSearchParams(defaultInit) {
   false ? 0 : void 0;
  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = React.useRef(false);
  let location = useLocation();
  let searchParams = React.useMemo(() =>
  // Only merge in the defaults if we haven't yet called setSearchParams.
  // Once we call that we want those to take precedence, otherwise you can't
  // remove a param with setSearchParams({}) if it has an initial value
  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
function validateClientSideSubmission() {
  if (typeof document === "undefined") {
    throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
  }
}
let fetcherId = 0;
let getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";
/**
 * Returns a function that may be used to programmatically submit a form (or
 * some arbitrary data) to the server.
 */
function useSubmit() {
  let {
    router
  } = dist_useDataRouterContext(dist_DataRouterHook.UseSubmit);
  let {
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  let currentRouteId = UNSAFE_useRouteId();
  return React.useCallback(function (target, options) {
    if (options === void 0) {
      options = {};
    }
    validateClientSideSubmission();
    let {
      action,
      method,
      encType,
      formData,
      body
    } = getFormSubmissionInfo(target, basename);
    if (options.navigate === false) {
      let key = options.fetcherKey || getUniqueFetcherId();
      router.fetch(key, currentRouteId, options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        unstable_flushSync: options.unstable_flushSync
      });
    } else {
      router.navigate(options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        replace: options.replace,
        state: options.state,
        fromRouteId: currentRouteId,
        unstable_flushSync: options.unstable_flushSync,
        unstable_viewTransition: options.unstable_viewTransition
      });
    }
  }, [router, basename, currentRouteId]);
}
// v7: Eventually we should deprecate this entirely in favor of using the
// router method directly?
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  let routeContext = React.useContext(UNSAFE_RouteContext);
  !routeContext ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  let [match] = routeContext.matches.slice(-1);
  // Shallow clone path so we can modify it below, otherwise we modify the
  // object referenced by useMemo inside useResolvedPath
  let path = react_router_dom_dist_extends({}, useResolvedPath(action ? action : ".", {
    relative
  }));
  // If no action was specified, browsers will persist current search params
  // when determining the path, so match that behavior
  // https://github.com/remix-run/remix/issues/927
  let location = useLocation();
  if (action == null) {
    // Safe to write to this directly here since if action was undefined, we
    // would have called useResolvedPath(".") which will never include a search
    path.search = location.search;
    // When grabbing search params from the URL, remove any included ?index param
    // since it might not apply to our contextual route.  We add it back based
    // on match.route.index below
    let params = new URLSearchParams(path.search);
    if (params.has("index") && params.get("index") === "") {
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  // If we're operating within a basename, prepend it to the pathname prior
  // to creating the form action.  If this is a root navigation, then just use
  // the raw basename which allows the basename to have full control over the
  // presence of a trailing slash on root actions
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`
/**
 * Interacts with route loaders and actions without causing a navigation. Great
 * for any interaction that stays on the same page.
 */
function useFetcher(_temp3) {
  var _route$matches;
  let {
    key
  } = _temp3 === void 0 ? {} : _temp3;
  let {
    router
  } = dist_useDataRouterContext(dist_DataRouterHook.UseFetcher);
  let state = dist_useDataRouterState(dist_DataRouterStateHook.UseFetcher);
  let fetcherData = React.useContext(FetchersContext);
  let route = React.useContext(UNSAFE_RouteContext);
  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
  !fetcherData ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  !route ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  !(routeId != null) ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  // Fetcher key handling
  // OK to call conditionally to feature detect `useId`
  // eslint-disable-next-line react-hooks/rules-of-hooks
  let defaultKey = useIdImpl ? useIdImpl() : "";
  let [fetcherKey, setFetcherKey] = React.useState(key || defaultKey);
  if (key && key !== fetcherKey) {
    setFetcherKey(key);
  } else if (!fetcherKey) {
    // We will only fall through here when `useId` is not available
    setFetcherKey(getUniqueFetcherId());
  }
  // Registration/cleanup
  React.useEffect(() => {
    router.getFetcher(fetcherKey);
    return () => {
      // Tell the router we've unmounted - if v7_fetcherPersist is enabled this
      // will not delete immediately but instead queue up a delete after the
      // fetcher returns to an `idle` state
      router.deleteFetcher(fetcherKey);
    };
  }, [router, fetcherKey]);
  // Fetcher additions
  let load = React.useCallback((href, opts) => {
    !routeId ?  false ? 0 : UNSAFE_invariant(false) : void 0;
    router.fetch(fetcherKey, routeId, href, opts);
  }, [fetcherKey, routeId, router]);
  let submitImpl = useSubmit();
  let submit = React.useCallback((target, opts) => {
    submitImpl(target, react_router_dom_dist_extends({}, opts, {
      navigate: false,
      fetcherKey
    }));
  }, [fetcherKey, submitImpl]);
  let FetcherForm = React.useMemo(() => {
    let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {
      return /*#__PURE__*/React.createElement(Form, react_router_dom_dist_extends({}, props, {
        navigate: false,
        fetcherKey: fetcherKey,
        ref: ref
      }));
    });
    if (false) {}
    return FetcherForm;
  }, [fetcherKey]);
  // Exposed FetcherWithComponents
  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;
  let data = fetcherData.get(fetcherKey);
  let fetcherWithComponents = React.useMemo(() => react_router_dom_dist_extends({
    Form: FetcherForm,
    submit,
    load
  }, fetcher, {
    data
  }), [FetcherForm, submit, load, fetcher, data]);
  return fetcherWithComponents;
}
/**
 * Provides all fetchers currently on the page. Useful for layouts and parent
 * routes that need to provide pending/optimistic UI regarding the fetch.
 */
function useFetchers() {
  let state = dist_useDataRouterState(dist_DataRouterStateHook.UseFetchers);
  return Array.from(state.fetchers.entries()).map(_ref11 => {
    let [key, fetcher] = _ref11;
    return react_router_dom_dist_extends({}, fetcher, {
      key
    });
  });
}
const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
let savedScrollPositions = {};
/**
 * When rendered inside a RouterProvider, will restore scroll positions on navigations
 */
function useScrollRestoration(_temp4) {
  let {
    getKey,
    storageKey
  } = _temp4 === void 0 ? {} : _temp4;
  let {
    router
  } = dist_useDataRouterContext(dist_DataRouterHook.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = dist_useDataRouterState(dist_DataRouterStateHook.UseScrollRestoration);
  let {
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  // Trigger manual scroll restoration while we're active
  React.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  // Save positions on pagehide
  usePageHide(React.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    try {
      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    } catch (error) {
       false ? 0 : void 0;
    }
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches]));
  // Read in any saved scroll locations
  if (typeof document !== "undefined") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {
        // no-op, use default empty object
      }
    }, [storageKey]);
    // Enable scroll restoration in the router
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useLayoutEffect(() => {
      let getKeyWithoutBasename = getKey && basename !== "/" ? (location, matches) => getKey( // Strip the basename to match useLocation()
      react_router_dom_dist_extends({}, location, {
        pathname: stripBasename(location.pathname, basename) || location.pathname
      }), matches) : getKey;
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, basename, getKey]);
    // Restore scrolling when state.restoreScrollPosition changes
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useLayoutEffect(() => {
      // Explicit false means don't do anything (used for submissions)
      if (restoreScrollPosition === false) {
        return;
      }
      // been here before, scroll to it
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      // try to scroll to the hash
      if (location.hash) {
        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      // Don't reset if this navigation opted out
      if (preventScrollReset === true) {
        return;
      }
      // otherwise go to the top on new locations
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
/**
 * Setup a callback to be fired on the window's `beforeunload` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */
function useBeforeUnload(callback, options) {
  let {
    capture
  } = options || {};
  React.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : undefined;
    window.addEventListener("beforeunload", callback, opts);
    return () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
/**
 * Setup a callback to be fired on the window's `pagehide` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.  This event is better supported than beforeunload across browsers.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */
function usePageHide(callback, options) {
  let {
    capture
  } = options || {};
  React.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : undefined;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
/**
 * Wrapper around useBlocker to show a window.confirm prompt to users instead
 * of building a custom UI with useBlocker.
 *
 * Warning: This has *a lot of rough edges* and behaves very differently (and
 * very incorrectly in some cases) across browsers if user click addition
 * back/forward navigations while the confirm is open.  Use at your own risk.
 */
function usePrompt(_ref12) {
  let {
    when,
    message
  } = _ref12;
  let blocker = useBlocker(when);
  React.useEffect(() => {
    if (blocker.state === "blocked") {
      let proceed = window.confirm(message);
      if (proceed) {
        // This timeout is needed to avoid a weird "race" on POP navigations
        // between the `window.history` revert navigation and the result of
        // `window.confirm`
        setTimeout(blocker.proceed, 0);
      } else {
        blocker.reset();
      }
    }
  }, [blocker, message]);
  React.useEffect(() => {
    if (blocker.state === "blocked" && !when) {
      blocker.reset();
    }
  }, [blocker, when]);
}
/**
 * Return a boolean indicating if there is an active view transition to the
 * given href.  You can use this value to render CSS classes or viewTransitionName
 * styles onto your elements
 *
 * @param href The destination href
 * @param [opts.relative] Relative routing type ("route" | "path")
 */
function useViewTransitionState(to, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let vtContext = React.useContext(ViewTransitionContext);
  !(vtContext != null) ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  let {
    basename
  } = dist_useDataRouterContext(dist_DataRouterHook.useViewTransitionState);
  let path = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  // Transition is active if we're going to or coming from the indicated
  // destination.  This ensures that other PUSH navigations that reverse
  // an indicated transition apply.  I.e., on the list view you have:
  //
  //   <NavLink to="/details/1" unstable_viewTransition>
  //
  // If you click the breadcrumb back to the list view:
  //
  //   <NavLink to="/list" unstable_viewTransition>
  //
  // We should apply the transition because it's indicated as active going
  // from /list -> /details/1 and therefore should be active on the reverse
  // (even though this isn't strictly a POP reverse)
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
//#endregion


//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/.store/aurad@1.4.2/node_modules/aurad/dist/index.js
var JS = Object.defineProperty;
var QS = (r, e, t) => e in r ? JS(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var Wi = (r, e, t) => (QS(r, typeof e != "symbol" ? e + "" : e, t), t);



function Jo(r) {
  return r == null || r !== r;
}
function aw(r) {
  return typeof r != "object" || Jo(r) ? !1 : /Iterator\]$/.test(r.toString());
}
function ow(r) {
  try {
    if (aw(r))
      return "Iterator";
    const e = Object.prototype.toString.call(r).match(/\[object (\w+)\]/)[1];
    return e === "Number" && isNaN(r) ? "NaN" : e;
  } catch {
    return "Undefined";
  }
}
function Wy(r) {
  return typeof r == "string";
}
const Hh = (r) => typeof r == "number" && ow(r) === "Number";
function sw(r) {
  return Array.isArray(r);
}
function lw(r) {
  return Jo(r) ? !1 : sw(r) && r.length > 0;
}
const uw = (r) => typeof r == "boolean";
function hB(r = !0) {
  const [e, t] = Le(r);
  return [
    e,
    $y((n) => t((i) => uw(n) ? n : !i), [])
  ];
}
function zf(r, e = {}) {
  const { min: t = 0, max: n = 1 / 0 } = e;
  let i = r;
  return Hh(n) && (i = Math.min(n, i)), Hh(t) && (i = Math.max(t, i)), i;
}
function vB(r = 0, e = {}) {
  const [t, n] = Le(zf(r, e));
  return [t, (a) => {
    if (Jo(a)) {
      const o = zf(t + 1, e);
      o !== t && n(o);
      return;
    }
    n(zf(a, e));
  }];
}
function fw(r) {
  return r == null || r !== r;
}
function X0(r) {
  return Array.isArray(r);
}
function cw(r) {
  return typeof r != "object" || fw(r) ? !1 : /Iterator\]$/.test(r.toString());
}
function zn(r) {
  try {
    if (cw(r))
      return "Iterator";
    const e = Object.prototype.toString.call(r).match(/\[object (\w+)\]/)[1];
    return e === "Number" && isNaN(r) ? "NaN" : e;
  } catch {
    return "Undefined";
  }
}
function Z0(r) {
  return r !== null && typeof r == "object" && zn(r) === "Object";
}
function q0(r) {
  return zn(r) === "Date";
}
function K0(r) {
  return zn(r) === "Set";
}
function j0(r) {
  return zn(r) === "Map";
}
function Zu(r, e) {
  const t = zn(r), n = zn(e);
  return r !== n || t === "Symbol" ? !1 : r === e;
}
function hw(r, e, t = Zu) {
  if (!j0(r) || !j0(e) || r.size !== e.size)
    return !1;
  for (const [n, i] of r) {
    const a = e.get(n);
    if (!t(i, a))
      return !1;
  }
  return !0;
}
function vw(r, e, t = Zu) {
  if (!K0(r) || !K0(e) || r.size !== e.size)
    return !1;
  const n = [...r], i = [...e];
  for (let a = 0; a < n.length; a++)
    if (!t(n[a], i[a]))
      return !1;
  return !0;
}
function dw(r, e, t = Zu) {
  if (X0(r) && X0(e) && r.length === e.length) {
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      if (!t(i, e[n]))
        return !1;
    }
    return !0;
  }
  return !1;
}
function pw(r, e, t = Zu) {
  if (!Z0(r) || !Z0(e))
    return !1;
  const n = Object.keys(r), i = Object.keys(e);
  if (n.length !== i.length)
    return !1;
  for (let a = 0; a < n.length; a++) {
    const o = n[a];
    if (!t(r[o], e[o]))
      return !1;
  }
  return !0;
}
function En(r, e) {
  const t = zn(r), n = zn(e);
  return t !== n ? !1 : t === "Object" ? pw(r, e, En) : t === "Array" ? dw(r, e, En) : t === "Map" ? hw(r, e, En) : t === "Set" ? vw(r, e, En) : Number.isNaN(r) ? Number.isNaN(e) : q0(r) && q0(e) ? r.getTime() === e.getTime() : r === e;
}
function J0(r) {
  const e = () => r === void 0 ? /* @__PURE__ */ new Map() : new Map(r), [t, n] = (0,react.useState)(() => e());
  return [t, {
    keys: () => Array.from(t.keys()),
    set: (f, c, h = !1) => {
      En(t.get(f), c) && !h || n((v) => {
        const d = new Map(v);
        return d.set(f, c), d;
      });
    },
    setAll: (f) => {
      n(new Map(f));
    },
    remove: (f) => {
      n((c) => {
        const h = new Map(c);
        return h.delete(f), h;
      });
    },
    reset: () => n(e()),
    get: (f) => t.get(f)
  }];
}
function dB(r) {
  const e = () => r || {}, [t, n] = Le(() => e());
  return [
    t,
    {
      set: (l, u, f = !1) => {
        if (!f && En(u, t[l]))
          return;
        const c = { ...t };
        c[l] = u, n(c);
      },
      remove: (l) => {
        if (Object.keys(t).includes(l)) {
          const u = { ...t };
          delete u[l], n(u);
        }
      },
      reset: (l = !1) => {
        !l && En(t, e()) || n(e());
      },
      setObject: (l) => {
        En(l, t) || n(l);
      }
    }
  ];
}
function $h(r = {}) {
  const [e, t] = (0,react.useState)(r);
  return [
    e,
    (n, i = !1) => {
      const a = typeof n == "function" ? n(e) : n;
      t(i ? a : { ...e, ...a });
    },
    (n) => {
      if (lw(n)) {
        const i = { ...e };
        n.forEach((a) => {
          (Wy(a) || Hh(a)) && (i[a] = r[a]);
        }), t(i);
        return;
      }
      t(r);
    }
  ];
}
function Uy(r, e, t = {}) {
  const { storage: n = sessionStorage } = t, i = () => Jo(n.getItem(r)) ? e : n.getItem(r), [a, o] = A.useState(i() || null), s = (l) => {
    o(l), Wy(l) ? n.setItem(r, l) : n.setItem(r, JSON.stringify(l));
  };
  return A.useEffect(() => {
    const l = n.getItem(r);
    Jo(l) || l !== a && s(l);
  }, [r, s, n]), [a, s];
}
const pB = (r, e) => Uy(r, e, { storage: localStorage }), gw = (r, e) => Uy(r, e, { storage: sessionStorage }), gB = () => {
  const [, r] = Le(1);
  return $y(() => r(1), []);
};
function mB(r, e) {
  const t = A.useRef(() => {
  });
  t.current = r;
  const [n, i] = A.useState(null);
  return A.useEffect(() => {
    if (e !== null) {
      const o = setInterval(() => t.current(), e);
      return i(o), () => o && clearInterval(o);
    }
  }, [e]), n;
}
function yB(r, e) {
  const t = A.useRef(() => {
  });
  t.current = r, A.useEffect(() => {
    if (e !== null) {
      const i = setTimeout(() => t.current(), e);
      return () => clearInterval(i);
    }
  }, [e]);
}
function _B(r, e, t) {
  ws(() => {
    let n = null;
    const i = setTimeout(async () => {
      const a = r && await r();
      a && (n = a);
    }, e);
    return () => {
      clearTimeout(i), n && n();
    };
  }, t);
}
function dist_ue(r) {
  return r == null || r !== r;
}
function Wh(r) {
  return r != null && r === r;
}
function Qo(r) {
  return r === void 0;
}
function mw(r) {
  return typeof r != "object" || dist_ue(r) ? !1 : /Iterator\]$/.test(r.toString());
}
function qu(r) {
  try {
    if (mw(r))
      return "Iterator";
    const e = Object.prototype.toString.call(r).match(/\[object (\w+)\]/)[1];
    return e === "Number" && isNaN(r) ? "NaN" : e;
  } catch {
    return "Undefined";
  }
}
function yw(r) {
  return r !== null && typeof r == "object" && qu(r) === "Object";
}
function lr(r) {
  return typeof r == "string";
}
const it = (r) => typeof r == "number" && qu(r) === "Number";
function _w(r) {
  return it(r) ? r % 1 !== 0 : !1;
}
function Sw(r) {
  return it(r) ? r % 1 === 0 : !1;
}
function jr(r) {
  return Array.isArray(r);
}
function wt(r) {
  return dist_ue(r) ? !1 : jr(r) && r.length > 0;
}
function ww(r) {
  return qu(r) === "Date";
}
const bw = (r) => typeof r == "boolean";
function Q0(r) {
  return qu(r) === "RegExp";
}
const Yy = (r) => (e) => `${r}${dist_ue(e) ? "" : "-" + e}`, Xy = react.createContext({});
function Zy(r) {
  return r == null || r != r;
}
const ep = Array.isArray;
function Ku(r) {
  try {
    if (typeof (e = r) == "object" && !Zy(e) && /Iterator\]$/.test(e.toString()))
      return "Iterator";
    const t = Object.prototype.toString.call(r).match(/\[object (\w+)\]/)[1];
    return t === "Number" && isNaN(r) ? "NaN" : t;
  } catch {
    return "Undefined";
  }
  var e;
}
function Gf(r, e = !1) {
  return e ? typeof r == "function" : Ku(r) === "Function";
}
function tp(r) {
  return r !== null && typeof r == "object" && Ku(r) === "Object";
}
function Hf(r) {
  return typeof r == "string";
}
const rp = (r) => typeof r == "number" && Ku(r) === "Number";
function dist_Y(...r) {
  const e = /* @__PURE__ */ new Set(), t = {};
  function n(i, a) {
    i === !1 && e.has(a) && e.delete(a), i !== !0 || e.has(a) || e.add(a);
  }
  (function i(a) {
    a.forEach((o) => {
      if (o) {
        if (Array.isArray(o))
          return i(o);
        if (typeof o != "string" && typeof o != "number") {
          if (Ku(o) === "Object")
            for (const s in o) {
              const l = !!o[s];
              t[s] = l, n(l, s);
            }
        } else
          e.add(o);
      }
    });
  })(r);
  for (const i in t)
    n(t[i], i);
  return [...e].join(" ");
}
/ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase());
/android/.test(navigator.userAgent.toLowerCase());
window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
let qy = class {
  constructor(e, t) {
    Wi(this, "length");
    Wi(this, "storage");
    Wi(this, "defaultValue");
    Wi(this, "setCallback");
    Wi(this, "getCallback");
    this.storage = e, this.length = e.length;
    const { defaultValue: n = null, getCallback: i, setCallback: a } = t || {};
    this.defaultValue = n, Gf(i) && (this.getCallback = i), Gf(a) && (this.setCallback = a);
  }
  getItem(e) {
    return this.storage.getItem(e);
  }
  get(e, t = this.defaultValue) {
    const n = this.storage.getItem(e);
    return Gf(this.getCallback) ? this.getCallback(e, n, t) : Zy(n) ? t : n;
  }
  getNumber(e, t = rp(this.defaultValue) ? this.defaultValue : 0) {
    const n = Number(this.get(e));
    return rp(n) ? n : t;
  }
  getString(e, t = Hf(this.defaultValue) ? this.defaultValue : "") {
    const n = this.get(e);
    return Hf(n) ? n : t;
  }
  getObject(e, t = tp(this.defaultValue) ? this.defaultValue : {}) {
    try {
      const n = JSON.parse(this.get(e) || "{}");
      return tp(n) ? n : t;
    } catch {
      return t;
    }
  }
  getArray(e, t = ep(this.defaultValue) ? this.defaultValue : []) {
    try {
      const n = JSON.parse(this.get(e) || "{}");
      return ep(n) ? n : t;
    } catch {
      return t;
    }
  }
  setItem(e, t) {
    Hf(t) ? this.storage.setItem(e, t) : this.storage.setItem(e, JSON.stringify(t));
  }
  key(e) {
    return this.storage.key(e);
  }
  removeItem(e) {
    return this.storage.removeItem(e);
  }
  clear() {
    return this.storage.clear();
  }
};
new qy(localStorage);
new qy(sessionStorage);
function hd(r) {
  return r == null || r !== r;
}
const np = Number.isNaN;
function Uh(r) {
  return Array.isArray(r);
}
function xw(r) {
  return typeof r != "object" || hd(r) ? !1 : /Iterator\]$/.test(r.toString());
}
function Ar(r) {
  try {
    if (xw(r))
      return "Iterator";
    const e = Object.prototype.toString.call(r).match(/\[object (\w+)\]/)[1];
    return e === "Number" && isNaN(r) ? "NaN" : e;
  } catch {
    return "Undefined";
  }
}
function Yh(r) {
  return r !== null && typeof r == "object" && Ar(r) === "Object";
}
function Ky(r) {
  return typeof r == "string";
}
const ip = (r) => typeof r == "number" && Ar(r) === "Number";
function ap(r) {
  return Ar(r) === "Date";
}
function Cw(r) {
  return typeof r == "symbol";
}
function op(r) {
  return Ar(r) === "Set";
}
function sp(r) {
  return Ar(r) === "Map";
}
function Tw(r, e, t = !1) {
  const n = ip(r) ? String(r) : r, [i, a] = n.split("."), o = i ? i.length : 0;
  if (ip(e))
    return e > 0 ? e > o ? new Array(e + 1 - o).join("0") + n : t ? new Array(e + 1).join("9") : n : e < 0 ? Number(n).toFixed(-e) : n;
  if (Ky(e)) {
    const [s, l] = e.split(".").map((f) => Math.abs(Number(f)));
    let u = i;
    return !np(s) && s > 0 && (s > o ? u = new Array(s + 1 - o).join("0") + i : t && (u = new Array(s + 1).join("9"))), !np(l) && l > 0 && (t || !a || l > a.length ? u = u + Number(a || 0).toFixed(l).toString().slice(1) : u = u + "." + a), u;
  }
  return n;
}
function es(r) {
  return Ky(r) ? r : hd(r) ? "" : [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "Symbol",
    "RegExp",
    "Promise",
    "Date",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "BigInt"
  ].includes(Ar(r)) ? r.toString() : r === 1 / 0 ? "Infinity" : r === -1 / 0 ? "-Infinity" : JSON.stringify(r);
}
function jy(r, e, t) {
  return hd(r) ? String(r) : Yh(r) || Uh(r) ? JSON.stringify(r, e, t) : Cw(r) ? r.toString() : JSON.stringify(es(r), e, t).replace(/^(")+|(")+$/g, "");
}
function ju(r, e) {
  const t = Ar(r), n = Ar(e);
  return r !== n || t === "Symbol" ? !1 : r === e;
}
function Mw(r, e, t = ju) {
  if (!sp(r) || !sp(e) || r.size !== e.size)
    return !1;
  for (const [n, i] of r) {
    const a = e.get(n);
    if (!t(i, a))
      return !1;
  }
  return !0;
}
function Dw(r, e, t = ju) {
  if (!op(r) || !op(e) || r.size !== e.size)
    return !1;
  const n = [...r], i = [...e];
  for (let a = 0; a < n.length; a++)
    if (!t(n[a], i[a]))
      return !1;
  return !0;
}
function Ew(r, e, t = ju) {
  if (Uh(r) && Uh(e) && r.length === e.length) {
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      if (!t(i, e[n]))
        return !1;
    }
    return !0;
  }
  return !1;
}
function Aw(r, e, t = ju) {
  if (!Yh(r) || !Yh(e))
    return !1;
  const n = Object.keys(r), i = Object.keys(e);
  if (n.length !== i.length)
    return !1;
  for (let a = 0; a < n.length; a++) {
    const o = n[a];
    if (!t(r[o], e[o]))
      return !1;
  }
  return !0;
}
function Cr(r, e) {
  const t = Ar(r), n = Ar(e);
  return t !== n ? !1 : t === "Object" ? Aw(r, e, Cr) : t === "Array" ? Ew(r, e, Cr) : t === "Map" ? Mw(r, e, Cr) : t === "Set" ? Dw(r, e, Cr) : Number.isNaN(r) ? Number.isNaN(e) : ap(r) && ap(e) ? r.getTime() === e.getTime() : r === e;
}
function lp(r) {
  return [...new Set(r)];
}
function vd(r, e) {
  let t = 0;
  return (...i) => {
    clearTimeout(t), t = setTimeout(() => {
      r.apply(this, i);
    }, e);
  };
}
function Iw(r) {
  const { className: e, label: t, name: n, valueIndex: i = "value", rules: a, __form__: o, children: s, ...l } = r;
  if (react.useEffect(() => {
    n && o && (o.fieldAction.set(n, { name: n, rules: a }), wt(a) && o.ruleAction.set(n, a));
  }, [es(a), n]), o && n && react.isValidElement(s)) {
    const { values: u, errorState: f = {} } = o, { onChange: c, ...h } = s.props, v = {
      ...h,
      [i]: u[n],
      onChange: (m) => {
        c && c(m);
        const _ = (() => {
          const S = m.target[i];
          return dist_ue(S) ? "" : S;
        })();
        o.validateField(n, _), o.setValues({ [n]: _ });
      }
    };
    dist_ue(u[n]) && delete v[i];
    const d = f[n] && f[n].error && f[n].error.length > 0, g = dist_Y("au-form-item", e, {
      "au-form-item-error-status": d
    }), p = () => {
      const { error: m = [] } = f[n] || {};
      return m.length > 0 ? m.join(", ") : "";
    };
    return react.createElement(
      "div",
      { className: g, ...l },
      t && react.createElement("label", { className: "au-form-item-label" }, t),
      react.createElement("div", { className: "au-form-item-control" }, react.cloneElement(s, v)),
      react.createElement("div", { className: "au-form-item-error-status-message" }, p())
    );
  }
  return react.createElement(
    "div",
    { className: dist_Y("au-form-item", e), ...l },
    t && react.createElement("label", null, t),
    s
  );
}
function Lw(r) {
  return react.createElement(Xy.Consumer, null, (e) => react.createElement(Iw, { ...e, ...r }));
}
const Nw = (r) => !(dist_ue(r) || lr(r) && r.length === 0), $s = (r) => it(r) ? r : lr(r) || jr(r) ? r.length : null, Pw = (r, e) => {
  const { required: t = !1, min: n, max: i, pattern: a, len: o, transform: s, type: l, whitespace: u = !1 } = e;
  let f = s ? s(r) : r;
  if (t && Nw(f) === !1)
    return !1;
  const c = $s(f);
  if (!dist_ue(n)) {
    if (c === null)
      return !1;
    const h = $s(n);
    if (h !== null && c < h)
      return !1;
  }
  if (!dist_ue(i)) {
    if (c === null)
      return !1;
    const h = $s(i);
    if (h !== null && c > h)
      return !1;
  }
  if (!dist_ue(o)) {
    if (c === null)
      return !1;
    const h = $s(o);
    if (h !== null && c !== h)
      return !1;
  }
  return !(l === "string" && (!lr(f) || u && f.indexOf(" ") > -1 || a && Q0(a) && !a.test(f)) || l === "number" && !it(f) || l === "boolean" && !bw(f) || l === "regexp" && !Q0(f) || l === "float" && !_w(f) || l === "array" && !jr(f) || l === "object" && !yw(f) || l === "date" && !ww(f) || l === "integer" && !Sw(f) || l === "email" && (!lr(f) || /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/.test(f)) || l === "url" && (!lr(f) || /https?\/\/:[-a-z0-9]+(\.[-a-z0-9])*\.(com|cn|edu|uk)\/[-a-z0-9_:@&?=+,.!/~*'%$]*/.test(f)));
}, $f = (r, e, t = [], n = {}) => {
  const { mode: i = "all" } = n, a = { name: r, value: e, error: [] };
  let o = it(i) ? i : -1;
  for (let s = 0; s < t.length; s++) {
    const l = t[s];
    if (Pw(e, l)) {
      if (o === -1)
        continue;
      if (o === 0)
        return a;
      --o;
    } else
      a.error.push(l.message);
  }
  return a;
};
function Jy() {
  const [r, e] = J0([]), [t, n] = J0([]), [i, a] = (0,react.useState)({}), [o, s] = $h({}), [l, u, f] = $h({}), c = Array.from(r.keys());
  return {
    fields: r,
    fieldAction: e,
    rules: t,
    ruleAction: n,
    initialValues: i,
    setInitialValues: a,
    values: o,
    setValues: s,
    errorState: l,
    setErrorState: u,
    setValue: (h, v) => s({ [h]: v }),
    getValue: (h) => o[h],
    getValues: (h) => {
      if (h) {
        const v = {};
        return h.forEach((d) => {
          v[d] = o[d];
        }), v;
      } else
        return o;
    },
    validateField: (h, v) => c.includes(h) ? (u({ [h]: $f(h, v, n.get(h)) }), {}) : {},
    validateFields: (h) => {
      const v = {};
      return h ? h.forEach((d) => {
        c.includes(d) && (v[d] = $f(d, o[d], n.get(d)));
      }) : c.forEach((d) => {
        v[d] = $f(d, o[d], n.get(d));
      }), u(v), {};
    },
    resetFields: (h) => {
      if (f(h), h && jr(h)) {
        const v = {};
        h.forEach((d) => {
          v[d] = i[d];
        }), s(v, !0);
      } else
        s(i, !0);
    },
    resetErrorStatus: (h) => {
      f(h);
    }
  };
}
function wB(r) {
  return function(e) {
    const t = Jy();
    return A.createElement(r, { ...e, form: t });
  };
}
function Rw(r) {
  const { className: e, children: t, initialValues: n, onSubmit: i, onReset: a, form: o = Jy(), ...s } = r;
  return react.useEffect(() => {
    n && (o.setInitialValues(n), o.setValues(n));
  }, [es(n)]), react.createElement(
    Xy.Provider,
    { value: { __form__: o } },
    react.createElement("form", { className: dist_Y(e), noValidate: !0, onReset: () => {
      a ? a(o) : o.resetFields();
    }, onSubmit: (l) => {
      l.preventDefault(), i && i(o);
    }, ...s }, t)
  );
}
Rw.Item = Lw;
const iu = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  unit: "px"
}, Ui = (r, e, t) => Math.min(Math.max(r, e), t), Ow = (...r) => r.filter((e) => e && typeof e == "string").join(" "), up = (r, e) => r === e || r.width === e.width && r.height === e.height && r.x === e.x && r.y === e.y && r.unit === e.unit;
function Yi(r, e, t) {
  return r.unit === "%" ? { ...iu, ...r, unit: "%" } : {
    unit: "%",
    x: r.x ? r.x / e * 100 : 0,
    y: r.y ? r.y / t * 100 : 0,
    width: r.width ? r.width / e * 100 : 0,
    height: r.height ? r.height / t * 100 : 0
  };
}
function dn(r, e, t) {
  return r.unit ? r.unit === "px" ? { ...iu, ...r, unit: "px" } : {
    unit: "px",
    x: r.x ? r.x * e / 100 : 0,
    y: r.y ? r.y * t / 100 : 0,
    width: r.width ? r.width * e / 100 : 0,
    height: r.height ? r.height * t / 100 : 0
  } : { ...iu, ...r, unit: "px" };
}
function fp(r, e, t, n, i, a = 0, o = 0, s = n, l = i) {
  const u = { ...r };
  let f = Math.min(a, n), c = Math.min(o, i), h = Math.min(s, n), v = Math.min(l, i);
  e && (e > 1 ? (f = o ? o * e : f, c = f / e, h = s * e) : (c = a ? a / e : c, f = c * e, v = l / e)), u.y < 0 && (u.height = Math.max(u.height + u.y, c), u.y = 0), u.x < 0 && (u.width = Math.max(u.width + u.x, f), u.x = 0);
  const d = n - (u.x + u.width);
  d < 0 && (u.x = Math.min(u.x, n - f), u.width += d);
  const g = i - (u.y + u.height);
  if (g < 0 && (u.y = Math.min(u.y, i - c), u.height += g), u.width < f && ((t === "sw" || t == "nw") && (u.x -= f - u.width), u.width = f), u.height < c && ((t === "nw" || t == "ne") && (u.y -= c - u.height), u.height = c), u.width > h && ((t === "sw" || t == "nw") && (u.x -= h - u.width), u.width = h), u.height > v && ((t === "nw" || t == "ne") && (u.y -= v - u.height), u.height = v), e) {
    const p = u.width / u.height;
    if (p < e) {
      const m = Math.max(u.width / e, c);
      (t === "nw" || t == "ne") && (u.y -= m - u.height), u.height = m;
    } else if (p > e) {
      const m = Math.max(u.height * e, f);
      (t === "sw" || t == "nw") && (u.x -= m - u.width), u.width = m;
    }
  }
  return u;
}
function kw(r, e, t, n) {
  const i = { ...r };
  return e === "ArrowLeft" ? n === "nw" ? (i.x -= t, i.y -= t, i.width += t, i.height += t) : n === "w" ? (i.x -= t, i.width += t) : n === "sw" ? (i.x -= t, i.width += t, i.height += t) : n === "ne" ? (i.y += t, i.width -= t, i.height -= t) : n === "e" ? i.width -= t : n === "se" && (i.width -= t, i.height -= t) : e === "ArrowRight" && (n === "nw" ? (i.x += t, i.y += t, i.width -= t, i.height -= t) : n === "w" ? (i.x += t, i.width -= t) : n === "sw" ? (i.x += t, i.width -= t, i.height -= t) : n === "ne" ? (i.y -= t, i.width += t, i.height += t) : n === "e" ? i.width += t : n === "se" && (i.width += t, i.height += t)), e === "ArrowUp" ? n === "nw" ? (i.x -= t, i.y -= t, i.width += t, i.height += t) : n === "n" ? (i.y -= t, i.height += t) : n === "ne" ? (i.y -= t, i.width += t, i.height += t) : n === "sw" ? (i.x += t, i.width -= t, i.height -= t) : n === "s" ? i.height -= t : n === "se" && (i.width -= t, i.height -= t) : e === "ArrowDown" && (n === "nw" ? (i.x += t, i.y += t, i.width -= t, i.height -= t) : n === "n" ? (i.y += t, i.height -= t) : n === "ne" ? (i.y += t, i.width -= t, i.height -= t) : n === "sw" ? (i.x -= t, i.width += t, i.height += t) : n === "s" ? i.height += t : n === "se" && (i.width += t, i.height += t)), i;
}
const Xi = { capture: !0, passive: !1 };
let Vw = 0;
const Xn = class tr extends react.PureComponent {
  constructor() {
    super(...arguments), this.docMoveBound = !1, this.mouseDownOnCrop = !1, this.dragStarted = !1, this.evData = {
      startClientX: 0,
      startClientY: 0,
      startCropX: 0,
      startCropY: 0,
      clientX: 0,
      clientY: 0,
      isResize: !0
    }, this.componentRef = (0,react.createRef)(), this.mediaRef = (0,react.createRef)(), this.initChangeCalled = !1, this.instanceId = `rc-${Vw++}`, this.state = {
      cropIsActive: !1,
      newCropIsBeingDrawn: !1
    }, this.onCropPointerDown = (e) => {
      const { crop: t, disabled: n } = this.props, i = this.getBox();
      if (!t)
        return;
      const a = dn(t, i.width, i.height);
      if (n)
        return;
      e.cancelable && e.preventDefault(), this.bindDocMove(), this.componentRef.current.focus({ preventScroll: !0 });
      const o = e.target.dataset.ord, s = !!o;
      let l = e.clientX, u = e.clientY, f = a.x, c = a.y;
      if (o) {
        const h = e.clientX - i.x, v = e.clientY - i.y;
        let d = 0, g = 0;
        o === "ne" || o == "e" ? (d = h - (a.x + a.width), g = v - a.y, f = a.x, c = a.y + a.height) : o === "se" || o === "s" ? (d = h - (a.x + a.width), g = v - (a.y + a.height), f = a.x, c = a.y) : o === "sw" || o == "w" ? (d = h - a.x, g = v - (a.y + a.height), f = a.x + a.width, c = a.y) : (o === "nw" || o == "n") && (d = h - a.x, g = v - a.y, f = a.x + a.width, c = a.y + a.height), l = f + i.x + d, u = c + i.y + g;
      }
      this.evData = {
        startClientX: l,
        startClientY: u,
        startCropX: f,
        startCropY: c,
        clientX: e.clientX,
        clientY: e.clientY,
        isResize: s,
        ord: o
      }, this.mouseDownOnCrop = !0, this.setState({ cropIsActive: !0 });
    }, this.onComponentPointerDown = (e) => {
      const { crop: t, disabled: n, locked: i, keepSelection: a, onChange: o } = this.props, s = this.getBox();
      if (n || i || a && t)
        return;
      e.cancelable && e.preventDefault(), this.bindDocMove(), this.componentRef.current.focus({ preventScroll: !0 });
      const l = e.clientX - s.x, u = e.clientY - s.y, f = {
        unit: "px",
        x: l,
        y: u,
        width: 0,
        height: 0
      };
      this.evData = {
        startClientX: e.clientX,
        startClientY: e.clientY,
        startCropX: l,
        startCropY: u,
        clientX: e.clientX,
        clientY: e.clientY,
        isResize: !0
      }, this.mouseDownOnCrop = !0, o(dn(f, s.width, s.height), Yi(f, s.width, s.height)), this.setState({ cropIsActive: !0, newCropIsBeingDrawn: !0 });
    }, this.onDocPointerMove = (e) => {
      const { crop: t, disabled: n, onChange: i, onDragStart: a } = this.props, o = this.getBox();
      if (n || !t || !this.mouseDownOnCrop)
        return;
      e.cancelable && e.preventDefault(), this.dragStarted || (this.dragStarted = !0, a && a(e));
      const { evData: s } = this;
      s.clientX = e.clientX, s.clientY = e.clientY;
      let l;
      s.isResize ? l = this.resizeCrop() : l = this.dragCrop(), up(t, l) || i(
        dn(l, o.width, o.height),
        Yi(l, o.width, o.height)
      );
    }, this.onComponentKeyDown = (e) => {
      const { crop: t, disabled: n, onChange: i, onComplete: a } = this.props;
      if (n)
        return;
      const o = e.key;
      let s = !1;
      if (!t)
        return;
      const l = this.getBox(), u = this.makePixelCrop(l), f = (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey) ? tr.nudgeStepLarge : e.shiftKey ? tr.nudgeStepMedium : tr.nudgeStep;
      if (o === "ArrowLeft" ? (u.x -= f, s = !0) : o === "ArrowRight" ? (u.x += f, s = !0) : o === "ArrowUp" ? (u.y -= f, s = !0) : o === "ArrowDown" && (u.y += f, s = !0), s) {
        e.cancelable && e.preventDefault(), u.x = Ui(u.x, 0, l.width - u.width), u.y = Ui(u.y, 0, l.height - u.height);
        const c = dn(u, l.width, l.height), h = Yi(u, l.width, l.height);
        i(c, h), a && a(c, h);
      }
    }, this.onHandlerKeyDown = (e, t) => {
      const {
        aspect: n = 0,
        crop: i,
        disabled: a,
        minWidth: o = 0,
        minHeight: s = 0,
        maxWidth: l,
        maxHeight: u,
        onChange: f,
        onComplete: c
      } = this.props, h = this.getBox();
      if (a || !i)
        return;
      if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight")
        e.stopPropagation(), e.preventDefault();
      else
        return;
      const v = (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey) ? tr.nudgeStepLarge : e.shiftKey ? tr.nudgeStepMedium : tr.nudgeStep, d = dn(i, h.width, h.height), g = kw(d, e.key, v, t), p = fp(
        g,
        n,
        t,
        h.width,
        h.height,
        o,
        s,
        l,
        u
      );
      if (!up(i, p)) {
        const m = Yi(p, h.width, h.height);
        f(p, m), c && c(p, m);
      }
    }, this.onDocPointerDone = (e) => {
      const { crop: t, disabled: n, onComplete: i, onDragEnd: a } = this.props, o = this.getBox();
      this.unbindDocMove(), !(n || !t) && this.mouseDownOnCrop && (this.mouseDownOnCrop = !1, this.dragStarted = !1, a && a(e), i && i(dn(t, o.width, o.height), Yi(t, o.width, o.height)), this.setState({ cropIsActive: !1, newCropIsBeingDrawn: !1 }));
    }, this.onDragFocus = () => {
      var e;
      (e = this.componentRef.current) == null || e.scrollTo(0, 0);
    };
  }
  get document() {
    return document;
  }
  // We unfortunately get the bounding box every time as x+y changes
  // due to scrolling.
  getBox() {
    const e = this.mediaRef.current;
    if (!e)
      return { x: 0, y: 0, width: 0, height: 0 };
    const { x: t, y: n, width: i, height: a } = e.getBoundingClientRect();
    return { x: t, y: n, width: i, height: a };
  }
  componentDidUpdate(e) {
    const { crop: t, onComplete: n } = this.props;
    if (n && !e.crop && t) {
      const { width: i, height: a } = this.getBox();
      i && a && n(dn(t, i, a), Yi(t, i, a));
    }
  }
  componentWillUnmount() {
    this.resizeObserver && this.resizeObserver.disconnect();
  }
  bindDocMove() {
    this.docMoveBound || (this.document.addEventListener("pointermove", this.onDocPointerMove, Xi), this.document.addEventListener("pointerup", this.onDocPointerDone, Xi), this.document.addEventListener("pointercancel", this.onDocPointerDone, Xi), this.docMoveBound = !0);
  }
  unbindDocMove() {
    this.docMoveBound && (this.document.removeEventListener("pointermove", this.onDocPointerMove, Xi), this.document.removeEventListener("pointerup", this.onDocPointerDone, Xi), this.document.removeEventListener("pointercancel", this.onDocPointerDone, Xi), this.docMoveBound = !1);
  }
  getCropStyle() {
    const { crop: e } = this.props;
    if (e)
      return {
        top: `${e.y}${e.unit}`,
        left: `${e.x}${e.unit}`,
        width: `${e.width}${e.unit}`,
        height: `${e.height}${e.unit}`
      };
  }
  dragCrop() {
    const { evData: e } = this, t = this.getBox(), n = this.makePixelCrop(t), i = e.clientX - e.startClientX, a = e.clientY - e.startClientY;
    return n.x = Ui(e.startCropX + i, 0, t.width - n.width), n.y = Ui(e.startCropY + a, 0, t.height - n.height), n;
  }
  getPointRegion(e, t, n, i) {
    const { evData: a } = this, o = a.clientX - e.x, s = a.clientY - e.y;
    let l;
    i && t ? l = t === "nw" || t === "n" || t === "ne" : l = s < a.startCropY;
    let u;
    return n && t ? u = t === "nw" || t === "w" || t === "sw" : u = o < a.startCropX, u ? l ? "nw" : "sw" : l ? "ne" : "se";
  }
  resolveMinDimensions(e, t, n = 0, i = 0) {
    const a = Math.min(n, e.width), o = Math.min(i, e.height);
    return !t || !a && !o ? [a, o] : t > 1 ? a ? [a, a / t] : [o * t, o] : o ? [o * t, o] : [a, a / t];
  }
  resizeCrop() {
    const { evData: e } = this, { aspect: t = 0, maxWidth: n, maxHeight: i } = this.props, a = this.getBox(), [o, s] = this.resolveMinDimensions(a, t, this.props.minWidth, this.props.minHeight);
    let l = this.makePixelCrop(a);
    const u = this.getPointRegion(a, e.ord, o, s), f = e.ord || u;
    let c = e.clientX - e.startClientX, h = e.clientY - e.startClientY;
    (o && f === "nw" || f === "w" || f === "sw") && (c = Math.min(c, -o)), (s && f === "nw" || f === "n" || f === "ne") && (h = Math.min(h, -s));
    const v = {
      unit: "px",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    u === "ne" ? (v.x = e.startCropX, v.width = c, t ? (v.height = v.width / t, v.y = e.startCropY - v.height) : (v.height = Math.abs(h), v.y = e.startCropY - v.height)) : u === "se" ? (v.x = e.startCropX, v.y = e.startCropY, v.width = c, t ? v.height = v.width / t : v.height = h) : u === "sw" ? (v.x = e.startCropX + c, v.y = e.startCropY, v.width = Math.abs(c), t ? v.height = v.width / t : v.height = h) : u === "nw" && (v.x = e.startCropX + c, v.width = Math.abs(c), t ? (v.height = v.width / t, v.y = e.startCropY - v.height) : (v.height = Math.abs(h), v.y = e.startCropY + h));
    const d = fp(
      v,
      t,
      u,
      a.width,
      a.height,
      o,
      s,
      n,
      i
    );
    return t || tr.xyOrds.indexOf(f) > -1 ? l = d : tr.xOrds.indexOf(f) > -1 ? (l.x = d.x, l.width = d.width) : tr.yOrds.indexOf(f) > -1 && (l.y = d.y, l.height = d.height), l.x = Ui(l.x, 0, a.width - l.width), l.y = Ui(l.y, 0, a.height - l.height), l;
  }
  renderCropSelection() {
    const {
      ariaLabels: e = tr.defaultProps.ariaLabels,
      disabled: t,
      locked: n,
      renderSelectionAddon: i,
      ruleOfThirds: a,
      crop: o
    } = this.props, s = this.getCropStyle();
    if (o)
      return /* @__PURE__ */ react.createElement(
        "div",
        {
          style: s,
          className: "ReactCrop__crop-selection",
          onPointerDown: this.onCropPointerDown,
          "aria-label": e.cropArea,
          tabIndex: 0,
          onKeyDown: this.onComponentKeyDown,
          role: "group"
        },
        !t && !n && /* @__PURE__ */ react.createElement("div", { className: "ReactCrop__drag-elements", onFocus: this.onDragFocus }, /* @__PURE__ */ react.createElement("div", { className: "ReactCrop__drag-bar ord-n", "data-ord": "n" }), /* @__PURE__ */ react.createElement("div", { className: "ReactCrop__drag-bar ord-e", "data-ord": "e" }), /* @__PURE__ */ react.createElement("div", { className: "ReactCrop__drag-bar ord-s", "data-ord": "s" }), /* @__PURE__ */ react.createElement("div", { className: "ReactCrop__drag-bar ord-w", "data-ord": "w" }), /* @__PURE__ */ react.createElement(
          "div",
          {
            className: "ReactCrop__drag-handle ord-nw",
            "data-ord": "nw",
            tabIndex: 0,
            "aria-label": e.nwDragHandle,
            onKeyDown: (l) => this.onHandlerKeyDown(l, "nw"),
            role: "button"
          }
        ), /* @__PURE__ */ react.createElement(
          "div",
          {
            className: "ReactCrop__drag-handle ord-n",
            "data-ord": "n",
            tabIndex: 0,
            "aria-label": e.nDragHandle,
            onKeyDown: (l) => this.onHandlerKeyDown(l, "n"),
            role: "button"
          }
        ), /* @__PURE__ */ react.createElement(
          "div",
          {
            className: "ReactCrop__drag-handle ord-ne",
            "data-ord": "ne",
            tabIndex: 0,
            "aria-label": e.neDragHandle,
            onKeyDown: (l) => this.onHandlerKeyDown(l, "ne"),
            role: "button"
          }
        ), /* @__PURE__ */ react.createElement(
          "div",
          {
            className: "ReactCrop__drag-handle ord-e",
            "data-ord": "e",
            tabIndex: 0,
            "aria-label": e.eDragHandle,
            onKeyDown: (l) => this.onHandlerKeyDown(l, "e"),
            role: "button"
          }
        ), /* @__PURE__ */ react.createElement(
          "div",
          {
            className: "ReactCrop__drag-handle ord-se",
            "data-ord": "se",
            tabIndex: 0,
            "aria-label": e.seDragHandle,
            onKeyDown: (l) => this.onHandlerKeyDown(l, "se"),
            role: "button"
          }
        ), /* @__PURE__ */ react.createElement(
          "div",
          {
            className: "ReactCrop__drag-handle ord-s",
            "data-ord": "s",
            tabIndex: 0,
            "aria-label": e.sDragHandle,
            onKeyDown: (l) => this.onHandlerKeyDown(l, "s"),
            role: "button"
          }
        ), /* @__PURE__ */ react.createElement(
          "div",
          {
            className: "ReactCrop__drag-handle ord-sw",
            "data-ord": "sw",
            tabIndex: 0,
            "aria-label": e.swDragHandle,
            onKeyDown: (l) => this.onHandlerKeyDown(l, "sw"),
            role: "button"
          }
        ), /* @__PURE__ */ react.createElement(
          "div",
          {
            className: "ReactCrop__drag-handle ord-w",
            "data-ord": "w",
            tabIndex: 0,
            "aria-label": e.wDragHandle,
            onKeyDown: (l) => this.onHandlerKeyDown(l, "w"),
            role: "button"
          }
        )),
        i && /* @__PURE__ */ react.createElement("div", { className: "ReactCrop__selection-addon", onPointerDown: (l) => l.stopPropagation() }, i(this.state)),
        a && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement("div", { className: "ReactCrop__rule-of-thirds-hz" }), /* @__PURE__ */ react.createElement("div", { className: "ReactCrop__rule-of-thirds-vt" }))
      );
  }
  makePixelCrop(e) {
    const t = { ...iu, ...this.props.crop || {} };
    return dn(t, e.width, e.height);
  }
  render() {
    const { aspect: e, children: t, circularCrop: n, className: i, crop: a, disabled: o, locked: s, style: l, ruleOfThirds: u } = this.props, { cropIsActive: f, newCropIsBeingDrawn: c } = this.state, h = a ? this.renderCropSelection() : null, v = Ow(
      "ReactCrop",
      i,
      f && "ReactCrop--active",
      o && "ReactCrop--disabled",
      s && "ReactCrop--locked",
      c && "ReactCrop--new-crop",
      a && e && "ReactCrop--fixed-aspect",
      a && n && "ReactCrop--circular-crop",
      a && u && "ReactCrop--rule-of-thirds",
      !this.dragStarted && a && !a.width && !a.height && "ReactCrop--invisible-crop",
      n && "ReactCrop--no-animate"
    );
    return /* @__PURE__ */ react.createElement("div", { ref: this.componentRef, className: v, style: l }, /* @__PURE__ */ react.createElement("div", { ref: this.mediaRef, className: "ReactCrop__child-wrapper", onPointerDown: this.onComponentPointerDown }, t), a ? /* @__PURE__ */ react.createElement("svg", { className: "ReactCrop__crop-mask", width: "100%", height: "100%" }, /* @__PURE__ */ react.createElement("defs", null, /* @__PURE__ */ react.createElement("mask", { id: `hole-${this.instanceId}` }, /* @__PURE__ */ react.createElement("rect", { width: "100%", height: "100%", fill: "white" }), n ? /* @__PURE__ */ react.createElement(
      "ellipse",
      {
        cx: `${a.x + a.width / 2}${a.unit}`,
        cy: `${a.y + a.height / 2}${a.unit}`,
        rx: `${a.width / 2}${a.unit}`,
        ry: `${a.height / 2}${a.unit}`,
        fill: "black"
      }
    ) : /* @__PURE__ */ react.createElement(
      "rect",
      {
        x: `${a.x}${a.unit}`,
        y: `${a.y}${a.unit}`,
        width: `${a.width}${a.unit}`,
        height: `${a.height}${a.unit}`,
        fill: "black"
      }
    ))), /* @__PURE__ */ react.createElement("rect", { fill: "black", fillOpacity: 0.5, width: "100%", height: "100%", mask: `url(#hole-${this.instanceId})` })) : void 0, h);
  }
};
Xn.xOrds = ["e", "w"], Xn.yOrds = ["n", "s"], Xn.xyOrds = ["nw", "ne", "se", "sw"], Xn.nudgeStep = 1, Xn.nudgeStepMedium = 10, Xn.nudgeStepLarge = 100, Xn.defaultProps = {
  ariaLabels: {
    cropArea: "Use the arrow keys to move the crop selection area",
    nwDragHandle: "Use the arrow keys to move the north west drag handle to change the crop selection area",
    nDragHandle: "Use the up and down arrow keys to move the north drag handle to change the crop selection area",
    neDragHandle: "Use the arrow keys to move the north east drag handle to change the crop selection area",
    eDragHandle: "Use the up and down arrow keys to move the east drag handle to change the crop selection area",
    seDragHandle: "Use the arrow keys to move the south east drag handle to change the crop selection area",
    sDragHandle: "Use the up and down arrow keys to move the south drag handle to change the crop selection area",
    swDragHandle: "Use the arrow keys to move the south west drag handle to change the crop selection area",
    wDragHandle: "Use the up and down arrow keys to move the west drag handle to change the crop selection area"
  }
};
const Bw = Math.PI / 180;
async function Fw(r, e, t, n = 1, i = 0) {
  const a = e.getContext("2d");
  if (!a)
    throw new Error("No 2d context");
  const o = r.naturalWidth / r.width, s = r.naturalHeight / r.height, l = window.devicePixelRatio;
  e.width = Math.floor(t.width * o * l), e.height = Math.floor(t.height * s * l), a.scale(l, l), a.imageSmoothingQuality = "high";
  const u = t.x * o, f = t.y * s, c = i * Bw, h = r.naturalWidth / 2, v = r.naturalHeight / 2;
  a.save(), a.translate(-u, -f), a.translate(h, v), a.rotate(c), a.scale(n, n), a.translate(-h, -v), a.drawImage(r, 0, 0, r.naturalWidth, r.naturalHeight, 0, 0, r.naturalWidth, r.naturalHeight), a.restore();
}
function zw(r, e, t) {
  ws(() => {
    const n = setTimeout(() => {
      r.apply(void 0, t);
    }, e);
    return () => {
      clearTimeout(n);
    };
  }, t);
}
function bB() {
  const r = Oi(null), e = Oi(null);
  Le();
  const [t, n] = Le();
  async function i() {
    const a = e.current, o = r.current;
    if (!a || !o || !t)
      throw new Error("Crop canvas does not exist");
    const s = a.naturalWidth / a.width, l = a.naturalHeight / a.height, u = new OffscreenCanvas(t.width * s, t.height * l), f = u.getContext("2d");
    if (!f)
      throw new Error("No 2d context");
    f.drawImage(o, 0, 0, o.width, o.height, 0, 0, u.width, u.height);
    const c = await u.convertToBlob({
      type: "image/png"
    }), h = new FileReader();
    h.onload = function() {
      h.result;
    }, h.readAsDataURL(c);
  }
  return zw(async () => {
    t != null && t.width && (t != null && t.height) && e.current && r.current && Fw(e.current, r.current, t, 1, 0);
  }, 100, [t]), A.createElement("div", { className: "App" }, t && A.createElement(
    "div",
    null,
    A.createElement("canvas", { ref: r, style: {
      border: "1px solid black",
      objectFit: "contain",
      width: t.width,
      height: t.height
    } }),
    A.createElement("button", { onClick: i }, "Download Crop")
  ));
}
function cp(r) {
  const { htmlType: e = "button", children: t = "", className: n, type: i, ...a } = r, s = dist_Y("au-btn", `au-btn-${e === "submit" && Qo(i) ? "primary" : Qo(i) ? "default" : i}`, n), l = Oi(null);
  return A.useEffect(() => {
    if (!l.current || a.disabled)
      return;
    const u = () => {
      var c;
      const f = document.createElement("span");
      f.className = "ripple", (c = l.current) == null || c.appendChild(f), setTimeout(() => {
        var h;
        (h = l.current) == null || h.removeChild(f);
      }, 1e3);
    };
    l.current.removeEventListener("click", u, !1), l.current.addEventListener("click", u, !1);
  }, [l.current]), A.createElement(
    "button",
    { ref: l, type: e, className: s, ...a },
    A.createElement("span", { className: "content" }, t)
  );
}
const Gw = {
  top: {
    path: "M84.48 648.896C71.456 661.472 64.096 678.752 64 696.832 65.696 737.632 100 769.408 140.8 767.968 161.92 768.064 182.176 759.712 197.12 744.8L512 432.096 826.88 744.8C841.824 759.712 862.08 768.064 883.2 767.968 924 769.408 958.304 737.632 960 696.832 959.904 678.752 952.544 661.472 939.52 648.896L568.32 279.04C537.056 248.32 486.944 248.32 455.68 279.04L84.48 648.896Z"
  },
  bottom: {
    path: "M84.48 375.104C71.456 362.528 64.096 345.248 64 327.168 65.696 286.368 100 254.592 140.8 256.032 161.92 255.936 182.176 264.288 197.12 279.2L512 591.904 826.88 279.2C841.824 264.288 862.08 255.936 883.2 256.032 924 254.592 958.304 286.368 960 327.168 959.904 345.248 952.544 362.528 939.52 375.104L568.32 744.96C537.056 775.68 486.944 775.68 455.68 744.96L84.48 375.104Z"
  },
  left: {
    path: "M616.896 939.52C629.472 952.544 646.752 959.904 664.832 960 705.632 958.304 737.408 924 735.968 883.2 736.064 862.08 727.712 841.824 712.8 826.88L400.096 512 712.8 197.12C727.712 182.176 736.064 161.92 735.968 140.8 737.408 100 705.632 65.696 664.832 64 646.752 64.096 629.472 71.456 616.896 84.48L247.04 455.68C216.32 486.944 216.32 537.056 247.04 568.32L616.896 939.52Z"
  },
  right: {
    path: "M407.104 939.52C394.528 952.544 377.248 959.904 359.168 960 318.368 958.304 286.592 924 288.032 883.2 287.936 862.08 296.288 841.824 311.2 826.88L623.904 512 311.2 197.12C296.288 182.176 287.936 161.92 288.032 140.8 286.592 100 318.368 65.696 359.168 64 377.248 64.096 394.528 71.456 407.104 84.48L776.96 455.68C807.68 486.944 807.68 537.056 776.96 568.32L407.104 939.52Z"
  },
  close: {
    path: "M507.168 473.232L716.48 263.936a16 16 0 0 1 22.624 0l11.312 11.312a16 16 0 0 1 0 22.624L541.12 507.168 750.4 716.48a16 16 0 0 1 0 22.624l-11.312 11.312a16 16 0 0 1-22.624 0L507.168 541.12 297.872 750.4a16 16 0 0 1-22.624 0l-11.312-11.312a16 16 0 0 1 0-22.624l209.296-209.312-209.296-209.296a16 16 0 0 1 0-22.624l11.312-11.312a16 16 0 0 1 22.624 0l209.296 209.296z"
  },
  effect: {
    path: [
      "M564.34 171.38l76.94 47.12 32.28 19.77 34.59-15.38 82.43-36.66-21 87.73-8.83 36.81L786 338.91 846.37 406l-89.94 7.1-37.73 3-18.94 32.77L654.62 527l-34.55-83.4-14.49-35-37-7.88L480.32 382l68.59-58.61 28.77-24.59-3.94-37.65-9.4-89.73m-46.11-107c-18.77 0-35.79 16.11-33.58 37.28l17.48 166.91-127.58 109c-21.24 18.15-12.45 52.77 14.87 58.59l164.14 34.95 64.26 155a33.7 33.7 0 0 0 60.31 4l84-145.31 167.3-13.2c27.85-2.2 41.08-35.38 22.4-56.14L839.56 290.75l39.13-163.19C884 105.29 866.54 85.92 846 85.92a33.89 33.89 0 0 0-13.78 3l-153.33 68.19-143.11-87.66a33.4 33.4 0 0 0-17.55-5zM267.36 623.38l29.64 30 23.65 23.93 33.12-5.91 41.53-7.4-19.38 37.47-15.45 29.89L376.32 761l19.89 37.21-41.63-6.85-33.2-5.47-23.32 24.26-29.24 30.4-6.35-41.7-5.06-33.27-30.27-14.69-38-18.41 37.7-18.92L257 698.49l4.61-33.33 5.79-41.78m-33.88-118.49a16.36 16.36 0 0 0-16.33 14.17l-19 137.33-123.92 62.19a16.4 16.4 0 0 0 0.2 29.41L199.2 808.5l20.85 137.06a16.38 16.38 0 0 0 16.31 14 16.12 16.12 0 0 0 11.73-5l96.1-99.92L481 877.06a17.77 17.77 0 0 0 2.78 0.23 16.41 16.41 0 0 0 14.35-24.14l-65.36-122.28 63.69-123.14a16.41 16.41 0 0 0-14.45-24 17.24 17.24 0 0 0-3 0.27l-136.48 24.41-97.43-98.63a16.12 16.12 0 0 0-11.58-4.89zM822.7 742.55l-0.05 10.4-0.13 29.44 24.18 16.8 8.54 5.93-9.91 3.17-28 9-8.5 28.19-3 9.95-6.12-8.43-17.2-23.89-29.43 0.62-10.4 0.22 6.15-8.39 17.41-23.74-9.68-27.82-3.43-9.82 9.88 3.26 28 9.22 23.45-17.8 8.28-6.29M862.63 646a16.16 16.16 0 0 0-9.82 3.36l-72.26 54.87-86.17-28.42a16.59 16.59 0 0 0-5.2-0.85 16.38 16.38 0 0 0-15.36 21.76l29.85 85.68L650 855.57a16.35 16.35 0 0 0 13.15 26h0.38l90.71-1.91 53 73.64a16.09 16.09 0 0 0 13.21 6.8 16.26 16.26 0 0 0 15.72-11.63l26.21-86.86L948.82 834a16.35 16.35 0 0 0 4.34-29l-74.51-51.8 0.4-90.73A16.36 16.36 0 0 0 862.63 646z"
    ]
  },
  message: {
    path: [
      "M341.333333 405.333333h341.333334c12.8 0 21.333333-8.533333 21.333333-21.333333s-8.533333-21.333333-21.333333-21.333333H341.333333c-12.8 0-21.333333 8.533333-21.333333 21.333333s10.666667 21.333333 21.333333 21.333333zM341.333333 533.333333h256c12.8 0 21.333333-8.533333 21.333334-21.333333s-8.533333-21.333333-21.333334-21.333333H341.333333c-12.8 0-21.333333 8.533333-21.333333 21.333333s10.666667 21.333333 21.333333 21.333333z",
      "M957.866667 448c0-211.2-200.533333-381.866667-445.866667-381.866667-247.466667 0-448 170.666667-448 381.866667 0 108.8 66.133333 217.6 181.333333 294.4 10.666667 6.4 23.466667 4.266667 29.866667-6.4 6.4-10.666667 4.266667-23.466667-6.4-29.866667C209.066667 665.6 106.666667 578.133333 106.666667 448c0-187.733333 181.333333-339.2 405.333333-339.2 221.866667 0 403.2 151.466667 403.2 339.2S733.866667 787.2 512 787.2c-2.133333 0-4.266667 0-6.4 2.133333-10.666667-4.266667-21.333333 2.133333-25.6 12.8-8.533333 25.6-70.4 66.133333-125.866667 96 23.466667-76.8 12.8-89.6 8.533334-96-4.266667-6.4-12.8-10.666667-21.333334-10.666666-12.8 0-21.333333 8.533333-21.333333 21.333333 0 6.4 2.133333 10.666667 6.4 14.933333 0 17.066667-14.933333 66.133333-27.733333 104.533334-2.133333 8.533333 0 17.066667 6.4 23.466666 4.266667 4.266667 8.533333 6.4 14.933333 6.4 2.133333 0 6.4 0 8.533333-2.133333 25.6-10.666667 151.466667-68.266667 185.6-128 245.333333-2.133333 443.733333-172.8 443.733334-384z"
    ]
  },
  drag: {
    path: "M682.666667 554.666667l297.130666 173.312-126.848 36.266666 90.666667 157.056-73.898667 42.666667-90.666666-157.013333-94.848 91.733333L682.666667 554.666667z m-85.333334-298.666667h85.333334v85.333333h213.333333a42.666667 42.666667 0 0 1 42.666667 42.666667v170.666667h-85.333334v-128H426.666667v426.666666h170.666666v85.333334H384a42.666667 42.666667 0 0 1-42.666667-42.666667v-213.333333H256v-85.333334h85.333333V384a42.666667 42.666667 0 0 1 42.666667-42.666667h213.333333V256zM170.666667 597.333333v85.333334H85.333333v-85.333334h85.333334z m0-170.666666v85.333333H85.333333v-85.333333h85.333334z m0-170.666667v85.333333H85.333333V256h85.333334z m0-170.666667v85.333334H85.333333V85.333333h85.333334z m170.666666 0v85.333334H256V85.333333h85.333333z m170.666667 0v85.333334h-85.333333V85.333333h85.333333z m170.666667 0v85.333334h-85.333334V85.333333h85.333334z"
  },
  form: {
    path: [
      "M750.933333 170.666667a34.133333 34.133333 0 0 0 0 68.266666 68.266667 68.266667 0 0 1 68.266667 68.266667v512a68.266667 68.266667 0 0 1-68.266667 68.266667H273.066667a68.266667 68.266667 0 0 1-68.266667-68.266667V307.2a68.266667 68.266667 0 0 1 68.266667-68.266667 34.133333 34.133333 0 0 0 0-68.266666 136.533333 136.533333 0 0 0-136.533334 136.533333v512a136.533333 136.533333 0 0 0 136.533334 136.533333h477.866666a136.533333 136.533333 0 0 0 136.533334-136.533333V307.2a136.533333 136.533333 0 0 0-136.533334-136.533333z",
      "M375.466667 477.866667h273.066666a34.133333 34.133333 0 0 0 0-68.266667h-273.066666a34.133333 34.133333 0 0 0 0 68.266667z m0 204.8h273.066666a34.133333 34.133333 0 0 0 0-68.266667h-273.066666a34.133333 34.133333 0 0 0 0 68.266667z m34.133333-443.733334h204.8a34.133333 34.133333 0 0 0 34.133333-34.133333 136.533333 136.533333 0 0 0-273.066666 0 34.133333 34.133333 0 0 0 34.133333 34.133333z m102.4-102.4a68.266667 68.266667 0 0 1 58.709333 34.133334h-117.418666A68.266667 68.266667 0 0 1 512 136.533333z"
    ]
  },
  feedback: {
    path: [
      "M855.552 270.0288H175.4624c-3.9936 0-7.0656 3.0208-7.0656 6.4512v436.3776h139.1616c15.0528 0 27.2896 12.2368 27.2896 27.3408v120.576l122.6752-127.5904 11.4176-11.9296c5.1712-5.3248 12.288-8.3968 19.712-8.3968h359.936c3.9936 0 7.0656-2.9696 7.0656-6.4V270.0288zM280.2176 767.488H141.056a27.2896 27.2896 0 0 1-27.2896-27.2896V276.48c0-33.792 27.6992-61.0304 61.6448-61.0304h707.4816c15.104 0 27.3408 12.1856 27.3408 27.2896v463.7184a61.44 61.44 0 0 1-61.696 61.0304H500.2752l-3.3792 3.5328-169.728 176.4352a27.2896 27.2896 0 0 1-47.0016-18.944V767.488z",
      "M560.9984 327.68l-8.1408 218.4704H498.432L490.8032 327.68h70.144z m-35.328 268.544c11.4688 0 21.6064 3.7888 29.4912 11.6736 7.68 7.68 11.6736 17.4592 11.6736 28.6208a40.0896 40.0896 0 0 1-12.0832 29.4912A42.3936 42.3936 0 0 1 496.5888 665.6a39.424 39.424 0 0 1-11.6736-29.0816 37.376 37.376 0 0 1 11.6736-28.6208 39.424 39.424 0 0 1 29.0816-11.6736z"
    ]
  },
  code: {
    path: "M377.558543 489.629503l67.034742 66.925249-134.025483 133.787052-67.014276-66.838268L377.558543 489.629503zM556.630988 690.733731l223.376487 0 0-89.436962L556.630988 601.296769 556.630988 690.733731zM958.70846 243.936755l0 536.105001c0 98.730629-79.927377 178.744987-178.700985 178.744987L243.903497 958.786743c-98.599645 0-178.61298-80.013335-178.61298-178.744987L65.290517 243.936755c0-98.730629 80.013335-178.722474 178.61298-178.722474l536.105001 0C878.781082 65.213257 958.70846 145.205103 958.70846 243.936755zM869.44546 288.612257c0-74.015737-60.119239-133.981481-134.113487-133.981481L288.578999 154.630776c-73.994248 0-134.027529 59.965743-134.027529 133.981481l0 446.775486c0 74.015737 60.033281 133.961014 134.027529 133.961014l446.752973 0c73.994248 0 134.113487-59.945277 134.113487-133.961014L869.44546 288.612257zM243.553527 355.842451l134.005017 133.787052 0.021489-0.021489 67.01223 66.946738 67.100234-66.946738L310.567803 289.00623 243.553527 355.842451z"
  },
  layout: {
    path: "M365.714286 969.142857h566.857143c20.228571 0 36.571429-16.342857 36.571428-36.571428V315.428571H365.714286v653.714286z m566.857143-914.285714H365.714286v187.428571h603.428571V91.428571c0-20.228571-16.342857-36.571429-36.571428-36.571428z m-877.714286 36.571428v841.142858c0 20.228571 16.342857 36.571429 36.571428 36.571428h201.142858V54.857143H91.428571c-20.228571 0-36.571429 16.342857-36.571428 36.571428z"
  },
  data: {
    path: [
      "M511.654442 955.724413l-382.972425-222.547256L127.316696 290.813286l382.972426 222.547256 1.36532 442.363871z",
      "M511.654442 1023.990443a64.170068 64.170068 0 0 1-34.815675-9.557244l-382.289765-221.864596a68.26603 68.26603 0 0 1-34.133015-59.391446L59.050667 290.813286a68.26603 68.26603 0 0 1 34.133014-59.391446 68.26603 68.26603 0 0 1 68.26603 0l382.972426 222.547256a68.26603 68.26603 0 0 1 34.133014 58.708786V955.724413a68.26603 68.26603 0 0 1-68.266029 68.26603zM195.582726 694.26552l245.757706 142.676002V552.272179L195.582726 409.596177z",
      "M510.289122 581.626571a68.26603 68.26603 0 0 1-34.815675-9.557244L93.183681 349.522071a68.26603 68.26603 0 0 1 0-118.100231L478.204088 8.874584a68.26603 68.26603 0 0 1 68.266029 0l382.289766 221.864596a68.26603 68.26603 0 0 1 34.133014 59.391445 68.26603 68.26603 0 0 1-34.133014 58.708786L544.422137 572.069327a68.26603 68.26603 0 0 1-34.133015 9.557244zM263.848755 290.813286l246.440367 143.358662 248.488347-143.358662-246.440366-143.358662z",
      "M511.654442 1023.990443a68.26603 68.26603 0 0 1-34.133014-8.874584 68.26603 68.26603 0 0 1-34.133015-59.391446V513.360542a68.26603 68.26603 0 0 1 34.133015-59.391446l385.020406-222.547256a68.26603 68.26603 0 0 1 68.26603 0 68.26603 68.26603 0 0 1 34.133014 59.391446v442.363871a68.26603 68.26603 0 0 1-34.133014 59.391446l-385.020407 222.547256a68.26603 68.26603 0 0 1-34.133015 8.874584z m68.26603-471.718264v285.352003l249.171008-143.358662V408.913517z"
    ]
  },
  icon: {
    path: "M871.424 61.44q18.432 0 34.816 6.656t28.672 18.944 19.456 28.672 7.168 35.84v720.896q0 38.912-25.088 64.512t-62.976 25.6h-721.92q-40.96 0-66.048-26.624t-25.088-66.56V150.528q0-35.84 24.576-62.464t65.536-26.624h720.896z m-237.568 768q18.432 0 26.624-8.704t8.192-23.04q0-13.312-8.192-22.528t-26.624-9.216h-62.464q1.024-2.048 1.024-6.144V251.904h63.488q18.432 0 25.6-9.216t7.168-22.528-7.168-22.528-25.6-9.216H386.048q-18.432 0-25.6 9.216t-7.168 22.528 7.168 22.528 25.6 9.216h57.344v507.904q0 2.048 0.512 3.072t0.512 3.072h-56.32q-18.432 0-26.624 9.216t-8.192 22.528q0 14.336 8.192 23.04t26.624 8.704h245.76z"
  },
  component: {
    path: "M877.710524 475.426534a146.285087 146.285087 0 0 0-73.142544 20.479912v-219.427631a57.051184 57.051184 0 0 0-57.782609-57.051184h-219.427631a139.702258 139.702258 0 0 0 21.211338-73.142544 146.285087 146.285087 0 0 0-292.570175 0 146.285087 146.285087 0 0 0 20.479912 73.142544H62.902588a63.634013 63.634013 0 0 0-62.902588 63.634013v212.844802a139.702258 139.702258 0 0 1 73.142544-20.479912 146.285087 146.285087 0 0 1 0 292.570175 139.702258 139.702258 0 0 1-73.142544-20.479913v219.427631a57.051184 57.051184 0 0 0 57.051184 57.051184h689.734187a57.051184 57.051184 0 0 0 57.782609-57.051184v-219.427631a146.285087 146.285087 0 1 0 73.142544-272.090262z"
  },
  "base-component": {
    path: [
      "M587.921446 661.119082h-8.080344a95.494978 95.494978 0 0 0-57.296987 0A16.895265 16.895265 0 0 0 514.46377 661.119082V546.525108a36.728838 36.728838 0 0 0-36.728837-36.728838H360.937228a105.044476 105.044476 0 0 0 0-73.457676 109.451937 109.451937 0 0 0-207.150646 0 105.044476 105.044476 0 0 0 0 73.457676H40.661762a40.401722 40.401722 0 0 0-40.401722 40.401721V661.119082a102.106169 102.106169 0 0 1 36.728838-6.611191A110.186514 110.186514 0 0 1 147.175392 766.898135a100.637016 100.637016 0 0 1-11.018652 47.012912 108.71736 108.71736 0 0 1-99.167862 63.173601 102.106169 102.106169 0 0 1-36.728838-6.61119v116.797704a6.611191 6.611191 0 0 0 0 3.672884 34.525108 34.525108 0 0 0 32.321378 32.321377H477.734933a36.728838 36.728838 0 0 0 36.728837-36.728838v-116.063127a105.044476 105.044476 0 0 0 73.457676 0A109.451937 109.451937 0 0 0 587.921446 661.119082z",
      "M918.480987 293.830703a120.470588 120.470588 0 0 0-36.728838 6.611191V183.644189a36.728838 36.728838 0 0 0-36.728838-36.728837H728.225607a102.106169 102.106169 0 0 0 6.611191-36.728838 110.186514 110.186514 0 0 0-220.373028 0 120.470588 120.470588 0 0 0 6.611191 36.728838H407.950141a40.401722 40.401722 0 0 0-40.401722 40.401721v113.124821A102.106169 102.106169 0 0 1 404.277257 293.830703 110.186514 110.186514 0 0 1 514.46377 404.017217a96.229555 96.229555 0 0 1-5.142037 32.321377h36.728838a41.136298 41.136298 0 0 1 41.870875 41.870875v146.915352a141.038737 141.038737 0 0 1 64.642755 35.994261h192.45911a36.728838 36.728838 0 0 0 36.728838-36.728838V507.592539a120.470588 120.470588 0 0 0 36.728838 6.611191 110.186514 110.186514 0 0 0 0-220.373027z"
    ]
  },
  loading: {
    path: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"
  },
  home: {
    path: "M1013.248 486.4l-476.16-476.16c-13.824-13.824-35.84-13.824-49.664 0l-476.16 476.16c-22.016 22.016-6.656 59.904 25.088 59.904H112.64v404.48c0 40.448 32.768 73.216 73.216 73.216h120.32c33.28 0 59.904-27.136 59.904-59.904v-86.016c0-40.448 32.768-73.216 73.216-73.216h146.432c40.448 0 73.216 32.768 73.216 73.216v86.016c0 33.28 27.136 59.904 59.904 59.904h118.784c40.448 0 73.216-32.768 73.216-73.216v-404.48H988.16c31.232 0 47.104-37.888 25.088-59.904z"
  },
  radio: {
    path: "M512 65.984C266.08 65.984 65.984 266.08 65.984 512c0 245.952 200.064 446.016 446.016 446.016 245.952 0 446.016-200.064 446.016-446.016C958.016 266.08 757.952 65.984 512 65.984zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160S600.224 672 512 672z"
  },
  ellipsis: {
    path: "M176 511a56 56 0 1 0 112 0 56 56 0 1 0-112 0zM456 511a56 56 0 1 0 112 0 56 56 0 1 0-112 0zM736 511a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"
  },
  leftArrow: {
    path: "M729.6 931.2l-416-425.6 416-416c9.6-9.6 9.6-25.6 0-35.2-9.6-9.6-25.6-9.6-35.2 0l-432 435.2c-9.6 9.6-9.6 25.6 0 35.2l432 441.6c9.6 9.6 25.6 9.6 35.2 0C739.2 956.8 739.2 940.8 729.6 931.2z"
  },
  rightArrow: {
    path: "M761.6 489.6l-432-435.2c-9.6-9.6-25.6-9.6-35.2 0-9.6 9.6-9.6 25.6 0 35.2l416 416-416 425.6c-9.6 9.6-9.6 25.6 0 35.2s25.6 9.6 35.2 0l432-441.6C771.2 515.2 771.2 499.2 761.6 489.6z"
  },
  no: {
    path: "M902.741 816.213l-306.005-307.2L894.72 205.056c18.859-18.859 18.859-49.323 0-68.181s-36.01-18.859-54.87 0L532.396 444.416 226.048 136.875c-18.859-18.859-49.323-18.859-68.181 0s-18.859 49.322 0 68.181L464.81 512 157.952 818.944c-18.859 18.859-18.859 49.323 0 68.181s49.323 18.859 68.181 0l303.787-309.93 309.93 309.93c18.86 18.859 44.033 16.128 62.806-2.645s18.944-49.408 0.085-68.267z"
  },
  yes: {
    viewBox: "0 0 1024 1024",
    path: "M939.126472 312.141136 939.126472 312.141136 449.642279 801.685705c-11.582803 11.605316-27.561729 18.733667-45.196365 18.733667-17.593703 0-33.549094-7.128351-45.131897-18.733667L82.546529 524.989849c-11.523451-11.533684-18.671245-27.528983-18.671245-45.090964 0-35.270295 28.595268-63.938218 63.866586-63.938218 17.633612 0 33.612539 7.188726 45.195342 18.721387l231.509724 231.562936 444.391183-444.452581c11.56336-11.531638 27.561729-18.649755 45.215808-18.649755 35.228339 0 63.866586 28.586059 63.866586 63.865563C957.920514 284.58964 950.792163 300.619732 939.126472 312.141136"
  },
  unFold: {
    path: "M867.1 141.17H156.08c-17.67 0-32 14.33-32 32s14.33 32 32 32H867.1c17.67 0 32-14.33 32-32s-14.33-32-32-32zM867.92 367.52H403.2c-17.67 0-32 14.33-32 32s14.33 32 32 32h464.73c17.67 0 32-14.33 32-32s-14.33-32-32.01-32zM867.92 573.87H403.2c-17.67 0-32 14.33-32 32s14.33 32 32 32h464.73c17.67 0 32-14.33 32-32s-14.33-32-32.01-32zM867.92 800.22H156.9c-17.67 0-32 14.33-32 32s14.33 32 32 32h711.02c17.67 0 32-14.33 32-32 0-17.68-14.32-32-32-32zM312.01 367.52v270.35L137.47 489.71z"
  },
  fold: {
    path: "M867.1 141.17H156.08c-17.67 0-32 14.33-32 32s14.33 32 32 32H867.1c17.67 0 32-14.33 32-32s-14.33-32-32-32zM867.92 367.52H403.2c-17.67 0-32 14.33-32 32s14.33 32 32 32h464.73c17.67 0 32-14.33 32-32s-14.33-32-32.01-32zM867.92 573.87H403.2c-17.67 0-32 14.33-32 32s14.33 32 32 32h464.73c17.67 0 32-14.33 32-32s-14.33-32-32.01-32zM867.92 800.22H156.9c-17.67 0-32 14.33-32 32s14.33 32 32 32h711.02c17.67 0 32-14.33 32-32 0-17.68-14.32-32-32-32zM137.47 637.87V367.52l174.54 148.15z"
  },
  block: {
    path: "M830.464 63.488q26.624 0 50.176 12.288t41.472 31.232 28.672 43.008 10.752 46.592l0 635.904q0 23.552-11.264 46.592t-30.208 41.472-43.008 30.208-48.64 11.776l-641.024 0q-22.528 0-44.544-10.752t-39.424-28.16-28.16-40.96-10.752-50.176l0-633.856q0-25.6 10.752-50.176t29.696-43.52 43.52-30.208 52.224-11.264l629.76 0z"
  },
  appManage: {
    path: "M891.52 1018.24h-262.4c-47.36 0-85.76-39.04-85.76-87.04v-266.24c0-48 38.4-87.04 85.76-87.04h262.4c47.36 0 85.76 39.04 85.76 87.04v266.24c0 48-38.4 87.04-85.76 87.04z m-262.4-375.04c-12.16 0-21.76 9.6-21.76 21.76v266.24c0 12.16 9.6 21.76 21.76 21.76h262.4c11.52 0 21.12-9.6 21.12-21.76v-266.24c0-12.16-9.6-21.76-21.12-21.76h-262.4zM760.32 531.2c-21.76 0-44.16-8.32-60.8-25.6L526.08 329.6c-33.28-33.92-33.28-88.96 0-122.88L699.52 30.72c33.28-33.92 87.68-33.92 120.96 0l173.44 176c33.28 33.92 33.28 88.96 0 122.88l-172.8 176c-16.64 17.28-39.04 25.6-60.8 25.6z m0-460.8c-5.76 0-10.88 1.92-15.36 6.4L571.52 252.8c-8.32 8.32-8.32 22.4 0 30.72l173.44 176c8.32 8.32 21.76 8.32 30.08 0l173.44-176c8.32-8.32 8.32-22.4 0-30.72l-172.8-176a23.616 23.616 0 0 0-15.36-6.4zM352.64 1018.24h-262.4c-47.36 0-85.76-39.04-85.76-87.04v-266.24c0-48 38.4-87.04 85.76-87.04h262.4c47.36 0 85.76 39.04 85.76 87.04v266.24c0 48-38.4 87.04-85.76 87.04z m-262.4-375.04c-12.16 0-21.76 9.6-21.76 21.76v266.24c0 12.16 9.6 21.76 21.76 21.76h262.4c11.52 0 21.12-9.6 21.12-21.76v-266.24c0-12.16-9.6-21.76-21.12-21.76h-262.4zM352.64 480.64h-262.4C42.88 480.64 4.48 441.6 4.48 393.6V126.72c0-48 38.4-87.04 85.76-87.04h262.4c47.36 0 85.76 39.04 85.76 87.04v266.24c0 48-38.4 87.68-85.76 87.68z m-262.4-375.68c-12.16 0-21.76 9.6-21.76 21.76v266.24c0 12.16 9.6 21.76 21.76 21.76h262.4c11.52 0 21.12-9.6 21.12-21.76V126.72c0-12.16-9.6-21.76-21.12-21.76h-262.4z"
  }
};
function At(r) {
  const { prefixCls: e, className: t, type: n, size: i, width: a, height: o, fill: s = "currentColor", ...l } = r, { viewBox: u = "0 0 1024 1024", path: f = "" } = Gw[n];
  return n === "loading" ? l.className = dist_Y(l.className, "au-rotate") : l.className = dist_Y(l.className), react.createElement("svg", { viewBox: u, version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: a || i || "1em", height: o || i || "1em", ...l }, jr(f) ? f.map((c, h) => react.createElement("path", { key: h, d: c, fill: s })) : react.createElement("path", { d: f, fill: s }));
}
function Hw(r) {
  const { value: e, defaultValue: t, children: n, className: i, label: a, onChange: o } = r, [s, l] = A.useState(!1);
  A.useEffect(() => {
    if (!dist_ue(e)) {
      e !== s && l(e);
      return;
    }
    if (!dist_ue(t)) {
      s !== t && l(!!t);
      return;
    }
    l(!1);
  }, [e, t]);
  const u = () => {
    const f = {
      target: {
        value: !s
      }
    };
    o ? o(f) : l(f.target.value);
  };
  return A.createElement(
    "span",
    { className: dist_Y("au-checkbox", i), style: r.style || {} },
    A.createElement(
      "span",
      { className: "au-checkbox-item", onClick: u },
      A.createElement("div", { className: dist_Y("au-checkbox-icon", {
        "au-checkbox-select": s
      }) }, s && A.createElement(At, { type: "yes", size: 12, fill: "#fff" })),
      A.createElement("label", null, n || a || "")
    )
  );
}
function $w(r) {
  const { value: e, defaultValue: t, className: n, onChange: i, options: a = [] } = r, [o, s] = A.useState([]);
  A.useEffect(() => {
    if (!dist_ue(e)) {
      if (wt(e)) {
        !Cr(e, o) && s(e);
        return;
      }
      s([]);
      return;
    }
    if (!dist_ue(t)) {
      if (wt(t)) {
        !Cr(o, t) && s(t);
        return;
      }
      s([]);
      return;
    }
    s([]);
  }, [e, t]);
  const l = (u) => {
    if (u.disabled)
      return;
    const f = {
      target: {
        value: []
      }
    };
    let c = !1;
    for (let h = 0; h < o.length; h++) {
      if (Cr(o[h], u.value)) {
        c = !0;
        continue;
      }
      f.target.value.push(o[h]);
    }
    c || f.target.value.push(u.value), i ? i(f) : s(f.target.value);
  };
  return A.createElement("span", { className: dist_Y("au-checkbox", n) }, wt(a) && a.map((u, f) => A.createElement(
    "span",
    { className: dist_Y("au-checkbox-item", {
      disabled: u.disabled
    }), key: f, onClick: () => l(u) },
    A.createElement("span", { className: dist_Y("au-checkbox-icon", {
      "au-checkbox-select": o.includes(u.value)
    }) }, o && A.createElement(At, { type: "yes", size: 12, fill: "#fff" })),
    A.createElement("label", null, u.label || u.value || "")
  )));
}
function xB(r) {
  return wt(r.options) ? A.createElement($w, { ...r }) : A.createElement(Hw, { ...r });
}
const Ww = (r) => {
  const e = !dist_ue(r.value), t = !dist_ue(r.onChange);
  return e && !t && (r.onChange = () => {
  }), !e && t && (r.value = ""), r;
};
function Uw(r) {
  const e = () => {
    const { mode: t = "text", className: n, ...i } = r, a = {
      inputMode: "text",
      className: dist_Y("au-input", n),
      ...i
    };
    return Ww(a), a;
  };
  return A.createElement("input", { ...e() });
}
function Yw(r) {
  const { value: e = [], defaultValue: t, className: n, onBlur: i, onChange: a = () => {
  }, ...o } = r, [s, l] = A.useState(""), [u, f] = A.useState([]), c = (v) => {
    f(u.filter((d) => !(!dist_ue(d.id) && d.id === v.id)));
  };
  A.useEffect(() => {
    if (e !== s && (dist_ue(e) || e === "")) {
      l("");
      return;
    }
  }, [e]);
  const h = () => (/* @__PURE__ */ new Date()).getTime() + "_" + u.length;
  return A.createElement(
    "div",
    { className: dist_Y("au-input-tags", n) },
    wt(u) && u.map((v) => {
      const { value: d, id: g, label: p = "" } = v;
      return A.createElement(
        "div",
        { className: "au-input-tags-item", title: p, key: g || d },
        p,
        A.createElement(At, { type: "close", onClick: () => c(v) })
      );
    }),
    A.createElement("input", { value: s, inputMode: "text", onChange: (v) => {
      a && a(v), l(v.target.value);
    }, onKeyUp: (v) => {
      dist_ue(s) || s === "" || v.code === "Enter" && (f([
        ...u,
        {
          id: h() + s,
          value: s,
          label: s
        }
      ]), l(""));
    } })
  );
}
function Xw(r) {
  const { value: e = "", defaultValue: t, className: n, onBlur: i, onChange: a = () => {
  }, ...o } = r, [s, l] = A.useState(e), u = (f) => {
    const c = Number(f.target.value);
    if (!it(c))
      return;
    const h = c, v = {
      target: {
        value: h
      }
    };
    l(h), a && a(v);
  };
  return A.useEffect(() => {
    if (e !== s) {
      if (dist_ue(e) || e === "") {
        l("");
        return;
      }
      if (it(e)) {
        l(e);
        return;
      }
    }
  }, [e]), A.createElement("input", { value: s, type: "number", inputMode: "numeric", className: dist_Y("au-input-number", n), onBlur: (f) => {
    i && i(f);
    const c = Number(s).toString();
    l(c);
  }, onChange: u, ...o });
}
function Zw(r) {
  const { mode: e = "text", ...t } = r;
  switch (e) {
    case "number":
      return A.createElement(Xw, { ...t });
    case "tags":
      return A.createElement(Yw, { ...t });
    default:
      return A.createElement(Uw, { ...t });
  }
}
function qw(r) {
  const { value: e, defaultValue: t, children: n, className: i, label: a, onChange: o } = r, [s, l] = A.useState(!1);
  A.useEffect(() => {
    if (!dist_ue(e)) {
      e !== s && l(e);
      return;
    }
    if (!dist_ue(t)) {
      s !== t && l(!!t);
      return;
    }
    l(!1);
  }, [e, t]);
  const u = () => {
    const f = {
      target: {
        value: !s
      }
    };
    o ? o(f) : l(f.target.value);
  };
  return A.createElement(
    "span",
    { className: dist_Y("au-radio", i), style: r.style || {} },
    A.createElement(
      "span",
      { className: "au-radio-item", onClick: u },
      A.createElement("span", { className: dist_Y("au-radio-icon", {
        "au-radio-select": s
      }) }),
      A.createElement("label", null, n || a || "")
    )
  );
}
function Kw(r) {
  const { value: e, defaultValue: t, className: n, onChange: i, options: a = [] } = r, [o, s] = A.useState(void 0);
  A.useEffect(() => {
    if (!dist_ue(e)) {
      e !== o && s(e);
      return;
    }
    if (!dist_ue(t)) {
      o !== t && s(t);
      return;
    }
    s(void 0);
  }, [e, t]);
  const l = (u) => {
    if (u.disabled || Cr(u.value, o))
      return;
    const f = {
      target: {
        value: u.value
      }
    };
    i ? i(f) : s(f.target.value);
  };
  return A.createElement("span", { className: dist_Y("au-radio", n) }, wt(a) && a.map((u, f) => {
    const c = Cr(u.value, o);
    return A.createElement(
      "span",
      { className: dist_Y("au-radio-item", {
        disabled: u.disabled
      }), key: f, onClick: () => l(u) },
      A.createElement("span", { className: dist_Y("au-radio-icon", {
        "au-radio-select": c
      }) }),
      A.createElement("label", null, u.label || u.value || "")
    );
  }));
}
function CB(r) {
  return wt(r.options) ? A.createElement(Kw, { ...r }) : A.createElement(qw, { ...r });
}
const jw = (r, e) => {
  if (e !== void 0) {
    for (let t = 0; t < r.length; t++)
      if (r[t].value === e)
        return r[t].label;
  }
};
function Jw(r) {
  const { className: e, name: t, options: n = [], placeholder: i = "", open: a = !1, defaultValue: o, value: s, disabled: l = !1, onChange: u } = r, [f, c] = (0,react.useState)(a), [h, v] = (0,react.useState)(!1), [d, g] = (0,react.useState)(jr(o) ? o[0] : o);
  return react.useEffect(() => {
    s !== d && g(jr(s) ? s[0] : s);
  }, [s]), react.createElement(
    "div",
    { className: dist_Y(e, { hidden: l }) },
    react.createElement(
      "div",
      { className: dist_Y("au-select-input", { isHover: f && !l }) },
      react.createElement("input", { key: d, placeholder: i, value: jw(n, d), onFocus: () => c(!0), onClick: () => c(!0), onMouseLeave: () => v(!0), onBlur: () => h && c(!1), readOnly: !0, unselectable: "on" }),
      t && react.createElement("input", { name: t, style: { display: "none" } })
    ),
    !l && react.createElement("div", { className: dist_Y("au-select-options", { "au-select-options-hover": f }), onMouseEnter: () => v(!1), onMouseLeave: () => v(!0) }, n == null ? void 0 : n.map((p, m) => {
      const { value: y, label: _ } = p;
      return react.createElement("div", { key: m.toString(), title: _, onClick: () => {
        u && u({
          target: {
            value: y
          }
        }), g(y), c(!1);
      }, className: dist_Y("au-select-options-item", { selected: d === y }) }, _);
    }))
  );
}
function Qw(r) {
  const { value: e, className: t, options: n = [], onChange: i, placeholder: a = "", open: o = !1, defaultValue: s = [], disabled: l = !1 } = r, [u, f] = (0,react.useState)(o), [c, h] = $h({ options: !0 }), [v, d] = (0,react.useState)(jr(s) ? lp(s) : [s]);
  return react.useEffect(() => {
    if (es(v) !== es(e)) {
      if (dist_ue(e)) {
        d([]);
        return;
      }
      if (jr(e)) {
        d(lp(e));
        return;
      }
      lr(e) && d([e]);
    }
  }, [e]), react.createElement(
    "div",
    { className: dist_Y(t, { hidden: l }) },
    react.createElement(
      "div",
      { tabIndex: 999, className: dist_Y("au-select-mult-input", "au-select-input", { isHover: u && !l }), onMouseLeave: () => h({ inputBox: !0 }), onClick: () => {
        h({ inputBox: !1 }), f(!0);
      }, onBlur: () => {
        !Object.values(c).includes(!1) && f(!1);
      } },
      v.length === 0 && react.createElement("div", { style: { color: "rgb(117,117,117)" } }, a),
      v.map((g, p) => {
        if (lr(g))
          return react.createElement(
            "span",
            { className: "au-select-item", key: p.toString() },
            react.createElement("span", null, g),
            react.createElement(
              "span",
              { className: "icon-close", style: { cursor: "pointer", paddingRight: 5 }, onClick: () => {
                const m = v.filter((_) => _ !== g);
                d(m), i && i({
                  target: {
                    value: m
                  }
                });
              } },
              react.createElement(At, { type: "no", size: 9, fill: "#8a8a94" })
            )
          );
      })
    ),
    !l && react.createElement("div", { className: dist_Y("au-select-options", { "au-select-options-hover": u }), onMouseLeave: () => h({ options: !0 }), onMouseEnter: () => h({ options: !1 }) }, n == null ? void 0 : n.map((g, p) => {
      const { value: m, label: y } = g;
      return react.createElement("div", { tabIndex: p + 999, key: p.toString(), onBlur: () => {
        !Object.values(c).includes(!1) && f(!1);
      }, onClick: () => {
        const _ = v.includes(m) ? v.filter((b) => b !== m) : v.concat(m);
        d(_), i && i({
          target: {
            value: _
          }
        });
      }, className: dist_Y("au-select-options-item", { selected: v.includes(m) }) }, y);
    }))
  );
}
function Qy(r) {
  const { mode: e, className: t, ...n } = r;
  return e == "multiple" ? react.createElement(Qw, { className: dist_Y("au-select", t), ...n }) : react.createElement(Jw, { className: dist_Y("au-select", t), ...n });
}
Qy.Option = Option;
function TB(r) {
  const { value: e = "", onChange: t, className: n, autoZoom: i = !1, onInput: a, ...o } = r, [s, l] = Le(e);
  return A.useEffect(() => {
    e !== s && l(e);
  }, [e]), i ? A.createElement(
    "div",
    { className: dist_Y("au-textarea", n), "data-replicated-value": s },
    A.createElement("textarea", { value: s, onChange: (u) => t && t(u), onInput: (u) => {
      l(u.target.value || ""), a && a(u);
    }, ...o })
  ) : A.createElement(
    "div",
    { className: dist_Y("au-textarea", n) },
    A.createElement("textarea", { onChange: (u) => t && t(u), value: s, onInput: (u) => {
      l(u.target.value || ""), a && a(u);
    }, ...o })
  );
}
function MB(r) {
  const { columns: e, gap: t = 0, className: n, style: i = {}, children: a, ...o } = r, s = e === void 0 ? A.Children.count(a) : e, l = {
    gap: t,
    gridTemplateColumns: `repeat(${s}, 1fr)`,
    ...i
  };
  return A.createElement("div", { className: dist_Y(n, "row"), style: l, ...o }, a);
}
function DB(r) {
  const { className: e, children: t, ...n } = r;
  return A.createElement("div", { className: dist_Y(e, "col"), ...n }, t);
}
function EB(r) {
  const { className: e, children: t, ...n } = r;
  return A.createElement("div", { className: dist_Y(e, "au-flex"), ...n }, t);
}
function eb(r, e) {
  return function(t) {
    const n = r[t];
    if (dist_ue(n))
      return {};
    const { row: i = 1, column: a = 1 } = n, o = Math.ceil((t + 1) / e), s = (t + 1) % e;
    return {
      gridArea: `${o}/${s}/ span ${i} / span ${a}`
    };
  };
}
function tb(r, e) {
  const t = [];
  for (const n in r) {
    if (!it(Number(n)))
      continue;
    const { row: i = 1, column: a = 1 } = r[n];
    if (!(i === 1 && a === 1))
      for (let o = 0; o < i; o++)
        for (let s = 0; s < a; s++)
          o === 0 && s === 0 || t.push(Number(n) + o * e + s);
  }
  return t;
}
function AB(r) {
  const { className: e, fill: t = !0, merge: n = {}, columns: i = 12, rows: a = "auto", maxRows: o = "auto", childClassName: s, childStyle: l = {}, fillChildClassName: u, style: f = {}, children: c, ...h } = r, v = a === "auto" ? o : a, d = A.Children.count(c);
  let g = v == "auto" || t === !1 ? Math.ceil(d / i) * i : v * i, p = g - d;
  it(v) && (g = v * i, p = 0);
  const m = eb(n, i), y = tb(n, i);
  return A.createElement(
    "div",
    { className: dist_Y("au-grid", e), style: {
      gridTemplateColumns: `repeat(${i},1fr)`,
      ...f
    }, ...h },
    A.Children.map(c, (_, S) => {
      if (!(S + 1 > g || y.includes(S))) {
        if (A.isValidElement(_)) {
          const { className: b, style: w, ...x } = _.props;
          return A.cloneElement(_, {
            className: dist_Y(s, b),
            style: {
              ...m(S),
              ...l,
              ...w
            },
            ...x
          });
        }
        return A.createElement("div", { className: dist_Y(s) }, _);
      }
    }),
    t && it(p) && p > 0 && new Array(p).fill(null).map((_, S) => {
      const b = S + d;
      return A.createElement("div", { style: {
        ...l
      }, key: b, className: dist_Y(u, s) });
    })
  );
}
function e3(r) {
  const { fold: e, select: t, onSelect: n, menu: i, selectNames: a = [], selectRecords: o = [], lv: s = 1, className: l, open: u, setOpen: f } = r, c = JSON.parse(u || "[]");
  return A.createElement(A.Fragment, null, i.map((h, v) => {
    const { icon: d, title: g, name: p, path: m = "", children: y } = h, _ = p + m;
    if (!p)
      return;
    const S = () => {
      const I = c.includes(_) ? c.filter((L) => L !== _) : [...c, _];
      f(jy(I));
    }, w = (() => {
      const I = g || p;
      if (e) {
        if (d)
          return;
        if (lr(I))
          return I[0];
      }
      return I;
    })(), x = !e && wt(y), C = x && !c.includes(_), T = [...a, p], E = [...o, h], D = p && a[s - 1] === p && Cr(t.slice(0, s), T.slice(0, s));
    return A.createElement(
      "div",
      { key: p + m + v, className: dist_Y("au-next-menu", "lv" + s, l) },
      A.createElement(
        "div",
        { className: dist_Y("au-next-menu-content", {
          isSelect: D,
          fold: e
        }), title: p, onClick: () => {
          S(), !wt(y) && n && n({ name: p, names: T, record: h, selectRecords: E });
        } },
        A.createElement(
          "div",
          { className: "label" },
          d && A.createElement("div", { className: "icon" }, d),
          A.createElement("div", null, w)
        ),
        x && A.createElement(At, { style: {
          cursor: "pointer"
        }, onClick: () => {
          S();
        }, type: "bottom" })
      ),
      x && A.createElement(
        "div",
        { style: {
          height: C ? 0 : "auto"
        }, className: "au-next-menu-content-children" },
        A.createElement(e3, { lv: s + 1, selectNames: t, menu: y, selectName: T, open: u, setOpen: f, onSelect: n })
      )
    );
  }));
}
function IB(r) {
  const { lv: e = 0, menu: t = [], className: n, selectName: i, selectNames: a, onSelect: o, fold: s, ...l } = r, [u, f] = gw("menu-aside");
  return A.createElement(
    "aside",
    { className: dist_Y("au-menu", "lv" + e, { "au-menu-fold": s }, n), ...l },
    A.createElement(e3, { menu: t, fold: s, selectName: i, selectNames: a, onSelect: o, open: u, setOpen: f })
  );
}
function LB(r) {
  const { footer: e, footerStyle: t, header: n, headerStyle: i, className: a, children: o, ...s } = r;
  return A.createElement(
    "div",
    { className: dist_Y("au-card", a), ...s },
    Wh(n) && A.createElement("div", { className: "au-card-header", style: i }, n),
    A.createElement("div", { className: "au-card-content" }, o),
    Wh(e) && A.createElement("div", { className: "au-card-footer", style: t }, e)
  );
}
const rb = 576, nb = 576, ib = 768, ab = 992, ob = 1200, sb = 1600, hp = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  between: "space-between",
  around: "space-around"
};
function NB(r) {
  const { direction: e = "horizontal", className: t, style: n, children: i, align: a = "start", wrap: o = !0, gap: s = 10, ...l } = r, u = {
    gap: s,
    flexDirection: e === "horizontal" ? "row" : "column",
    justifyContent: hp[a],
    flexWrap: o ? "wrap" : "nowrap",
    ...n
  };
  return e === "vertical" && (u.alignItems = hp[a]), A.createElement("div", { className: dist_Y("au-space", t), style: u, ...l }, i);
}
function lb(r, e) {
  const t = {};
  for (const n in r)
    e.includes(n) || (t[n] = r[n]);
  return t;
}
function ub(r) {
  const { callback: e, props: t, defaultEffectKey: n, defaultValue: i } = r, a = Oi(null), o = lb(t, ["xxl", "xl", "lg", "md", "sm", "xs"]);
  function s(l) {
    return !dist_ue(t.xxl) && l > sb ? e(t.xxl, "xxl") : !dist_ue(t.xl) && l > ob ? e(t.xl, "xl") : !dist_ue(t.lg) && l > ab ? e(t.lg, "lg") : !dist_ue(t.md) && l > ib ? e(t.md, "md") : !dist_ue(t.sm) && l > nb ? e(t.sm, "sm") : !dist_ue(t.xs) && l < rb ? e(t.xs, "xs") : dist_ue(t[n]) ? e(i, n) : e(t[n], n);
  }
  return ws(() => {
    if (dist_ue(a.current))
      return;
    const { width: l } = a.current.getBoundingClientRect();
    s(l);
    const u = new ResizeObserver(vd(() => {
      if (dist_ue(a.current))
        return;
      const { width: f } = a.current.getBoundingClientRect();
      s(f);
    }, 50));
    return u.observe(a.current), () => {
      a.current && u.unobserve(a.current);
    };
  }, [a.current]), {
    ref: a,
    props: o
  };
}
function PB(r) {
  const { count: e = 2, xGap: t = 10, yGap: n = 10, children: i, style: a = {}, type: o, ...s } = r, [l, u] = Le(e), { ref: f, props: c } = ub({
    callback: (h) => {
      u(h);
    },
    defaultValue: e,
    defaultEffectKey: "count",
    props: s
  });
  if (o === "x") {
    const h = new Array(e).fill("").map(() => new Array());
    return A.Children.map(i, (v, d) => {
      h[d % e].push(v);
    }), A.createElement("div", { ref: f, style: {
      display: "grid",
      gridTemplateColumns: `repeat(${e}, 1fr)`,
      gap: t,
      ...a
    }, ...c }, h.map((v, d) => A.createElement("div", { key: d }, v.map((g, p) => {
      const m = {
        marginBottom: n
      };
      return A.createElement("div", { key: p, style: m }, g);
    }))));
  }
  return A.createElement("div", { ref: f, style: {
    columnCount: l,
    gap: t,
    ...a
  }, ...c }, A.Children.map(i, (h) => {
    const v = {
      overflow: "hidden",
      breakInside: "avoid",
      marginBottom: n
    };
    if (Qo(n) || (v.marginBottom = n), A.isValidElement(h)) {
      const d = { ...h.props };
      return d.style = { ...v, ...d.style }, A.cloneElement(h, d);
    }
    return A.createElement("div", { style: v }, h);
  }));
}
function RB(r) {
  const { open: e = !1, children: t, className: n, title: i, onCancel: a, hiddenCancel: o = !1, onOk: s, hiddenOk: l = !1, maskClosable: u = !1 } = r;
  return e === !1 ? A.createElement("div", null) : A.createElement(
    "div",
    { className: dist_Y("au-dialog", n) },
    A.createElement("div", { className: "au-dialog-mask", onClick: () => u && a && a() }),
    A.createElement(
      "div",
      { className: "au-dialog-layout" },
      Wh(i) && A.createElement(
        "div",
        { className: "au-dialog-header" },
        A.createElement("div", { className: "au-dialog-header-label" }, i),
        A.createElement(
          "div",
          { className: "au-dialog-header-logo-close", onClick: () => {
            a && a();
          } },
          A.createElement(At, { type: "no", size: 16, fill: "currentColor" })
        )
      ),
      A.createElement("div", { className: "au-dialog-body" }, t),
      A.createElement(
        "div",
        { className: "au-dialog-footer" },
        A.createElement(
          "div",
          { className: "au-dialog-footer-controls" },
          !o && a && A.createElement(cp, { onClick: () => a() }, "Cancel"),
          !l && s && A.createElement(cp, { type: "primary", onClick: () => {
            s();
          } }, "OK")
        )
      )
    )
  );
}
const Tt = 10, fb = (r) => {
  const { placement: e, childSize: t, popSize: n } = r, i = {}, a = {}, o = {};
  return !t || !t.width || !e || !n || !n.width ? {
    arrowStyle: i,
    innerStyle: a,
    popStyle: o
  } : (e.indexOf("top") === 0 && (o.top = -Tt - n.height, o.left = (t.width - n.width) / 2, i.bottom = 1 - Tt / 2, i.left = (n.width - Tt) / 2), e === "topLeft" && (o.left = 0, i.left = (n.width - t.width) / 2 + 8), e === "topRight" && (o.left = t.width - n.width, i.left = t.width - 8), e.indexOf("bottom") === 0 && (o.top = Tt / 2 + t.height, o.left = (t.width - n.width) / 2, i.top = 2 - Tt / 2, i.left = (n.width - Tt) / 2), e === "bottomLeft" && (o.left = 0, i.left = (n.width - t.width) / 2 + 8), e === "bottomRight" && (o.left = t.width - n.width, i.left = t.width - 8), e.indexOf("left") === 0 && (o.left = -Tt - n.width, o.top = (t.height - n.height) / 2, i.right = 1 - Tt / 2, i.top = (n.height - Tt) / 2), e === "leftTop" && (o.top = 0, i.top = 8), e === "leftBottom" && (o.top = t.height - n.height, i.top = n.height - Tt - 8), e.indexOf("right") === 0 && (o.left = Tt + t.width, o.top = (t.height - n.height) / 2, i.left = -Tt / 2 + 1, i.top = t.height / 2), e === "rightTop" && (o.top = 0, i.top = 8), e === "rightBottom" && (o.top = t.height - n.height, i.top = n.height - Tt - 8), e === "center" && (i.display = "none", o.top = 0), {
    arrowStyle: i,
    popStyle: o,
    innerStyle: a
  });
};
function OB(r) {
  const { placement: e = "top", children: t, content: n = "" } = r, i = A.useRef(null), a = dist_Y("au-popConfirm-box", `au-popConfirm-box-placement-${e}`, {}), [o, s] = A.useState({}), [l, u] = A.useState({}), [f, c] = A.useState({});
  A.useEffect(() => {
    if (!i.current)
      return;
    const g = i.current, p = g.firstChild, m = g.lastChild;
    s(p.getBoundingClientRect()), u(m.getBoundingClientRect());
    const y = "mouseenter", _ = "mouseleave", S = () => {
      f.visibility !== "visible" && (c({
        visibility: "visible"
      }), g.addEventListener(_, b));
    }, b = () => {
      c({
        visibility: "hidden"
      }), g.removeEventListener(_, b);
    };
    return g.removeEventListener(y, S), g.addEventListener(y, S), () => {
      g.removeEventListener(y, S), g.removeEventListener(_, b);
    };
  }, [i.current]);
  const { arrowStyle: h, innerStyle: v, popStyle: d } = fb({
    placement: e,
    childSize: o,
    popSize: l
  });
  return A.createElement(
    "span",
    { className: a, ref: i },
    t,
    A.createElement(
      "div",
      { className: "au-popConfirm", style: { ...d, ...f } },
      A.createElement("div", { className: "au-popConfirm-arrow", style: h }),
      A.createElement("div", { className: "au-popConfirm-inner", style: v }, n)
    )
  );
}
const vp = {
  success: `<svg
      viewBox='64 64 896 896'
      focusable='false'
      data-icon='check-circle'
      width='1em'
      height='1em'
      fill='currentColor'
      aria-hidden='true'>
      <path d='M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z'></path>
    </svg>`,
  error: `<svg
      fill-rule='evenodd'
      viewBox='64 64 896 896'
      focusable='false'
      data-icon='close-circle'
      width='1em'
      height='1em'
      fill='currentColor'
      aria-hidden='true'>
      <path d='M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z'></path>
    </svg>`,
  warning: `<svg
      viewBox='64 64 896 896'
      focusable='false'
      data-icon='exclamation-circle'
      width='1em'
      height='1em'
      fill='currentColor'
      aria-hidden='true'>
      <path d='M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z'></path>
    </svg>`
}, cb = () => {
  const r = document.querySelector(".au-message");
  if (r)
    return r;
  const e = document.createElement("div");
  e.classList.add("au-message"), document.body.appendChild(e);
  const t = setInterval(() => {
    const n = document.querySelector(".au-message");
    n ? n.childNodes.length || (document.body.removeChild(n), clearInterval(t)) : clearInterval(t);
  }, 3100);
  return e;
}, kB = (r, e) => {
  const t = cb(), n = document.createElement("div");
  n.classList.add("au-message-inner");
  const i = document.createElement("span");
  i.classList.add(r), i.innerHTML = vp[r] || vp.warning, n.appendChild(i);
  const a = document.createElement("span");
  a.innerText = e, n.appendChild(a), t.appendChild(n);
  const o = setTimeout(() => {
    t.removeChild(n), clearTimeout(o);
  }, 3e3);
};
function VB(r) {
  return A.createElement(
    "div",
    null,
    "Theme",
    JSON.stringify(Object.keys(r))
  );
}
const t3 = react.createContext({});
function hb(r) {
  return A.createElement(
    "div",
    null,
    JSON.stringify(r),
    A.createElement("br", null),
    A.createElement("button", { onClick: () => {
      var e;
      (e = r == null ? void 0 : r.theme) == null || e.handleTheme();
    } }, "BTN")
  );
}
function vb() {
  return A.createElement(
    "div",
    null,
    A.createElement(db, null)
  );
}
function db() {
  return A.createElement(t3.Consumer, null, (r) => A.createElement(hb, { theme: r }));
}
function BB() {
  const [r, e] = Le("dark");
  return A.createElement(
    "div",
    null,
    "Demo1",
    A.createElement(
      t3.Provider,
      { value: {
        theme: r,
        handleTheme: () => {
          e("light");
        }
      } },
      A.createElement(vb, null)
    )
  );
}
function FB(r, e = A.createElement("div", null, "Loading")) {
  return A.createElement(tw, { fallback: e }, A.createElement(rw(() => r)));
}
/**
 * @remix-run/router v1.16.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function ts() {
  return ts = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, ts.apply(this, arguments);
}
var An;
(function(r) {
  r.Pop = "POP", r.Push = "PUSH", r.Replace = "REPLACE";
})(An || (An = {}));
const dp = "popstate";
function pb(r) {
  r === void 0 && (r = {});
  function e(n, i) {
    let {
      pathname: a,
      search: o,
      hash: s
    } = n.location;
    return Xh(
      "",
      {
        pathname: a,
        search: o,
        hash: s
      },
      // state defaults to `null` because `window.history.state` does
      i.state && i.state.usr || null,
      i.state && i.state.key || "default"
    );
  }
  function t(n, i) {
    return typeof i == "string" ? i : rs(i);
  }
  return mb(e, t, null, r);
}
function pe(r, e) {
  if (r === !1 || r === null || typeof r > "u")
    throw new Error(e);
}
function Ir(r, e) {
  if (!r)
    try {
      throw new Error(e);
    } catch {
    }
}
function gb() {
  return Math.random().toString(36).substr(2, 8);
}
function pp(r, e) {
  return {
    usr: r.state,
    key: r.key,
    idx: e
  };
}
function Xh(r, e, t, n) {
  return t === void 0 && (t = null), ts({
    pathname: typeof r == "string" ? r : r.pathname,
    search: "",
    hash: ""
  }, typeof e == "string" ? za(e) : e, {
    state: t,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: e && e.key || n || gb()
  });
}
function rs(r) {
  let {
    pathname: e = "/",
    search: t = "",
    hash: n = ""
  } = r;
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function za(r) {
  let e = {};
  if (r) {
    let t = r.indexOf("#");
    t >= 0 && (e.hash = r.substr(t), r = r.substr(0, t));
    let n = r.indexOf("?");
    n >= 0 && (e.search = r.substr(n), r = r.substr(0, n)), r && (e.pathname = r);
  }
  return e;
}
function mb(r, e, t, n) {
  n === void 0 && (n = {});
  let {
    window: i = document.defaultView,
    v5Compat: a = !1
  } = n, o = i.history, s = An.Pop, l = null, u = f();
  u == null && (u = 0, o.replaceState(ts({}, o.state, {
    idx: u
  }), ""));
  function f() {
    return (o.state || {
      idx: null
    }).idx;
  }
  function c() {
    s = An.Pop;
    let p = f(), m = p == null ? null : p - u;
    u = p, l && l({
      action: s,
      location: g.location,
      delta: m
    });
  }
  function h(p, m) {
    s = An.Push;
    let y = Xh(g.location, p, m);
    t && t(y, p), u = f() + 1;
    let _ = pp(y, u), S = g.createHref(y);
    try {
      o.pushState(_, "", S);
    } catch (b) {
      if (b instanceof DOMException && b.name === "DataCloneError")
        throw b;
      i.location.assign(S);
    }
    a && l && l({
      action: s,
      location: g.location,
      delta: 1
    });
  }
  function v(p, m) {
    s = An.Replace;
    let y = Xh(g.location, p, m);
    t && t(y, p), u = f();
    let _ = pp(y, u), S = g.createHref(y);
    o.replaceState(_, "", S), a && l && l({
      action: s,
      location: g.location,
      delta: 0
    });
  }
  function d(p) {
    let m = i.location.origin !== "null" ? i.location.origin : i.location.href, y = typeof p == "string" ? p : rs(p);
    return y = y.replace(/ $/, "%20"), pe(m, "No window.location.(origin|href) available to create URL for href: " + y), new URL(y, m);
  }
  let g = {
    get action() {
      return s;
    },
    get location() {
      return r(i, o);
    },
    listen(p) {
      if (l)
        throw new Error("A history only accepts one active listener");
      return i.addEventListener(dp, c), l = p, () => {
        i.removeEventListener(dp, c), l = null;
      };
    },
    createHref(p) {
      return e(i, p);
    },
    createURL: d,
    encodeLocation(p) {
      let m = d(p);
      return {
        pathname: m.pathname,
        search: m.search,
        hash: m.hash
      };
    },
    push: h,
    replace: v,
    go(p) {
      return o.go(p);
    }
  };
  return g;
}
var gp;
(function(r) {
  r.data = "data", r.deferred = "deferred", r.redirect = "redirect", r.error = "error";
})(gp || (gp = {}));
function yb(r, e, t) {
  t === void 0 && (t = "/");
  let n = typeof e == "string" ? za(e) : e, i = Gn(n.pathname || "/", t);
  if (i == null)
    return null;
  let a = r3(r);
  _b(a);
  let o = null;
  for (let s = 0; o == null && s < a.length; ++s) {
    let l = Ib(i);
    o = Eb(a[s], l);
  }
  return o;
}
function r3(r, e, t, n) {
  e === void 0 && (e = []), t === void 0 && (t = []), n === void 0 && (n = "");
  let i = (a, o, s) => {
    let l = {
      relativePath: s === void 0 ? a.path || "" : s,
      caseSensitive: a.caseSensitive === !0,
      childrenIndex: o,
      route: a
    };
    l.relativePath.startsWith("/") && (pe(l.relativePath.startsWith(n), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + n + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(n.length));
    let u = Wr([n, l.relativePath]), f = t.concat(l);
    a.children && a.children.length > 0 && (pe(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      a.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')
    ), r3(a.children, e, f, u)), !(a.path == null && !a.index) && e.push({
      path: u,
      score: Mb(u, a.index),
      routesMeta: f
    });
  };
  return r.forEach((a, o) => {
    var s;
    if (a.path === "" || !((s = a.path) != null && s.includes("?")))
      i(a, o);
    else
      for (let l of n3(a.path))
        i(a, o, l);
  }), e;
}
function n3(r) {
  let e = r.split("/");
  if (e.length === 0)
    return [];
  let [t, ...n] = e, i = t.endsWith("?"), a = t.replace(/\?$/, "");
  if (n.length === 0)
    return i ? [a, ""] : [a];
  let o = n3(n.join("/")), s = [];
  return s.push(...o.map((l) => l === "" ? a : [a, l].join("/"))), i && s.push(...o), s.map((l) => r.startsWith("/") && l === "" ? "/" : l);
}
function _b(r) {
  r.sort((e, t) => e.score !== t.score ? t.score - e.score : Db(e.routesMeta.map((n) => n.childrenIndex), t.routesMeta.map((n) => n.childrenIndex)));
}
const Sb = /^:[\w-]+$/, wb = 3, bb = 2, xb = 1, Cb = 10, Tb = (/* unused pure expression or super */ null && (-2)), mp = (r) => r === "*";
function Mb(r, e) {
  let t = r.split("/"), n = t.length;
  return t.some(mp) && (n += Tb), e && (n += bb), t.filter((i) => !mp(i)).reduce((i, a) => i + (Sb.test(a) ? wb : a === "" ? xb : Cb), n);
}
function Db(r, e) {
  return r.length === e.length && r.slice(0, -1).every((n, i) => n === e[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    r[r.length - 1] - e[e.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function Eb(r, e) {
  let {
    routesMeta: t
  } = r, n = {}, i = "/", a = [];
  for (let o = 0; o < t.length; ++o) {
    let s = t[o], l = o === t.length - 1, u = i === "/" ? e : e.slice(i.length) || "/", f = Zh({
      path: s.relativePath,
      caseSensitive: s.caseSensitive,
      end: l
    }, u);
    if (!f)
      return null;
    Object.assign(n, f.params);
    let c = s.route;
    a.push({
      // TODO: Can this as be avoided?
      params: n,
      pathname: Wr([i, f.pathname]),
      pathnameBase: Rb(Wr([i, f.pathnameBase])),
      route: c
    }), f.pathnameBase !== "/" && (i = Wr([i, f.pathnameBase]));
  }
  return a;
}
function Zh(r, e) {
  typeof r == "string" && (r = {
    path: r,
    caseSensitive: !1,
    end: !0
  });
  let [t, n] = Ab(r.path, r.caseSensitive, r.end), i = e.match(t);
  if (!i)
    return null;
  let a = i[0], o = a.replace(/(.)\/+$/, "$1"), s = i.slice(1);
  return {
    params: n.reduce((u, f, c) => {
      let {
        paramName: h,
        isOptional: v
      } = f;
      if (h === "*") {
        let g = s[c] || "";
        o = a.slice(0, a.length - g.length).replace(/(.)\/+$/, "$1");
      }
      const d = s[c];
      return v && !d ? u[h] = void 0 : u[h] = (d || "").replace(/%2F/g, "/"), u;
    }, {}),
    pathname: a,
    pathnameBase: o,
    pattern: r
  };
}
function Ab(r, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !0), Ir(r === "*" || !r.endsWith("*") || r.endsWith("/*"), 'Route path "' + r + '" will be treated as if it were ' + ('"' + r.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + r.replace(/\*$/, "/*") + '".'));
  let n = [], i = "^" + r.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, s, l) => (n.push({
    paramName: s,
    isOptional: l != null
  }), l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return r.endsWith("*") ? (n.push({
    paramName: "*"
  }), i += r === "*" || r === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? i += "\\/*$" : r !== "" && r !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), n];
}
function Ib(r) {
  try {
    return r.split("/").map((e) => decodeURIComponent(e).replace(/\//g, "%2F")).join("/");
  } catch (e) {
    return Ir(!1, 'The URL path "' + r + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), r;
  }
}
function Gn(r, e) {
  if (e === "/")
    return r;
  if (!r.toLowerCase().startsWith(e.toLowerCase()))
    return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length, n = r.charAt(t);
  return n && n !== "/" ? null : r.slice(t) || "/";
}
function Lb(r, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: n = "",
    hash: i = ""
  } = typeof r == "string" ? za(r) : r;
  return {
    pathname: t ? t.startsWith("/") ? t : Nb(t, e) : e,
    search: Ob(n),
    hash: kb(i)
  };
}
function Nb(r, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return r.split("/").forEach((i) => {
    i === ".." ? t.length > 1 && t.pop() : i !== "." && t.push(i);
  }), t.length > 1 ? t.join("/") : "/";
}
function Wf(r, e, t, n) {
  return "Cannot include a '" + r + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(n) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function Pb(r) {
  return r.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0);
}
function i3(r, e) {
  let t = Pb(r);
  return e ? t.map((n, i) => i === r.length - 1 ? n.pathname : n.pathnameBase) : t.map((n) => n.pathnameBase);
}
function a3(r, e, t, n) {
  n === void 0 && (n = !1);
  let i;
  typeof r == "string" ? i = za(r) : (i = ts({}, r), pe(!i.pathname || !i.pathname.includes("?"), Wf("?", "pathname", "search", i)), pe(!i.pathname || !i.pathname.includes("#"), Wf("#", "pathname", "hash", i)), pe(!i.search || !i.search.includes("#"), Wf("#", "search", "hash", i)));
  let a = r === "" || i.pathname === "", o = a ? "/" : i.pathname, s;
  if (o == null)
    s = t;
  else {
    let c = e.length - 1;
    if (!n && o.startsWith("..")) {
      let h = o.split("/");
      for (; h[0] === ".."; )
        h.shift(), c -= 1;
      i.pathname = h.join("/");
    }
    s = c >= 0 ? e[c] : "/";
  }
  let l = Lb(i, s), u = o && o !== "/" && o.endsWith("/"), f = (a || o === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (u || f) && (l.pathname += "/"), l;
}
const Wr = (r) => r.join("/").replace(/\/\/+/g, "/"), Rb = (r) => r.replace(/\/+$/, "").replace(/^\/*/, "/"), Ob = (r) => !r || r === "?" ? "" : r.startsWith("?") ? r : "?" + r, kb = (r) => !r || r === "#" ? "" : r.startsWith("#") ? r : "#" + r;
function Vb(r) {
  return r != null && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.internal == "boolean" && "data" in r;
}
const o3 = ["post", "put", "patch", "delete"];
new Set(o3);
const Bb = ["get", ...o3];
new Set(Bb);
/**
 * React Router v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function ns() {
  return ns = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, ns.apply(this, arguments);
}
const bs = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.createContext(null)));
 false && (0);
const dd = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.createContext(null)));
 false && (0);
const Fb = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.createContext(null)));
 false && (0);
const hr = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.createContext(null)));
 false && (0);
const xs = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.createContext(null)));
 false && (0);
const ln = /* @__PURE__ */ react.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
 false && (0);
const pd = /* @__PURE__ */ react.createContext(null);
 false && (0);
function zb(r, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e;
  Cs() || ( false ? 0 : pe(!1));
  let {
    basename: n,
    navigator: i
  } = G.useContext(hr), {
    hash: a,
    pathname: o,
    search: s
  } = Ts(r, {
    relative: t
  }), l = o;
  return n !== "/" && (l = o === "/" ? n : Wr([n, o])), i.createHref({
    pathname: l,
    search: s,
    hash: a
  });
}
function Cs() {
  return G.useContext(xs) != null;
}
function Ga() {
  return Cs() || ( false ? 0 : pe(!1)), G.useContext(xs).location;
}
const s3 = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function l3(r) {
  G.useContext(hr).static || G.useLayoutEffect(r);
}
function Gb() {
  let {
    isDataRoute: r
  } = G.useContext(ln);
  return r ? tx() : Hb();
}
function Hb() {
  Cs() || ( false ? 0 : pe(!1));
  let r = G.useContext(bs), {
    basename: e,
    future: t,
    navigator: n
  } = G.useContext(hr), {
    matches: i
  } = G.useContext(ln), {
    pathname: a
  } = Ga(), o = JSON.stringify(i3(i, t.v7_relativeSplatPath)), s = G.useRef(!1);
  return l3(() => {
    s.current = !0;
  }), G.useCallback(function(u, f) {
    if (f === void 0 && (f = {}),  false && 0, !s.current)
      return;
    if (typeof u == "number") {
      n.go(u);
      return;
    }
    let c = a3(u, JSON.parse(o), a, f.relative === "path");
    r == null && e !== "/" && (c.pathname = c.pathname === "/" ? e : Wr([e, c.pathname])), (f.replace ? n.replace : n.push)(c, f.state, f);
  }, [e, n, o, a, r]);
}
function Ts(r, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    future: n
  } = G.useContext(hr), {
    matches: i
  } = G.useContext(ln), {
    pathname: a
  } = Ga(), o = JSON.stringify(i3(i, n.v7_relativeSplatPath));
  return G.useMemo(() => a3(r, JSON.parse(o), a, t === "path"), [r, o, a, t]);
}
function $b(r, e) {
  return Wb(r, e);
}
function Wb(r, e, t, n) {
  Cs() || ( false ? 0 : pe(!1));
  let {
    navigator: i
  } = G.useContext(hr), {
    matches: a
  } = G.useContext(ln), o = a[a.length - 1], s = o ? o.params : {}, l = o ? o.pathname : "/", u = o ? o.pathnameBase : "/", f = o && o.route;
  if (false) {}
  let c = Ga(), h;
  if (e) {
    var v;
    let y = typeof e == "string" ? za(e) : e;
    u === "/" || (v = y.pathname) != null && v.startsWith(u) || ( false ? 0 : pe(!1)), h = y;
  } else
    h = c;
  let d = h.pathname || "/", g = d;
  if (u !== "/") {
    let y = u.replace(/^\//, "").split("/");
    g = "/" + d.replace(/^\//, "").split("/").slice(y.length).join("/");
  }
  let p = yb(r, {
    pathname: g
  });
   false && (0);
  let m = qb(p && p.map((y) => Object.assign({}, y, {
    params: Object.assign({}, s, y.params),
    pathname: Wr([
      u,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(y.pathname).pathname : y.pathname
    ]),
    pathnameBase: y.pathnameBase === "/" ? u : Wr([
      u,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(y.pathnameBase).pathname : y.pathnameBase
    ])
  })), a, t, n);
  return e && m ? /* @__PURE__ */ G.createElement(xs.Provider, {
    value: {
      location: ns({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, h),
      navigationType: An.Pop
    }
  }, m) : m;
}
function Ub() {
  let r = ex(), e = Vb(r) ? r.status + " " + r.statusText : r instanceof Error ? r.message : JSON.stringify(r), t = r instanceof Error ? r.stack : null, n = "rgba(200,200,200, 0.5)", i = {
    padding: "0.5rem",
    backgroundColor: n
  }, a = {
    padding: "2px 4px",
    backgroundColor: n
  }, o = null;
  return  false && (0), /* @__PURE__ */ G.createElement(G.Fragment, null, /* @__PURE__ */ G.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ G.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, e), t ? /* @__PURE__ */ G.createElement("pre", {
    style: i
  }, t) : null, o);
}
const Yb = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.createElement(Ub, null)));
class Xb extends react.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return {
      error: e
    };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ react.createElement(ln.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ react.createElement(pd.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function Zb(r) {
  let {
    routeContext: e,
    match: t,
    children: n
  } = r, i = G.useContext(bs);
  return i && i.static && i.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ G.createElement(ln.Provider, {
    value: e
  }, n);
}
function qb(r, e, t, n) {
  var i;
  if (e === void 0 && (e = []), t === void 0 && (t = null), n === void 0 && (n = null), r == null) {
    var a;
    if ((a = t) != null && a.errors)
      r = t.matches;
    else
      return null;
  }
  let o = r, s = (i = t) == null ? void 0 : i.errors;
  if (s != null) {
    let f = o.findIndex((c) => c.route.id && (s == null ? void 0 : s[c.route.id]) !== void 0);
    f >= 0 || ( false ? 0 : pe(!1)), o = o.slice(0, Math.min(o.length, f + 1));
  }
  let l = !1, u = -1;
  if (t && n && n.v7_partialHydration)
    for (let f = 0; f < o.length; f++) {
      let c = o[f];
      if ((c.route.HydrateFallback || c.route.hydrateFallbackElement) && (u = f), c.route.id) {
        let {
          loaderData: h,
          errors: v
        } = t, d = c.route.loader && h[c.route.id] === void 0 && (!v || v[c.route.id] === void 0);
        if (c.route.lazy || d) {
          l = !0, u >= 0 ? o = o.slice(0, u + 1) : o = [o[0]];
          break;
        }
      }
    }
  return o.reduceRight((f, c, h) => {
    let v, d = !1, g = null, p = null;
    t && (v = s && c.route.id ? s[c.route.id] : void 0, g = c.route.errorElement || Yb, l && (u < 0 && h === 0 ? (f3("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), d = !0, p = null) : u === h && (d = !0, p = c.route.hydrateFallbackElement || null)));
    let m = e.concat(o.slice(0, h + 1)), y = () => {
      let _;
      return v ? _ = g : d ? _ = p : c.route.Component ? _ = /* @__PURE__ */ G.createElement(c.route.Component, null) : c.route.element ? _ = c.route.element : _ = f, /* @__PURE__ */ G.createElement(Zb, {
        match: c,
        routeContext: {
          outlet: f,
          matches: m,
          isDataRoute: t != null
        },
        children: _
      });
    };
    return t && (c.route.ErrorBoundary || c.route.errorElement || h === 0) ? /* @__PURE__ */ G.createElement(Xb, {
      location: t.location,
      revalidation: t.revalidation,
      component: g,
      error: v,
      children: y(),
      routeContext: {
        outlet: null,
        matches: m,
        isDataRoute: !0
      }
    }) : y();
  }, null);
}
var u3 = /* @__PURE__ */ function(r) {
  return r.UseBlocker = "useBlocker", r.UseRevalidator = "useRevalidator", r.UseNavigateStable = "useNavigate", r;
}(u3 || {}), is = /* @__PURE__ */ function(r) {
  return r.UseBlocker = "useBlocker", r.UseLoaderData = "useLoaderData", r.UseActionData = "useActionData", r.UseRouteError = "useRouteError", r.UseNavigation = "useNavigation", r.UseRouteLoaderData = "useRouteLoaderData", r.UseMatches = "useMatches", r.UseRevalidator = "useRevalidator", r.UseNavigateStable = "useNavigate", r.UseRouteId = "useRouteId", r;
}(is || {});
function gd(r) {
  return r + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Kb(r) {
  let e = G.useContext(bs);
  return e || ( false ? 0 : pe(!1)), e;
}
function jb(r) {
  let e = G.useContext(dd);
  return e || ( false ? 0 : pe(!1)), e;
}
function Jb(r) {
  let e = G.useContext(ln);
  return e || ( false ? 0 : pe(!1)), e;
}
function md(r) {
  let e = Jb(r), t = e.matches[e.matches.length - 1];
  return t.route.id || ( false ? 0 : pe(!1)), t.route.id;
}
function Qb() {
  return md(is.UseRouteId);
}
function ex() {
  var r;
  let e = G.useContext(pd), t = jb(is.UseRouteError), n = md(is.UseRouteError);
  return e !== void 0 ? e : (r = t.errors) == null ? void 0 : r[n];
}
function tx() {
  let {
    router: r
  } = Kb(u3.UseNavigateStable), e = md(is.UseNavigateStable), t = G.useRef(!1);
  return l3(() => {
    t.current = !0;
  }), G.useCallback(function(i, a) {
    a === void 0 && (a = {}),  false && 0, t.current && (typeof i == "number" ? r.navigate(i) : r.navigate(i, ns({
      fromRouteId: e
    }, a)));
  }, [r, e]);
}
const yp = {};
function f3(r, e, t) {
  !e && !yp[r] && (yp[r] = !0,  false && 0);
}
function rx(r) {
  let {
    basename: e = "/",
    children: t = null,
    location: n,
    navigationType: i = An.Pop,
    navigator: a,
    static: o = !1,
    future: s
  } = r;
  Cs() && ( false ? 0 : pe(!1));
  let l = e.replace(/^\/*/, "/"), u = G.useMemo(() => ({
    basename: l,
    navigator: a,
    static: o,
    future: ns({
      v7_relativeSplatPath: !1
    }, s)
  }), [l, s, a, o]);
  typeof n == "string" && (n = za(n));
  let {
    pathname: f = "/",
    search: c = "",
    hash: h = "",
    state: v = null,
    key: d = "default"
  } = n, g = G.useMemo(() => {
    let p = Gn(f, l);
    return p == null ? null : {
      location: {
        pathname: p,
        search: c,
        hash: h,
        state: v,
        key: d
      },
      navigationType: i
    };
  }, [l, f, c, h, v, d, i]);
  return  false && 0, g == null ? null : /* @__PURE__ */ G.createElement(hr.Provider, {
    value: u
  }, /* @__PURE__ */ G.createElement(xs.Provider, {
    children: t,
    value: g
  }));
}
new Promise(() => {
});
/**
 * React Router DOM v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Ia() {
  return Ia = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Ia.apply(this, arguments);
}
function yd(r, e) {
  if (r == null)
    return {};
  var t = {}, n = Object.keys(r), i, a;
  for (a = 0; a < n.length; a++)
    i = n[a], !(e.indexOf(i) >= 0) && (t[i] = r[i]);
  return t;
}
const Bl = "get", Fl = "application/x-www-form-urlencoded";
function Ju(r) {
  return r != null && typeof r.tagName == "string";
}
function nx(r) {
  return Ju(r) && r.tagName.toLowerCase() === "button";
}
function ix(r) {
  return Ju(r) && r.tagName.toLowerCase() === "form";
}
function ax(r) {
  return Ju(r) && r.tagName.toLowerCase() === "input";
}
function ox(r) {
  return !!(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey);
}
function sx(r, e) {
  return r.button === 0 && // Ignore everything but left clicks
  (!e || e === "_self") && // Let browser handle "target=_blank" etc.
  !ox(r);
}
let Ws = null;
function lx() {
  if (Ws === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Ws = !1;
    } catch {
      Ws = !0;
    }
  return Ws;
}
const ux = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Uf(r) {
  return r != null && !ux.has(r) ? ( false && 0, null) : r;
}
function fx(r, e) {
  let t, n, i, a, o;
  if (ix(r)) {
    let s = r.getAttribute("action");
    n = s ? Gn(s, e) : null, t = r.getAttribute("method") || Bl, i = Uf(r.getAttribute("enctype")) || Fl, a = new FormData(r);
  } else if (nx(r) || ax(r) && (r.type === "submit" || r.type === "image")) {
    let s = r.form;
    if (s == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let l = r.getAttribute("formaction") || s.getAttribute("action");
    if (n = l ? Gn(l, e) : null, t = r.getAttribute("formmethod") || s.getAttribute("method") || Bl, i = Uf(r.getAttribute("formenctype")) || Uf(s.getAttribute("enctype")) || Fl, a = new FormData(s, r), !lx()) {
      let {
        name: u,
        type: f,
        value: c
      } = r;
      if (f === "image") {
        let h = u ? u + "." : "";
        a.append(h + "x", "0"), a.append(h + "y", "0");
      } else
        u && a.append(u, c);
    }
  } else {
    if (Ju(r))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    t = Bl, n = null, i = Fl, o = r;
  }
  return a && i === "text/plain" && (o = a, a = void 0), {
    action: n,
    method: t.toLowerCase(),
    encType: i,
    formData: a,
    body: o
  };
}
const cx = (/* unused pure expression or super */ null && (["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"])), hx = (/* unused pure expression or super */ null && (["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"])), vx = (/* unused pure expression or super */ null && (["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"])), dx = "6";
try {
  window.__reactRouterVersion = dx;
} catch {
}
const c3 = /* @__PURE__ */ react.createContext({
  isTransitioning: !1
});
 false && (0);
const px = /* @__PURE__ */ react.createContext(/* @__PURE__ */ new Map());
 false && (0);
const gx = "startTransition", _p = react_namespaceObject[gx];
function mx(r) {
  let {
    basename: e,
    children: t,
    future: n,
    window: i
  } = r, a = G.useRef();
  a.current == null && (a.current = pb({
    window: i,
    v5Compat: !0
  }));
  let o = a.current, [s, l] = G.useState({
    action: o.action,
    location: o.location
  }), {
    v7_startTransition: u
  } = n || {}, f = G.useCallback((c) => {
    u && _p ? _p(() => l(c)) : l(c);
  }, [l, u]);
  return G.useLayoutEffect(() => o.listen(f), [o, f]), /* @__PURE__ */ G.createElement(rx, {
    basename: e,
    children: t,
    location: s.location,
    navigationType: s.action,
    navigator: o,
    future: n
  });
}
"production";
const yx = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", _x = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, h3 = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.forwardRef(function(e, t) {
  let {
    onClick: n,
    relative: i,
    reloadDocument: a,
    replace: o,
    state: s,
    target: l,
    to: u,
    preventScrollReset: f,
    unstable_viewTransition: c
  } = e, h = yd(e, cx), {
    basename: v
  } = G.useContext(hr), d, g = !1;
  if (typeof u == "string" && _x.test(u) && (d = u, yx))
    try {
      let _ = new URL(window.location.href), S = u.startsWith("//") ? new URL(_.protocol + u) : new URL(u), b = Gn(S.pathname, v);
      S.origin === _.origin && b != null ? u = b + S.search + S.hash : g = !0;
    } catch {
       false && 0;
    }
  let p = zb(u, {
    relative: i
  }), m = Cx(u, {
    replace: o,
    state: s,
    target: l,
    preventScrollReset: f,
    relative: i,
    unstable_viewTransition: c
  });
  function y(_) {
    n && n(_), _.defaultPrevented || m(_);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ G.createElement("a", Ia({}, h, {
      href: d || p,
      onClick: g || a ? n : y,
      ref: t,
      target: l
    }))
  );
})));
 false && (0);
const Sx = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.forwardRef(function(e, t) {
  let {
    "aria-current": n = "page",
    caseSensitive: i = !1,
    className: a = "",
    end: o = !1,
    style: s,
    to: l,
    unstable_viewTransition: u,
    children: f
  } = e, c = yd(e, hx), h = Ts(l, {
    relative: c.relative
  }), v = Ga(), d = G.useContext(dd), {
    navigator: g,
    basename: p
  } = G.useContext(hr), m = d != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  Ix(h) && u === !0, y = g.encodeLocation ? g.encodeLocation(h).pathname : h.pathname, _ = v.pathname, S = d && d.navigation && d.navigation.location ? d.navigation.location.pathname : null;
  i || (_ = _.toLowerCase(), S = S ? S.toLowerCase() : null, y = y.toLowerCase()), S && p && (S = Gn(S, p) || S);
  const b = y !== "/" && y.endsWith("/") ? y.length - 1 : y.length;
  let w = _ === y || !o && _.startsWith(y) && _.charAt(b) === "/", x = S != null && (S === y || !o && S.startsWith(y) && S.charAt(y.length) === "/"), C = {
    isActive: w,
    isPending: x,
    isTransitioning: m
  }, T = w ? n : void 0, E;
  typeof a == "function" ? E = a(C) : E = [a, w ? "active" : null, x ? "pending" : null, m ? "transitioning" : null].filter(Boolean).join(" ");
  let D = typeof s == "function" ? s(C) : s;
  return /* @__PURE__ */ G.createElement(h3, Ia({}, c, {
    "aria-current": T,
    className: E,
    ref: t,
    style: D,
    to: l,
    unstable_viewTransition: u
  }), typeof f == "function" ? f(C) : f);
})));
 false && (0);
const bx = /* @__PURE__ */ (/* unused pure expression or super */ null && (G.forwardRef((r, e) => {
  let {
    fetcherKey: t,
    navigate: n,
    reloadDocument: i,
    replace: a,
    state: o,
    method: s = Bl,
    action: l,
    onSubmit: u,
    relative: f,
    preventScrollReset: c,
    unstable_viewTransition: h
  } = r, v = yd(r, vx), d = Ex(), g = Ax(l, {
    relative: f
  }), p = s.toLowerCase() === "get" ? "get" : "post", m = (y) => {
    if (u && u(y), y.defaultPrevented)
      return;
    y.preventDefault();
    let _ = y.nativeEvent.submitter, S = (_ == null ? void 0 : _.getAttribute("formmethod")) || s;
    d(_ || y.currentTarget, {
      fetcherKey: t,
      method: S,
      navigate: n,
      replace: a,
      state: o,
      relative: f,
      preventScrollReset: c,
      unstable_viewTransition: h
    });
  };
  return /* @__PURE__ */ G.createElement("form", Ia({
    ref: e,
    method: p,
    action: g,
    onSubmit: i ? u : m
  }, v));
})));
 false && (0);
"production";
var au;
(function(r) {
  r.UseScrollRestoration = "useScrollRestoration", r.UseSubmit = "useSubmit", r.UseSubmitFetcher = "useSubmitFetcher", r.UseFetcher = "useFetcher", r.useViewTransitionState = "useViewTransitionState";
})(au || (au = {}));
var Sp;
(function(r) {
  r.UseFetcher = "useFetcher", r.UseFetchers = "useFetchers", r.UseScrollRestoration = "useScrollRestoration";
})(Sp || (Sp = {}));
function xx(r) {
  return r + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function v3(r) {
  let e = G.useContext(bs);
  return e || ( false ? 0 : pe(!1)), e;
}
function Cx(r, e) {
  let {
    target: t,
    replace: n,
    state: i,
    preventScrollReset: a,
    relative: o,
    unstable_viewTransition: s
  } = e === void 0 ? {} : e, l = Gb(), u = Ga(), f = Ts(r, {
    relative: o
  });
  return G.useCallback((c) => {
    if (sx(c, t)) {
      c.preventDefault();
      let h = n !== void 0 ? n : rs(u) === rs(f);
      l(r, {
        replace: h,
        state: i,
        preventScrollReset: a,
        relative: o,
        unstable_viewTransition: s
      });
    }
  }, [u, l, f, n, i, t, r, a, o, s]);
}
function Tx() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let Mx = 0, Dx = () => "__" + String(++Mx) + "__";
function Ex() {
  let {
    router: r
  } = v3(au.UseSubmit), {
    basename: e
  } = G.useContext(hr), t = Qb();
  return G.useCallback(function(n, i) {
    i === void 0 && (i = {}), Tx();
    let {
      action: a,
      method: o,
      encType: s,
      formData: l,
      body: u
    } = fx(n, e);
    if (i.navigate === !1) {
      let f = i.fetcherKey || Dx();
      r.fetch(f, t, i.action || a, {
        preventScrollReset: i.preventScrollReset,
        formData: l,
        body: u,
        formMethod: i.method || o,
        formEncType: i.encType || s,
        unstable_flushSync: i.unstable_flushSync
      });
    } else
      r.navigate(i.action || a, {
        preventScrollReset: i.preventScrollReset,
        formData: l,
        body: u,
        formMethod: i.method || o,
        formEncType: i.encType || s,
        replace: i.replace,
        state: i.state,
        fromRouteId: t,
        unstable_flushSync: i.unstable_flushSync,
        unstable_viewTransition: i.unstable_viewTransition
      });
  }, [r, e, t]);
}
function Ax(r, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    basename: n
  } = G.useContext(hr), i = G.useContext(ln);
  i || ( false ? 0 : pe(!1));
  let [a] = i.matches.slice(-1), o = Ia({}, Ts(r || ".", {
    relative: t
  })), s = Ga();
  if (r == null) {
    o.search = s.search;
    let l = new URLSearchParams(o.search);
    l.has("index") && l.get("index") === "" && (l.delete("index"), o.search = l.toString() ? "?" + l.toString() : "");
  }
  return (!r || r === ".") && a.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (o.pathname = o.pathname === "/" ? n : Wr([n, o.pathname])), rs(o);
}
function Ix(r, e) {
  e === void 0 && (e = {});
  let t = G.useContext(c3);
  t == null && ( false ? 0 : pe(!1));
  let {
    basename: n
  } = v3(au.useViewTransitionState), i = Ts(r, {
    relative: e.relative
  });
  if (!t.isTransitioning)
    return !1;
  let a = Gn(t.currentLocation.pathname, n) || t.currentLocation.pathname, o = Gn(t.nextLocation.pathname, n) || t.nextLocation.pathname;
  return Zh(i.pathname, o) != null || Zh(i.pathname, a) != null;
}
const Lx = (r) => $b(r.routes);
function zB(r) {
  const { basename: e = "/", window: t = window, menu: n } = r;
  return A.createElement(
    A.StrictMode,
    null,
    A.createElement(
      mx,
      { basename: e, window: t },
      A.createElement(Lx, { routes: n })
    )
  );
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var qh = function(r, e) {
  return qh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, qh(r, e);
};
function dist_k(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  qh(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Nx = /* @__PURE__ */ function() {
  function r() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return r;
}(), Px = /* @__PURE__ */ function() {
  function r() {
    this.browser = new Nx(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return r;
}(), dist_ee = new Px();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (dist_ee.wxa = !0, dist_ee.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? dist_ee.worker = !0 : typeof navigator > "u" || navigator.userAgent.indexOf("Node.js") === 0 ? (dist_ee.node = !0, dist_ee.svgSupported = !0) : Rx(navigator.userAgent, dist_ee);
function Rx(r, e) {
  var t = e.browser, n = r.match(/Firefox\/([\d.]+)/), i = r.match(/MSIE\s([\d.]+)/) || r.match(/Trident\/.+?rv:(([\d.]+))/), a = r.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(r);
  n && (t.firefox = !0, t.version = n[1]), i && (t.ie = !0, t.version = i[1]), a && (t.edge = !0, t.version = a[1], t.newEdge = +a[1].split(".")[0] > 18), o && (t.weChat = !0), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !t.ie && !t.edge, e.pointerEventsSupported = "onpointerdown" in window && (t.edge || t.ie && +t.version >= 11), e.domSupported = typeof document < "u";
  var s = document.documentElement.style;
  e.transform3dSupported = (t.ie && "transition" in s || t.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), e.transformSupported = e.transform3dSupported || t.ie && +t.version >= 9;
}
var _d = 12, Ox = "sans-serif", ki = _d + "px " + Ox, kx = 20, Vx = 100, Bx = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function Fx(r) {
  var e = {};
  if (typeof JSON > "u")
    return e;
  for (var t = 0; t < r.length; t++) {
    var n = String.fromCharCode(t + 32), i = (r.charCodeAt(t) - kx) / Vx;
    e[n] = i;
  }
  return e;
}
var zx = Fx(Bx), Ha = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    var r, e;
    return function(t, n) {
      if (!r) {
        var i = Ha.createCanvas();
        r = i && i.getContext("2d");
      }
      if (r)
        return e !== n && (e = r.font = n || ki), r.measureText(t);
      t = t || "", n = n || ki;
      var a = /(\d+)px/.exec(n), o = a && +a[1] || _d, s = 0;
      if (n.indexOf("mono") >= 0)
        s = o * t.length;
      else
        for (var l = 0; l < t.length; l++) {
          var u = zx[t[l]];
          s += u == null ? o : u * o;
        }
      return { width: s };
    };
  }(),
  loadImage: function(r, e, t) {
    var n = new Image();
    return n.onload = e, n.onerror = t, n.src = r, n;
  }
}, d3 = Jr([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(r, e) {
  return r["[object " + e + "]"] = !0, r;
}, {}), p3 = Jr([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(r, e) {
  return r["[object " + e + "Array]"] = !0, r;
}, {}), $a = Object.prototype.toString, Qu = Array.prototype, Gx = Qu.forEach, Hx = Qu.filter, Sd = Qu.slice, $x = Qu.map, wp = (function() {
}).constructor, Us = wp ? wp.prototype : null, wd = "__proto__", Wx = 2311;
function g3() {
  return Wx++;
}
function Ei() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
}
function dist_te(r) {
  if (r == null || typeof r != "object")
    return r;
  var e = r, t = $a.call(r);
  if (t === "[object Array]") {
    if (!Bo(r)) {
      e = [];
      for (var n = 0, i = r.length; n < i; n++)
        e[n] = dist_te(r[n]);
    }
  } else if (p3[t]) {
    if (!Bo(r)) {
      var a = r.constructor;
      if (a.from)
        e = a.from(r);
      else {
        e = new a(r.length);
        for (var n = 0, i = r.length; n < i; n++)
          e[n] = r[n];
      }
    }
  } else if (!d3[t] && !Bo(r) && !La(r)) {
    e = {};
    for (var o in r)
      r.hasOwnProperty(o) && o !== wd && (e[o] = dist_te(r[o]));
  }
  return e;
}
function he(r, e, t) {
  if (!dist_X(e) || !dist_X(r))
    return t ? dist_te(e) : r;
  for (var n in e)
    if (e.hasOwnProperty(n) && n !== wd) {
      var i = r[n], a = e[n];
      dist_X(a) && dist_X(i) && !dist_F(a) && !dist_F(i) && !La(a) && !La(i) && !bp(a) && !bp(i) && !Bo(a) && !Bo(i) ? he(i, a, t) : (t || !(n in r)) && (r[n] = dist_te(e[n]));
    }
  return r;
}
function m3(r, e) {
  for (var t = r[0], n = 1, i = r.length; n < i; n++)
    t = he(t, r[n], e);
  return t;
}
function dist_V(r, e) {
  if (Object.assign)
    Object.assign(r, e);
  else
    for (var t in e)
      e.hasOwnProperty(t) && t !== wd && (r[t] = e[t]);
  return r;
}
function dist_se(r, e, t) {
  for (var n = we(e), i = 0; i < n.length; i++) {
    var a = n[i];
    (t ? e[a] != null : r[a] == null) && (r[a] = e[a]);
  }
  return r;
}
function ye(r, e) {
  if (r) {
    if (r.indexOf)
      return r.indexOf(e);
    for (var t = 0, n = r.length; t < n; t++)
      if (r[t] === e)
        return t;
  }
  return -1;
}
function Ux(r, e) {
  var t = r.prototype;
  function n() {
  }
  n.prototype = e.prototype, r.prototype = new n();
  for (var i in t)
    t.hasOwnProperty(i) && (r.prototype[i] = t[i]);
  r.prototype.constructor = r, r.superClass = e;
}
function Ot(r, e, t) {
  if (r = "prototype" in r ? r.prototype : r, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(e), i = 0; i < n.length; i++) {
      var a = n[i];
      a !== "constructor" && (t ? e[a] != null : r[a] == null) && (r[a] = e[a]);
    }
  else
    dist_se(r, e, t);
}
function ct(r) {
  return !r || typeof r == "string" ? !1 : typeof r.length == "number";
}
function dist_M(r, e, t) {
  if (r && e)
    if (r.forEach && r.forEach === Gx)
      r.forEach(e, t);
    else if (r.length === +r.length)
      for (var n = 0, i = r.length; n < i; n++)
        e.call(t, r[n], n, r);
    else
      for (var a in r)
        r.hasOwnProperty(a) && e.call(t, r[a], a, r);
}
function dist_$(r, e, t) {
  if (!r)
    return [];
  if (!e)
    return bd(r);
  if (r.map && r.map === $x)
    return r.map(e, t);
  for (var n = [], i = 0, a = r.length; i < a; i++)
    n.push(e.call(t, r[i], i, r));
  return n;
}
function Jr(r, e, t, n) {
  if (r && e) {
    for (var i = 0, a = r.length; i < a; i++)
      t = e.call(n, t, r[i], i, r);
    return t;
  }
}
function ke(r, e, t) {
  if (!r)
    return [];
  if (!e)
    return bd(r);
  if (r.filter && r.filter === Hx)
    return r.filter(e, t);
  for (var n = [], i = 0, a = r.length; i < a; i++)
    e.call(t, r[i], i, r) && n.push(r[i]);
  return n;
}
function we(r) {
  if (!r)
    return [];
  if (Object.keys)
    return Object.keys(r);
  var e = [];
  for (var t in r)
    r.hasOwnProperty(t) && e.push(t);
  return e;
}
function Yx(r, e) {
  for (var t = [], n = 2; n < arguments.length; n++)
    t[n - 2] = arguments[n];
  return function() {
    return r.apply(e, t.concat(Sd.call(arguments)));
  };
}
var dist_Z = Us && dist_j(Us.bind) ? Us.call.bind(Us.bind) : Yx;
function Te(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return function() {
    return r.apply(this, e.concat(Sd.call(arguments)));
  };
}
function dist_F(r) {
  return Array.isArray ? Array.isArray(r) : $a.call(r) === "[object Array]";
}
function dist_j(r) {
  return typeof r == "function";
}
function dist_U(r) {
  return typeof r == "string";
}
function ou(r) {
  return $a.call(r) === "[object String]";
}
function ve(r) {
  return typeof r == "number";
}
function dist_X(r) {
  var e = typeof r;
  return e === "function" || !!r && e === "object";
}
function bp(r) {
  return !!d3[$a.call(r)];
}
function ht(r) {
  return !!p3[$a.call(r)];
}
function La(r) {
  return typeof r == "object" && typeof r.nodeType == "number" && typeof r.ownerDocument == "object";
}
function ef(r) {
  return r.colorStops != null;
}
function Xx(r) {
  return r.image != null;
}
function y3(r) {
  return $a.call(r) === "[object RegExp]";
}
function as(r) {
  return r !== r;
}
function Kt() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  for (var t = 0, n = r.length; t < n; t++)
    if (r[t] != null)
      return r[t];
}
function dist_ne(r, e) {
  return r ?? e;
}
function Dr(r, e, t) {
  return r ?? e ?? t;
}
function bd(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return Sd.apply(r, e);
}
function _3(r) {
  if (typeof r == "number")
    return [r, r, r, r];
  var e = r.length;
  return e === 2 ? [r[0], r[1], r[0], r[1]] : e === 3 ? [r[0], r[1], r[2], r[1]] : r;
}
function dist_re(r, e) {
  if (!r)
    throw new Error(e);
}
function or(r) {
  return r == null ? null : typeof r.trim == "function" ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var S3 = "__ec_primitive__";
function su(r) {
  r[S3] = !0;
}
function Bo(r) {
  return r[S3];
}
var Zx = function() {
  function r() {
    this.data = {};
  }
  return r.prototype.delete = function(e) {
    var t = this.has(e);
    return t && delete this.data[e], t;
  }, r.prototype.has = function(e) {
    return this.data.hasOwnProperty(e);
  }, r.prototype.get = function(e) {
    return this.data[e];
  }, r.prototype.set = function(e, t) {
    return this.data[e] = t, this;
  }, r.prototype.keys = function() {
    return we(this.data);
  }, r.prototype.forEach = function(e) {
    var t = this.data;
    for (var n in t)
      t.hasOwnProperty(n) && e(t[n], n);
  }, r;
}(), w3 = typeof Map == "function";
function qx() {
  return w3 ? /* @__PURE__ */ new Map() : new Zx();
}
var Kx = function() {
  function r(e) {
    var t = dist_F(e);
    this.data = qx();
    var n = this;
    e instanceof r ? e.each(i) : e && dist_M(e, i);
    function i(a, o) {
      t ? n.set(a, o) : n.set(o, a);
    }
  }
  return r.prototype.hasKey = function(e) {
    return this.data.has(e);
  }, r.prototype.get = function(e) {
    return this.data.get(e);
  }, r.prototype.set = function(e, t) {
    return this.data.set(e, t), t;
  }, r.prototype.each = function(e, t) {
    this.data.forEach(function(n, i) {
      e.call(t, n, i);
    });
  }, r.prototype.keys = function() {
    var e = this.data.keys();
    return w3 ? Array.from(e) : e;
  }, r.prototype.removeKey = function(e) {
    this.data.delete(e);
  }, r;
}();
function dist_W(r) {
  return new Kx(r);
}
function Kh(r, e) {
  for (var t = new r.constructor(r.length + e.length), n = 0; n < r.length; n++)
    t[n] = r[n];
  for (var i = r.length, n = 0; n < e.length; n++)
    t[n + i] = e[n];
  return t;
}
function tf(r, e) {
  var t;
  if (Object.create)
    t = Object.create(r);
  else {
    var n = function() {
    };
    n.prototype = r, t = new n();
  }
  return e && dist_V(t, e), t;
}
function b3(r) {
  var e = r.style;
  e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none";
}
function xt(r, e) {
  return r.hasOwnProperty(e);
}
function Ue() {
}
var jx = 180 / Math.PI;
function Fi(r, e) {
  return r == null && (r = 0), e == null && (e = 0), [r, e];
}
function st(r, e) {
  return r[0] = e[0], r[1] = e[1], r;
}
function Ur(r) {
  return [r[0], r[1]];
}
function Jx(r, e, t) {
  return r[0] = e, r[1] = t, r;
}
function xp(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function jh(r, e, t, n) {
  return r[0] = e[0] + t[0] * n, r[1] = e[1] + t[1] * n, r;
}
function bi(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r;
}
function Jh(r) {
  return Math.sqrt(Qx(r));
}
function Qx(r) {
  return r[0] * r[0] + r[1] * r[1];
}
function zl(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r;
}
function Wa(r, e) {
  var t = Jh(e);
  return t === 0 ? (r[0] = 0, r[1] = 0) : (r[0] = e[0] / t, r[1] = e[1] / t), r;
}
function Qh(r, e) {
  return Math.sqrt((r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]));
}
var In = Qh;
function e7(r, e) {
  return (r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]);
}
var Ai = e7;
function Gl(r, e, t, n) {
  return r[0] = e[0] + n * (t[0] - e[0]), r[1] = e[1] + n * (t[1] - e[1]), r;
}
function Xe(r, e, t) {
  var n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i + t[4], r[1] = t[1] * n + t[3] * i + t[5], r;
}
function Ln(r, e, t) {
  return r[0] = Math.min(e[0], t[0]), r[1] = Math.min(e[1], t[1]), r;
}
function Nn(r, e, t) {
  return r[0] = Math.max(e[0], t[0]), r[1] = Math.max(e[1], t[1]), r;
}
var Zi = /* @__PURE__ */ function() {
  function r(e, t) {
    this.target = e, this.topTarget = t && t.topTarget;
  }
  return r;
}(), t7 = function() {
  function r(e) {
    this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this);
  }
  return r.prototype._dragStart = function(e) {
    for (var t = e.target; t && !t.draggable; )
      t = t.parent || t.__hostTarget;
    t && (this._draggingTarget = t, t.dragging = !0, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new Zi(t, e), "dragstart", e.event));
  }, r.prototype._drag = function(e) {
    var t = this._draggingTarget;
    if (t) {
      var n = e.offsetX, i = e.offsetY, a = n - this._x, o = i - this._y;
      this._x = n, this._y = i, t.drift(a, o, e), this.handler.dispatchToElement(new Zi(t, e), "drag", e.event);
      var s = this.handler.findHover(n, i, t).target, l = this._dropTarget;
      this._dropTarget = s, t !== s && (l && s !== l && this.handler.dispatchToElement(new Zi(l, e), "dragleave", e.event), s && s !== l && this.handler.dispatchToElement(new Zi(s, e), "dragenter", e.event));
    }
  }, r.prototype._dragEnd = function(e) {
    var t = this._draggingTarget;
    t && (t.dragging = !1), this.handler.dispatchToElement(new Zi(t, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new Zi(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null;
  }, r;
}(), vr = function() {
  function r(e) {
    e && (this._$eventProcessor = e);
  }
  return r.prototype.on = function(e, t, n, i) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof t == "function" && (i = n, n = t, t = null), !n || !e)
      return this;
    var o = this._$eventProcessor;
    t != null && o && o.normalizeQuery && (t = o.normalizeQuery(t)), a[e] || (a[e] = []);
    for (var s = 0; s < a[e].length; s++)
      if (a[e][s].h === n)
        return this;
    var l = {
      h: n,
      query: t,
      ctx: i || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = a[e].length - 1, f = a[e][u];
    return f && f.callAtLast ? a[e].splice(u, 0, l) : a[e].push(l), this;
  }, r.prototype.isSilent = function(e) {
    var t = this._$handlers;
    return !t || !t[e] || !t[e].length;
  }, r.prototype.off = function(e, t) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!e)
      return this._$handlers = {}, this;
    if (t) {
      if (n[e]) {
        for (var i = [], a = 0, o = n[e].length; a < o; a++)
          n[e][a].h !== t && i.push(n[e][a]);
        n[e] = i;
      }
      n[e] && n[e].length === 0 && delete n[e];
    } else
      delete n[e];
    return this;
  }, r.prototype.trigger = function(e) {
    for (var t = [], n = 1; n < arguments.length; n++)
      t[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[e], a = this._$eventProcessor;
    if (i)
      for (var o = t.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(a && a.filter && u.query != null && !a.filter(e, u.query)))
          switch (o) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, t[0]);
              break;
            case 2:
              u.h.call(u.ctx, t[0], t[1]);
              break;
            default:
              u.h.apply(u.ctx, t);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(e), this;
  }, r.prototype.triggerWithContext = function(e) {
    for (var t = [], n = 1; n < arguments.length; n++)
      t[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[e], a = this._$eventProcessor;
    if (i)
      for (var o = t.length, s = t[o - 1], l = i.length, u = 0; u < l; u++) {
        var f = i[u];
        if (!(a && a.filter && f.query != null && !a.filter(e, f.query)))
          switch (o) {
            case 0:
              f.h.call(s);
              break;
            case 1:
              f.h.call(s, t[0]);
              break;
            case 2:
              f.h.call(s, t[0], t[1]);
              break;
            default:
              f.h.apply(s, t.slice(1, o - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(e), this;
  }, r;
}(), r7 = Math.log(2);
function ev(r, e, t, n, i, a) {
  var o = n + "-" + i, s = r.length;
  if (a.hasOwnProperty(o))
    return a[o];
  if (e === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~i) / r7);
    return r[t][l];
  }
  for (var u = n | 1 << t, f = t + 1; n & 1 << f; )
    f++;
  for (var c = 0, h = 0, v = 0; h < s; h++) {
    var d = 1 << h;
    d & i || (c += (v % 2 ? -1 : 1) * r[t][h] * ev(r, e - 1, f, u, i | d, a), v++);
  }
  return a[o] = c, c;
}
function Cp(r, e) {
  var t = [
    [r[0], r[1], 1, 0, 0, 0, -e[0] * r[0], -e[0] * r[1]],
    [0, 0, 0, r[0], r[1], 1, -e[1] * r[0], -e[1] * r[1]],
    [r[2], r[3], 1, 0, 0, 0, -e[2] * r[2], -e[2] * r[3]],
    [0, 0, 0, r[2], r[3], 1, -e[3] * r[2], -e[3] * r[3]],
    [r[4], r[5], 1, 0, 0, 0, -e[4] * r[4], -e[4] * r[5]],
    [0, 0, 0, r[4], r[5], 1, -e[5] * r[4], -e[5] * r[5]],
    [r[6], r[7], 1, 0, 0, 0, -e[6] * r[6], -e[6] * r[7]],
    [0, 0, 0, r[6], r[7], 1, -e[7] * r[6], -e[7] * r[7]]
  ], n = {}, i = ev(t, 8, 0, 0, 0, n);
  if (i !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * ev(t, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, n) / i * e[o];
    return function(l, u, f) {
      var c = u * a[6] + f * a[7] + 1;
      l[0] = (u * a[0] + f * a[1] + a[2]) / c, l[1] = (u * a[3] + f * a[4] + a[5]) / c;
    };
  }
}
var Tp = "___zrEVENTSAVED", Yf = [];
function n7(r, e, t, n, i) {
  return tv(Yf, e, n, i, !0) && tv(r, t, Yf[0], Yf[1]);
}
function tv(r, e, t, n, i) {
  if (e.getBoundingClientRect && dist_ee.domSupported && !x3(e)) {
    var a = e[Tp] || (e[Tp] = {}), o = i7(e, a), s = a7(o, a, i);
    if (s)
      return s(r, t, n), !0;
  }
  return !1;
}
function i7(r, e) {
  var t = e.markers;
  if (t)
    return t;
  t = e.markers = [];
  for (var n = ["left", "right"], i = ["top", "bottom"], a = 0; a < 4; a++) {
    var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      i[u] + ":0",
      n[1 - l] + ":auto",
      i[1 - u] + ":auto",
      ""
    ].join("!important;"), r.appendChild(o), t.push(o);
  }
  return t;
}
function a7(r, e, t) {
  for (var n = t ? "invTrans" : "trans", i = e[n], a = e.srcCoords, o = [], s = [], l = !0, u = 0; u < 4; u++) {
    var f = r[u].getBoundingClientRect(), c = 2 * u, h = f.left, v = f.top;
    o.push(h, v), l = l && a && h === a[c] && v === a[c + 1], s.push(r[u].offsetLeft, r[u].offsetTop);
  }
  return l && i ? i : (e.srcCoords = o, e[n] = t ? Cp(s, o) : Cp(o, s));
}
function x3(r) {
  return r.nodeName.toUpperCase() === "CANVAS";
}
var o7 = /([&<>"'])/g, s7 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Wt(r) {
  return r == null ? "" : (r + "").replace(o7, function(e, t) {
    return s7[t];
  });
}
var l7 = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Xf = [], u7 = dist_ee.browser.firefox && +dist_ee.browser.version.split(".")[0] < 39;
function rv(r, e, t, n) {
  return t = t || {}, n ? Mp(r, e, t) : u7 && e.layerX != null && e.layerX !== e.offsetX ? (t.zrX = e.layerX, t.zrY = e.layerY) : e.offsetX != null ? (t.zrX = e.offsetX, t.zrY = e.offsetY) : Mp(r, e, t), t;
}
function Mp(r, e, t) {
  if (dist_ee.domSupported && r.getBoundingClientRect) {
    var n = e.clientX, i = e.clientY;
    if (x3(r)) {
      var a = r.getBoundingClientRect();
      t.zrX = n - a.left, t.zrY = i - a.top;
      return;
    } else if (tv(Xf, r, n, i)) {
      t.zrX = Xf[0], t.zrY = Xf[1];
      return;
    }
  }
  t.zrX = t.zrY = 0;
}
function xd(r) {
  return r || window.event;
}
function Gt(r, e, t) {
  if (e = xd(e), e.zrX != null)
    return e;
  var n = e.type, i = n && n.indexOf("touch") >= 0;
  if (i) {
    var o = n !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
    o && rv(r, o, e, t);
  } else {
    rv(r, e, e, t);
    var a = f7(e);
    e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3;
  }
  var s = e.button;
  return e.which == null && s !== void 0 && l7.test(e.type) && (e.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), e;
}
function f7(r) {
  var e = r.wheelDelta;
  if (e)
    return e;
  var t = r.deltaX, n = r.deltaY;
  if (t == null || n == null)
    return e;
  var i = Math.abs(n !== 0 ? n : t), a = n > 0 ? -1 : n < 0 ? 1 : t > 0 ? -1 : 1;
  return 3 * i * a;
}
function c7(r, e, t, n) {
  r.addEventListener(e, t, n);
}
function h7(r, e, t, n) {
  r.removeEventListener(e, t, n);
}
var Qr = function(r) {
  r.preventDefault(), r.stopPropagation(), r.cancelBubble = !0;
};
function Dp(r) {
  return r.which === 2 || r.which === 3;
}
var v7 = function() {
  function r() {
    this._track = [];
  }
  return r.prototype.recognize = function(e, t, n) {
    return this._doTrack(e, t, n), this._recognize(e);
  }, r.prototype.clear = function() {
    return this._track.length = 0, this;
  }, r.prototype._doTrack = function(e, t, n) {
    var i = e.touches;
    if (i) {
      for (var a = {
        points: [],
        touches: [],
        target: t,
        event: e
      }, o = 0, s = i.length; o < s; o++) {
        var l = i[o], u = rv(n, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, r.prototype._recognize = function(e) {
    for (var t in Zf)
      if (Zf.hasOwnProperty(t)) {
        var n = Zf[t](this._track, e);
        if (n)
          return n;
      }
  }, r;
}();
function Ep(r) {
  var e = r[1][0] - r[0][0], t = r[1][1] - r[0][1];
  return Math.sqrt(e * e + t * t);
}
function d7(r) {
  return [
    (r[0][0] + r[1][0]) / 2,
    (r[0][1] + r[1][1]) / 2
  ];
}
var Zf = {
  pinch: function(r, e) {
    var t = r.length;
    if (t) {
      var n = (r[t - 1] || {}).points, i = (r[t - 2] || {}).points || n;
      if (i && i.length > 1 && n && n.length > 1) {
        var a = Ep(n) / Ep(i);
        !isFinite(a) && (a = 1), e.pinchScale = a;
        var o = d7(n);
        return e.pinchX = o[0], e.pinchY = o[1], {
          type: "pinch",
          target: r[0].target,
          event: e
        };
      }
    }
  }
};
function Yr() {
  return [1, 0, 0, 1, 0, 0];
}
function rf(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
}
function Cd(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r;
}
function Xr(r, e, t) {
  var n = e[0] * t[0] + e[2] * t[1], i = e[1] * t[0] + e[3] * t[1], a = e[0] * t[2] + e[2] * t[3], o = e[1] * t[2] + e[3] * t[3], s = e[0] * t[4] + e[2] * t[5] + e[4], l = e[1] * t[4] + e[3] * t[5] + e[5];
  return r[0] = n, r[1] = i, r[2] = a, r[3] = o, r[4] = s, r[5] = l, r;
}
function lu(r, e, t) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4] + t[0], r[5] = e[5] + t[1], r;
}
function nf(r, e, t, n) {
  n === void 0 && (n = [0, 0]);
  var i = e[0], a = e[2], o = e[4], s = e[1], l = e[3], u = e[5], f = Math.sin(t), c = Math.cos(t);
  return r[0] = i * c + s * f, r[1] = -i * f + s * c, r[2] = a * c + l * f, r[3] = -a * f + c * l, r[4] = c * (o - n[0]) + f * (u - n[1]) + n[0], r[5] = c * (u - n[1]) - f * (o - n[0]) + n[1], r;
}
function C3(r, e, t) {
  var n = t[0], i = t[1];
  return r[0] = e[0] * n, r[1] = e[1] * i, r[2] = e[2] * n, r[3] = e[3] * i, r[4] = e[4] * n, r[5] = e[5] * i, r;
}
function Ua(r, e) {
  var t = e[0], n = e[2], i = e[4], a = e[1], o = e[3], s = e[5], l = t * o - a * n;
  return l ? (l = 1 / l, r[0] = o * l, r[1] = -a * l, r[2] = -n * l, r[3] = t * l, r[4] = (n * s - o * i) * l, r[5] = (a * i - t * s) * l, r) : null;
}
function p7(r) {
  var e = Yr();
  return Cd(e, r), e;
}
var g7 = function() {
  function r(e, t) {
    this.x = e || 0, this.y = t || 0;
  }
  return r.prototype.copy = function(e) {
    return this.x = e.x, this.y = e.y, this;
  }, r.prototype.clone = function() {
    return new r(this.x, this.y);
  }, r.prototype.set = function(e, t) {
    return this.x = e, this.y = t, this;
  }, r.prototype.equal = function(e) {
    return e.x === this.x && e.y === this.y;
  }, r.prototype.add = function(e) {
    return this.x += e.x, this.y += e.y, this;
  }, r.prototype.scale = function(e) {
    this.x *= e, this.y *= e;
  }, r.prototype.scaleAndAdd = function(e, t) {
    this.x += e.x * t, this.y += e.y * t;
  }, r.prototype.sub = function(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }, r.prototype.dot = function(e) {
    return this.x * e.x + this.y * e.y;
  }, r.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, r.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, r.prototype.normalize = function() {
    var e = this.len();
    return this.x /= e, this.y /= e, this;
  }, r.prototype.distance = function(e) {
    var t = this.x - e.x, n = this.y - e.y;
    return Math.sqrt(t * t + n * n);
  }, r.prototype.distanceSquare = function(e) {
    var t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }, r.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, r.prototype.transform = function(e) {
    if (e) {
      var t = this.x, n = this.y;
      return this.x = e[0] * t + e[2] * n + e[4], this.y = e[1] * t + e[3] * n + e[5], this;
    }
  }, r.prototype.toArray = function(e) {
    return e[0] = this.x, e[1] = this.y, e;
  }, r.prototype.fromArray = function(e) {
    this.x = e[0], this.y = e[1];
  }, r.set = function(e, t, n) {
    e.x = t, e.y = n;
  }, r.copy = function(e, t) {
    e.x = t.x, e.y = t.y;
  }, r.len = function(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y);
  }, r.lenSquare = function(e) {
    return e.x * e.x + e.y * e.y;
  }, r.dot = function(e, t) {
    return e.x * t.x + e.y * t.y;
  }, r.add = function(e, t, n) {
    e.x = t.x + n.x, e.y = t.y + n.y;
  }, r.sub = function(e, t, n) {
    e.x = t.x - n.x, e.y = t.y - n.y;
  }, r.scale = function(e, t, n) {
    e.x = t.x * n, e.y = t.y * n;
  }, r.scaleAndAdd = function(e, t, n, i) {
    e.x = t.x + n.x * i, e.y = t.y + n.y * i;
  }, r.lerp = function(e, t, n, i) {
    var a = 1 - i;
    e.x = a * t.x + i * n.x, e.y = a * t.y + i * n.y;
  }, r;
}();
const dist_K = g7;
var Ys = Math.min, Xs = Math.max, Zn = new dist_K(), qn = new dist_K(), Kn = new dist_K(), jn = new dist_K(), eo = new dist_K(), to = new dist_K(), dist_ae = function() {
  function r(e, t, n, i) {
    n < 0 && (e = e + n, n = -n), i < 0 && (t = t + i, i = -i), this.x = e, this.y = t, this.width = n, this.height = i;
  }
  return r.prototype.union = function(e) {
    var t = Ys(e.x, this.x), n = Ys(e.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Xs(e.x + e.width, this.x + this.width) - t : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = Xs(e.y + e.height, this.y + this.height) - n : this.height = e.height, this.x = t, this.y = n;
  }, r.prototype.applyTransform = function(e) {
    r.applyTransform(this, this, e);
  }, r.prototype.calculateTransform = function(e) {
    var t = this, n = e.width / t.width, i = e.height / t.height, a = Yr();
    return lu(a, a, [-t.x, -t.y]), C3(a, a, [n, i]), lu(a, a, [e.x, e.y]), a;
  }, r.prototype.intersect = function(e, t) {
    if (!e)
      return !1;
    e instanceof r || (e = r.create(e));
    var n = this, i = n.x, a = n.x + n.width, o = n.y, s = n.y + n.height, l = e.x, u = e.x + e.width, f = e.y, c = e.y + e.height, h = !(a < l || u < i || s < f || c < o);
    if (t) {
      var v = 1 / 0, d = 0, g = Math.abs(a - l), p = Math.abs(u - i), m = Math.abs(s - f), y = Math.abs(c - o), _ = Math.min(g, p), S = Math.min(m, y);
      a < l || u < i ? _ > d && (d = _, g < p ? dist_K.set(to, -g, 0) : dist_K.set(to, p, 0)) : _ < v && (v = _, g < p ? dist_K.set(eo, g, 0) : dist_K.set(eo, -p, 0)), s < f || c < o ? S > d && (d = S, m < y ? dist_K.set(to, 0, -m) : dist_K.set(to, 0, y)) : _ < v && (v = _, m < y ? dist_K.set(eo, 0, m) : dist_K.set(eo, 0, -y));
    }
    return t && dist_K.copy(t, h ? eo : to), h;
  }, r.prototype.contain = function(e, t) {
    var n = this;
    return e >= n.x && e <= n.x + n.width && t >= n.y && t <= n.y + n.height;
  }, r.prototype.clone = function() {
    return new r(this.x, this.y, this.width, this.height);
  }, r.prototype.copy = function(e) {
    r.copy(this, e);
  }, r.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, r.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, r.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, r.create = function(e) {
    return new r(e.x, e.y, e.width, e.height);
  }, r.copy = function(e, t) {
    e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height;
  }, r.applyTransform = function(e, t, n) {
    if (!n) {
      e !== t && r.copy(e, t);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var i = n[0], a = n[3], o = n[4], s = n[5];
      e.x = t.x * i + o, e.y = t.y * a + s, e.width = t.width * i, e.height = t.height * a, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
      return;
    }
    Zn.x = Kn.x = t.x, Zn.y = jn.y = t.y, qn.x = jn.x = t.x + t.width, qn.y = Kn.y = t.y + t.height, Zn.transform(n), jn.transform(n), qn.transform(n), Kn.transform(n), e.x = Ys(Zn.x, qn.x, Kn.x, jn.x), e.y = Ys(Zn.y, qn.y, Kn.y, jn.y);
    var l = Xs(Zn.x, qn.x, Kn.x, jn.x), u = Xs(Zn.y, qn.y, Kn.y, jn.y);
    e.width = l - e.x, e.height = u - e.y;
  }, r;
}(), T3 = "silent";
function m7(r, e, t) {
  return {
    type: r,
    event: t,
    target: e.target,
    topTarget: e.topTarget,
    cancelBubble: !1,
    offsetX: t.zrX,
    offsetY: t.zrY,
    gestureEvent: t.gestureEvent,
    pinchX: t.pinchX,
    pinchY: t.pinchY,
    pinchScale: t.pinchScale,
    wheelDelta: t.zrDelta,
    zrByTouch: t.zrByTouch,
    which: t.which,
    stop: y7
  };
}
function y7() {
  Qr(this.event);
}
var _7 = function(r) {
  dist_k(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.handler = null, t;
  }
  return e.prototype.dispose = function() {
  }, e.prototype.setCursor = function() {
  }, e;
}(vr), ro = /* @__PURE__ */ function() {
  function r(e, t) {
    this.x = e, this.y = t;
  }
  return r;
}(), S7 = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], qf = new dist_ae(0, 0, 0, 0), M3 = function(r) {
  dist_k(e, r);
  function e(t, n, i, a, o) {
    var s = r.call(this) || this;
    return s._hovered = new ro(0, 0), s.storage = t, s.painter = n, s.painterRoot = a, s._pointerSize = o, i = i || new _7(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new t7(s), s;
  }
  return e.prototype.setHandlerProxy = function(t) {
    this.proxy && this.proxy.dispose(), t && (dist_M(S7, function(n) {
      t.on && t.on(n, this[n], this);
    }, this), t.handler = this), this.proxy = t;
  }, e.prototype.mousemove = function(t) {
    var n = t.zrX, i = t.zrY, a = D3(this, n, i), o = this._hovered, s = o.target;
    s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
    var l = this._hovered = a ? new ro(n, i) : this.findHover(n, i), u = l.target, f = this.proxy;
    f.setCursor && f.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", t), this.dispatchToElement(l, "mousemove", t), u && u !== s && this.dispatchToElement(l, "mouseover", t);
  }, e.prototype.mouseout = function(t) {
    var n = t.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: t });
  }, e.prototype.resize = function() {
    this._hovered = new ro(0, 0);
  }, e.prototype.dispatch = function(t, n) {
    var i = this[t];
    i && i.call(this, n);
  }, e.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, e.prototype.setCursorStyle = function(t) {
    var n = this.proxy;
    n.setCursor && n.setCursor(t);
  }, e.prototype.dispatchToElement = function(t, n, i) {
    t = t || {};
    var a = t.target;
    if (!(a && a.silent)) {
      for (var o = "on" + n, s = m7(n, t, i); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(n, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(n, s);
      }));
    }
  }, e.prototype.findHover = function(t, n, i) {
    var a = this.storage.getDisplayList(), o = new ro(t, n);
    if (Ap(a, o, t, n, i), this._pointerSize && !o.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, f = new dist_ae(t - u, n - u, l, l), c = a.length - 1; c >= 0; c--) {
        var h = a[c];
        h !== i && !h.ignore && !h.ignoreCoarsePointer && (!h.parent || !h.parent.ignoreCoarsePointer) && (qf.copy(h.getBoundingRect()), h.transform && qf.applyTransform(h.transform), qf.intersect(f) && s.push(h));
      }
      if (s.length)
        for (var v = 4, d = Math.PI / 12, g = Math.PI * 2, p = 0; p < u; p += v)
          for (var m = 0; m < g; m += d) {
            var y = t + p * Math.cos(m), _ = n + p * Math.sin(m);
            if (Ap(s, o, y, _, i), o.target)
              return o;
          }
    }
    return o;
  }, e.prototype.processGesture = function(t, n) {
    this._gestureMgr || (this._gestureMgr = new v7());
    var i = this._gestureMgr;
    n === "start" && i.clear();
    var a = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
    if (n === "end" && i.clear(), a) {
      var o = a.type;
      t.gestureEvent = o;
      var s = new ro();
      s.target = a.target, this.dispatchToElement(s, o, a.event);
    }
  }, e;
}(vr);
dist_M(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(r) {
  M3.prototype[r] = function(e) {
    var t = e.zrX, n = e.zrY, i = D3(this, t, n), a, o;
    if ((r !== "mouseup" || !i) && (a = this.findHover(t, n), o = a.target), r === "mousedown")
      this._downEl = o, this._downPoint = [e.zrX, e.zrY], this._upEl = o;
    else if (r === "mouseup")
      this._upEl = o;
    else if (r === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || In(this._downPoint, [e.zrX, e.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, r, e);
  };
});
function w7(r, e, t) {
  if (r[r.rectHover ? "rectContain" : "contain"](e, t)) {
    for (var n = r, i = void 0, a = !1; n; ) {
      if (n.ignoreClip && (a = !0), !a) {
        var o = n.getClipPath();
        if (o && !o.contain(e, t))
          return !1;
      }
      n.silent && (i = !0);
      var s = n.__hostTarget;
      n = s || n.parent;
    }
    return i ? T3 : !0;
  }
  return !1;
}
function Ap(r, e, t, n, i) {
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a], s = void 0;
    if (o !== i && !o.ignore && (s = w7(o, t, n)) && (!e.topTarget && (e.topTarget = o), s !== T3)) {
      e.target = o;
      break;
    }
  }
}
function D3(r, e, t) {
  var n = r.painter;
  return e < 0 || e > n.getWidth() || t < 0 || t > n.getHeight();
}
const b7 = M3;
var E3 = 32, no = 7;
function x7(r) {
  for (var e = 0; r >= E3; )
    e |= r & 1, r >>= 1;
  return r + e;
}
function Ip(r, e, t, n) {
  var i = e + 1;
  if (i === t)
    return 1;
  if (n(r[i++], r[e]) < 0) {
    for (; i < t && n(r[i], r[i - 1]) < 0; )
      i++;
    C7(r, e, i);
  } else
    for (; i < t && n(r[i], r[i - 1]) >= 0; )
      i++;
  return i - e;
}
function C7(r, e, t) {
  for (t--; e < t; ) {
    var n = r[e];
    r[e++] = r[t], r[t--] = n;
  }
}
function Lp(r, e, t, n, i) {
  for (n === e && n++; n < t; n++) {
    for (var a = r[n], o = e, s = n, l; o < s; )
      l = o + s >>> 1, i(a, r[l]) < 0 ? s = l : o = l + 1;
    var u = n - o;
    switch (u) {
      case 3:
        r[o + 3] = r[o + 2];
      case 2:
        r[o + 2] = r[o + 1];
      case 1:
        r[o + 1] = r[o];
        break;
      default:
        for (; u > 0; )
          r[o + u] = r[o + u - 1], u--;
    }
    r[o] = a;
  }
}
function Kf(r, e, t, n, i, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, e[t + i]) > 0) {
    for (s = n - i; l < s && a(r, e[t + i + l]) > 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += i, l += i;
  } else {
    for (s = i + 1; l < s && a(r, e[t + i - l]) <= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = i - l, l = i - u;
  }
  for (o++; o < l; ) {
    var f = o + (l - o >>> 1);
    a(r, e[t + f]) > 0 ? o = f + 1 : l = f;
  }
  return l;
}
function jf(r, e, t, n, i, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, e[t + i]) < 0) {
    for (s = i + 1; l < s && a(r, e[t + i - l]) < 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = i - l, l = i - u;
  } else {
    for (s = n - i; l < s && a(r, e[t + i + l]) >= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += i, l += i;
  }
  for (o++; o < l; ) {
    var f = o + (l - o >>> 1);
    a(r, e[t + f]) < 0 ? l = f : o = f + 1;
  }
  return l;
}
function T7(r, e) {
  var t = no, n, i, a = 0, o = [];
  n = [], i = [];
  function s(v, d) {
    n[a] = v, i[a] = d, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var v = a - 2;
      if (v >= 1 && i[v - 1] <= i[v] + i[v + 1] || v >= 2 && i[v - 2] <= i[v] + i[v - 1])
        i[v - 1] < i[v + 1] && v--;
      else if (i[v] > i[v + 1])
        break;
      f(v);
    }
  }
  function u() {
    for (; a > 1; ) {
      var v = a - 2;
      v > 0 && i[v - 1] < i[v + 1] && v--, f(v);
    }
  }
  function f(v) {
    var d = n[v], g = i[v], p = n[v + 1], m = i[v + 1];
    i[v] = g + m, v === a - 3 && (n[v + 1] = n[v + 2], i[v + 1] = i[v + 2]), a--;
    var y = jf(r[p], r, d, g, 0, e);
    d += y, g -= y, g !== 0 && (m = Kf(r[d + g - 1], r, p, m, m - 1, e), m !== 0 && (g <= m ? c(d, g, p, m) : h(d, g, p, m)));
  }
  function c(v, d, g, p) {
    var m = 0;
    for (m = 0; m < d; m++)
      o[m] = r[v + m];
    var y = 0, _ = g, S = v;
    if (r[S++] = r[_++], --p === 0) {
      for (m = 0; m < d; m++)
        r[S + m] = o[y + m];
      return;
    }
    if (d === 1) {
      for (m = 0; m < p; m++)
        r[S + m] = r[_ + m];
      r[S + p] = o[y];
      return;
    }
    for (var b = t, w, x, C; ; ) {
      w = 0, x = 0, C = !1;
      do
        if (e(r[_], o[y]) < 0) {
          if (r[S++] = r[_++], x++, w = 0, --p === 0) {
            C = !0;
            break;
          }
        } else if (r[S++] = o[y++], w++, x = 0, --d === 1) {
          C = !0;
          break;
        }
      while ((w | x) < b);
      if (C)
        break;
      do {
        if (w = jf(r[_], o, y, d, 0, e), w !== 0) {
          for (m = 0; m < w; m++)
            r[S + m] = o[y + m];
          if (S += w, y += w, d -= w, d <= 1) {
            C = !0;
            break;
          }
        }
        if (r[S++] = r[_++], --p === 0) {
          C = !0;
          break;
        }
        if (x = Kf(o[y], r, _, p, 0, e), x !== 0) {
          for (m = 0; m < x; m++)
            r[S + m] = r[_ + m];
          if (S += x, _ += x, p -= x, p === 0) {
            C = !0;
            break;
          }
        }
        if (r[S++] = o[y++], --d === 1) {
          C = !0;
          break;
        }
        b--;
      } while (w >= no || x >= no);
      if (C)
        break;
      b < 0 && (b = 0), b += 2;
    }
    if (t = b, t < 1 && (t = 1), d === 1) {
      for (m = 0; m < p; m++)
        r[S + m] = r[_ + m];
      r[S + p] = o[y];
    } else {
      if (d === 0)
        throw new Error();
      for (m = 0; m < d; m++)
        r[S + m] = o[y + m];
    }
  }
  function h(v, d, g, p) {
    var m = 0;
    for (m = 0; m < p; m++)
      o[m] = r[g + m];
    var y = v + d - 1, _ = p - 1, S = g + p - 1, b = 0, w = 0;
    if (r[S--] = r[y--], --d === 0) {
      for (b = S - (p - 1), m = 0; m < p; m++)
        r[b + m] = o[m];
      return;
    }
    if (p === 1) {
      for (S -= d, y -= d, w = S + 1, b = y + 1, m = d - 1; m >= 0; m--)
        r[w + m] = r[b + m];
      r[S] = o[_];
      return;
    }
    for (var x = t; ; ) {
      var C = 0, T = 0, E = !1;
      do
        if (e(o[_], r[y]) < 0) {
          if (r[S--] = r[y--], C++, T = 0, --d === 0) {
            E = !0;
            break;
          }
        } else if (r[S--] = o[_--], T++, C = 0, --p === 1) {
          E = !0;
          break;
        }
      while ((C | T) < x);
      if (E)
        break;
      do {
        if (C = d - jf(o[_], r, v, d, d - 1, e), C !== 0) {
          for (S -= C, y -= C, d -= C, w = S + 1, b = y + 1, m = C - 1; m >= 0; m--)
            r[w + m] = r[b + m];
          if (d === 0) {
            E = !0;
            break;
          }
        }
        if (r[S--] = o[_--], --p === 1) {
          E = !0;
          break;
        }
        if (T = p - Kf(r[y], o, 0, p, p - 1, e), T !== 0) {
          for (S -= T, _ -= T, p -= T, w = S + 1, b = _ + 1, m = 0; m < T; m++)
            r[w + m] = o[b + m];
          if (p <= 1) {
            E = !0;
            break;
          }
        }
        if (r[S--] = r[y--], --d === 0) {
          E = !0;
          break;
        }
        x--;
      } while (C >= no || T >= no);
      if (E)
        break;
      x < 0 && (x = 0), x += 2;
    }
    if (t = x, t < 1 && (t = 1), p === 1) {
      for (S -= d, y -= d, w = S + 1, b = y + 1, m = d - 1; m >= 0; m--)
        r[w + m] = r[b + m];
      r[S] = o[_];
    } else {
      if (p === 0)
        throw new Error();
      for (b = S - (p - 1), m = 0; m < p; m++)
        r[b + m] = o[m];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function Hl(r, e, t, n) {
  t || (t = 0), n || (n = r.length);
  var i = n - t;
  if (!(i < 2)) {
    var a = 0;
    if (i < E3) {
      a = Ip(r, t, n, e), Lp(r, t, n, t + a, e);
      return;
    }
    var o = T7(r, e), s = x7(i);
    do {
      if (a = Ip(r, t, n, e), a < s) {
        var l = i;
        l > s && (l = s), Lp(r, t, t + l, t + a, e), a = l;
      }
      o.pushRun(t, a), o.mergeRuns(), i -= a, t += a;
    } while (i !== 0);
    o.forceMergeRuns();
  }
}
var Et = 1, Do = 2, ma = 4, Np = !1;
function Jf() {
  Np || (Np = !0);
}
function Pp(r, e) {
  return r.zlevel === e.zlevel ? r.z === e.z ? r.z2 - e.z2 : r.z - e.z : r.zlevel - e.zlevel;
}
var M7 = function() {
  function r() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = Pp;
  }
  return r.prototype.traverse = function(e, t) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(e, t);
  }, r.prototype.getDisplayList = function(e, t) {
    t = t || !1;
    var n = this._displayList;
    return (e || !n.length) && this.updateDisplayList(t), n;
  }, r.prototype.updateDisplayList = function(e) {
    this._displayListLen = 0;
    for (var t = this._roots, n = this._displayList, i = 0, a = t.length; i < a; i++)
      this._updateAndAddDisplayable(t[i], null, e);
    n.length = this._displayListLen, Hl(n, Pp);
  }, r.prototype._updateAndAddDisplayable = function(e, t, n) {
    if (!(e.ignore && !n)) {
      e.beforeUpdate(), e.update(), e.afterUpdate();
      var i = e.getClipPath();
      if (e.ignoreClip)
        t = null;
      else if (i) {
        t ? t = t.slice() : t = [];
        for (var a = i, o = e; a; )
          a.parent = o, a.updateTransform(), t.push(a), o = a, a = a.getClipPath();
      }
      if (e.childrenRef) {
        for (var s = e.childrenRef(), l = 0; l < s.length; l++) {
          var u = s[l];
          e.__dirty && (u.__dirty |= Et), this._updateAndAddDisplayable(u, t, n);
        }
        e.__dirty = 0;
      } else {
        var f = e;
        t && t.length ? f.__clipPaths = t : f.__clipPaths && f.__clipPaths.length > 0 && (f.__clipPaths = []), isNaN(f.z) && (Jf(), f.z = 0), isNaN(f.z2) && (Jf(), f.z2 = 0), isNaN(f.zlevel) && (Jf(), f.zlevel = 0), this._displayList[this._displayListLen++] = f;
      }
      var c = e.getDecalElement && e.getDecalElement();
      c && this._updateAndAddDisplayable(c, t, n);
      var h = e.getTextGuideLine();
      h && this._updateAndAddDisplayable(h, t, n);
      var v = e.getTextContent();
      v && this._updateAndAddDisplayable(v, t, n);
    }
  }, r.prototype.addRoot = function(e) {
    e.__zr && e.__zr.storage === this || this._roots.push(e);
  }, r.prototype.delRoot = function(e) {
    if (e instanceof Array) {
      for (var t = 0, n = e.length; t < n; t++)
        this.delRoot(e[t]);
      return;
    }
    var i = ye(this._roots, e);
    i >= 0 && this._roots.splice(i, 1);
  }, r.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, r.prototype.getRoots = function() {
    return this._roots;
  }, r.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, r;
}(), A3;
A3 = dist_ee.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(r) {
  return setTimeout(r, 16);
};
const nv = A3;
var Fo = {
  linear: function(r) {
    return r;
  },
  quadraticIn: function(r) {
    return r * r;
  },
  quadraticOut: function(r) {
    return r * (2 - r);
  },
  quadraticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
  },
  cubicIn: function(r) {
    return r * r * r;
  },
  cubicOut: function(r) {
    return --r * r * r + 1;
  },
  cubicInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
  },
  quarticIn: function(r) {
    return r * r * r * r;
  },
  quarticOut: function(r) {
    return 1 - --r * r * r * r;
  },
  quarticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
  },
  quinticIn: function(r) {
    return r * r * r * r * r;
  },
  quinticOut: function(r) {
    return --r * r * r * r * r + 1;
  },
  quinticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
  },
  sinusoidalIn: function(r) {
    return 1 - Math.cos(r * Math.PI / 2);
  },
  sinusoidalOut: function(r) {
    return Math.sin(r * Math.PI / 2);
  },
  sinusoidalInOut: function(r) {
    return 0.5 * (1 - Math.cos(Math.PI * r));
  },
  exponentialIn: function(r) {
    return r === 0 ? 0 : Math.pow(1024, r - 1);
  },
  exponentialOut: function(r) {
    return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
  },
  exponentialInOut: function(r) {
    return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
  },
  circularIn: function(r) {
    return 1 - Math.sqrt(1 - r * r);
  },
  circularOut: function(r) {
    return Math.sqrt(1 - --r * r);
  },
  circularInOut: function(r) {
    return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
  },
  elasticIn: function(r) {
    var e, t = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = n / 4) : e = n * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / n)));
  },
  elasticOut: function(r) {
    var e, t = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = n / 4) : e = n * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * r) * Math.sin((r - e) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(r) {
    var e, t = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = n / 4) : e = n * Math.asin(1 / t) / (2 * Math.PI), (r *= 2) < 1 ? -0.5 * (t * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / n)) : t * Math.pow(2, -10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(r) {
    var e = 1.70158;
    return r * r * ((e + 1) * r - e);
  },
  backOut: function(r) {
    var e = 1.70158;
    return --r * r * ((e + 1) * r + e) + 1;
  },
  backInOut: function(r) {
    var e = 2.5949095;
    return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
  },
  bounceIn: function(r) {
    return 1 - Fo.bounceOut(1 - r);
  },
  bounceOut: function(r) {
    return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
  },
  bounceInOut: function(r) {
    return r < 0.5 ? Fo.bounceIn(r * 2) * 0.5 : Fo.bounceOut(r * 2 - 1) * 0.5 + 0.5;
  }
}, Zs = Math.pow, Vn = Math.sqrt, uu = 1e-8, I3 = 1e-4, Rp = Vn(3), qs = 1 / 3, br = Fi(), Ut = Fi(), Ca = Fi();
function Pn(r) {
  return r > -uu && r < uu;
}
function L3(r) {
  return r > uu || r < -uu;
}
function ze(r, e, t, n, i) {
  var a = 1 - i;
  return a * a * (a * r + 3 * i * e) + i * i * (i * n + 3 * a * t);
}
function Op(r, e, t, n, i) {
  var a = 1 - i;
  return 3 * (((e - r) * a + 2 * (t - e) * i) * a + (n - t) * i * i);
}
function fu(r, e, t, n, i, a) {
  var o = n + 3 * (e - t) - r, s = 3 * (t - e * 2 + r), l = 3 * (e - r), u = r - i, f = s * s - 3 * o * l, c = s * l - 9 * o * u, h = l * l - 3 * s * u, v = 0;
  if (Pn(f) && Pn(c))
    if (Pn(s))
      a[0] = 0;
    else {
      var d = -l / s;
      d >= 0 && d <= 1 && (a[v++] = d);
    }
  else {
    var g = c * c - 4 * f * h;
    if (Pn(g)) {
      var p = c / f, d = -s / o + p, m = -p / 2;
      d >= 0 && d <= 1 && (a[v++] = d), m >= 0 && m <= 1 && (a[v++] = m);
    } else if (g > 0) {
      var y = Vn(g), _ = f * s + 1.5 * o * (-c + y), S = f * s + 1.5 * o * (-c - y);
      _ < 0 ? _ = -Zs(-_, qs) : _ = Zs(_, qs), S < 0 ? S = -Zs(-S, qs) : S = Zs(S, qs);
      var d = (-s - (_ + S)) / (3 * o);
      d >= 0 && d <= 1 && (a[v++] = d);
    } else {
      var b = (2 * f * s - 3 * o * c) / (2 * Vn(f * f * f)), w = Math.acos(b) / 3, x = Vn(f), C = Math.cos(w), d = (-s - 2 * x * C) / (3 * o), m = (-s + x * (C + Rp * Math.sin(w))) / (3 * o), T = (-s + x * (C - Rp * Math.sin(w))) / (3 * o);
      d >= 0 && d <= 1 && (a[v++] = d), m >= 0 && m <= 1 && (a[v++] = m), T >= 0 && T <= 1 && (a[v++] = T);
    }
  }
  return v;
}
function N3(r, e, t, n, i) {
  var a = 6 * t - 12 * e + 6 * r, o = 9 * e + 3 * n - 3 * r - 9 * t, s = 3 * e - 3 * r, l = 0;
  if (Pn(o)) {
    if (L3(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var f = a * a - 4 * o * s;
    if (Pn(f))
      i[0] = -a / (2 * o);
    else if (f > 0) {
      var c = Vn(f), u = (-a + c) / (2 * o), h = (-a - c) / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function Hn(r, e, t, n, i, a) {
  var o = (e - r) * i + r, s = (t - e) * i + e, l = (n - t) * i + t, u = (s - o) * i + o, f = (l - s) * i + s, c = (f - u) * i + u;
  a[0] = r, a[1] = o, a[2] = u, a[3] = c, a[4] = c, a[5] = f, a[6] = l, a[7] = n;
}
function P3(r, e, t, n, i, a, o, s, l, u, f) {
  var c, h = 5e-3, v = 1 / 0, d, g, p, m;
  br[0] = l, br[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    Ut[0] = ze(r, t, i, o, y), Ut[1] = ze(e, n, a, s, y), p = Ai(br, Ut), p < v && (c = y, v = p);
  v = 1 / 0;
  for (var _ = 0; _ < 32 && !(h < I3); _++)
    d = c - h, g = c + h, Ut[0] = ze(r, t, i, o, d), Ut[1] = ze(e, n, a, s, d), p = Ai(Ut, br), d >= 0 && p < v ? (c = d, v = p) : (Ca[0] = ze(r, t, i, o, g), Ca[1] = ze(e, n, a, s, g), m = Ai(Ca, br), g <= 1 && m < v ? (c = g, v = m) : h *= 0.5);
  return f && (f[0] = ze(r, t, i, o, c), f[1] = ze(e, n, a, s, c)), Vn(v);
}
function D7(r, e, t, n, i, a, o, s, l) {
  for (var u = r, f = e, c = 0, h = 1 / l, v = 1; v <= l; v++) {
    var d = v * h, g = ze(r, t, i, o, d), p = ze(e, n, a, s, d), m = g - u, y = p - f;
    c += Math.sqrt(m * m + y * y), u = g, f = p;
  }
  return c;
}
function We(r, e, t, n) {
  var i = 1 - n;
  return i * (i * r + 2 * n * e) + n * n * t;
}
function iv(r, e, t, n) {
  return 2 * ((1 - n) * (e - r) + n * (t - e));
}
function E7(r, e, t, n, i) {
  var a = r - 2 * e + t, o = 2 * (e - r), s = r - n, l = 0;
  if (Pn(a)) {
    if (L3(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var f = o * o - 4 * a * s;
    if (Pn(f)) {
      var u = -o / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u);
    } else if (f > 0) {
      var c = Vn(f), u = (-o + c) / (2 * a), h = (-o - c) / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function R3(r, e, t) {
  var n = r + t - 2 * e;
  return n === 0 ? 0.5 : (r - e) / n;
}
function os(r, e, t, n, i) {
  var a = (e - r) * n + r, o = (t - e) * n + e, s = (o - a) * n + a;
  i[0] = r, i[1] = a, i[2] = s, i[3] = s, i[4] = o, i[5] = t;
}
function O3(r, e, t, n, i, a, o, s, l) {
  var u, f = 5e-3, c = 1 / 0;
  br[0] = o, br[1] = s;
  for (var h = 0; h < 1; h += 0.05) {
    Ut[0] = We(r, t, i, h), Ut[1] = We(e, n, a, h);
    var v = Ai(br, Ut);
    v < c && (u = h, c = v);
  }
  c = 1 / 0;
  for (var d = 0; d < 32 && !(f < I3); d++) {
    var g = u - f, p = u + f;
    Ut[0] = We(r, t, i, g), Ut[1] = We(e, n, a, g);
    var v = Ai(Ut, br);
    if (g >= 0 && v < c)
      u = g, c = v;
    else {
      Ca[0] = We(r, t, i, p), Ca[1] = We(e, n, a, p);
      var m = Ai(Ca, br);
      p <= 1 && m < c ? (u = p, c = m) : f *= 0.5;
    }
  }
  return l && (l[0] = We(r, t, i, u), l[1] = We(e, n, a, u)), Vn(c);
}
function A7(r, e, t, n, i, a, o) {
  for (var s = r, l = e, u = 0, f = 1 / o, c = 1; c <= o; c++) {
    var h = c * f, v = We(r, t, i, h), d = We(e, n, a, h), g = v - s, p = d - l;
    u += Math.sqrt(g * g + p * p), s = v, l = d;
  }
  return u;
}
var I7 = /cubic-bezier\(([0-9,\.e ]+)\)/;
function k3(r) {
  var e = r && I7.exec(r);
  if (e) {
    var t = e[1].split(","), n = +or(t[0]), i = +or(t[1]), a = +or(t[2]), o = +or(t[3]);
    if (isNaN(n + i + a + o))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : fu(0, n, a, 1, l, s) && ze(0, i, o, 1, s[0]);
    };
  }
}
var L7 = function() {
  function r(e) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || !1, this.onframe = e.onframe || Ue, this.ondestroy = e.ondestroy || Ue, this.onrestart = e.onrestart || Ue, e.easing && this.setEasing(e.easing);
  }
  return r.prototype.step = function(e, t) {
    if (this._inited || (this._startTime = e + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += t;
      return;
    }
    var n = this._life, i = e - this._startTime - this._pausedTime, a = i / n;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var o = this.easingFunc, s = o ? o(a) : a;
    if (this.onframe(s), a === 1)
      if (this.loop) {
        var l = i % n;
        this._startTime = e - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, r.prototype.pause = function() {
    this._paused = !0;
  }, r.prototype.resume = function() {
    this._paused = !1;
  }, r.prototype.setEasing = function(e) {
    this.easing = e, this.easingFunc = dist_j(e) ? e : Fo[e] || k3(e);
  }, r;
}();
const N7 = L7;
var V3 = /* @__PURE__ */ function() {
  function r(e) {
    this.value = e;
  }
  return r;
}(), P7 = function() {
  function r() {
    this._len = 0;
  }
  return r.prototype.insert = function(e) {
    var t = new V3(e);
    return this.insertEntry(t), t;
  }, r.prototype.insertEntry = function(e) {
    this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
  }, r.prototype.remove = function(e) {
    var t = e.prev, n = e.next;
    t ? t.next = n : this.head = n, n ? n.prev = t : this.tail = t, e.next = e.prev = null, this._len--;
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, r;
}(), Ms = function() {
  function r(e) {
    this._list = new P7(), this._maxSize = 10, this._map = {}, this._maxSize = e;
  }
  return r.prototype.put = function(e, t) {
    var n = this._list, i = this._map, a = null;
    if (i[e] == null) {
      var o = n.len(), s = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        var l = n.head;
        n.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = t : s = new V3(t), s.key = e, n.insertEntry(s), i[e] = s;
    }
    return a;
  }, r.prototype.get = function(e) {
    var t = this._map[e], n = this._list;
    if (t != null)
      return t !== n.tail && (n.remove(t), n.insertEntry(t)), t.value;
  }, r.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, r.prototype.len = function() {
    return this._list.len();
  }, r;
}(), kp = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function ur(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 255 ? 255 : r;
}
function R7(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 360 ? 360 : r;
}
function ss(r) {
  return r < 0 ? 0 : r > 1 ? 1 : r;
}
function Qf(r) {
  var e = r;
  return e.length && e.charAt(e.length - 1) === "%" ? ur(parseFloat(e) / 100 * 255) : ur(parseInt(e, 10));
}
function Ii(r) {
  var e = r;
  return e.length && e.charAt(e.length - 1) === "%" ? ss(parseFloat(e) / 100) : ss(parseFloat(e));
}
function ec(r, e, t) {
  return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? r + (e - r) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? r + (e - r) * (2 / 3 - t) * 6 : r;
}
function Rn(r, e, t) {
  return r + (e - r) * t;
}
function zt(r, e, t, n, i) {
  return r[0] = e, r[1] = t, r[2] = n, r[3] = i, r;
}
function av(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r;
}
var B3 = new Ms(20), Ks = null;
function qi(r, e) {
  Ks && av(Ks, e), Ks = B3.put(r, Ks || e.slice());
}
function Xt(r, e) {
  if (r) {
    e = e || [];
    var t = B3.get(r);
    if (t)
      return av(e, t);
    r = r + "";
    var n = r.replace(/ /g, "").toLowerCase();
    if (n in kp)
      return av(e, kp[n]), qi(r, e), e;
    var i = n.length;
    if (n.charAt(0) === "#") {
      if (i === 4 || i === 5) {
        var a = parseInt(n.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          zt(e, 0, 0, 0, 1);
          return;
        }
        return zt(e, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(n.slice(4), 16) / 15 : 1), qi(r, e), e;
      } else if (i === 7 || i === 9) {
        var a = parseInt(n.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          zt(e, 0, 0, 0, 1);
          return;
        }
        return zt(e, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(n.slice(7), 16) / 255 : 1), qi(r, e), e;
      }
      return;
    }
    var o = n.indexOf("("), s = n.indexOf(")");
    if (o !== -1 && s + 1 === i) {
      var l = n.substr(0, o), u = n.substr(o + 1, s - (o + 1)).split(","), f = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? zt(e, +u[0], +u[1], +u[2], 1) : zt(e, 0, 0, 0, 1);
          f = Ii(u.pop());
        case "rgb":
          if (u.length >= 3)
            return zt(e, Qf(u[0]), Qf(u[1]), Qf(u[2]), u.length === 3 ? f : Ii(u[3])), qi(r, e), e;
          zt(e, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            zt(e, 0, 0, 0, 1);
            return;
          }
          return u[3] = Ii(u[3]), ov(u, e), qi(r, e), e;
        case "hsl":
          if (u.length !== 3) {
            zt(e, 0, 0, 0, 1);
            return;
          }
          return ov(u, e), qi(r, e), e;
        default:
          return;
      }
    }
    zt(e, 0, 0, 0, 1);
  }
}
function ov(r, e) {
  var t = (parseFloat(r[0]) % 360 + 360) % 360 / 360, n = Ii(r[1]), i = Ii(r[2]), a = i <= 0.5 ? i * (n + 1) : i + n - i * n, o = i * 2 - a;
  return e = e || [], zt(e, ur(ec(o, a, t + 1 / 3) * 255), ur(ec(o, a, t) * 255), ur(ec(o, a, t - 1 / 3) * 255), 1), r.length === 4 && (e[3] = r[3]), e;
}
function O7(r) {
  if (r) {
    var e = r[0] / 255, t = r[1] / 255, n = r[2] / 255, i = Math.min(e, t, n), a = Math.max(e, t, n), o = a - i, s = (a + i) / 2, l, u;
    if (o === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = o / (a + i) : u = o / (2 - a - i);
      var f = ((a - e) / 6 + o / 2) / o, c = ((a - t) / 6 + o / 2) / o, h = ((a - n) / 6 + o / 2) / o;
      e === a ? l = h - c : t === a ? l = 1 / 3 + f - h : n === a && (l = 2 / 3 + c - f), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var v = [l * 360, u, s];
    return r[3] != null && v.push(r[3]), v;
  }
}
function Vp(r, e) {
  var t = Xt(r);
  if (t) {
    for (var n = 0; n < 3; n++)
      e < 0 ? t[n] = t[n] * (1 - e) | 0 : t[n] = (255 - t[n]) * e + t[n] | 0, t[n] > 255 ? t[n] = 255 : t[n] < 0 && (t[n] = 0);
    return Zr(t, t.length === 4 ? "rgba" : "rgb");
  }
}
function tc(r, e, t) {
  if (!(!(e && e.length) || !(r >= 0 && r <= 1))) {
    t = t || [];
    var n = r * (e.length - 1), i = Math.floor(n), a = Math.ceil(n), o = e[i], s = e[a], l = n - i;
    return t[0] = ur(Rn(o[0], s[0], l)), t[1] = ur(Rn(o[1], s[1], l)), t[2] = ur(Rn(o[2], s[2], l)), t[3] = ss(Rn(o[3], s[3], l)), t;
  }
}
function k7(r, e, t) {
  if (!(!(e && e.length) || !(r >= 0 && r <= 1))) {
    var n = r * (e.length - 1), i = Math.floor(n), a = Math.ceil(n), o = Xt(e[i]), s = Xt(e[a]), l = n - i, u = Zr([
      ur(Rn(o[0], s[0], l)),
      ur(Rn(o[1], s[1], l)),
      ur(Rn(o[2], s[2], l)),
      ss(Rn(o[3], s[3], l))
    ], "rgba");
    return t ? {
      color: u,
      leftIndex: i,
      rightIndex: a,
      value: n
    } : u;
  }
}
function rc(r, e, t, n) {
  var i = Xt(r);
  if (r)
    return i = O7(i), e != null && (i[0] = R7(e)), t != null && (i[1] = Ii(t)), n != null && (i[2] = Ii(n)), Zr(ov(i), "rgba");
}
function V7(r, e) {
  var t = Xt(r);
  if (t && e != null)
    return t[3] = ss(e), Zr(t, "rgba");
}
function Zr(r, e) {
  if (!(!r || !r.length)) {
    var t = r[0] + "," + r[1] + "," + r[2];
    return (e === "rgba" || e === "hsva" || e === "hsla") && (t += "," + r[3]), e + "(" + t + ")";
  }
}
function cu(r, e) {
  var t = Xt(r);
  return t ? (0.299 * t[0] + 0.587 * t[1] + 0.114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0;
}
var Bp = new Ms(100);
function Fp(r) {
  if (dist_U(r)) {
    var e = Bp.get(r);
    return e || (e = Vp(r, -0.1), Bp.put(r, e)), e;
  } else if (ef(r)) {
    var t = dist_V({}, r);
    return t.colorStops = dist_$(r.colorStops, function(n) {
      return {
        offset: n.offset,
        color: Vp(n.color, -0.1)
      };
    }), t;
  }
  return r;
}
function B7(r) {
  return r.type === "linear";
}
function F7(r) {
  return r.type === "radial";
}
(function() {
  return dist_ee.hasGlobalWindow && dist_j(window.btoa) ? function(r) {
    return window.btoa(unescape(encodeURIComponent(r)));
  } : typeof Buffer < "u" ? function(r) {
    return Buffer.from(r).toString("base64");
  } : function(r) {
    return  false && 0, null;
  };
})();
var sv = Array.prototype.slice;
function Vr(r, e, t) {
  return (e - r) * t + r;
}
function nc(r, e, t, n) {
  for (var i = e.length, a = 0; a < i; a++)
    r[a] = Vr(e[a], t[a], n);
  return r;
}
function z7(r, e, t, n) {
  for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = Vr(e[o][s], t[o][s], n);
  }
  return r;
}
function js(r, e, t, n) {
  for (var i = e.length, a = 0; a < i; a++)
    r[a] = e[a] + t[a] * n;
  return r;
}
function zp(r, e, t, n) {
  for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = e[o][s] + t[o][s] * n;
  }
  return r;
}
function G7(r, e) {
  for (var t = r.length, n = e.length, i = t > n ? e : r, a = Math.min(t, n), o = i[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(t, n); s++)
    i.push({
      offset: o.offset,
      color: o.color.slice()
    });
}
function H7(r, e, t) {
  var n = r, i = e;
  if (!(!n.push || !i.push)) {
    var a = n.length, o = i.length;
    if (a !== o) {
      var s = a > o;
      if (s)
        n.length = o;
      else
        for (var l = a; l < o; l++)
          n.push(t === 1 ? i[l] : sv.call(i[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (t === 1)
        isNaN(n[l]) && (n[l] = i[l]);
      else
        for (var f = 0; f < u; f++)
          isNaN(n[l][f]) && (n[l][f] = i[l][f]);
  }
}
function $l(r) {
  if (ct(r)) {
    var e = r.length;
    if (ct(r[0])) {
      for (var t = [], n = 0; n < e; n++)
        t.push(sv.call(r[n]));
      return t;
    }
    return sv.call(r);
  }
  return r;
}
function Wl(r) {
  return r[0] = Math.floor(r[0]) || 0, r[1] = Math.floor(r[1]) || 0, r[2] = Math.floor(r[2]) || 0, r[3] = r[3] == null ? 1 : r[3], "rgba(" + r.join(",") + ")";
}
function $7(r) {
  return ct(r && r[0]) ? 2 : 1;
}
var Js = 0, Ul = 1, F3 = 2, Eo = 3, lv = 4, uv = 5, Gp = 6;
function Hp(r) {
  return r === lv || r === uv;
}
function Qs(r) {
  return r === Ul || r === F3;
}
var io = [0, 0, 0, 0], W7 = function() {
  function r(e) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = e;
  }
  return r.prototype.isFinished = function() {
    return this._finished;
  }, r.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, r.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, r.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, r.prototype.addKeyframe = function(e, t, n) {
    this._needsSort = !0;
    var i = this.keyframes, a = i.length, o = !1, s = Gp, l = t;
    if (ct(t)) {
      var u = $7(t);
      s = u, (u === 1 && !ve(t[0]) || u === 2 && !ve(t[0][0])) && (o = !0);
    } else if (ve(t) && !as(t))
      s = Js;
    else if (dist_U(t))
      if (!isNaN(+t))
        s = Js;
      else {
        var f = Xt(t);
        f && (l = f, s = Eo);
      }
    else if (ef(t)) {
      var c = dist_V({}, l);
      c.colorStops = dist_$(t.colorStops, function(v) {
        return {
          offset: v.offset,
          color: Xt(v.color)
        };
      }), B7(t) ? s = lv : F7(t) && (s = uv), l = c;
    }
    a === 0 ? this.valType = s : (s !== this.valType || s === Gp) && (o = !0), this.discrete = this.discrete || o;
    var h = {
      time: e,
      value: l,
      rawValue: t,
      percent: 0
    };
    return n && (h.easing = n, h.easingFunc = dist_j(n) ? n : Fo[n] || k3(n)), i.push(h), h;
  }, r.prototype.prepare = function(e, t) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(g, p) {
      return g.time - p.time;
    });
    for (var i = this.valType, a = n.length, o = n[a - 1], s = this.discrete, l = Qs(i), u = Hp(i), f = 0; f < a; f++) {
      var c = n[f], h = c.value, v = o.value;
      c.percent = c.time / e, s || (l && f !== a - 1 ? H7(h, v, i) : u && G7(h.colorStops, v.colorStops));
    }
    if (!s && i !== uv && t && this.needsAnimate() && t.needsAnimate() && i === t.valType && !t._finished) {
      this._additiveTrack = t;
      for (var d = n[0].value, f = 0; f < a; f++)
        i === Js ? n[f].additiveValue = n[f].value - d : i === Eo ? n[f].additiveValue = js([], n[f].value, d, -1) : Qs(i) && (n[f].additiveValue = i === Ul ? js([], n[f].value, d, -1) : zp([], n[f].value, d, -1));
    }
  }, r.prototype.step = function(e, t) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, i = n ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === Eo, f, c = this._lastFr, h = Math.min, v, d;
      if (s === 1)
        v = d = o[0];
      else {
        if (t < 0)
          f = 0;
        else if (t < this._lastFrP) {
          var g = h(c + 1, s - 1);
          for (f = g; f >= 0 && !(o[f].percent <= t); f--)
            ;
          f = h(f, s - 2);
        } else {
          for (f = c; f < s && !(o[f].percent > t); f++)
            ;
          f = h(f - 1, s - 2);
        }
        d = o[f + 1], v = o[f];
      }
      if (v && d) {
        this._lastFr = f, this._lastFrP = t;
        var p = d.percent - v.percent, m = p === 0 ? 1 : h((t - v.percent) / p, 1);
        d.easingFunc && (m = d.easingFunc(m));
        var y = n ? this._additiveValue : u ? io : e[l];
        if ((Qs(a) || u) && !y && (y = this._additiveValue = []), this.discrete)
          e[l] = m < 1 ? v.rawValue : d.rawValue;
        else if (Qs(a))
          a === Ul ? nc(y, v[i], d[i], m) : z7(y, v[i], d[i], m);
        else if (Hp(a)) {
          var _ = v[i], S = d[i], b = a === lv;
          e[l] = {
            type: b ? "linear" : "radial",
            x: Vr(_.x, S.x, m),
            y: Vr(_.y, S.y, m),
            colorStops: dist_$(_.colorStops, function(x, C) {
              var T = S.colorStops[C];
              return {
                offset: Vr(x.offset, T.offset, m),
                color: Wl(nc([], x.color, T.color, m))
              };
            }),
            global: S.global
          }, b ? (e[l].x2 = Vr(_.x2, S.x2, m), e[l].y2 = Vr(_.y2, S.y2, m)) : e[l].r = Vr(_.r, S.r, m);
        } else if (u)
          nc(y, v[i], d[i], m), n || (e[l] = Wl(y));
        else {
          var w = Vr(v[i], d[i], m);
          n ? this._additiveValue = w : e[l] = w;
        }
        n && this._addToTarget(e);
      }
    }
  }, r.prototype._addToTarget = function(e) {
    var t = this.valType, n = this.propName, i = this._additiveValue;
    t === Js ? e[n] = e[n] + i : t === Eo ? (Xt(e[n], io), js(io, io, i, 1), e[n] = Wl(io)) : t === Ul ? js(e[n], e[n], i, 1) : t === F3 && zp(e[n], e[n], i, 1);
  }, r;
}(), Td = function() {
  function r(e, t, n, i) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = t, t && i) {
      Ei("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = i, this._allowDiscrete = n;
  }
  return r.prototype.getMaxTime = function() {
    return this._maxTime;
  }, r.prototype.getDelay = function() {
    return this._delay;
  }, r.prototype.getLoop = function() {
    return this._loop;
  }, r.prototype.getTarget = function() {
    return this._target;
  }, r.prototype.changeTarget = function(e) {
    this._target = e;
  }, r.prototype.when = function(e, t, n) {
    return this.whenWithKeys(e, t, we(t), n);
  }, r.prototype.whenWithKeys = function(e, t, n, i) {
    for (var a = this._tracks, o = 0; o < n.length; o++) {
      var s = n[o], l = a[s];
      if (!l) {
        l = a[s] = new W7(s);
        var u = void 0, f = this._getAdditiveTrack(s);
        if (f) {
          var c = f.keyframes, h = c[c.length - 1];
          u = h && h.value, f.valType === Eo && u && (u = Wl(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        e > 0 && l.addKeyframe(0, $l(u), i), this._trackKeys.push(s);
      }
      l.addKeyframe(e, $l(t[s]), i);
    }
    return this._maxTime = Math.max(this._maxTime, e), this;
  }, r.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, r.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, r.prototype.isPaused = function() {
    return !!this._paused;
  }, r.prototype.duration = function(e) {
    return this._maxTime = e, this._force = !0, this;
  }, r.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var e = this._doneCbs;
    if (e)
      for (var t = e.length, n = 0; n < t; n++)
        e[n].call(this);
  }, r.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var e = this.animation, t = this._abortedCbs;
    if (e && e.removeClip(this._clip), this._clip = null, t)
      for (var n = 0; n < t.length; n++)
        t[n].call(this);
  }, r.prototype._setTracksFinished = function() {
    for (var e = this._tracks, t = this._trackKeys, n = 0; n < t.length; n++)
      e[t[n]].setFinished();
  }, r.prototype._getAdditiveTrack = function(e) {
    var t, n = this._additiveAnimators;
    if (n)
      for (var i = 0; i < n.length; i++) {
        var a = n[i].getTrack(e);
        a && (t = a);
      }
    return t;
  }, r.prototype.start = function(e) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var t = this, n = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, f = u.length;
        if (s.prepare(i, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var c = u[f - 1];
            c && (t._target[s.propName] = c.rawValue), s.setFinished();
          } else
            n.push(s);
      }
      if (n.length || this._force) {
        var h = new N7({
          life: i,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(v) {
            t._started = 2;
            var d = t._additiveAnimators;
            if (d) {
              for (var g = !1, p = 0; p < d.length; p++)
                if (d[p]._clip) {
                  g = !0;
                  break;
                }
              g || (t._additiveAnimators = null);
            }
            for (var p = 0; p < n.length; p++)
              n[p].step(t._target, v);
            var m = t._onframeCbs;
            if (m)
              for (var p = 0; p < m.length; p++)
                m[p](t._target, v);
          },
          ondestroy: function() {
            t._doneCallback();
          }
        });
        this._clip = h, this.animation && this.animation.addClip(h), e && h.setEasing(e);
      } else
        this._doneCallback();
      return this;
    }
  }, r.prototype.stop = function(e) {
    if (this._clip) {
      var t = this._clip;
      e && t.onframe(1), this._abortedCallback();
    }
  }, r.prototype.delay = function(e) {
    return this._delay = e, this;
  }, r.prototype.during = function(e) {
    return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this;
  }, r.prototype.done = function(e) {
    return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this;
  }, r.prototype.aborted = function(e) {
    return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this;
  }, r.prototype.getClip = function() {
    return this._clip;
  }, r.prototype.getTrack = function(e) {
    return this._tracks[e];
  }, r.prototype.getTracks = function() {
    var e = this;
    return dist_$(this._trackKeys, function(t) {
      return e._tracks[t];
    });
  }, r.prototype.stopTracks = function(e, t) {
    if (!e.length || !this._clip)
      return !0;
    for (var n = this._tracks, i = this._trackKeys, a = 0; a < e.length; a++) {
      var o = n[e[a]];
      o && !o.isFinished() && (t ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
    }
    for (var s = !0, a = 0; a < i.length; a++)
      if (!n[i[a]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, r.prototype.saveTo = function(e, t, n) {
    if (e) {
      t = t || this._trackKeys;
      for (var i = 0; i < t.length; i++) {
        var a = t[i], o = this._tracks[a];
        if (!(!o || o.isFinished())) {
          var s = o.keyframes, l = s[n ? 0 : s.length - 1];
          l && (e[a] = $l(l.rawValue));
        }
      }
    }
  }, r.prototype.__changeFinalValue = function(e, t) {
    t = t || we(e);
    for (var n = 0; n < t.length; n++) {
      var i = t[n], a = this._tracks[i];
      if (a) {
        var o = a.keyframes;
        if (o.length > 1) {
          var s = o.pop();
          a.addKeyframe(s.time, e[i]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, r;
}();
function Sa() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var U7 = function(r) {
  dist_k(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, t = t || {}, n.stage = t.stage || {}, n;
  }
  return e.prototype.addClip = function(t) {
    t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this;
  }, e.prototype.addAnimator = function(t) {
    t.animation = this;
    var n = t.getClip();
    n && this.addClip(n);
  }, e.prototype.removeClip = function(t) {
    if (t.animation) {
      var n = t.prev, i = t.next;
      n ? n.next = i : this._head = i, i ? i.prev = n : this._tail = n, t.next = t.prev = t.animation = null;
    }
  }, e.prototype.removeAnimator = function(t) {
    var n = t.getClip();
    n && this.removeClip(n), t.animation = null;
  }, e.prototype.update = function(t) {
    for (var n = Sa() - this._pausedTime, i = n - this._time, a = this._head; a; ) {
      var o = a.next, s = a.step(n, i);
      s && (a.ondestroy(), this.removeClip(a)), a = o;
    }
    this._time = n, t || (this.trigger("frame", i), this.stage.update && this.stage.update());
  }, e.prototype._startLoop = function() {
    var t = this;
    this._running = !0;
    function n() {
      t._running && (nv(n), !t._paused && t.update());
    }
    nv(n);
  }, e.prototype.start = function() {
    this._running || (this._time = Sa(), this._pausedTime = 0, this._startLoop());
  }, e.prototype.stop = function() {
    this._running = !1;
  }, e.prototype.pause = function() {
    this._paused || (this._pauseStart = Sa(), this._paused = !0);
  }, e.prototype.resume = function() {
    this._paused && (this._pausedTime += Sa() - this._pauseStart, this._paused = !1);
  }, e.prototype.clear = function() {
    for (var t = this._head; t; ) {
      var n = t.next;
      t.prev = t.next = t.animation = null, t = n;
    }
    this._head = this._tail = null;
  }, e.prototype.isFinished = function() {
    return this._head == null;
  }, e.prototype.animate = function(t, n) {
    n = n || {}, this.start();
    var i = new Td(t, n.loop);
    return this.addAnimator(i), i;
  }, e;
}(vr), Y7 = 300, ic = dist_ee.domSupported, ac = function() {
  var r = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], e = [
    "touchstart",
    "touchend",
    "touchmove"
  ], t = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = dist_$(r, function(i) {
    var a = i.replace("mouse", "pointer");
    return t.hasOwnProperty(a) ? a : i;
  });
  return {
    mouse: r,
    touch: e,
    pointer: n
  };
}(), $p = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, Wp = !1;
function fv(r) {
  var e = r.pointerType;
  return e === "pen" || e === "touch";
}
function X7(r) {
  r.touching = !0, r.touchTimer != null && (clearTimeout(r.touchTimer), r.touchTimer = null), r.touchTimer = setTimeout(function() {
    r.touching = !1, r.touchTimer = null;
  }, 700);
}
function oc(r) {
  r && (r.zrByTouch = !0);
}
function Z7(r, e) {
  return Gt(r.dom, new q7(r, e), !0);
}
function z3(r, e) {
  for (var t = e, n = !1; t && t.nodeType !== 9 && !(n = t.domBelongToZr || t !== e && t === r.painterRoot); )
    t = t.parentNode;
  return n;
}
var q7 = /* @__PURE__ */ function() {
  function r(e, t) {
    this.stopPropagation = Ue, this.stopImmediatePropagation = Ue, this.preventDefault = Ue, this.type = t.type, this.target = this.currentTarget = e.dom, this.pointerType = t.pointerType, this.clientX = t.clientX, this.clientY = t.clientY;
  }
  return r;
}(), nr = {
  mousedown: function(r) {
    r = Gt(this.dom, r), this.__mayPointerCapture = [r.zrX, r.zrY], this.trigger("mousedown", r);
  },
  mousemove: function(r) {
    r = Gt(this.dom, r);
    var e = this.__mayPointerCapture;
    e && (r.zrX !== e[0] || r.zrY !== e[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    r = Gt(this.dom, r), this.__togglePointerCapture(!1), this.trigger("mouseup", r);
  },
  mouseout: function(r) {
    r = Gt(this.dom, r);
    var e = r.toElement || r.relatedTarget;
    z3(this, e) || (this.__pointerCapturing && (r.zrEventControl = "no_globalout"), this.trigger("mouseout", r));
  },
  wheel: function(r) {
    Wp = !0, r = Gt(this.dom, r), this.trigger("mousewheel", r);
  },
  mousewheel: function(r) {
    Wp || (r = Gt(this.dom, r), this.trigger("mousewheel", r));
  },
  touchstart: function(r) {
    r = Gt(this.dom, r), oc(r), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(r, "start"), nr.mousemove.call(this, r), nr.mousedown.call(this, r);
  },
  touchmove: function(r) {
    r = Gt(this.dom, r), oc(r), this.handler.processGesture(r, "change"), nr.mousemove.call(this, r);
  },
  touchend: function(r) {
    r = Gt(this.dom, r), oc(r), this.handler.processGesture(r, "end"), nr.mouseup.call(this, r), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < Y7 && nr.click.call(this, r);
  },
  pointerdown: function(r) {
    nr.mousedown.call(this, r);
  },
  pointermove: function(r) {
    fv(r) || nr.mousemove.call(this, r);
  },
  pointerup: function(r) {
    nr.mouseup.call(this, r);
  },
  pointerout: function(r) {
    fv(r) || nr.mouseout.call(this, r);
  }
};
dist_M(["click", "dblclick", "contextmenu"], function(r) {
  nr[r] = function(e) {
    e = Gt(this.dom, e), this.trigger(r, e);
  };
});
var cv = {
  pointermove: function(r) {
    fv(r) || cv.mousemove.call(this, r);
  },
  pointerup: function(r) {
    cv.mouseup.call(this, r);
  },
  mousemove: function(r) {
    this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    var e = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", r), e && (r.zrEventControl = "only_globalout", this.trigger("mouseout", r));
  }
};
function K7(r, e) {
  var t = e.domHandlers;
  dist_ee.pointerEventsSupported ? dist_M(ac.pointer, function(n) {
    Yl(e, n, function(i) {
      t[n].call(r, i);
    });
  }) : (dist_ee.touchEventsSupported && dist_M(ac.touch, function(n) {
    Yl(e, n, function(i) {
      t[n].call(r, i), X7(e);
    });
  }), dist_M(ac.mouse, function(n) {
    Yl(e, n, function(i) {
      i = xd(i), e.touching || t[n].call(r, i);
    });
  }));
}
function j7(r, e) {
  dist_ee.pointerEventsSupported ? dist_M($p.pointer, t) : dist_ee.touchEventsSupported || dist_M($p.mouse, t);
  function t(n) {
    function i(a) {
      a = xd(a), z3(r, a.target) || (a = Z7(r, a), e.domHandlers[n].call(r, a));
    }
    Yl(e, n, i, { capture: !0 });
  }
}
function Yl(r, e, t, n) {
  r.mounted[e] = t, r.listenerOpts[e] = n, c7(r.domTarget, e, t, n);
}
function sc(r) {
  var e = r.mounted;
  for (var t in e)
    e.hasOwnProperty(t) && h7(r.domTarget, t, e[t], r.listenerOpts[t]);
  r.mounted = {};
}
var Up = /* @__PURE__ */ function() {
  function r(e, t) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = e, this.domHandlers = t;
  }
  return r;
}(), J7 = function(r) {
  dist_k(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.__pointerCapturing = !1, i.dom = t, i.painterRoot = n, i._localHandlerScope = new Up(t, nr), ic && (i._globalHandlerScope = new Up(document, cv)), K7(i, i._localHandlerScope), i;
  }
  return e.prototype.dispose = function() {
    sc(this._localHandlerScope), ic && sc(this._globalHandlerScope);
  }, e.prototype.setCursor = function(t) {
    this.dom.style && (this.dom.style.cursor = t || "default");
  }, e.prototype.__togglePointerCapture = function(t) {
    if (this.__mayPointerCapture = null, ic && +this.__pointerCapturing ^ +t) {
      this.__pointerCapturing = t;
      var n = this._globalHandlerScope;
      t ? j7(this, n) : sc(n);
    }
  }, e;
}(vr);
const Q7 = J7;
var G3 = 1;
dist_ee.hasGlobalWindow && (G3 = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var hu = G3, hv = 0.4, vv = "#333", dv = "#ccc", eC = "#eee", Yp = rf, Xp = 5e-5;
function Jn(r) {
  return r > Xp || r < -Xp;
}
var Qn = [], Ki = [], lc = Yr(), uc = Math.abs, Fr = function() {
  function r() {
  }
  return r.prototype.getLocalTransform = function(e) {
    return r.getLocalTransform(this, e);
  }, r.prototype.setPosition = function(e) {
    this.x = e[0], this.y = e[1];
  }, r.prototype.setScale = function(e) {
    this.scaleX = e[0], this.scaleY = e[1];
  }, r.prototype.setSkew = function(e) {
    this.skewX = e[0], this.skewY = e[1];
  }, r.prototype.setOrigin = function(e) {
    this.originX = e[0], this.originY = e[1];
  }, r.prototype.needLocalTransform = function() {
    return Jn(this.rotation) || Jn(this.x) || Jn(this.y) || Jn(this.scaleX - 1) || Jn(this.scaleY - 1) || Jn(this.skewX) || Jn(this.skewY);
  }, r.prototype.updateTransform = function() {
    var e = this.parent && this.parent.transform, t = this.needLocalTransform(), n = this.transform;
    if (!(t || e)) {
      n && (Yp(n), this.invTransform = null);
      return;
    }
    n = n || Yr(), t ? this.getLocalTransform(n) : Yp(n), e && (t ? Xr(n, e, n) : Cd(n, e)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, r.prototype._resolveGlobalScaleRatio = function(e) {
    var t = this.globalScaleRatio;
    if (t != null && t !== 1) {
      this.getGlobalScale(Qn);
      var n = Qn[0] < 0 ? -1 : 1, i = Qn[1] < 0 ? -1 : 1, a = ((Qn[0] - n) * t + n) / Qn[0] || 0, o = ((Qn[1] - i) * t + i) / Qn[1] || 0;
      e[0] *= a, e[1] *= a, e[2] *= o, e[3] *= o;
    }
    this.invTransform = this.invTransform || Yr(), Ua(this.invTransform, e);
  }, r.prototype.getComputedTransform = function() {
    for (var e = this, t = []; e; )
      t.push(e), e = e.parent;
    for (; e = t.pop(); )
      e.updateTransform();
    return this.transform;
  }, r.prototype.setLocalTransform = function(e) {
    if (e) {
      var t = e[0] * e[0] + e[1] * e[1], n = e[2] * e[2] + e[3] * e[3], i = Math.atan2(e[1], e[0]), a = Math.PI / 2 + i - Math.atan2(e[3], e[2]);
      n = Math.sqrt(n) * Math.cos(a), t = Math.sqrt(t), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +e[4], this.y = +e[5], this.scaleX = t, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, r.prototype.decomposeTransform = function() {
    if (this.transform) {
      var e = this.parent, t = this.transform;
      e && e.transform && (e.invTransform = e.invTransform || Yr(), Xr(Ki, e.invTransform, t), t = Ki);
      var n = this.originX, i = this.originY;
      (n || i) && (lc[4] = n, lc[5] = i, Xr(Ki, t, lc), Ki[4] -= n, Ki[5] -= i, t = Ki), this.setLocalTransform(t);
    }
  }, r.prototype.getGlobalScale = function(e) {
    var t = this.transform;
    return e = e || [], t ? (e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1]), e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3]), t[0] < 0 && (e[0] = -e[0]), t[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e);
  }, r.prototype.transformCoordToLocal = function(e, t) {
    var n = [e, t], i = this.invTransform;
    return i && Xe(n, n, i), n;
  }, r.prototype.transformCoordToGlobal = function(e, t) {
    var n = [e, t], i = this.transform;
    return i && Xe(n, n, i), n;
  }, r.prototype.getLineScale = function() {
    var e = this.transform;
    return e && uc(e[0] - 1) > 1e-10 && uc(e[3] - 1) > 1e-10 ? Math.sqrt(uc(e[0] * e[3] - e[2] * e[1])) : 1;
  }, r.prototype.copyTransform = function(e) {
    tC(this, e);
  }, r.getLocalTransform = function(e, t) {
    t = t || [];
    var n = e.originX || 0, i = e.originY || 0, a = e.scaleX, o = e.scaleY, s = e.anchorX, l = e.anchorY, u = e.rotation || 0, f = e.x, c = e.y, h = e.skewX ? Math.tan(e.skewX) : 0, v = e.skewY ? Math.tan(-e.skewY) : 0;
    if (n || i || s || l) {
      var d = n + s, g = i + l;
      t[4] = -d * a - h * g * o, t[5] = -g * o - v * d * a;
    } else
      t[4] = t[5] = 0;
    return t[0] = a, t[3] = o, t[1] = v * a, t[2] = h * o, u && nf(t, t, u), t[4] += n + f, t[5] += i + c, t;
  }, r.initDefaultProps = function() {
    var e = r.prototype;
    e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0;
  }(), r;
}(), ls = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function tC(r, e) {
  for (var t = 0; t < ls.length; t++) {
    var n = ls[t];
    r[n] = e[n];
  }
}
var Zp = {};
function It(r, e) {
  e = e || ki;
  var t = Zp[e];
  t || (t = Zp[e] = new Ms(500));
  var n = t.get(r);
  return n == null && (n = Ha.measureText(r, e).width, t.put(r, n)), n;
}
function qp(r, e, t, n) {
  var i = It(r, e), a = Dd(e), o = Ao(0, i, t), s = ya(0, a, n), l = new dist_ae(o, s, i, a);
  return l;
}
function Md(r, e, t, n) {
  var i = ((r || "") + "").split(`
`), a = i.length;
  if (a === 1)
    return qp(i[0], e, t, n);
  for (var o = new dist_ae(0, 0, 0, 0), s = 0; s < i.length; s++) {
    var l = qp(i[s], e, t, n);
    s === 0 ? o.copy(l) : o.union(l);
  }
  return o;
}
function Ao(r, e, t) {
  return t === "right" ? r -= e : t === "center" && (r -= e / 2), r;
}
function ya(r, e, t) {
  return t === "middle" ? r -= e / 2 : t === "bottom" && (r -= e), r;
}
function Dd(r) {
  return It("国", r);
}
function Lr(r, e) {
  return typeof r == "string" ? r.lastIndexOf("%") >= 0 ? parseFloat(r) / 100 * e : parseFloat(r) : r;
}
function vu(r, e, t) {
  var n = e.position || "inside", i = e.distance != null ? e.distance : 5, a = t.height, o = t.width, s = a / 2, l = t.x, u = t.y, f = "left", c = "top";
  if (n instanceof Array)
    l += Lr(n[0], t.width), u += Lr(n[1], t.height), f = null, c = null;
  else
    switch (n) {
      case "left":
        l -= i, u += s, f = "right", c = "middle";
        break;
      case "right":
        l += i + o, u += s, c = "middle";
        break;
      case "top":
        l += o / 2, u -= i, f = "center", c = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + i, f = "center";
        break;
      case "inside":
        l += o / 2, u += s, f = "center", c = "middle";
        break;
      case "insideLeft":
        l += i, u += s, c = "middle";
        break;
      case "insideRight":
        l += o - i, u += s, f = "right", c = "middle";
        break;
      case "insideTop":
        l += o / 2, u += i, f = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - i, f = "center", c = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += o - i, u += i, f = "right";
        break;
      case "insideBottomLeft":
        l += i, u += a - i, c = "bottom";
        break;
      case "insideBottomRight":
        l += o - i, u += a - i, f = "right", c = "bottom";
        break;
    }
  return r = r || {}, r.x = l, r.y = u, r.align = f, r.verticalAlign = c, r;
}
var fc = "__zr_normal__", cc = ls.concat(["ignore"]), rC = Jr(ls, function(r, e) {
  return r[e] = !0, r;
}, { ignore: !1 }), ji = {}, nC = new dist_ae(0, 0, 0, 0), Ed = function() {
  function r(e) {
    this.id = g3(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e);
  }
  return r.prototype._init = function(e) {
    this.attr(e);
  }, r.prototype.drift = function(e, t, n) {
    switch (this.draggable) {
      case "horizontal":
        t = 0;
        break;
      case "vertical":
        e = 0;
        break;
    }
    var i = this.transform;
    i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += e, i[5] += t, this.decomposeTransform(), this.markRedraw();
  }, r.prototype.beforeUpdate = function() {
  }, r.prototype.afterUpdate = function() {
  }, r.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, r.prototype.updateInnerText = function(e) {
    var t = this._textContent;
    if (t && (!t.ignore || e)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, i = n.local, a = t.innerTransformable, o = void 0, s = void 0, l = !1;
      a.parent = i ? this : null;
      var u = !1;
      if (a.copyTransform(t), n.position != null) {
        var f = nC;
        n.layoutRect ? f.copy(n.layoutRect) : f.copy(this.getBoundingRect()), i || f.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(ji, n, f) : vu(ji, n, f), a.x = ji.x, a.y = ji.y, o = ji.align, s = ji.verticalAlign;
        var c = n.origin;
        if (c && n.rotation != null) {
          var h = void 0, v = void 0;
          c === "center" ? (h = f.width * 0.5, v = f.height * 0.5) : (h = Lr(c[0], f.width), v = Lr(c[1], f.height)), u = !0, a.originX = -a.x + h + (i ? 0 : f.x), a.originY = -a.y + v + (i ? 0 : f.y);
        }
      }
      n.rotation != null && (a.rotation = n.rotation);
      var d = n.offset;
      d && (a.x += d[0], a.y += d[1], u || (a.originX = -d[0], a.originY = -d[1]));
      var g = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, p = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), m = void 0, y = void 0, _ = void 0;
      g && this.canBeInsideText() ? (m = n.insideFill, y = n.insideStroke, (m == null || m === "auto") && (m = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(m), _ = !0)) : (m = n.outsideFill, y = n.outsideStroke, (m == null || m === "auto") && (m = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(m), _ = !0)), m = m || "#000", (m !== p.fill || y !== p.stroke || _ !== p.autoStroke || o !== p.align || s !== p.verticalAlign) && (l = !0, p.fill = m, p.stroke = y, p.autoStroke = _, p.align = o, p.verticalAlign = s, t.setDefaultTextStyle(p)), t.__dirty |= Et, l && t.dirtyStyle(!0);
    }
  }, r.prototype.canBeInsideText = function() {
    return !0;
  }, r.prototype.getInsideTextFill = function() {
    return "#fff";
  }, r.prototype.getInsideTextStroke = function(e) {
    return "#000";
  }, r.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? dv : vv;
  }, r.prototype.getOutsideStroke = function(e) {
    var t = this.__zr && this.__zr.getBackgroundColor(), n = typeof t == "string" && Xt(t);
    n || (n = [255, 255, 255, 1]);
    for (var i = n[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
      n[o] = n[o] * i + (a ? 0 : 255) * (1 - i);
    return n[3] = 1, Zr(n, "rgba");
  }, r.prototype.traverse = function(e, t) {
  }, r.prototype.attrKV = function(e, t) {
    e === "textConfig" ? this.setTextConfig(t) : e === "textContent" ? this.setTextContent(t) : e === "clipPath" ? this.setClipPath(t) : e === "extra" ? (this.extra = this.extra || {}, dist_V(this.extra, t)) : this[e] = t;
  }, r.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, r.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, r.prototype.attr = function(e, t) {
    if (typeof e == "string")
      this.attrKV(e, t);
    else if (dist_X(e))
      for (var n = e, i = we(n), a = 0; a < i.length; a++) {
        var o = i[a];
        this.attrKV(o, e[o]);
      }
    return this.markRedraw(), this;
  }, r.prototype.saveCurrentToNormalState = function(e) {
    this._innerSaveToNormal(e);
    for (var t = this._normalState, n = 0; n < this.animators.length; n++) {
      var i = this.animators[n], a = i.__fromStateTransition;
      if (!(i.getLoop() || a && a !== fc)) {
        var o = i.targetName, s = o ? t[o] : t;
        i.saveTo(s);
      }
    }
  }, r.prototype._innerSaveToNormal = function(e) {
    var t = this._normalState;
    t || (t = this._normalState = {}), e.textConfig && !t.textConfig && (t.textConfig = this.textConfig), this._savePrimaryToNormal(e, t, cc);
  }, r.prototype._savePrimaryToNormal = function(e, t, n) {
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      e[a] != null && !(a in t) && (t[a] = this[a]);
    }
  }, r.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, r.prototype.getState = function(e) {
    return this.states[e];
  }, r.prototype.ensureState = function(e) {
    var t = this.states;
    return t[e] || (t[e] = {}), t[e];
  }, r.prototype.clearStates = function(e) {
    this.useState(fc, !1, e);
  }, r.prototype.useState = function(e, t, n, i) {
    var a = e === fc, o = this.hasState();
    if (!(!o && a)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(ye(s, e) >= 0 && (t || s.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(e)), u || (u = this.states && this.states[e]), !u && !a) {
          Ei("State " + e + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var f = !!(u && u.hoverLayer || i);
        f && this._toggleHoverLayerFlag(!0), this._applyStateObj(e, u, this._normalState, t, !n && !this.__inHover && l && l.duration > 0, l);
        var c = this._textContent, h = this._textGuide;
        return c && c.useState(e, t, n, f), h && h.useState(e, t, n, f), a ? (this.currentStates = [], this._normalState = {}) : t ? this.currentStates.push(e) : this.currentStates = [e], this._updateAnimationTargets(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Et), u;
      }
    }
  }, r.prototype.useStates = function(e, t, n) {
    if (!e.length)
      this.clearStates();
    else {
      var i = [], a = this.currentStates, o = e.length, s = o === a.length;
      if (s) {
        for (var l = 0; l < o; l++)
          if (e[l] !== a[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < o; l++) {
        var u = e[l], f = void 0;
        this.stateProxy && (f = this.stateProxy(u, e)), f || (f = this.states[u]), f && i.push(f);
      }
      var c = i[o - 1], h = !!(c && c.hoverLayer || n);
      h && this._toggleHoverLayerFlag(!0);
      var v = this._mergeStates(i), d = this.stateTransition;
      this.saveCurrentToNormalState(v), this._applyStateObj(e.join(","), v, this._normalState, !1, !t && !this.__inHover && d && d.duration > 0, d);
      var g = this._textContent, p = this._textGuide;
      g && g.useStates(e, t, h), p && p.useStates(e, t, h), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Et);
    }
  }, r.prototype.isSilent = function() {
    for (var e = this.silent, t = this.parent; !e && t; ) {
      if (t.silent) {
        e = !0;
        break;
      }
      t = t.parent;
    }
    return e;
  }, r.prototype._updateAnimationTargets = function() {
    for (var e = 0; e < this.animators.length; e++) {
      var t = this.animators[e];
      t.targetName && t.changeTarget(this[t.targetName]);
    }
  }, r.prototype.removeState = function(e) {
    var t = ye(this.currentStates, e);
    if (t >= 0) {
      var n = this.currentStates.slice();
      n.splice(t, 1), this.useStates(n);
    }
  }, r.prototype.replaceState = function(e, t, n) {
    var i = this.currentStates.slice(), a = ye(i, e), o = ye(i, t) >= 0;
    a >= 0 ? o ? i.splice(a, 1) : i[a] = t : n && !o && i.push(t), this.useStates(i);
  }, r.prototype.toggleState = function(e, t) {
    t ? this.useState(e, !0) : this.removeState(e);
  }, r.prototype._mergeStates = function(e) {
    for (var t = {}, n, i = 0; i < e.length; i++) {
      var a = e[i];
      dist_V(t, a), a.textConfig && (n = n || {}, dist_V(n, a.textConfig));
    }
    return n && (t.textConfig = n), t;
  }, r.prototype._applyStateObj = function(e, t, n, i, a, o) {
    var s = !(t && i);
    t && t.textConfig ? (this.textConfig = dist_V({}, i ? this.textConfig : n.textConfig), dist_V(this.textConfig, t.textConfig)) : s && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, f = 0; f < cc.length; f++) {
      var c = cc[f], h = a && rC[c];
      t && t[c] != null ? h ? (u = !0, l[c] = t[c]) : this[c] = t[c] : s && n[c] != null && (h ? (u = !0, l[c] = n[c]) : this[c] = n[c]);
    }
    if (!a)
      for (var f = 0; f < this.animators.length; f++) {
        var v = this.animators[f], d = v.targetName;
        v.getLoop() || v.__changeFinalValue(d ? (t || n)[d] : t || n);
      }
    u && this._transitionState(e, l, o);
  }, r.prototype._attachComponent = function(e) {
    if (e.__zr && !e.__hostTarget) {
      if (false)
        {}
      return;
    }
    if (e === this) {
      if (false)
        {}
      return;
    }
    var t = this.__zr;
    t && e.addSelfToZr(t), e.__zr = t, e.__hostTarget = this;
  }, r.prototype._detachComponent = function(e) {
    e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null;
  }, r.prototype.getClipPath = function() {
    return this._clipPath;
  }, r.prototype.setClipPath = function(e) {
    this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw();
  }, r.prototype.removeClipPath = function() {
    var e = this._clipPath;
    e && (this._detachComponent(e), this._clipPath = null, this.markRedraw());
  }, r.prototype.getTextContent = function() {
    return this._textContent;
  }, r.prototype.setTextContent = function(e) {
    var t = this._textContent;
    if (t !== e) {
      if (t && t !== e && this.removeTextContent(),  false && 0)
        throw new Error("Text element has been added to zrender.");
      e.innerTransformable = new Fr(), this._attachComponent(e), this._textContent = e, this.markRedraw();
    }
  }, r.prototype.setTextConfig = function(e) {
    this.textConfig || (this.textConfig = {}), dist_V(this.textConfig, e), this.markRedraw();
  }, r.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, r.prototype.removeTextContent = function() {
    var e = this._textContent;
    e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, r.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, r.prototype.setTextGuideLine = function(e) {
    this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw();
  }, r.prototype.removeTextGuideLine = function() {
    var e = this._textGuide;
    e && (this._detachComponent(e), this._textGuide = null, this.markRedraw());
  }, r.prototype.markRedraw = function() {
    this.__dirty |= Et;
    var e = this.__zr;
    e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, r.prototype.dirty = function() {
    this.markRedraw();
  }, r.prototype._toggleHoverLayerFlag = function(e) {
    this.__inHover = e;
    var t = this._textContent, n = this._textGuide;
    t && (t.__inHover = e), n && (n.__inHover = e);
  }, r.prototype.addSelfToZr = function(e) {
    if (this.__zr !== e) {
      this.__zr = e;
      var t = this.animators;
      if (t)
        for (var n = 0; n < t.length; n++)
          e.animation.addAnimator(t[n]);
      this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e);
    }
  }, r.prototype.removeSelfFromZr = function(e) {
    if (this.__zr) {
      this.__zr = null;
      var t = this.animators;
      if (t)
        for (var n = 0; n < t.length; n++)
          e.animation.removeAnimator(t[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e);
    }
  }, r.prototype.animate = function(e, t, n) {
    var i = e ? this[e] : this;
    if (false) {}
    var a = new Td(i, t, n);
    return e && (a.targetName = e), this.addAnimator(a, e), a;
  }, r.prototype.addAnimator = function(e, t) {
    var n = this.__zr, i = this;
    e.during(function() {
      i.updateDuringAnimation(t);
    }).done(function() {
      var a = i.animators, o = ye(a, e);
      o >= 0 && a.splice(o, 1);
    }), this.animators.push(e), n && n.animation.addAnimator(e), n && n.wakeUp();
  }, r.prototype.updateDuringAnimation = function(e) {
    this.markRedraw();
  }, r.prototype.stopAnimation = function(e, t) {
    for (var n = this.animators, i = n.length, a = [], o = 0; o < i; o++) {
      var s = n[o];
      !e || e === s.scope ? s.stop(t) : a.push(s);
    }
    return this.animators = a, this;
  }, r.prototype.animateTo = function(e, t, n) {
    hc(this, e, t, n);
  }, r.prototype.animateFrom = function(e, t, n) {
    hc(this, e, t, n, !0);
  }, r.prototype._transitionState = function(e, t, n, i) {
    for (var a = hc(this, t, n, i), o = 0; o < a.length; o++)
      a[o].__fromStateTransition = e;
  }, r.prototype.getBoundingRect = function() {
    return null;
  }, r.prototype.getPaintRect = function() {
    return null;
  }, r.initDefaultProps = function() {
    var e = r.prototype;
    e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = !1, e.__dirty = Et;
    var t = {};
    function n(a, o, s) {
      t[a + o + s] || (t[a + o + s] = !0);
    }
    function i(a, o, s, l) {
      Object.defineProperty(e, a, {
        get: function() {
          if ( false && 0, !this[o]) {
            var f = this[o] = [];
            u(this, f);
          }
          return this[o];
        },
        set: function(f) {
           false && 0, this[s] = f[0], this[l] = f[1], this[o] = f, u(this, f);
        }
      });
      function u(f, c) {
        Object.defineProperty(c, 0, {
          get: function() {
            return f[s];
          },
          set: function(h) {
            f[s] = h;
          }
        }), Object.defineProperty(c, 1, {
          get: function() {
            return f[l];
          },
          set: function(h) {
            f[l] = h;
          }
        });
      }
    }
    Object.defineProperty && (i("position", "_legacyPos", "x", "y"), i("scale", "_legacyScale", "scaleX", "scaleY"), i("origin", "_legacyOrigin", "originX", "originY"));
  }(), r;
}();
Ot(Ed, vr);
Ot(Ed, Fr);
function hc(r, e, t, n, i) {
  t = t || {};
  var a = [];
  H3(r, "", r, e, t, n, a, i);
  var o = a.length, s = !1, l = t.done, u = t.aborted, f = function() {
    s = !0, o--, o <= 0 && (s ? l && l() : u && u());
  }, c = function() {
    o--, o <= 0 && (s ? l && l() : u && u());
  };
  o || l && l(), a.length > 0 && t.during && a[0].during(function(d, g) {
    t.during(g);
  });
  for (var h = 0; h < a.length; h++) {
    var v = a[h];
    f && v.done(f), c && v.aborted(c), t.force && v.duration(t.duration), v.start(t.easing);
  }
  return a;
}
function vc(r, e, t) {
  for (var n = 0; n < t; n++)
    r[n] = e[n];
}
function iC(r) {
  return ct(r[0]);
}
function aC(r, e, t) {
  if (ct(e[t]))
    if (ct(r[t]) || (r[t] = []), ht(e[t])) {
      var n = e[t].length;
      r[t].length !== n && (r[t] = new e[t].constructor(n), vc(r[t], e[t], n));
    } else {
      var i = e[t], a = r[t], o = i.length;
      if (iC(i))
        for (var s = i[0].length, l = 0; l < o; l++)
          a[l] ? vc(a[l], i[l], s) : a[l] = Array.prototype.slice.call(i[l]);
      else
        vc(a, i, o);
      a.length = i.length;
    }
  else
    r[t] = e[t];
}
function oC(r, e) {
  return r === e || ct(r) && ct(e) && sC(r, e);
}
function sC(r, e) {
  var t = r.length;
  if (t !== e.length)
    return !1;
  for (var n = 0; n < t; n++)
    if (r[n] !== e[n])
      return !1;
  return !0;
}
function H3(r, e, t, n, i, a, o, s) {
  for (var l = we(n), u = i.duration, f = i.delay, c = i.additive, h = i.setToFinal, v = !dist_X(a), d = r.animators, g = [], p = 0; p < l.length; p++) {
    var m = l[p], y = n[m];
    if (y != null && t[m] != null && (v || a[m]))
      if (dist_X(y) && !ct(y) && !ef(y)) {
        if (e) {
          s || (t[m] = y, r.updateDuringAnimation(e));
          continue;
        }
        H3(r, m, t[m], y, i, a && a[m], o, s);
      } else
        g.push(m);
    else
      s || (t[m] = y, r.updateDuringAnimation(e), g.push(m));
  }
  var _ = g.length;
  if (!c && _)
    for (var S = 0; S < d.length; S++) {
      var b = d[S];
      if (b.targetName === e) {
        var w = b.stopTracks(g);
        if (w) {
          var x = ye(d, b);
          d.splice(x, 1);
        }
      }
    }
  if (i.force || (g = ke(g, function(D) {
    return !oC(n[D], t[D]);
  }), _ = g.length), _ > 0 || i.force && !o.length) {
    var C = void 0, T = void 0, E = void 0;
    if (s) {
      T = {}, h && (C = {});
      for (var S = 0; S < _; S++) {
        var m = g[S];
        T[m] = t[m], h ? C[m] = n[m] : t[m] = n[m];
      }
    } else if (h) {
      E = {};
      for (var S = 0; S < _; S++) {
        var m = g[S];
        E[m] = $l(t[m]), aC(t, n, m);
      }
    }
    var b = new Td(t, !1, !1, c ? ke(d, function(I) {
      return I.targetName === e;
    }) : null);
    b.targetName = e, i.scope && (b.scope = i.scope), h && C && b.whenWithKeys(0, C, g), E && b.whenWithKeys(0, E, g), b.whenWithKeys(u ?? 500, s ? T : n, g).delay(f || 0), r.addAnimator(b, e), o.push(b);
  }
}
const $3 = Ed;
var dist_oe = function(r) {
  dist_k(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(t), n;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.children = function() {
    return this._children.slice();
  }, e.prototype.childAt = function(t) {
    return this._children[t];
  }, e.prototype.childOfName = function(t) {
    for (var n = this._children, i = 0; i < n.length; i++)
      if (n[i].name === t)
        return n[i];
  }, e.prototype.childCount = function() {
    return this._children.length;
  }, e.prototype.add = function(t) {
    if (t && (t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)),  false && 0))
      throw "This elemenet has been used as an attachment";
    return this;
  }, e.prototype.addBefore = function(t, n) {
    if (t && t !== this && t.parent !== this && n && n.parent === this) {
      var i = this._children, a = i.indexOf(n);
      a >= 0 && (i.splice(a, 0, t), this._doAdd(t));
    }
    return this;
  }, e.prototype.replace = function(t, n) {
    var i = ye(this._children, t);
    return i >= 0 && this.replaceAt(n, i), this;
  }, e.prototype.replaceAt = function(t, n) {
    var i = this._children, a = i[n];
    if (t && t !== this && t.parent !== this && t !== a) {
      i[n] = t, a.parent = null;
      var o = this.__zr;
      o && a.removeSelfFromZr(o), this._doAdd(t);
    }
    return this;
  }, e.prototype._doAdd = function(t) {
    t.parent && t.parent.remove(t), t.parent = this;
    var n = this.__zr;
    n && n !== t.__zr && t.addSelfToZr(n), n && n.refresh();
  }, e.prototype.remove = function(t) {
    var n = this.__zr, i = this._children, a = ye(i, t);
    return a < 0 ? this : (i.splice(a, 1), t.parent = null, n && t.removeSelfFromZr(n), n && n.refresh(), this);
  }, e.prototype.removeAll = function() {
    for (var t = this._children, n = this.__zr, i = 0; i < t.length; i++) {
      var a = t[i];
      n && a.removeSelfFromZr(n), a.parent = null;
    }
    return t.length = 0, this;
  }, e.prototype.eachChild = function(t, n) {
    for (var i = this._children, a = 0; a < i.length; a++) {
      var o = i[a];
      t.call(n, o, a);
    }
    return this;
  }, e.prototype.traverse = function(t, n) {
    for (var i = 0; i < this._children.length; i++) {
      var a = this._children[i], o = t.call(n, a);
      a.isGroup && !o && a.traverse(t, n);
    }
    return this;
  }, e.prototype.addSelfToZr = function(t) {
    r.prototype.addSelfToZr.call(this, t);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    r.prototype.removeSelfFromZr.call(this, t);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.removeSelfFromZr(t);
    }
  }, e.prototype.getBoundingRect = function(t) {
    for (var n = new dist_ae(0, 0, 0, 0), i = t || this._children, a = [], o = null, s = 0; s < i.length; s++) {
      var l = i[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), f = l.getLocalTransform(a);
        f ? (dist_ae.applyTransform(n, u, f), o = o || n.clone(), o.union(n)) : (o = o || u.clone(), o.union(u));
      }
    }
    return o || n;
  }, e;
}($3);
dist_oe.prototype.type = "group";
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var Io = {}, W3 = {};
function lC(r) {
  delete W3[r];
}
function uC(r) {
  if (!r)
    return !1;
  if (typeof r == "string")
    return cu(r, 1) < hv;
  if (r.colorStops) {
    for (var e = r.colorStops, t = 0, n = e.length, i = 0; i < n; i++)
      t += cu(e[i].color, 1);
    return t /= n, t < hv;
  }
  return !1;
}
var fC = function() {
  function r(e, t, n) {
    var i = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = t, this.id = e;
    var a = new M7(), o = n.renderer || "canvas";
    if (Io[o] || (o = we(Io)[0]),  false && 0)
      throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var s = new Io[o](t, a, n, e), l = n.ssr || s.ssrOnly;
    this.storage = a, this.painter = s;
    var u = !dist_ee.node && !dist_ee.worker && !l ? new Q7(s.getViewportRoot(), s.root) : null, f = n.useCoarsePointer, c = f == null || f === "auto" ? dist_ee.touchEventsSupported : !!f, h = 44, v;
    c && (v = dist_ne(n.pointerSize, h)), this.handler = new b7(a, s, u, s.root, v), this.animation = new U7({
      stage: {
        update: l ? null : function() {
          return i._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return r.prototype.add = function(e) {
    this._disposed || !e || (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh());
  }, r.prototype.remove = function(e) {
    this._disposed || !e || (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh());
  }, r.prototype.configLayer = function(e, t) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(e, t), this.refresh());
  }, r.prototype.setBackgroundColor = function(e) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = uC(e));
  }, r.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, r.prototype.setDarkMode = function(e) {
    this._darkMode = e;
  }, r.prototype.isDarkMode = function() {
    return this._darkMode;
  }, r.prototype.refreshImmediately = function(e) {
    this._disposed || (e || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, r.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, r.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, r.prototype._flush = function(e) {
    var t, n = Sa();
    this._needsRefresh && (t = !0, this.refreshImmediately(e)), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately());
    var i = Sa();
    t ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: i - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, r.prototype.setSleepAfterStill = function(e) {
    this._sleepAfterStill = e;
  }, r.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, r.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, r.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, r.prototype.resize = function(e) {
    this._disposed || (e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize());
  }, r.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, r.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, r.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, r.prototype.setCursorStyle = function(e) {
    this._disposed || this.handler.setCursorStyle(e);
  }, r.prototype.findHover = function(e, t) {
    if (!this._disposed)
      return this.handler.findHover(e, t);
  }, r.prototype.on = function(e, t, n) {
    return this._disposed || this.handler.on(e, t, n), this;
  }, r.prototype.off = function(e, t) {
    this._disposed || this.handler.off(e, t);
  }, r.prototype.trigger = function(e, t) {
    this._disposed || this.handler.trigger(e, t);
  }, r.prototype.clear = function() {
    if (!this._disposed) {
      for (var e = this.storage.getRoots(), t = 0; t < e.length; t++)
        e[t] instanceof dist_oe && e[t].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, r.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, lC(this.id));
  }, r;
}();
function Kp(r, e) {
  var t = new fC(g3(), r, e);
  return W3[t.id] = t, t;
}
function cC(r, e) {
  Io[r] = e;
}
var jp = 1e-4, U3 = 20;
function hC(r) {
  return r.replace(/^\s+|\s+$/g, "");
}
function De(r, e, t, n) {
  var i = e[0], a = e[1], o = t[0], s = t[1], l = a - i, u = s - o;
  if (l === 0)
    return u === 0 ? o : (o + s) / 2;
  if (n)
    if (l > 0) {
      if (r <= i)
        return o;
      if (r >= a)
        return s;
    } else {
      if (r >= i)
        return o;
      if (r <= a)
        return s;
    }
  else {
    if (r === i)
      return o;
    if (r === a)
      return s;
  }
  return (r - i) / l * u + o;
}
function me(r, e) {
  switch (r) {
    case "center":
    case "middle":
      r = "50%";
      break;
    case "left":
    case "top":
      r = "0%";
      break;
    case "right":
    case "bottom":
      r = "100%";
      break;
  }
  return dist_U(r) ? hC(r).match(/%$/) ? parseFloat(r) / 100 * e : parseFloat(r) : r == null ? NaN : +r;
}
function Be(r, e, t) {
  return e == null && (e = 10), e = Math.min(Math.max(0, e), U3), r = (+r).toFixed(e), t ? r : +r;
}
function xi(r) {
  return r.sort(function(e, t) {
    return e - t;
  }), r;
}
function zr(r) {
  if (r = +r, isNaN(r))
    return 0;
  if (r > 1e-14) {
    for (var e = 1, t = 0; t < 15; t++, e *= 10)
      if (Math.round(r * e) / e === r)
        return t;
  }
  return pv(r);
}
function pv(r) {
  var e = r.toString().toLowerCase(), t = e.indexOf("e"), n = t > 0 ? +e.slice(t + 1) : 0, i = t > 0 ? t : e.length, a = e.indexOf("."), o = a < 0 ? 0 : i - 1 - a;
  return Math.max(0, o - n);
}
function Y3(r, e) {
  var t = Math.log, n = Math.LN10, i = Math.floor(t(r[1] - r[0]) / n), a = Math.round(t(Math.abs(e[1] - e[0])) / n), o = Math.min(Math.max(-i + a, 0), 20);
  return isFinite(o) ? o : 20;
}
function vC(r, e) {
  var t = Jr(r, function(v, d) {
    return v + (isNaN(d) ? 0 : d);
  }, 0);
  if (t === 0)
    return [];
  for (var n = Math.pow(10, e), i = dist_$(r, function(v) {
    return (isNaN(v) ? 0 : v) / t * n * 100;
  }), a = n * 100, o = dist_$(i, function(v) {
    return Math.floor(v);
  }), s = Jr(o, function(v, d) {
    return v + d;
  }, 0), l = dist_$(i, function(v, d) {
    return v - o[d];
  }); s < a; ) {
    for (var u = Number.NEGATIVE_INFINITY, f = null, c = 0, h = l.length; c < h; ++c)
      l[c] > u && (u = l[c], f = c);
    ++o[f], l[f] = 0, ++s;
  }
  return dist_$(o, function(v) {
    return v / n;
  });
}
function dC(r, e) {
  var t = Math.max(zr(r), zr(e)), n = r + e;
  return t > U3 ? n : Be(n, t);
}
function X3(r) {
  var e = Math.PI * 2;
  return (r % e + e) % e;
}
function du(r) {
  return r > -jp && r < jp;
}
var pC = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function en(r) {
  if (r instanceof Date)
    return r;
  if (dist_U(r)) {
    var e = pC.exec(r);
    if (!e)
      return /* @__PURE__ */ new Date(NaN);
    if (e[8]) {
      var t = +e[4] || 0;
      return e[8].toUpperCase() !== "Z" && (t -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, t, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0));
    } else
      return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0);
  } else if (r == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(r));
}
function gC(r) {
  return Math.pow(10, af(r));
}
function af(r) {
  if (r === 0)
    return 0;
  var e = Math.floor(Math.log(r) / Math.LN10);
  return r / Math.pow(10, e) >= 10 && e++, e;
}
function Z3(r, e) {
  var t = af(r), n = Math.pow(10, t), i = r / n, a;
  return e ? i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10 : i < 1 ? a = 1 : i < 2 ? a = 2 : i < 3 ? a = 3 : i < 5 ? a = 5 : a = 10, r = a * n, t >= -20 ? +r.toFixed(t < 0 ? -t : 0) : r;
}
function Jp(r) {
  r.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var e = -1 / 0, t = 1, n = 0; n < r.length; ) {
    for (var i = r[n].interval, a = r[n].close, o = 0; o < 2; o++)
      i[o] <= e && (i[o] = e, a[o] = o ? 1 : 1 - t), e = i[o], t = a[o];
    i[0] === i[1] && a[0] * a[1] !== 1 ? r.splice(n, 1) : n++;
  }
  return r;
  function s(l, u, f) {
    return l.interval[f] < u.interval[f] || l.interval[f] === u.interval[f] && (l.close[f] - u.close[f] === (f ? -1 : 1) || !f && s(l, u, 1));
  }
}
function $n(r) {
  var e = parseFloat(r);
  return e == r && (e !== 0 || !dist_U(r) || r.indexOf("x") <= 0) ? e : NaN;
}
function q3(r) {
  return !isNaN($n(r));
}
function K3() {
  return Math.round(Math.random() * 9);
}
function j3(r, e) {
  return e === 0 ? r : j3(e, r % e);
}
function Qp(r, e) {
  return r == null ? e : e == null ? r : r * e / j3(r, e);
}
var eg = {}, mC = typeof console < "u" && console.warn && console.log;
function of(r, e, t) {
  if (mC && t) {
    if (eg[e])
      return;
    eg[e] = !0;
  }
}
function yC(r, e) {
  of("log", r, e);
}
function Ve(r, e) {
  of("warn", r, e);
}
function Ke(r, e) {
  of("error", r, e);
}
function fr(r) {
   false && 0;
}
function Ge(r, e, t) {
   false && 0;
}
function Nt() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = "";
  if (false) { var n; }
  return t;
}
function de(r) {
  throw new Error(r);
}
function tg(r, e, t) {
  return (e - r) * t + r;
}
var J3 = "series\0", _C = "\0_ec_\0";
function Ae(r) {
  return r instanceof Array ? r : r == null ? [] : [r];
}
function us(r, e, t) {
  if (r) {
    r[e] = r[e] || {}, r.emphasis = r.emphasis || {}, r.emphasis[e] = r.emphasis[e] || {};
    for (var n = 0, i = t.length; n < i; n++) {
      var a = t[n];
      !r.emphasis[e].hasOwnProperty(a) && r[e].hasOwnProperty(a) && (r.emphasis[e][a] = r[e][a]);
    }
  }
}
var rg = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function Ds(r) {
  return dist_X(r) && !dist_F(r) && !(r instanceof Date) ? r.value : r;
}
function SC(r) {
  return dist_X(r) && !(r instanceof Array);
}
function wC(r, e, t) {
  var n = t === "normalMerge", i = t === "replaceMerge", a = t === "replaceAll";
  r = r || [], e = (e || []).slice();
  var o = dist_W();
  dist_M(e, function(l, u) {
    if (!dist_X(l)) {
      e[u] = null;
      return;
    }
     false && (0);
  });
  var s = bC(r, o, t);
  return (n || i) && xC(s, r, o, e), n && CC(s, e), n || i ? TC(s, e, i) : a && MC(s, e), DC(s), s;
}
function bC(r, e, t) {
  var n = [];
  if (t === "replaceAll")
    return n;
  for (var i = 0; i < r.length; i++) {
    var a = r[i];
    a && a.id != null && e.set(a.id, i), n.push({
      existing: t === "replaceMerge" || Na(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function xC(r, e, t, n) {
  dist_M(n, function(i, a) {
    if (!(!i || i.id == null)) {
      var o = zo(i.id), s = t.get(o);
      if (s != null) {
        var l = r[s];
        dist_re(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = i, l.existing = e[s], n[a] = null;
      }
    }
  });
}
function CC(r, e) {
  dist_M(e, function(t, n) {
    if (!(!t || t.name == null))
      for (var i = 0; i < r.length; i++) {
        var a = r[i].existing;
        if (!r[i].newOption && a && (a.id == null || t.id == null) && !Na(t) && !Na(a) && Q3("name", a, t)) {
          r[i].newOption = t, e[n] = null;
          return;
        }
      }
  });
}
function TC(r, e, t) {
  dist_M(e, function(n) {
    if (n) {
      for (
        var i, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (i = r[a]) && (i.newOption || Na(i.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        i.existing && n.id != null && !Q3("id", n, i.existing));
      )
        a++;
      i ? (i.newOption = n, i.brandNew = t) : r.push({
        newOption: n,
        brandNew: t,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function MC(r, e) {
  dist_M(e, function(t) {
    r.push({
      newOption: t,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function DC(r) {
  var e = dist_W();
  dist_M(r, function(t) {
    var n = t.existing;
    n && e.set(n.id, t);
  }), dist_M(r, function(t) {
    var n = t.newOption;
    dist_re(!n || n.id == null || !e.get(n.id) || e.get(n.id) === t, "id duplicates: " + (n && n.id)), n && n.id != null && e.set(n.id, t), !t.keyInfo && (t.keyInfo = {});
  }), dist_M(r, function(t, n) {
    var i = t.existing, a = t.newOption, o = t.keyInfo;
    if (dist_X(a)) {
      if (o.name = a.name != null ? zo(a.name) : i ? i.name : J3 + n, i)
        o.id = zo(i.id);
      else if (a.id != null)
        o.id = zo(a.id);
      else {
        var s = 0;
        do
          o.id = "\0" + o.name + "\0" + s++;
        while (e.get(o.id));
      }
      e.set(o.id, t);
    }
  });
}
function Q3(r, e, t) {
  var n = Zt(e[r], null), i = Zt(t[r], null);
  return n != null && i != null && n === i;
}
function zo(r) {
  if (false)
    {}
  return Zt(r, "");
}
function Zt(r, e) {
  return r == null ? e : dist_U(r) ? r : ve(r) || ou(r) ? r + "" : e;
}
function ng(r) {
   false && 0;
}
function ig(r) {
  return ou(r) || q3(r);
}
function Ad(r) {
  var e = r.name;
  return !!(e && e.indexOf(J3));
}
function Na(r) {
  return r && r.id != null && zo(r.id).indexOf(_C) === 0;
}
function EC(r, e, t) {
  dist_M(r, function(n) {
    var i = n.newOption;
    dist_X(i) && (n.keyInfo.mainType = e, n.keyInfo.subType = AC(e, i, n.existing, t));
  });
}
function AC(r, e, t, n) {
  var i = e.type ? e.type : t ? t.subType : n.determineSubType(r, e);
  return i;
}
function IC(r, e) {
  var t = {}, n = {};
  return i(r || [], t), i(e || [], n, t), [a(t), a(n)];
  function i(o, s, l) {
    for (var u = 0, f = o.length; u < f; u++) {
      var c = Zt(o[u].seriesId, null);
      if (c == null)
        return;
      for (var h = Ae(o[u].dataIndex), v = l && l[c], d = 0, g = h.length; d < g; d++) {
        var p = h[d];
        v && v[p] ? v[p] = null : (s[c] || (s[c] = {}))[p] = 1;
      }
    }
  }
  function a(o, s) {
    var l = [];
    for (var u in o)
      if (o.hasOwnProperty(u) && o[u] != null)
        if (s)
          l.push(+u);
        else {
          var f = a(o[u], !0);
          f.length && l.push({
            seriesId: u,
            dataIndex: f
          });
        }
    return l;
  }
}
function Vi(r, e) {
  if (e.dataIndexInside != null)
    return e.dataIndexInside;
  if (e.dataIndex != null)
    return dist_F(e.dataIndex) ? dist_$(e.dataIndex, function(t) {
      return r.indexOfRawIndex(t);
    }) : r.indexOfRawIndex(e.dataIndex);
  if (e.name != null)
    return dist_F(e.name) ? dist_$(e.name, function(t) {
      return r.indexOfName(t);
    }) : r.indexOfName(e.name);
}
function Me() {
  var r = "__ec_inner_" + LC++;
  return function(e) {
    return e[r] || (e[r] = {});
  };
}
var LC = K3();
function dc(r, e, t) {
  var n = Id(e, t), i = n.mainTypeSpecified, a = n.queryOptionMap, o = n.others, s = o, l = t ? t.defaultMainType : null;
  return !i && l && a.set(l, {}), a.each(function(u, f) {
    var c = Es(r, f, u, {
      useDefault: l === f,
      enableAll: t && t.enableAll != null ? t.enableAll : !0,
      enableNone: t && t.enableNone != null ? t.enableNone : !0
    });
    s[f + "Models"] = c.models, s[f + "Model"] = c.models[0];
  }), s;
}
function Id(r, e) {
  var t;
  if (dist_U(r)) {
    var n = {};
    n[r + "Index"] = 0, t = n;
  } else
    t = r;
  var i = dist_W(), a = {}, o = !1;
  return dist_M(t, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], f = u[1], c = (u[2] || "").toLowerCase();
    if (!(!f || !c || e && e.includeMainTypes && ye(e.includeMainTypes, f) < 0)) {
      o = o || !!f;
      var h = i.get(f) || i.set(f, {});
      h[c] = s;
    }
  }), {
    mainTypeSpecified: o,
    queryOptionMap: i,
    others: a
  };
}
var ft = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, NC = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function Es(r, e, t, n) {
  n = n || ft;
  var i = t.index, a = t.id, o = t.name, s = {
    models: null,
    specified: i != null || a != null || o != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = n.useDefault && (l = r.getComponent(e)) ? [l] : [], s;
  }
  return i === "none" || i === !1 ? (dist_re(n.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (i === "all" && (dist_re(n.enableAll, '`"all"` is not a valid value on index option.'), i = a = o = null), s.models = r.queryComponents({
    mainType: e,
    index: i,
    id: a,
    name: o
  }), s);
}
function e_(r, e, t) {
  r.setAttribute ? r.setAttribute(e, t) : r[e] = t;
}
function PC(r, e) {
  return r.getAttribute ? r.getAttribute(e) : r[e];
}
function RC(r) {
  return r === "auto" ? dist_ee.domSupported ? "html" : "richText" : r || "html";
}
function t_(r, e, t, n, i) {
  var a = e == null || e === "auto";
  if (n == null)
    return n;
  if (ve(n)) {
    var o = tg(t || 0, n, i);
    return Be(o, a ? Math.max(zr(t || 0), zr(n)) : e);
  } else {
    if (dist_U(n))
      return i < 1 ? t : n;
    for (var s = [], l = t, u = n, f = Math.max(l ? l.length : 0, u.length), c = 0; c < f; ++c) {
      var h = r.getDimensionInfo(c);
      if (h && h.type === "ordinal")
        s[c] = (i < 1 && l ? l : u)[c];
      else {
        var v = l && l[c] ? l[c] : 0, d = u[c], o = tg(v, d, i);
        s[c] = Be(o, a ? Math.max(zr(v), zr(d)) : e);
      }
    }
    return s;
  }
}
var OC = ".", ei = "___EC__COMPONENT__CONTAINER___", r_ = "___EC__EXTENDED_CLASS___";
function Tr(r) {
  var e = {
    main: "",
    sub: ""
  };
  if (r) {
    var t = r.split(OC);
    e.main = t[0] || "", e.sub = t[1] || "";
  }
  return e;
}
function kC(r) {
  dist_re(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(r), 'componentType "' + r + '" illegal');
}
function VC(r) {
  return !!(r && r[r_]);
}
function Ld(r, e) {
  r.$constructor = r, r.extend = function(t) {
     false && 0;
    var n = this, i;
    return BC(n) ? i = /** @class */
    function(a) {
      dist_k(o, a);
      function o() {
        return a.apply(this, arguments) || this;
      }
      return o;
    }(n) : (i = function() {
      (t.$constructor || n).apply(this, arguments);
    }, Ux(i, this)), dist_V(i.prototype, t), i[r_] = !0, i.extend = this.extend, i.superCall = GC, i.superApply = HC, i.superClass = n, i;
  };
}
function BC(r) {
  return dist_j(r) && /^class\s/.test(Function.prototype.toString.call(r));
}
function n_(r, e) {
  r.extend = e.extend;
}
var FC = Math.round(Math.random() * 10);
function zC(r) {
  var e = ["__\0is_clz", FC++].join("_");
  r.prototype[e] = !0,  false && 0, r.isInstance = function(t) {
    return !!(t && t[e]);
  };
}
function GC(r, e) {
  for (var t = [], n = 2; n < arguments.length; n++)
    t[n - 2] = arguments[n];
  return this.superClass.prototype[e].apply(r, t);
}
function HC(r, e, t) {
  return this.superClass.prototype[e].apply(r, t);
}
function sf(r) {
  var e = {};
  r.registerClass = function(n) {
    var i = n.type || n.prototype.type;
    if (i) {
      kC(i), n.prototype.type = i;
      var a = Tr(i);
      if (!a.sub)
         false && 0, e[a.main] = n;
      else if (a.sub !== ei) {
        var o = t(a);
        o[a.sub] = n;
      }
    }
    return n;
  }, r.getClass = function(n, i, a) {
    var o = e[n];
    if (o && o[ei] && (o = i ? o[i] : null), a && !o)
      throw new Error(i ? "Component " + n + "." + (i || "") + " is used but not imported." : n + ".type should be specified.");
    return o;
  }, r.getClassesByMainType = function(n) {
    var i = Tr(n), a = [], o = e[i.main];
    return o && o[ei] ? dist_M(o, function(s, l) {
      l !== ei && a.push(s);
    }) : a.push(o), a;
  }, r.hasClass = function(n) {
    var i = Tr(n);
    return !!e[i.main];
  }, r.getAllClassMainTypes = function() {
    var n = [];
    return dist_M(e, function(i, a) {
      n.push(a);
    }), n;
  }, r.hasSubTypes = function(n) {
    var i = Tr(n), a = e[i.main];
    return a && a[ei];
  };
  function t(n) {
    var i = e[n.main];
    return (!i || !i[ei]) && (i = e[n.main] = {}, i[ei] = !0), i;
  }
}
function fs(r, e) {
  for (var t = 0; t < r.length; t++)
    r[t][1] || (r[t][1] = r[t][0]);
  return e = e || !1, function(n, i, a) {
    for (var o = {}, s = 0; s < r.length; s++) {
      var l = r[s][1];
      if (!(i && ye(i, l) >= 0 || a && ye(a, l) < 0)) {
        var u = n.getShallow(l, e);
        u != null && (o[r[s][0]] = u);
      }
    }
    return o;
  };
}
var $C = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], WC = fs($C), UC = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getAreaStyle = function(e, t) {
      return WC(this, e, t);
    }, r;
  }()
), gv = new Ms(50);
function YC(r) {
  if (typeof r == "string") {
    var e = gv.get(r);
    return e && e.image;
  } else
    return r;
}
function i_(r, e, t, n, i) {
  if (r)
    if (typeof r == "string") {
      if (e && e.__zrImageSrc === r || !t)
        return e;
      var a = gv.get(r), o = { hostEl: t, cb: n, cbPayload: i };
      return a ? (e = a.image, !lf(e) && a.pending.push(o)) : (e = Ha.loadImage(r, ag, ag), e.__zrImageSrc = r, gv.put(r, e.__cachedImgObj = {
        image: e,
        pending: [o]
      })), e;
    } else
      return r;
  else
    return e;
}
function ag() {
  var r = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var e = 0; e < r.pending.length; e++) {
    var t = r.pending[e], n = t.cb;
    n && n(this, t.cbPayload), t.hostEl.dirty();
  }
  r.pending.length = 0;
}
function lf(r) {
  return r && r.width && r.height;
}
var pc = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function XC(r, e, t, n, i) {
  if (!e)
    return "";
  var a = (r + "").split(`
`);
  i = a_(e, t, n, i);
  for (var o = 0, s = a.length; o < s; o++)
    a[o] = o_(a[o], i);
  return a.join(`
`);
}
function a_(r, e, t, n) {
  n = n || {};
  var i = dist_V({}, n);
  i.font = e, t = dist_ne(t, "..."), i.maxIterations = dist_ne(n.maxIterations, 2);
  var a = i.minChar = dist_ne(n.minChar, 0);
  i.cnCharWidth = It("国", e);
  var o = i.ascCharWidth = It("a", e);
  i.placeholder = dist_ne(n.placeholder, "");
  for (var s = r = Math.max(0, r - 1), l = 0; l < a && s >= o; l++)
    s -= o;
  var u = It(t, e);
  return u > s && (t = "", u = 0), s = r - u, i.ellipsis = t, i.ellipsisWidth = u, i.contentWidth = s, i.containerWidth = r, i;
}
function o_(r, e) {
  var t = e.containerWidth, n = e.font, i = e.contentWidth;
  if (!t)
    return "";
  var a = It(r, n);
  if (a <= t)
    return r;
  for (var o = 0; ; o++) {
    if (a <= i || o >= e.maxIterations) {
      r += e.ellipsis;
      break;
    }
    var s = o === 0 ? ZC(r, i, e.ascCharWidth, e.cnCharWidth) : a > 0 ? Math.floor(r.length * i / a) : 0;
    r = r.substr(0, s), a = It(r, n);
  }
  return r === "" && (r = e.placeholder), r;
}
function ZC(r, e, t, n) {
  for (var i = 0, a = 0, o = r.length; a < o && i < e; a++) {
    var s = r.charCodeAt(a);
    i += 0 <= s && s <= 127 ? t : n;
  }
  return a;
}
function qC(r, e) {
  r != null && (r += "");
  var t = e.overflow, n = e.padding, i = e.font, a = t === "truncate", o = Dd(i), s = dist_ne(e.lineHeight, o), l = !!e.backgroundColor, u = e.lineOverflow === "truncate", f = e.width, c;
  f != null && (t === "break" || t === "breakAll") ? c = r ? s_(r, e.font, f, t === "breakAll", 0).lines : [] : c = r ? r.split(`
`) : [];
  var h = c.length * s, v = dist_ne(e.height, h);
  if (h > v && u) {
    var d = Math.floor(v / s);
    c = c.slice(0, d);
  }
  if (r && a && f != null)
    for (var g = a_(f, i, e.ellipsis, {
      minChar: e.truncateMinChar,
      placeholder: e.placeholder
    }), p = 0; p < c.length; p++)
      c[p] = o_(c[p], g);
  for (var m = v, y = 0, p = 0; p < c.length; p++)
    y = Math.max(It(c[p], i), y);
  f == null && (f = y);
  var _ = y;
  return n && (m += n[0] + n[2], _ += n[1] + n[3], f += n[1] + n[3]), l && (_ = f), {
    lines: c,
    height: v,
    outerWidth: _,
    outerHeight: m,
    lineHeight: s,
    calculatedLineHeight: o,
    contentWidth: y,
    contentHeight: h,
    width: f
  };
}
var KC = /* @__PURE__ */ function() {
  function r() {
  }
  return r;
}(), og = /* @__PURE__ */ function() {
  function r(e) {
    this.tokens = [], e && (this.tokens = e);
  }
  return r;
}(), jC = /* @__PURE__ */ function() {
  function r() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
  }
  return r;
}();
function JC(r, e) {
  var t = new jC();
  if (r != null && (r += ""), !r)
    return t;
  for (var n = e.width, i = e.height, a = e.overflow, o = (a === "break" || a === "breakAll") && n != null ? { width: n, accumWidth: 0, breakAll: a === "breakAll" } : null, s = pc.lastIndex = 0, l; (l = pc.exec(r)) != null; ) {
    var u = l.index;
    u > s && gc(t, r.substring(s, u), e, o), gc(t, l[2], e, o, l[1]), s = pc.lastIndex;
  }
  s < r.length && gc(t, r.substring(s, r.length), e, o);
  var f = [], c = 0, h = 0, v = e.padding, d = a === "truncate", g = e.lineOverflow === "truncate";
  function p(O, B, H) {
    O.width = B, O.lineHeight = H, c += H, h = Math.max(h, B);
  }
  e:
    for (var m = 0; m < t.lines.length; m++) {
      for (var y = t.lines[m], _ = 0, S = 0, b = 0; b < y.tokens.length; b++) {
        var w = y.tokens[b], x = w.styleName && e.rich[w.styleName] || {}, C = w.textPadding = x.padding, T = C ? C[1] + C[3] : 0, E = w.font = x.font || e.font;
        w.contentHeight = Dd(E);
        var D = dist_ne(x.height, w.contentHeight);
        if (w.innerHeight = D, C && (D += C[0] + C[2]), w.height = D, w.lineHeight = Dr(x.lineHeight, e.lineHeight, D), w.align = x && x.align || e.align, w.verticalAlign = x && x.verticalAlign || "middle", g && i != null && c + w.lineHeight > i) {
          b > 0 ? (y.tokens = y.tokens.slice(0, b), p(y, S, _), t.lines = t.lines.slice(0, m + 1)) : t.lines = t.lines.slice(0, m);
          break e;
        }
        var I = x.width, L = I == null || I === "auto";
        if (typeof I == "string" && I.charAt(I.length - 1) === "%")
          w.percentWidth = I, f.push(w), w.contentWidth = It(w.text, E);
        else {
          if (L) {
            var N = x.backgroundColor, P = N && N.image;
            P && (P = YC(P), lf(P) && (w.width = Math.max(w.width, P.width * D / P.height)));
          }
          var R = d && n != null ? n - S : null;
          R != null && R < w.width ? !L || R < T ? (w.text = "", w.width = w.contentWidth = 0) : (w.text = XC(w.text, R - T, E, e.ellipsis, { minChar: e.truncateMinChar }), w.width = w.contentWidth = It(w.text, E)) : w.contentWidth = It(w.text, E);
        }
        w.width += T, S += w.width, x && (_ = Math.max(_, w.lineHeight));
      }
      p(y, S, _);
    }
  t.outerWidth = t.width = dist_ne(n, h), t.outerHeight = t.height = dist_ne(i, c), t.contentHeight = c, t.contentWidth = h, v && (t.outerWidth += v[1] + v[3], t.outerHeight += v[0] + v[2]);
  for (var m = 0; m < f.length; m++) {
    var w = f[m], z = w.percentWidth;
    w.width = parseInt(z, 10) / 100 * t.width;
  }
  return t;
}
function gc(r, e, t, n, i) {
  var a = e === "", o = i && t.rich[i] || {}, s = r.lines, l = o.font || t.font, u = !1, f, c;
  if (n) {
    var h = o.padding, v = h ? h[1] + h[3] : 0;
    if (o.width != null && o.width !== "auto") {
      var d = Lr(o.width, n.width) + v;
      s.length > 0 && d + n.accumWidth > n.width && (f = e.split(`
`), u = !0), n.accumWidth = d;
    } else {
      var g = s_(e, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = g.accumWidth + v, c = g.linesWidths, f = g.lines;
    }
  } else
    f = e.split(`
`);
  for (var p = 0; p < f.length; p++) {
    var m = f[p], y = new KC();
    if (y.styleName = i, y.text = m, y.isLineHolder = !m && !a, typeof o.width == "number" ? y.width = o.width : y.width = c ? c[p] : It(m, l), !p && !u) {
      var _ = (s[s.length - 1] || (s[0] = new og())).tokens, S = _.length;
      S === 1 && _[0].isLineHolder ? _[0] = y : (m || !S || a) && _.push(y);
    } else
      s.push(new og([y]));
  }
}
function QC(r) {
  var e = r.charCodeAt(0);
  return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303;
}
var eT = Jr(",&?/;] ".split(""), function(r, e) {
  return r[e] = !0, r;
}, {});
function tT(r) {
  return QC(r) ? !!eT[r] : !0;
}
function s_(r, e, t, n, i) {
  for (var a = [], o = [], s = "", l = "", u = 0, f = 0, c = 0; c < r.length; c++) {
    var h = r.charAt(c);
    if (h === `
`) {
      l && (s += l, f += u), a.push(s), o.push(f), s = "", l = "", u = 0, f = 0;
      continue;
    }
    var v = It(h, e), d = n ? !1 : !tT(h);
    if (a.length ? f + v > t : i + f + v > t) {
      f ? (s || l) && (d ? (s || (s = l, l = "", u = 0, f = u), a.push(s), o.push(f - u), l += h, u += v, s = "", f = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(f), s = h, f = v)) : d ? (a.push(l), o.push(u), l = h, u = v) : (a.push(h), o.push(v));
      continue;
    }
    f += v, d ? (l += h, u += v) : (l && (s += l, l = "", u = 0), s += h);
  }
  return !a.length && !s && (s = r, l = "", u = 0), l && (s += l), s && (a.push(s), o.push(f)), a.length === 1 && (f += i), {
    accumWidth: f,
    lines: a,
    linesWidths: o
  };
}
var mv = "__zr_style_" + Math.round(Math.random() * 10), Li = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, uf = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
Li[mv] = !0;
var sg = ["z", "z2", "invisible"], rT = ["invisible"], nT = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype._init = function(t) {
    for (var n = we(t), i = 0; i < n.length; i++) {
      var a = n[i];
      a === "style" ? this.useStyle(t[a]) : r.prototype.attrKV.call(this, a, t[a]);
    }
    this.style || this.useStyle({});
  }, e.prototype.beforeBrush = function() {
  }, e.prototype.afterBrush = function() {
  }, e.prototype.innerBeforeBrush = function() {
  }, e.prototype.innerAfterBrush = function() {
  }, e.prototype.shouldBePainted = function(t, n, i, a) {
    var o = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && iT(this, t, n) || o && !o[0] && !o[3])
      return !1;
    if (i && this.__clipPaths) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, e.prototype.contain = function(t, n) {
    return this.rectContain(t, n);
  }, e.prototype.traverse = function(t, n) {
    t.call(n, this);
  }, e.prototype.rectContain = function(t, n) {
    var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
    return a.contain(i[0], i[1]);
  }, e.prototype.getPaintRect = function() {
    var t = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, i = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      t = this._paintRect || (this._paintRect = new dist_ae(0, 0, 0, 0)), n ? dist_ae.applyTransform(t, i, n) : t.copy(i), (o || s || l) && (t.width += o * 2 + Math.abs(s), t.height += o * 2 + Math.abs(l), t.x = Math.min(t.x, t.x + s - o), t.y = Math.min(t.y, t.y + l - o));
      var u = this.dirtyRectTolerance;
      t.isZero() || (t.x = Math.floor(t.x - u), t.y = Math.floor(t.y - u), t.width = Math.ceil(t.width + 1 + u * 2), t.height = Math.ceil(t.height + 1 + u * 2));
    }
    return t;
  }, e.prototype.setPrevPaintRect = function(t) {
    t ? (this._prevPaintRect = this._prevPaintRect || new dist_ae(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null;
  }, e.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, e.prototype.animateStyle = function(t) {
    return this.animate("style", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : this.markRedraw();
  }, e.prototype.attrKV = function(t, n) {
    t !== "style" ? r.prototype.attrKV.call(this, t, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, e.prototype.setStyle = function(t, n) {
    return typeof t == "string" ? this.style[t] = n : dist_V(this.style, t), this.dirtyStyle(), this;
  }, e.prototype.dirtyStyle = function(t) {
    t || this.markRedraw(), this.__dirty |= Do, this._rect && (this._rect = null);
  }, e.prototype.dirty = function() {
    this.dirtyStyle();
  }, e.prototype.styleChanged = function() {
    return !!(this.__dirty & Do);
  }, e.prototype.styleUpdated = function() {
    this.__dirty &= ~Do;
  }, e.prototype.createStyle = function(t) {
    return tf(Li, t);
  }, e.prototype.useStyle = function(t) {
    t[mv] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle();
  }, e.prototype.isStyleObject = function(t) {
    return t[mv];
  }, e.prototype._innerSaveToNormal = function(t) {
    r.prototype._innerSaveToNormal.call(this, t);
    var n = this._normalState;
    t.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(t, n, sg);
  }, e.prototype._applyStateObj = function(t, n, i, a, o, s) {
    r.prototype._applyStateObj.call(this, t, n, i, a, o, s);
    var l = !(n && a), u;
    if (n && n.style ? o ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(u, n.style)) : l && (u = i.style), u)
      if (o) {
        var f = this.style;
        if (this.style = this.createStyle(l ? {} : f), l)
          for (var c = we(f), h = 0; h < c.length; h++) {
            var v = c[h];
            v in u && (u[v] = u[v], this.style[v] = f[v]);
          }
        for (var d = we(u), h = 0; h < d.length; h++) {
          var v = d[h];
          this.style[v] = this.style[v];
        }
        this._transitionState(t, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? rT : sg, h = 0; h < g.length; h++) {
      var v = g[h];
      n && n[v] != null ? this[v] = n[v] : l && i[v] != null && (this[v] = i[v]);
    }
  }, e.prototype._mergeStates = function(t) {
    for (var n = r.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) {
      var o = t[a];
      o.style && (i = i || {}, this._mergeStyle(i, o.style));
    }
    return i && (n.style = i), n;
  }, e.prototype._mergeStyle = function(t, n) {
    return dist_V(t, n), t;
  }, e.prototype.getAnimationStyleProps = function() {
    return uf;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "displayable", t.invisible = !1, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = !1, t.cursor = "pointer", t.rectHover = !1, t.incremental = !1, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = Et | Do;
  }(), e;
}($3), mc = new dist_ae(0, 0, 0, 0), yc = new dist_ae(0, 0, 0, 0);
function iT(r, e, t) {
  return mc.copy(r.getBoundingRect()), r.transform && mc.applyTransform(r.transform), yc.width = e, yc.height = t, !mc.intersect(yc);
}
const Wn = nT;
var yt = Math.min, _t = Math.max, _c = Math.sin, Sc = Math.cos, ti = Math.PI * 2, el = Fi(), tl = Fi(), rl = Fi();
function Nd(r, e, t) {
  if (r.length !== 0) {
    for (var n = r[0], i = n[0], a = n[0], o = n[1], s = n[1], l = 1; l < r.length; l++)
      n = r[l], i = yt(i, n[0]), a = _t(a, n[0]), o = yt(o, n[1]), s = _t(s, n[1]);
    e[0] = i, e[1] = o, t[0] = a, t[1] = s;
  }
}
function lg(r, e, t, n, i, a) {
  i[0] = yt(r, t), i[1] = yt(e, n), a[0] = _t(r, t), a[1] = _t(e, n);
}
var ug = [], fg = [];
function aT(r, e, t, n, i, a, o, s, l, u) {
  var f = N3, c = ze, h = f(r, t, i, o, ug);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var v = 0; v < h; v++) {
    var d = c(r, t, i, o, ug[v]);
    l[0] = yt(d, l[0]), u[0] = _t(d, u[0]);
  }
  h = f(e, n, a, s, fg);
  for (var v = 0; v < h; v++) {
    var g = c(e, n, a, s, fg[v]);
    l[1] = yt(g, l[1]), u[1] = _t(g, u[1]);
  }
  l[0] = yt(r, l[0]), u[0] = _t(r, u[0]), l[0] = yt(o, l[0]), u[0] = _t(o, u[0]), l[1] = yt(e, l[1]), u[1] = _t(e, u[1]), l[1] = yt(s, l[1]), u[1] = _t(s, u[1]);
}
function oT(r, e, t, n, i, a, o, s) {
  var l = R3, u = We, f = _t(yt(l(r, t, i), 1), 0), c = _t(yt(l(e, n, a), 1), 0), h = u(r, t, i, f), v = u(e, n, a, c);
  o[0] = yt(r, i, h), o[1] = yt(e, a, v), s[0] = _t(r, i, h), s[1] = _t(e, a, v);
}
function sT(r, e, t, n, i, a, o, s, l) {
  var u = Ln, f = Nn, c = Math.abs(i - a);
  if (c % ti < 1e-4 && c > 1e-4) {
    s[0] = r - t, s[1] = e - n, l[0] = r + t, l[1] = e + n;
    return;
  }
  if (el[0] = Sc(i) * t + r, el[1] = _c(i) * n + e, tl[0] = Sc(a) * t + r, tl[1] = _c(a) * n + e, u(s, el, tl), f(l, el, tl), i = i % ti, i < 0 && (i = i + ti), a = a % ti, a < 0 && (a = a + ti), i > a && !o ? a += ti : i < a && o && (i += ti), o) {
    var h = a;
    a = i, i = h;
  }
  for (var v = 0; v < a; v += Math.PI / 2)
    v > i && (rl[0] = Sc(v) * t + r, rl[1] = _c(v) * n + e, u(s, rl, s), f(l, rl, l));
}
var _e = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, ri = [], ni = [], gr = [], pn = [], mr = [], yr = [], wc = Math.min, bc = Math.max, ii = Math.cos, ai = Math.sin, Or = Math.abs, yv = Math.PI, Cn = yv * 2, xc = typeof Float32Array < "u", ao = [];
function Cc(r) {
  var e = Math.round(r / yv * 1e8) / 1e8;
  return e % 2 * yv;
}
function l_(r, e) {
  var t = Cc(r[0]);
  t < 0 && (t += Cn);
  var n = t - r[0], i = r[1];
  i += n, !e && i - t >= Cn ? i = t + Cn : e && t - i >= Cn ? i = t - Cn : !e && t > i ? i = t + (Cn - Cc(t - i)) : e && t < i && (i = t - (Cn - Cc(i - t))), r[0] = t, r[1] = i;
}
var tn = function() {
  function r(e) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return r.prototype.increaseVersion = function() {
    this._version++;
  }, r.prototype.getVersion = function() {
    return this._version;
  }, r.prototype.setScale = function(e, t, n) {
    n = n || 0, n > 0 && (this._ux = Or(n / hu / e) || 0, this._uy = Or(n / hu / t) || 0);
  }, r.prototype.setDPR = function(e) {
    this.dpr = e;
  }, r.prototype.setContext = function(e) {
    this._ctx = e;
  }, r.prototype.getContext = function() {
    return this._ctx;
  }, r.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, r.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, r.prototype.moveTo = function(e, t) {
    return this._drawPendingPt(), this.addData(_e.M, e, t), this._ctx && this._ctx.moveTo(e, t), this._x0 = e, this._y0 = t, this._xi = e, this._yi = t, this;
  }, r.prototype.lineTo = function(e, t) {
    var n = Or(e - this._xi), i = Or(t - this._yi), a = n > this._ux || i > this._uy;
    if (this.addData(_e.L, e, t), this._ctx && a && this._ctx.lineTo(e, t), a)
      this._xi = e, this._yi = t, this._pendingPtDist = 0;
    else {
      var o = n * n + i * i;
      o > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = t, this._pendingPtDist = o);
    }
    return this;
  }, r.prototype.bezierCurveTo = function(e, t, n, i, a, o) {
    return this._drawPendingPt(), this.addData(_e.C, e, t, n, i, a, o), this._ctx && this._ctx.bezierCurveTo(e, t, n, i, a, o), this._xi = a, this._yi = o, this;
  }, r.prototype.quadraticCurveTo = function(e, t, n, i) {
    return this._drawPendingPt(), this.addData(_e.Q, e, t, n, i), this._ctx && this._ctx.quadraticCurveTo(e, t, n, i), this._xi = n, this._yi = i, this;
  }, r.prototype.arc = function(e, t, n, i, a, o) {
    this._drawPendingPt(), ao[0] = i, ao[1] = a, l_(ao, o), i = ao[0], a = ao[1];
    var s = a - i;
    return this.addData(_e.A, e, t, n, n, i, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(e, t, n, i, a, o), this._xi = ii(a) * n + e, this._yi = ai(a) * n + t, this;
  }, r.prototype.arcTo = function(e, t, n, i, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, t, n, i, a), this;
  }, r.prototype.rect = function(e, t, n, i) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(e, t, n, i), this.addData(_e.R, e, t, n, i), this;
  }, r.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(_e.Z);
    var e = this._ctx, t = this._x0, n = this._y0;
    return e && e.closePath(), this._xi = t, this._yi = n, this;
  }, r.prototype.fill = function(e) {
    e && e.fill(), this.toStatic();
  }, r.prototype.stroke = function(e) {
    e && e.stroke(), this.toStatic();
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.setData = function(e) {
    var t = e.length;
    !(this.data && this.data.length === t) && xc && (this.data = new Float32Array(t));
    for (var n = 0; n < t; n++)
      this.data[n] = e[n];
    this._len = t;
  }, r.prototype.appendPath = function(e) {
    e instanceof Array || (e = [e]);
    for (var t = e.length, n = 0, i = this._len, a = 0; a < t; a++)
      n += e[a].len();
    xc && this.data instanceof Float32Array && (this.data = new Float32Array(i + n));
    for (var a = 0; a < t; a++)
      for (var o = e[a].data, s = 0; s < o.length; s++)
        this.data[i++] = o[s];
    this._len = i;
  }, r.prototype.addData = function(e, t, n, i, a, o, s, l, u) {
    if (this._saveData) {
      var f = this.data;
      this._len + arguments.length > f.length && (this._expandData(), f = this.data);
      for (var c = 0; c < arguments.length; c++)
        f[this._len++] = arguments[c];
    }
  }, r.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, r.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var e = [], t = 0; t < this._len; t++)
        e[t] = this.data[t];
      this.data = e;
    }
  }, r.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var e = this.data;
      e instanceof Array && (e.length = this._len, xc && this._len > 11 && (this.data = new Float32Array(e)));
    }
  }, r.prototype.getBoundingRect = function() {
    gr[0] = gr[1] = mr[0] = mr[1] = Number.MAX_VALUE, pn[0] = pn[1] = yr[0] = yr[1] = -Number.MAX_VALUE;
    var e = this.data, t = 0, n = 0, i = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      var s = e[o++], l = o === 1;
      switch (l && (t = e[o], n = e[o + 1], i = t, a = n), s) {
        case _e.M:
          t = i = e[o++], n = a = e[o++], mr[0] = i, mr[1] = a, yr[0] = i, yr[1] = a;
          break;
        case _e.L:
          lg(t, n, e[o], e[o + 1], mr, yr), t = e[o++], n = e[o++];
          break;
        case _e.C:
          aT(t, n, e[o++], e[o++], e[o++], e[o++], e[o], e[o + 1], mr, yr), t = e[o++], n = e[o++];
          break;
        case _e.Q:
          oT(t, n, e[o++], e[o++], e[o], e[o + 1], mr, yr), t = e[o++], n = e[o++];
          break;
        case _e.A:
          var u = e[o++], f = e[o++], c = e[o++], h = e[o++], v = e[o++], d = e[o++] + v;
          o += 1;
          var g = !e[o++];
          l && (i = ii(v) * c + u, a = ai(v) * h + f), sT(u, f, c, h, v, d, g, mr, yr), t = ii(d) * c + u, n = ai(d) * h + f;
          break;
        case _e.R:
          i = t = e[o++], a = n = e[o++];
          var p = e[o++], m = e[o++];
          lg(i, a, i + p, a + m, mr, yr);
          break;
        case _e.Z:
          t = i, n = a;
          break;
      }
      Ln(gr, gr, mr), Nn(pn, pn, yr);
    }
    return o === 0 && (gr[0] = gr[1] = pn[0] = pn[1] = 0), new dist_ae(gr[0], gr[1], pn[0] - gr[0], pn[1] - gr[1]);
  }, r.prototype._calculateLength = function() {
    var e = this.data, t = this._len, n = this._ux, i = this._uy, a = 0, o = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, f = 0, c = 0, h = 0; h < t; ) {
      var v = e[h++], d = h === 1;
      d && (a = e[h], o = e[h + 1], s = a, l = o);
      var g = -1;
      switch (v) {
        case _e.M:
          a = s = e[h++], o = l = e[h++];
          break;
        case _e.L: {
          var p = e[h++], m = e[h++], y = p - a, _ = m - o;
          (Or(y) > n || Or(_) > i || h === t - 1) && (g = Math.sqrt(y * y + _ * _), a = p, o = m);
          break;
        }
        case _e.C: {
          var S = e[h++], b = e[h++], p = e[h++], m = e[h++], w = e[h++], x = e[h++];
          g = D7(a, o, S, b, p, m, w, x, 10), a = w, o = x;
          break;
        }
        case _e.Q: {
          var S = e[h++], b = e[h++], p = e[h++], m = e[h++];
          g = A7(a, o, S, b, p, m, 10), a = p, o = m;
          break;
        }
        case _e.A:
          var C = e[h++], T = e[h++], E = e[h++], D = e[h++], I = e[h++], L = e[h++], N = L + I;
          h += 1, d && (s = ii(I) * E + C, l = ai(I) * D + T), g = bc(E, D) * wc(Cn, Math.abs(L)), a = ii(N) * E + C, o = ai(N) * D + T;
          break;
        case _e.R: {
          s = a = e[h++], l = o = e[h++];
          var P = e[h++], R = e[h++];
          g = P * 2 + R * 2;
          break;
        }
        case _e.Z: {
          var y = s - a, _ = l - o;
          g = Math.sqrt(y * y + _ * _), a = s, o = l;
          break;
        }
      }
      g >= 0 && (u[c++] = g, f += g);
    }
    return this._pathLen = f, f;
  }, r.prototype.rebuildPath = function(e, t) {
    var n = this.data, i = this._ux, a = this._uy, o = this._len, s, l, u, f, c, h, v = t < 1, d, g, p = 0, m = 0, y, _ = 0, S, b;
    if (!(v && (this._pathSegLen || this._calculateLength(), d = this._pathSegLen, g = this._pathLen, y = t * g, !y)))
      e:
        for (var w = 0; w < o; ) {
          var x = n[w++], C = w === 1;
          switch (C && (u = n[w], f = n[w + 1], s = u, l = f), x !== _e.L && _ > 0 && (e.lineTo(S, b), _ = 0), x) {
            case _e.M:
              s = u = n[w++], l = f = n[w++], e.moveTo(u, f);
              break;
            case _e.L: {
              c = n[w++], h = n[w++];
              var T = Or(c - u), E = Or(h - f);
              if (T > i || E > a) {
                if (v) {
                  var D = d[m++];
                  if (p + D > y) {
                    var I = (y - p) / D;
                    e.lineTo(u * (1 - I) + c * I, f * (1 - I) + h * I);
                    break e;
                  }
                  p += D;
                }
                e.lineTo(c, h), u = c, f = h, _ = 0;
              } else {
                var L = T * T + E * E;
                L > _ && (S = c, b = h, _ = L);
              }
              break;
            }
            case _e.C: {
              var N = n[w++], P = n[w++], R = n[w++], z = n[w++], O = n[w++], B = n[w++];
              if (v) {
                var D = d[m++];
                if (p + D > y) {
                  var I = (y - p) / D;
                  Hn(u, N, R, O, I, ri), Hn(f, P, z, B, I, ni), e.bezierCurveTo(ri[1], ni[1], ri[2], ni[2], ri[3], ni[3]);
                  break e;
                }
                p += D;
              }
              e.bezierCurveTo(N, P, R, z, O, B), u = O, f = B;
              break;
            }
            case _e.Q: {
              var N = n[w++], P = n[w++], R = n[w++], z = n[w++];
              if (v) {
                var D = d[m++];
                if (p + D > y) {
                  var I = (y - p) / D;
                  os(u, N, R, I, ri), os(f, P, z, I, ni), e.quadraticCurveTo(ri[1], ni[1], ri[2], ni[2]);
                  break e;
                }
                p += D;
              }
              e.quadraticCurveTo(N, P, R, z), u = R, f = z;
              break;
            }
            case _e.A:
              var H = n[w++], q = n[w++], Q = n[w++], le = n[w++], ge = n[w++], Re = n[w++], Ce = n[w++], je = !n[w++], Je = Q > le ? Q : le, Fe = Or(Q - le) > 1e-3, Ee = ge + Re, J = !1;
              if (v) {
                var D = d[m++];
                p + D > y && (Ee = ge + Re * (y - p) / D, J = !0), p += D;
              }
              if (Fe && e.ellipse ? e.ellipse(H, q, Q, le, Ce, ge, Ee, je) : e.arc(H, q, Je, ge, Ee, je), J)
                break e;
              C && (s = ii(ge) * Q + H, l = ai(ge) * le + q), u = ii(Ee) * Q + H, f = ai(Ee) * le + q;
              break;
            case _e.R:
              s = u = n[w], l = f = n[w + 1], c = n[w++], h = n[w++];
              var ce = n[w++], pr = n[w++];
              if (v) {
                var D = d[m++];
                if (p + D > y) {
                  var $e = y - p;
                  e.moveTo(c, h), e.lineTo(c + wc($e, ce), h), $e -= ce, $e > 0 && e.lineTo(c + ce, h + wc($e, pr)), $e -= pr, $e > 0 && e.lineTo(c + bc(ce - $e, 0), h + pr), $e -= ce, $e > 0 && e.lineTo(c, h + bc(pr - $e, 0));
                  break e;
                }
                p += D;
              }
              e.rect(c, h, ce, pr);
              break;
            case _e.Z:
              if (v) {
                var D = d[m++];
                if (p + D > y) {
                  var I = (y - p) / D;
                  e.lineTo(u * (1 - I) + s * I, f * (1 - I) + l * I);
                  break e;
                }
                p += D;
              }
              e.closePath(), u = s, f = l;
          }
        }
  }, r.prototype.clone = function() {
    var e = new r(), t = this.data;
    return e.data = t.slice ? t.slice() : Array.prototype.slice.call(t), e._len = this._len, e;
  }, r.CMD = _e, r.initDefaultProps = function() {
    var e = r.prototype;
    e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
  }(), r;
}();
function Mn(r, e, t, n, i, a, o) {
  if (i === 0)
    return !1;
  var s = i, l = 0, u = r;
  if (o > e + s && o > n + s || o < e - s && o < n - s || a > r + s && a > t + s || a < r - s && a < t - s)
    return !1;
  if (r !== t)
    l = (e - n) / (r - t), u = (r * n - t * e) / (r - t);
  else
    return Math.abs(a - r) <= s / 2;
  var f = l * a - o + u, c = f * f / (l * l + 1);
  return c <= s / 2 * s / 2;
}
function lT(r, e, t, n, i, a, o, s, l, u, f) {
  if (l === 0)
    return !1;
  var c = l;
  if (f > e + c && f > n + c && f > a + c && f > s + c || f < e - c && f < n - c && f < a - c && f < s - c || u > r + c && u > t + c && u > i + c && u > o + c || u < r - c && u < t - c && u < i - c && u < o - c)
    return !1;
  var h = P3(r, e, t, n, i, a, o, s, u, f, null);
  return h <= c / 2;
}
function u_(r, e, t, n, i, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  if (l > e + u && l > n + u && l > a + u || l < e - u && l < n - u && l < a - u || s > r + u && s > t + u && s > i + u || s < r - u && s < t - u && s < i - u)
    return !1;
  var f = O3(r, e, t, n, i, a, s, l, null);
  return f <= u / 2;
}
var cg = Math.PI * 2;
function Gr(r) {
  return r %= cg, r < 0 && (r += cg), r;
}
var oo = Math.PI * 2;
function uT(r, e, t, n, i, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  s -= r, l -= e;
  var f = Math.sqrt(s * s + l * l);
  if (f - u > t || f + u < t)
    return !1;
  if (Math.abs(n - i) % oo < 1e-4)
    return !0;
  if (a) {
    var c = n;
    n = Gr(i), i = Gr(c);
  } else
    n = Gr(n), i = Gr(i);
  n > i && (i += oo);
  var h = Math.atan2(l, s);
  return h < 0 && (h += oo), h >= n && h <= i || h + oo >= n && h + oo <= i;
}
function Br(r, e, t, n, i, a) {
  if (a > e && a > n || a < e && a < n || n === e)
    return 0;
  var o = (a - e) / (n - e), s = n < e ? 1 : -1;
  (o === 1 || o === 0) && (s = n < e ? 0.5 : -0.5);
  var l = o * (t - r) + r;
  return l === i ? 1 / 0 : l > i ? s : 0;
}
var gn = tn.CMD, oi = Math.PI * 2, fT = 1e-4;
function cT(r, e) {
  return Math.abs(r - e) < fT;
}
var lt = [-1, -1, -1], $t = [-1, -1];
function hT() {
  var r = $t[0];
  $t[0] = $t[1], $t[1] = r;
}
function vT(r, e, t, n, i, a, o, s, l, u) {
  if (u > e && u > n && u > a && u > s || u < e && u < n && u < a && u < s)
    return 0;
  var f = fu(e, n, a, s, u, lt);
  if (f === 0)
    return 0;
  for (var c = 0, h = -1, v = void 0, d = void 0, g = 0; g < f; g++) {
    var p = lt[g], m = p === 0 || p === 1 ? 0.5 : 1, y = ze(r, t, i, o, p);
    y < l || (h < 0 && (h = N3(e, n, a, s, $t), $t[1] < $t[0] && h > 1 && hT(), v = ze(e, n, a, s, $t[0]), h > 1 && (d = ze(e, n, a, s, $t[1]))), h === 2 ? p < $t[0] ? c += v < e ? m : -m : p < $t[1] ? c += d < v ? m : -m : c += s < d ? m : -m : p < $t[0] ? c += v < e ? m : -m : c += s < v ? m : -m);
  }
  return c;
}
function dT(r, e, t, n, i, a, o, s) {
  if (s > e && s > n && s > a || s < e && s < n && s < a)
    return 0;
  var l = E7(e, n, a, s, lt);
  if (l === 0)
    return 0;
  var u = R3(e, n, a);
  if (u >= 0 && u <= 1) {
    for (var f = 0, c = We(e, n, a, u), h = 0; h < l; h++) {
      var v = lt[h] === 0 || lt[h] === 1 ? 0.5 : 1, d = We(r, t, i, lt[h]);
      d < o || (lt[h] < u ? f += c < e ? v : -v : f += a < c ? v : -v);
    }
    return f;
  } else {
    var v = lt[0] === 0 || lt[0] === 1 ? 0.5 : 1, d = We(r, t, i, lt[0]);
    return d < o ? 0 : a < e ? v : -v;
  }
}
function pT(r, e, t, n, i, a, o, s) {
  if (s -= e, s > t || s < -t)
    return 0;
  var l = Math.sqrt(t * t - s * s);
  lt[0] = -l, lt[1] = l;
  var u = Math.abs(n - i);
  if (u < 1e-4)
    return 0;
  if (u >= oi - 1e-4) {
    n = 0, i = oi;
    var f = a ? 1 : -1;
    return o >= lt[0] + r && o <= lt[1] + r ? f : 0;
  }
  if (n > i) {
    var c = n;
    n = i, i = c;
  }
  n < 0 && (n += oi, i += oi);
  for (var h = 0, v = 0; v < 2; v++) {
    var d = lt[v];
    if (d + r > o) {
      var g = Math.atan2(s, d), f = a ? 1 : -1;
      g < 0 && (g = oi + g), (g >= n && g <= i || g + oi >= n && g + oi <= i) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (f = -f), h += f);
    }
  }
  return h;
}
function f_(r, e, t, n, i) {
  for (var a = r.data, o = r.len(), s = 0, l = 0, u = 0, f = 0, c = 0, h, v, d = 0; d < o; ) {
    var g = a[d++], p = d === 1;
    switch (g === gn.M && d > 1 && (t || (s += Br(l, u, f, c, n, i))), p && (l = a[d], u = a[d + 1], f = l, c = u), g) {
      case gn.M:
        f = a[d++], c = a[d++], l = f, u = c;
        break;
      case gn.L:
        if (t) {
          if (Mn(l, u, a[d], a[d + 1], e, n, i))
            return !0;
        } else
          s += Br(l, u, a[d], a[d + 1], n, i) || 0;
        l = a[d++], u = a[d++];
        break;
      case gn.C:
        if (t) {
          if (lT(l, u, a[d++], a[d++], a[d++], a[d++], a[d], a[d + 1], e, n, i))
            return !0;
        } else
          s += vT(l, u, a[d++], a[d++], a[d++], a[d++], a[d], a[d + 1], n, i) || 0;
        l = a[d++], u = a[d++];
        break;
      case gn.Q:
        if (t) {
          if (u_(l, u, a[d++], a[d++], a[d], a[d + 1], e, n, i))
            return !0;
        } else
          s += dT(l, u, a[d++], a[d++], a[d], a[d + 1], n, i) || 0;
        l = a[d++], u = a[d++];
        break;
      case gn.A:
        var m = a[d++], y = a[d++], _ = a[d++], S = a[d++], b = a[d++], w = a[d++];
        d += 1;
        var x = !!(1 - a[d++]);
        h = Math.cos(b) * _ + m, v = Math.sin(b) * S + y, p ? (f = h, c = v) : s += Br(l, u, h, v, n, i);
        var C = (n - m) * S / _ + m;
        if (t) {
          if (uT(m, y, S, b, b + w, x, e, C, i))
            return !0;
        } else
          s += pT(m, y, S, b, b + w, x, C, i);
        l = Math.cos(b + w) * _ + m, u = Math.sin(b + w) * S + y;
        break;
      case gn.R:
        f = l = a[d++], c = u = a[d++];
        var T = a[d++], E = a[d++];
        if (h = f + T, v = c + E, t) {
          if (Mn(f, c, h, c, e, n, i) || Mn(h, c, h, v, e, n, i) || Mn(h, v, f, v, e, n, i) || Mn(f, v, f, c, e, n, i))
            return !0;
        } else
          s += Br(h, c, h, v, n, i), s += Br(f, v, f, c, n, i);
        break;
      case gn.Z:
        if (t) {
          if (Mn(l, u, f, c, e, n, i))
            return !0;
        } else
          s += Br(l, u, f, c, n, i);
        l = f, u = c;
        break;
    }
  }
  return !t && !cT(u, c) && (s += Br(l, u, f, c, n, i) || 0), s !== 0;
}
function gT(r, e, t) {
  return f_(r, 0, !1, e, t);
}
function mT(r, e, t, n) {
  return f_(r, e, !0, t, n);
}
var c_ = dist_se({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, Li), yT = {
  style: dist_se({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, uf.style)
}, Tc = ls.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), _T = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.update = function() {
    var t = this;
    r.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var i = this._decalEl = this._decalEl || new e();
      i.buildPath === e.prototype.buildPath && (i.buildPath = function(l) {
        t.buildPath(l, t.shape);
      }), i.silent = !0;
      var a = i.style;
      for (var o in n)
        a[o] !== n[o] && (a[o] = n[o]);
      a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
      for (var s = 0; s < Tc.length; ++s)
        i[Tc[s]] = this[Tc[s]];
      i.__dirty |= Et;
    } else
      this._decalEl && (this._decalEl = null);
  }, e.prototype.getDecalElement = function() {
    return this._decalEl;
  }, e.prototype._init = function(t) {
    var n = we(t);
    this.shape = this.getDefaultShape();
    var i = this.getDefaultStyle();
    i && this.useStyle(i);
    for (var a = 0; a < n.length; a++) {
      var o = n[a], s = t[o];
      o === "style" ? this.style ? dist_V(this.style, s) : this.useStyle(s) : o === "shape" ? dist_V(this.shape, s) : r.prototype.attrKV.call(this, o, s);
    }
    this.style || this.useStyle({});
  }, e.prototype.getDefaultStyle = function() {
    return null;
  }, e.prototype.getDefaultShape = function() {
    return {};
  }, e.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, e.prototype.getInsideTextFill = function() {
    var t = this.style.fill;
    if (t !== "none") {
      if (dist_U(t)) {
        var n = cu(t, 0);
        return n > 0.5 ? vv : n > 0.2 ? eC : dv;
      } else if (t)
        return dv;
    }
    return vv;
  }, e.prototype.getInsideTextStroke = function(t) {
    var n = this.style.fill;
    if (dist_U(n)) {
      var i = this.__zr, a = !!(i && i.isDarkMode()), o = cu(t, 0) < hv;
      if (a === o)
        return n;
    }
  }, e.prototype.buildPath = function(t, n, i) {
  }, e.prototype.pathUpdated = function() {
    this.__dirty &= ~ma;
  }, e.prototype.getUpdatedPathProxy = function(t) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path;
  }, e.prototype.createPathProxy = function() {
    this.path = new tn(!1);
  }, e.prototype.hasStroke = function() {
    var t = this.style, n = t.stroke;
    return !(n == null || n === "none" || !(t.lineWidth > 0));
  }, e.prototype.hasFill = function() {
    var t = this.style, n = t.fill;
    return n != null && n !== "none";
  }, e.prototype.getBoundingRect = function() {
    var t = this._rect, n = this.style, i = !t;
    if (i) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var o = this.path;
      (a || this.__dirty & ma) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), t = o.getBoundingRect();
    }
    if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = t.clone());
      if (this.__dirty || i) {
        s.copy(t);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var f = this.strokeContainThreshold;
          u = Math.max(u, f ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return t;
  }, e.prototype.contain = function(t, n) {
    var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect(), o = this.style;
    if (t = i[0], n = i[1], a.contain(t, n)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), mT(s, l / u, t, n)))
          return !0;
      }
      if (this.hasFill())
        return gT(s, t, n);
    }
    return !1;
  }, e.prototype.dirtyShape = function() {
    this.__dirty |= ma, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, e.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, e.prototype.animateShape = function(t) {
    return this.animate("shape", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw();
  }, e.prototype.attrKV = function(t, n) {
    t === "shape" ? this.setShape(n) : r.prototype.attrKV.call(this, t, n);
  }, e.prototype.setShape = function(t, n) {
    var i = this.shape;
    return i || (i = this.shape = {}), typeof t == "string" ? i[t] = n : dist_V(i, t), this.dirtyShape(), this;
  }, e.prototype.shapeChanged = function() {
    return !!(this.__dirty & ma);
  }, e.prototype.createStyle = function(t) {
    return tf(c_, t);
  }, e.prototype._innerSaveToNormal = function(t) {
    r.prototype._innerSaveToNormal.call(this, t);
    var n = this._normalState;
    t.shape && !n.shape && (n.shape = dist_V({}, this.shape));
  }, e.prototype._applyStateObj = function(t, n, i, a, o, s) {
    r.prototype._applyStateObj.call(this, t, n, i, a, o, s);
    var l = !(n && a), u;
    if (n && n.shape ? o ? a ? u = n.shape : (u = dist_V({}, i.shape), dist_V(u, n.shape)) : (u = dist_V({}, a ? this.shape : i.shape), dist_V(u, n.shape)) : l && (u = i.shape), u)
      if (o) {
        this.shape = dist_V({}, this.shape);
        for (var f = {}, c = we(u), h = 0; h < c.length; h++) {
          var v = c[h];
          typeof u[v] == "object" ? this.shape[v] = u[v] : f[v] = u[v];
        }
        this._transitionState(t, {
          shape: f
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, e.prototype._mergeStates = function(t) {
    for (var n = r.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) {
      var o = t[a];
      o.shape && (i = i || {}, this._mergeStyle(i, o.shape));
    }
    return i && (n.shape = i), n;
  }, e.prototype.getAnimationStyleProps = function() {
    return yT;
  }, e.prototype.isZeroArea = function() {
    return !1;
  }, e.extend = function(t) {
    var n = function(a) {
      dist_k(o, a);
      function o(s) {
        var l = a.call(this, s) || this;
        return t.init && t.init.call(l, s), l;
      }
      return o.prototype.getDefaultStyle = function() {
        return dist_te(t.style);
      }, o.prototype.getDefaultShape = function() {
        return dist_te(t.shape);
      }, o;
    }(e);
    for (var i in t)
      typeof t[i] == "function" && (n.prototype[i] = t[i]);
    return n;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = !1, t.autoBatch = !1, t.__dirty = Et | Do | ma;
  }(), e;
}(Wn);
const fe = _T;
var ST = dist_se({
  strokeFirst: !0,
  font: ki,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, c_), h_ = function(r) {
  dist_k(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.hasStroke = function() {
    var t = this.style, n = t.stroke;
    return n != null && n !== "none" && t.lineWidth > 0;
  }, e.prototype.hasFill = function() {
    var t = this.style, n = t.fill;
    return n != null && n !== "none";
  }, e.prototype.createStyle = function(t) {
    return tf(ST, t);
  }, e.prototype.setBoundingRect = function(t) {
    this._rect = t;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    if (!this._rect) {
      var n = t.text;
      n != null ? n += "" : n = "";
      var i = Md(n, t.font, t.textAlign, t.textBaseline);
      if (i.x += t.x || 0, i.y += t.y || 0, this.hasStroke()) {
        var a = t.lineWidth;
        i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a;
      }
      this._rect = i;
    }
    return this._rect;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.dirtyRectTolerance = 10;
  }(), e;
}(Wn);
h_.prototype.type = "tspan";
const pu = h_;
var wT = dist_se({
  x: 0,
  y: 0
}, Li), bT = {
  style: dist_se({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, uf.style)
};
function xT(r) {
  return !!(r && typeof r != "string" && r.width && r.height);
}
var v_ = function(r) {
  dist_k(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.createStyle = function(t) {
    return tf(wT, t);
  }, e.prototype._getSize = function(t) {
    var n = this.style, i = n[t];
    if (i != null)
      return i;
    var a = xT(n.image) ? n.image : this.__image;
    if (!a)
      return 0;
    var o = t === "width" ? "height" : "width", s = n[o];
    return s == null ? a[t] : a[t] / a[o] * s;
  }, e.prototype.getWidth = function() {
    return this._getSize("width");
  }, e.prototype.getHeight = function() {
    return this._getSize("height");
  }, e.prototype.getAnimationStyleProps = function() {
    return bT;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    return this._rect || (this._rect = new dist_ae(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, e;
}(Wn);
v_.prototype.type = "image";
const un = v_;
function CT(r, e) {
  var t = e.x, n = e.y, i = e.width, a = e.height, o = e.r, s, l, u, f;
  i < 0 && (t = t + i, i = -i), a < 0 && (n = n + a, a = -a), typeof o == "number" ? s = l = u = f = o : o instanceof Array ? o.length === 1 ? s = l = u = f = o[0] : o.length === 2 ? (s = u = o[0], l = f = o[1]) : o.length === 3 ? (s = o[0], l = f = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], f = o[3]) : s = l = u = f = 0;
  var c;
  s + l > i && (c = s + l, s *= i / c, l *= i / c), u + f > i && (c = u + f, u *= i / c, f *= i / c), l + u > a && (c = l + u, l *= a / c, u *= a / c), s + f > a && (c = s + f, s *= a / c, f *= a / c), r.moveTo(t + s, n), r.lineTo(t + i - l, n), l !== 0 && r.arc(t + i - l, n + l, l, -Math.PI / 2, 0), r.lineTo(t + i, n + a - u), u !== 0 && r.arc(t + i - u, n + a - u, u, 0, Math.PI / 2), r.lineTo(t + f, n + a), f !== 0 && r.arc(t + f, n + a - f, f, Math.PI / 2, Math.PI), r.lineTo(t, n + s), s !== 0 && r.arc(t + s, n + s, s, Math.PI, Math.PI * 1.5);
}
var wa = Math.round;
function d_(r, e, t) {
  if (e) {
    var n = e.x1, i = e.x2, a = e.y1, o = e.y2;
    r.x1 = n, r.x2 = i, r.y1 = a, r.y2 = o;
    var s = t && t.lineWidth;
    return s && (wa(n * 2) === wa(i * 2) && (r.x1 = r.x2 = Ci(n, s, !0)), wa(a * 2) === wa(o * 2) && (r.y1 = r.y2 = Ci(a, s, !0))), r;
  }
}
function p_(r, e, t) {
  if (e) {
    var n = e.x, i = e.y, a = e.width, o = e.height;
    r.x = n, r.y = i, r.width = a, r.height = o;
    var s = t && t.lineWidth;
    return s && (r.x = Ci(n, s, !0), r.y = Ci(i, s, !0), r.width = Math.max(Ci(n + a, s, !1) - r.x, a === 0 ? 0 : 1), r.height = Math.max(Ci(i + o, s, !1) - r.y, o === 0 ? 0 : 1)), r;
  }
}
function Ci(r, e, t) {
  if (!e)
    return r;
  var n = wa(r * 2);
  return (n + wa(e)) % 2 === 0 ? n / 2 : (n + (t ? 1 : -1)) / 2;
}
var TT = /* @__PURE__ */ function() {
  function r() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return r;
}(), MT = {}, g_ = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new TT();
  }, e.prototype.buildPath = function(t, n) {
    var i, a, o, s;
    if (this.subPixelOptimize) {
      var l = p_(MT, n, this.style);
      i = l.x, a = l.y, o = l.width, s = l.height, l.r = n.r, n = l;
    } else
      i = n.x, a = n.y, o = n.width, s = n.height;
    n.r ? CT(t, n) : t.rect(i, a, o, s);
  }, e.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, e;
}(fe);
g_.prototype.type = "rect";
const xe = g_;
var hg = {
  fill: "#000"
}, vg = 2, DT = {
  style: dist_se({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, uf.style)
}, m_ = function(r) {
  dist_k(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = hg, n.attr(t), n;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.update = function() {
    r.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var t = 0; t < this._children.length; t++) {
      var n = this._children[t];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, e.prototype.updateTransform = function() {
    var t = this.innerTransformable;
    t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : r.prototype.updateTransform.call(this);
  }, e.prototype.getLocalTransform = function(t) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(t) : r.prototype.getLocalTransform.call(this, t);
  }, e.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), r.prototype.getComputedTransform.call(this);
  }, e.prototype._updateSubTexts = function() {
    this._childCursor = 0, NT(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, e.prototype.addSelfToZr = function(t) {
    r.prototype.addSelfToZr.call(this, t);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = t;
  }, e.prototype.removeSelfFromZr = function(t) {
    r.prototype.removeSelfFromZr.call(this, t);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, e.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var t = new dist_ae(0, 0, 0, 0), n = this._children, i = [], a = null, o = 0; o < n.length; o++) {
        var s = n[o], l = s.getBoundingRect(), u = s.getLocalTransform(i);
        u ? (t.copy(l), t.applyTransform(u), a = a || t.clone(), a.union(t)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || t;
    }
    return this._rect;
  }, e.prototype.setDefaultTextStyle = function(t) {
    this._defaultStyle = t || hg;
  }, e.prototype.setTextContent = function(t) {
    if (false)
      {}
  }, e.prototype._mergeStyle = function(t, n) {
    if (!n)
      return t;
    var i = n.rich, a = t.rich || i && {};
    return dist_V(t, n), i && a ? (this._mergeRich(a, i), t.rich = a) : a && (t.rich = a), t;
  }, e.prototype._mergeRich = function(t, n) {
    for (var i = we(n), a = 0; a < i.length; a++) {
      var o = i[a];
      t[o] = t[o] || {}, dist_V(t[o], n[o]);
    }
  }, e.prototype.getAnimationStyleProps = function() {
    return DT;
  }, e.prototype._getOrCreateChild = function(t) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof t)) && (n = new t()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, e.prototype._updatePlainTexts = function() {
    var t = this.style, n = t.font || ki, i = t.padding, a = Sg(t), o = qC(a, t), s = Mc(t), l = !!t.backgroundColor, u = o.outerHeight, f = o.outerWidth, c = o.contentWidth, h = o.lines, v = o.lineHeight, d = this._defaultStyle, g = t.x || 0, p = t.y || 0, m = t.align || d.align || "left", y = t.verticalAlign || d.verticalAlign || "top", _ = g, S = ya(p, o.contentHeight, y);
    if (s || i) {
      var b = Ao(g, f, m), w = ya(p, u, y);
      s && this._renderBackground(t, t, b, w, f, u);
    }
    S += v / 2, i && (_ = _g(g, m, i), y === "top" ? S += i[0] : y === "bottom" && (S -= i[2]));
    for (var x = 0, C = !1, T = yg("fill" in t ? t.fill : (C = !0, d.fill)), E = mg("stroke" in t ? t.stroke : !l && (!d.autoStroke || C) ? (x = vg, d.stroke) : null), D = t.textShadowBlur > 0, I = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), L = o.calculatedLineHeight, N = 0; N < h.length; N++) {
      var P = this._getOrCreateChild(pu), R = P.createStyle();
      P.useStyle(R), R.text = h[N], R.x = _, R.y = S, m && (R.textAlign = m), R.textBaseline = "middle", R.opacity = t.opacity, R.strokeFirst = !0, D && (R.shadowBlur = t.textShadowBlur || 0, R.shadowColor = t.textShadowColor || "transparent", R.shadowOffsetX = t.textShadowOffsetX || 0, R.shadowOffsetY = t.textShadowOffsetY || 0), R.stroke = E, R.fill = T, E && (R.lineWidth = t.lineWidth || x, R.lineDash = t.lineDash, R.lineDashOffset = t.lineDashOffset || 0), R.font = n, pg(R, t), S += v, I && P.setBoundingRect(new dist_ae(Ao(R.x, t.width, R.textAlign), ya(R.y, L, R.textBaseline), c, L));
    }
  }, e.prototype._updateRichTexts = function() {
    var t = this.style, n = Sg(t), i = JC(n, t), a = i.width, o = i.outerWidth, s = i.outerHeight, l = t.padding, u = t.x || 0, f = t.y || 0, c = this._defaultStyle, h = t.align || c.align, v = t.verticalAlign || c.verticalAlign, d = Ao(u, o, h), g = ya(f, s, v), p = d, m = g;
    l && (p += l[3], m += l[0]);
    var y = p + a;
    Mc(t) && this._renderBackground(t, t, d, g, o, s);
    for (var _ = !!t.backgroundColor, S = 0; S < i.lines.length; S++) {
      for (var b = i.lines[S], w = b.tokens, x = w.length, C = b.lineHeight, T = b.width, E = 0, D = p, I = y, L = x - 1, N = void 0; E < x && (N = w[E], !N.align || N.align === "left"); )
        this._placeToken(N, t, C, m, D, "left", _), T -= N.width, D += N.width, E++;
      for (; L >= 0 && (N = w[L], N.align === "right"); )
        this._placeToken(N, t, C, m, I, "right", _), T -= N.width, I -= N.width, L--;
      for (D += (a - (D - p) - (y - I) - T) / 2; E <= L; )
        N = w[E], this._placeToken(N, t, C, m, D + N.width / 2, "center", _), D += N.width, E++;
      m += C;
    }
  }, e.prototype._placeToken = function(t, n, i, a, o, s, l) {
    var u = n.rich[t.styleName] || {};
    u.text = t.text;
    var f = t.verticalAlign, c = a + i / 2;
    f === "top" ? c = a + t.height / 2 : f === "bottom" && (c = a + i - t.height / 2);
    var h = !t.isLineHolder && Mc(u);
    h && this._renderBackground(u, n, s === "right" ? o - t.width : s === "center" ? o - t.width / 2 : o, c - t.height / 2, t.width, t.height);
    var v = !!u.backgroundColor, d = t.textPadding;
    d && (o = _g(o, s, d), c -= t.height / 2 - d[0] - t.innerHeight / 2);
    var g = this._getOrCreateChild(pu), p = g.createStyle();
    g.useStyle(p);
    var m = this._defaultStyle, y = !1, _ = 0, S = yg("fill" in u ? u.fill : "fill" in n ? n.fill : (y = !0, m.fill)), b = mg("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !v && !l && (!m.autoStroke || y) ? (_ = vg, m.stroke) : null), w = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    p.text = t.text, p.x = o, p.y = c, w && (p.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, p.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", p.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, p.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), p.textAlign = s, p.textBaseline = "middle", p.font = t.font || ki, p.opacity = Dr(u.opacity, n.opacity, 1), pg(p, u), b && (p.lineWidth = Dr(u.lineWidth, n.lineWidth, _), p.lineDash = dist_ne(u.lineDash, n.lineDash), p.lineDashOffset = n.lineDashOffset || 0, p.stroke = b), S && (p.fill = S);
    var x = t.contentWidth, C = t.contentHeight;
    g.setBoundingRect(new dist_ae(Ao(p.x, x, p.textAlign), ya(p.y, C, p.textBaseline), x, C));
  }, e.prototype._renderBackground = function(t, n, i, a, o, s) {
    var l = t.backgroundColor, u = t.borderWidth, f = t.borderColor, c = l && l.image, h = l && !c, v = t.borderRadius, d = this, g, p;
    if (h || t.lineHeight || u && f) {
      g = this._getOrCreateChild(xe), g.useStyle(g.createStyle()), g.style.fill = null;
      var m = g.shape;
      m.x = i, m.y = a, m.width = o, m.height = s, m.r = v, g.dirtyShape();
    }
    if (h) {
      var y = g.style;
      y.fill = l || null, y.fillOpacity = dist_ne(t.fillOpacity, 1);
    } else if (c) {
      p = this._getOrCreateChild(un), p.onload = function() {
        d.dirtyStyle();
      };
      var _ = p.style;
      _.image = l.image, _.x = i, _.y = a, _.width = o, _.height = s;
    }
    if (u && f) {
      var y = g.style;
      y.lineWidth = u, y.stroke = f, y.strokeOpacity = dist_ne(t.strokeOpacity, 1), y.lineDash = t.borderDash, y.lineDashOffset = t.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var S = (g || p).style;
    S.shadowBlur = t.shadowBlur || 0, S.shadowColor = t.shadowColor || "transparent", S.shadowOffsetX = t.shadowOffsetX || 0, S.shadowOffsetY = t.shadowOffsetY || 0, S.opacity = Dr(t.opacity, n.opacity, 1);
  }, e.makeFont = function(t) {
    var n = "";
    return LT(t) && (n = [
      t.fontStyle,
      t.fontWeight,
      IT(t.fontSize),
      t.fontFamily || "sans-serif"
    ].join(" ")), n && or(n) || t.textFont || t.font;
  }, e;
}(Wn), ET = { left: !0, right: 1, center: 1 }, AT = { top: 1, bottom: 1, middle: 1 }, dg = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function IT(r) {
  return typeof r == "string" && (r.indexOf("px") !== -1 || r.indexOf("rem") !== -1 || r.indexOf("em") !== -1) ? r : isNaN(+r) ? _d + "px" : r + "px";
}
function pg(r, e) {
  for (var t = 0; t < dg.length; t++) {
    var n = dg[t], i = e[n];
    i != null && (r[n] = i);
  }
}
function LT(r) {
  return r.fontSize != null || r.fontFamily || r.fontWeight;
}
function NT(r) {
  return gg(r), dist_M(r.rich, gg), r;
}
function gg(r) {
  if (r) {
    r.font = m_.makeFont(r);
    var e = r.align;
    e === "middle" && (e = "center"), r.align = e == null || ET[e] ? e : "left";
    var t = r.verticalAlign;
    t === "center" && (t = "middle"), r.verticalAlign = t == null || AT[t] ? t : "top";
    var n = r.padding;
    n && (r.padding = _3(r.padding));
  }
}
function mg(r, e) {
  return r == null || e <= 0 || r === "transparent" || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function yg(r) {
  return r == null || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function _g(r, e, t) {
  return e === "right" ? r - t[1] : e === "center" ? r + t[3] / 2 - t[1] / 2 : r + t[3];
}
function Sg(r) {
  var e = r.text;
  return e != null && (e += ""), e;
}
function Mc(r) {
  return !!(r.backgroundColor || r.lineHeight || r.borderWidth && r.borderColor);
}
const Ne = m_;
var dist_ie = Me(), PT = function(r, e, t, n) {
  if (n) {
    var i = dist_ie(n);
    i.dataIndex = t, i.dataType = e, i.seriesIndex = r, i.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
      var o = dist_ie(a);
      o.seriesIndex = r, o.dataIndex = t, o.dataType = e, o.ssrType = "chart";
    });
  }
}, wg = 1, bg = {}, y_ = Me(), Pd = Me(), Rd = 0, ff = 1, cf = 2, Ct = ["emphasis", "blur", "select"], gu = ["normal", "emphasis", "blur", "select"], __ = 10, RT = 9, Ni = "highlight", Xl = "downplay", Go = "select", Zl = "unselect", Ho = "toggleSelect";
function Ji(r) {
  return r != null && r !== "none";
}
function hf(r, e, t) {
  r.onHoverStateChange && (r.hoverState || 0) !== t && r.onHoverStateChange(e), r.hoverState = t;
}
function S_(r) {
  hf(r, "emphasis", cf);
}
function w_(r) {
  r.hoverState === cf && hf(r, "normal", Rd);
}
function Od(r) {
  hf(r, "blur", ff);
}
function b_(r) {
  r.hoverState === ff && hf(r, "normal", Rd);
}
function OT(r) {
  r.selected = !0;
}
function kT(r) {
  r.selected = !1;
}
function xg(r, e, t) {
  e(r, t);
}
function fn(r, e, t) {
  xg(r, e, t), r.isGroup && r.traverse(function(n) {
    xg(n, e, t);
  });
}
function _v(r, e) {
  switch (e) {
    case "emphasis":
      r.hoverState = cf;
      break;
    case "normal":
      r.hoverState = Rd;
      break;
    case "blur":
      r.hoverState = ff;
      break;
    case "select":
      r.selected = !0;
  }
}
function VT(r, e, t, n) {
  for (var i = r.style, a = {}, o = 0; o < e.length; o++) {
    var s = e[o], l = i[s];
    a[s] = l ?? (n && n[s]);
  }
  for (var o = 0; o < r.animators.length; o++) {
    var u = r.animators[o];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(t) < 0 && u.targetName === "style" && u.saveTo(a, e);
  }
  return a;
}
function BT(r, e, t, n) {
  var i = t && ye(t, "select") >= 0, a = !1;
  if (r instanceof fe) {
    var o = y_(r), s = i && o.selectFill || o.normalFill, l = i && o.selectStroke || o.normalStroke;
    if (Ji(s) || Ji(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (a = !0, n = dist_V({}, n), u = dist_V({}, u), u.fill = s) : !Ji(u.fill) && Ji(s) ? (a = !0, n = dist_V({}, n), u = dist_V({}, u), u.fill = Fp(s)) : !Ji(u.stroke) && Ji(l) && (a || (n = dist_V({}, n), u = dist_V({}, u)), u.stroke = Fp(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    a || (n = dist_V({}, n));
    var f = r.z2EmphasisLift;
    n.z2 = r.z2 + (f ?? __);
  }
  return n;
}
function FT(r, e, t) {
  if (t && t.z2 == null) {
    t = dist_V({}, t);
    var n = r.z2SelectLift;
    t.z2 = r.z2 + (n ?? RT);
  }
  return t;
}
function zT(r, e, t) {
  var n = ye(r.currentStates, e) >= 0, i = r.style.opacity, a = n ? null : VT(r, ["opacity"], e, {
    opacity: 1
  });
  t = t || {};
  var o = t.style || {};
  return o.opacity == null && (t = dist_V({}, t), o = dist_V({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? i : a.opacity * 0.1
  }, o), t.style = o), t;
}
function Dc(r, e) {
  var t = this.states[r];
  if (this.style) {
    if (r === "emphasis")
      return BT(this, r, e, t);
    if (r === "blur")
      return zT(this, r, t);
    if (r === "select")
      return FT(this, r, t);
  }
  return t;
}
function kd(r) {
  r.stateProxy = Dc;
  var e = r.getTextContent(), t = r.getTextGuideLine();
  e && (e.stateProxy = Dc), t && (t.stateProxy = Dc);
}
function Cg(r, e) {
  !M_(r, e) && !r.__highByOuter && fn(r, S_);
}
function Tg(r, e) {
  !M_(r, e) && !r.__highByOuter && fn(r, w_);
}
function Pa(r, e) {
  r.__highByOuter |= 1 << (e || 0), fn(r, S_);
}
function Ra(r, e) {
  !(r.__highByOuter &= ~(1 << (e || 0))) && fn(r, w_);
}
function GT(r) {
  fn(r, Od);
}
function x_(r) {
  fn(r, b_);
}
function C_(r) {
  fn(r, OT);
}
function T_(r) {
  fn(r, kT);
}
function M_(r, e) {
  return r.__highDownSilentOnTouch && e.zrByTouch;
}
function D_(r) {
  var e = r.getModel(), t = [], n = [];
  e.eachComponent(function(i, a) {
    var o = Pd(a), s = i === "series", l = s ? r.getViewOfSeriesModel(a) : r.getViewOfComponentModel(a);
    !s && n.push(l), o.isBlured && (l.group.traverse(function(u) {
      b_(u);
    }), s && t.push(a)), o.isBlured = !1;
  }), dist_M(n, function(i) {
    i && i.toggleBlurSeries && i.toggleBlurSeries(t, !1, e);
  });
}
function Sv(r, e, t, n) {
  var i = n.getModel();
  t = t || "coordinateSystem";
  function a(u, f) {
    for (var c = 0; c < f.length; c++) {
      var h = u.getItemGraphicEl(f[c]);
      h && x_(h);
    }
  }
  if (r != null && !(!e || e === "none")) {
    var o = i.getSeriesByIndex(r), s = o.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    i.eachSeries(function(u) {
      var f = o === u, c = u.coordinateSystem;
      c && c.master && (c = c.master);
      var h = c && s ? c === s : f;
      if (!// Not blur other series if blurScope series
      (t === "series" && !f || t === "coordinateSystem" && !h || e === "series" && f)) {
        var v = n.getViewOfSeriesModel(u);
        if (v.group.traverse(function(p) {
          p.__highByOuter && f && e === "self" || Od(p);
        }), ct(e))
          a(u.getData(), e);
        else if (dist_X(e))
          for (var d = we(e), g = 0; g < d.length; g++)
            a(u.getData(d[g]), e[d[g]]);
        l.push(u), Pd(u).isBlured = !0;
      }
    }), i.eachComponent(function(u, f) {
      if (u !== "series") {
        var c = n.getViewOfComponentModel(f);
        c && c.toggleBlurSeries && c.toggleBlurSeries(l, !0, i);
      }
    });
  }
}
function wv(r, e, t) {
  if (!(r == null || e == null)) {
    var n = t.getModel().getComponent(r, e);
    if (n) {
      Pd(n).isBlured = !0;
      var i = t.getViewOfComponentModel(n);
      !i || !i.focusBlurEnabled || i.group.traverse(function(a) {
        Od(a);
      });
    }
  }
}
function HT(r, e, t) {
  var n = r.seriesIndex, i = r.getData(e.dataType);
  if (!i) {
     false && 0;
    return;
  }
  var a = Vi(i, e);
  a = (dist_F(a) ? a[0] : a) || 0;
  var o = i.getItemGraphicEl(a);
  if (!o)
    for (var s = i.count(), l = 0; !o && l < s; )
      o = i.getItemGraphicEl(l++);
  if (o) {
    var u = dist_ie(o);
    Sv(n, u.focus, u.blurScope, t);
  } else {
    var f = r.get(["emphasis", "focus"]), c = r.get(["emphasis", "blurScope"]);
    f != null && Sv(n, f, c, t);
  }
}
function Vd(r, e, t, n) {
  var i = {
    focusSelf: !1,
    dispatchers: null
  };
  if (r == null || r === "series" || e == null || t == null)
    return i;
  var a = n.getModel().getComponent(r, e);
  if (!a)
    return i;
  var o = n.getViewOfComponentModel(a);
  if (!o || !o.findHighDownDispatchers)
    return i;
  for (var s = o.findHighDownDispatchers(t), l, u = 0; u < s.length; u++)
    if ( false && 0, dist_ie(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function $T(r, e, t) {
   false && 0;
  var n = dist_ie(r), i = Vd(n.componentMainType, n.componentIndex, n.componentHighDownName, t), a = i.dispatchers, o = i.focusSelf;
  a ? (o && wv(n.componentMainType, n.componentIndex, t), dist_M(a, function(s) {
    return Cg(s, e);
  })) : (Sv(n.seriesIndex, n.focus, n.blurScope, t), n.focus === "self" && wv(n.componentMainType, n.componentIndex, t), Cg(r, e));
}
function WT(r, e, t) {
   false && 0, D_(t);
  var n = dist_ie(r), i = Vd(n.componentMainType, n.componentIndex, n.componentHighDownName, t).dispatchers;
  i ? dist_M(i, function(a) {
    return Tg(a, e);
  }) : Tg(r, e);
}
function UT(r, e, t) {
  if (bv(e)) {
    var n = e.dataType, i = r.getData(n), a = Vi(i, e);
    dist_F(a) || (a = [a]), r[e.type === Ho ? "toggleSelect" : e.type === Go ? "select" : "unselect"](a, n);
  }
}
function Mg(r) {
  var e = r.getAllData();
  dist_M(e, function(t) {
    var n = t.data, i = t.type;
    n.eachItemGraphicEl(function(a, o) {
      r.isSelected(o, i) ? C_(a) : T_(a);
    });
  });
}
function YT(r) {
  var e = [];
  return r.eachSeries(function(t) {
    var n = t.getAllData();
    dist_M(n, function(i) {
      i.data;
      var a = i.type, o = t.getSelectedDataIndices();
      if (o.length > 0) {
        var s = {
          dataIndex: o,
          seriesIndex: t.seriesIndex
        };
        a != null && (s.dataType = a), e.push(s);
      }
    });
  }), e;
}
function mu(r, e, t) {
  Bd(r, !0), fn(r, kd), ZT(r, e, t);
}
function XT(r) {
  Bd(r, !1);
}
function rn(r, e, t, n) {
  n ? XT(r) : mu(r, e, t);
}
function ZT(r, e, t) {
  var n = dist_ie(r);
  e != null ? (n.focus = e, n.blurScope = t) : n.focus && (n.focus = null);
}
var Dg = ["emphasis", "blur", "select"], qT = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function yu(r, e, t, n) {
  t = t || "itemStyle";
  for (var i = 0; i < Dg.length; i++) {
    var a = Dg[i], o = e.getModel([a, t]), s = r.ensureState(a);
    s.style = n ? n(o) : o[qT[t]]();
  }
}
function Bd(r, e) {
  var t = e === !1, n = r;
  r.highDownSilentOnTouch && (n.__highDownSilentOnTouch = r.highDownSilentOnTouch), (!t || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !t);
}
function Oa(r) {
  return !!(r && r.__highDownDispatcher);
}
function KT(r, e, t) {
  var n = dist_ie(r);
  n.componentMainType = e.mainType, n.componentIndex = e.componentIndex, n.componentHighDownName = t;
}
function jT(r) {
  var e = bg[r];
  return e == null && wg <= 32 && (e = bg[r] = wg++), e;
}
function bv(r) {
  var e = r.type;
  return e === Go || e === Zl || e === Ho;
}
function Eg(r) {
  var e = r.type;
  return e === Ni || e === Xl;
}
function JT(r) {
  var e = y_(r);
  e.normalFill = r.style.fill, e.normalStroke = r.style.stroke;
  var t = r.states.select || {};
  e.selectFill = t.style && t.style.fill || null, e.selectStroke = t.style && t.style.stroke || null;
}
var Qi = tn.CMD, QT = [[], [], []], Ag = Math.sqrt, e8 = Math.atan2;
function E_(r, e) {
  if (e) {
    var t = r.data, n = r.len(), i, a, o, s, l, u, f = Qi.M, c = Qi.C, h = Qi.L, v = Qi.R, d = Qi.A, g = Qi.Q;
    for (o = 0, s = 0; o < n; ) {
      switch (i = t[o++], s = o, a = 0, i) {
        case f:
          a = 1;
          break;
        case h:
          a = 1;
          break;
        case c:
          a = 3;
          break;
        case g:
          a = 2;
          break;
        case d:
          var p = e[4], m = e[5], y = Ag(e[0] * e[0] + e[1] * e[1]), _ = Ag(e[2] * e[2] + e[3] * e[3]), S = e8(-e[1] / _, e[0] / y);
          t[o] *= y, t[o++] += p, t[o] *= _, t[o++] += m, t[o++] *= y, t[o++] *= _, t[o++] += S, t[o++] += S, o += 2, s = o;
          break;
        case v:
          u[0] = t[o++], u[1] = t[o++], Xe(u, u, e), t[s++] = u[0], t[s++] = u[1], u[0] += t[o++], u[1] += t[o++], Xe(u, u, e), t[s++] = u[0], t[s++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var b = QT[l];
        b[0] = t[o++], b[1] = t[o++], Xe(b, b, e), t[s++] = b[0], t[s++] = b[1];
      }
    }
    r.increaseVersion();
  }
}
var Ec = Math.sqrt, nl = Math.sin, il = Math.cos, so = Math.PI;
function Ig(r) {
  return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
}
function xv(r, e) {
  return (r[0] * e[0] + r[1] * e[1]) / (Ig(r) * Ig(e));
}
function Lg(r, e) {
  return (r[0] * e[1] < r[1] * e[0] ? -1 : 1) * Math.acos(xv(r, e));
}
function Ng(r, e, t, n, i, a, o, s, l, u, f) {
  var c = l * (so / 180), h = il(c) * (r - t) / 2 + nl(c) * (e - n) / 2, v = -1 * nl(c) * (r - t) / 2 + il(c) * (e - n) / 2, d = h * h / (o * o) + v * v / (s * s);
  d > 1 && (o *= Ec(d), s *= Ec(d));
  var g = (i === a ? -1 : 1) * Ec((o * o * (s * s) - o * o * (v * v) - s * s * (h * h)) / (o * o * (v * v) + s * s * (h * h))) || 0, p = g * o * v / s, m = g * -s * h / o, y = (r + t) / 2 + il(c) * p - nl(c) * m, _ = (e + n) / 2 + nl(c) * p + il(c) * m, S = Lg([1, 0], [(h - p) / o, (v - m) / s]), b = [(h - p) / o, (v - m) / s], w = [(-1 * h - p) / o, (-1 * v - m) / s], x = Lg(b, w);
  if (xv(b, w) <= -1 && (x = so), xv(b, w) >= 1 && (x = 0), x < 0) {
    var C = Math.round(x / so * 1e6) / 1e6;
    x = so * 2 + C % 2 * so;
  }
  f.addData(u, y, _, o, s, S, x, c, a);
}
var t8 = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, r8 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function n8(r) {
  var e = new tn();
  if (!r)
    return e;
  var t = 0, n = 0, i = t, a = n, o, s = tn.CMD, l = r.match(t8);
  if (!l)
    return e;
  for (var u = 0; u < l.length; u++) {
    for (var f = l[u], c = f.charAt(0), h = void 0, v = f.match(r8) || [], d = v.length, g = 0; g < d; g++)
      v[g] = parseFloat(v[g]);
    for (var p = 0; p < d; ) {
      var m = void 0, y = void 0, _ = void 0, S = void 0, b = void 0, w = void 0, x = void 0, C = t, T = n, E = void 0, D = void 0;
      switch (c) {
        case "l":
          t += v[p++], n += v[p++], h = s.L, e.addData(h, t, n);
          break;
        case "L":
          t = v[p++], n = v[p++], h = s.L, e.addData(h, t, n);
          break;
        case "m":
          t += v[p++], n += v[p++], h = s.M, e.addData(h, t, n), i = t, a = n, c = "l";
          break;
        case "M":
          t = v[p++], n = v[p++], h = s.M, e.addData(h, t, n), i = t, a = n, c = "L";
          break;
        case "h":
          t += v[p++], h = s.L, e.addData(h, t, n);
          break;
        case "H":
          t = v[p++], h = s.L, e.addData(h, t, n);
          break;
        case "v":
          n += v[p++], h = s.L, e.addData(h, t, n);
          break;
        case "V":
          n = v[p++], h = s.L, e.addData(h, t, n);
          break;
        case "C":
          h = s.C, e.addData(h, v[p++], v[p++], v[p++], v[p++], v[p++], v[p++]), t = v[p - 2], n = v[p - 1];
          break;
        case "c":
          h = s.C, e.addData(h, v[p++] + t, v[p++] + n, v[p++] + t, v[p++] + n, v[p++] + t, v[p++] + n), t += v[p - 2], n += v[p - 1];
          break;
        case "S":
          m = t, y = n, E = e.len(), D = e.data, o === s.C && (m += t - D[E - 4], y += n - D[E - 3]), h = s.C, C = v[p++], T = v[p++], t = v[p++], n = v[p++], e.addData(h, m, y, C, T, t, n);
          break;
        case "s":
          m = t, y = n, E = e.len(), D = e.data, o === s.C && (m += t - D[E - 4], y += n - D[E - 3]), h = s.C, C = t + v[p++], T = n + v[p++], t += v[p++], n += v[p++], e.addData(h, m, y, C, T, t, n);
          break;
        case "Q":
          C = v[p++], T = v[p++], t = v[p++], n = v[p++], h = s.Q, e.addData(h, C, T, t, n);
          break;
        case "q":
          C = v[p++] + t, T = v[p++] + n, t += v[p++], n += v[p++], h = s.Q, e.addData(h, C, T, t, n);
          break;
        case "T":
          m = t, y = n, E = e.len(), D = e.data, o === s.Q && (m += t - D[E - 4], y += n - D[E - 3]), t = v[p++], n = v[p++], h = s.Q, e.addData(h, m, y, t, n);
          break;
        case "t":
          m = t, y = n, E = e.len(), D = e.data, o === s.Q && (m += t - D[E - 4], y += n - D[E - 3]), t += v[p++], n += v[p++], h = s.Q, e.addData(h, m, y, t, n);
          break;
        case "A":
          _ = v[p++], S = v[p++], b = v[p++], w = v[p++], x = v[p++], C = t, T = n, t = v[p++], n = v[p++], h = s.A, Ng(C, T, t, n, w, x, _, S, b, h, e);
          break;
        case "a":
          _ = v[p++], S = v[p++], b = v[p++], w = v[p++], x = v[p++], C = t, T = n, t += v[p++], n += v[p++], h = s.A, Ng(C, T, t, n, w, x, _, S, b, h, e);
          break;
      }
    }
    (c === "z" || c === "Z") && (h = s.Z, e.addData(h), t = i, n = a), o = h;
  }
  return e.toStatic(), e;
}
var A_ = function(r) {
  dist_k(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.applyTransform = function(t) {
  }, e;
}(fe);
function I_(r) {
  return r.setData != null;
}
function L_(r, e) {
  var t = n8(r), n = dist_V({}, e);
  return n.buildPath = function(i) {
    if (I_(i)) {
      i.setData(t.data);
      var a = i.getContext();
      a && i.rebuildPath(a, 1);
    } else {
      var a = i;
      t.rebuildPath(a, 1);
    }
  }, n.applyTransform = function(i) {
    E_(t, i), this.dirtyShape();
  }, n;
}
function N_(r, e) {
  return new A_(L_(r, e));
}
function i8(r, e) {
  var t = L_(r, e), n = function(i) {
    dist_k(a, i);
    function a(o) {
      var s = i.call(this, o) || this;
      return s.applyTransform = t.applyTransform, s.buildPath = t.buildPath, s;
    }
    return a;
  }(A_);
  return n;
}
function a8(r, e) {
  for (var t = [], n = r.length, i = 0; i < n; i++) {
    var a = r[i];
    t.push(a.getUpdatedPathProxy(!0));
  }
  var o = new fe(e);
  return o.createPathProxy(), o.buildPath = function(s) {
    if (I_(s)) {
      s.appendPath(t);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, o;
}
function Fd(r, e) {
  e = e || {};
  var t = new fe();
  return r.shape && t.setShape(r.shape), t.setStyle(r.style), e.bakeTransform ? E_(t.path, r.getComputedTransform()) : e.toLocal ? t.setLocalTransform(r.getComputedTransform()) : t.copyTransform(r), t.buildPath = r.buildPath, t.applyTransform = t.applyTransform, t.z = r.z, t.z2 = r.z2, t.zlevel = r.zlevel, t;
}
var o8 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return r;
}(), P_ = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new o8();
  }, e.prototype.buildPath = function(t, n) {
    t.moveTo(n.cx + n.r, n.cy), t.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, e;
}(fe);
P_.prototype.type = "circle";
const As = P_;
var s8 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return r;
}(), R_ = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new s8();
  }, e.prototype.buildPath = function(t, n) {
    var i = 0.5522848, a = n.cx, o = n.cy, s = n.rx, l = n.ry, u = s * i, f = l * i;
    t.moveTo(a - s, o), t.bezierCurveTo(a - s, o - f, a - u, o - l, a, o - l), t.bezierCurveTo(a + u, o - l, a + s, o - f, a + s, o), t.bezierCurveTo(a + s, o + f, a + u, o + l, a, o + l), t.bezierCurveTo(a - u, o + l, a - s, o + f, a - s, o), t.closePath();
  }, e;
}(fe);
R_.prototype.type = "ellipse";
const zd = R_;
var O_ = Math.PI, Ac = O_ * 2, si = Math.sin, ea = Math.cos, l8 = Math.acos, Qe = Math.atan2, Pg = Math.abs, $o = Math.sqrt, Lo = Math.max, _r = Math.min, rr = 1e-4;
function u8(r, e, t, n, i, a, o, s) {
  var l = t - r, u = n - e, f = o - i, c = s - a, h = c * l - f * u;
  if (!(h * h < rr))
    return h = (f * (e - a) - c * (r - i)) / h, [r + h * l, e + h * u];
}
function al(r, e, t, n, i, a, o) {
  var s = r - t, l = e - n, u = (o ? a : -a) / $o(s * s + l * l), f = u * l, c = -u * s, h = r + f, v = e + c, d = t + f, g = n + c, p = (h + d) / 2, m = (v + g) / 2, y = d - h, _ = g - v, S = y * y + _ * _, b = i - a, w = h * g - d * v, x = (_ < 0 ? -1 : 1) * $o(Lo(0, b * b * S - w * w)), C = (w * _ - y * x) / S, T = (-w * y - _ * x) / S, E = (w * _ + y * x) / S, D = (-w * y + _ * x) / S, I = C - p, L = T - m, N = E - p, P = D - m;
  return I * I + L * L > N * N + P * P && (C = E, T = D), {
    cx: C,
    cy: T,
    x0: -f,
    y0: -c,
    x1: C * (i / b - 1),
    y1: T * (i / b - 1)
  };
}
function f8(r) {
  var e;
  if (dist_F(r)) {
    var t = r.length;
    if (!t)
      return r;
    t === 1 ? e = [r[0], r[0], 0, 0] : t === 2 ? e = [r[0], r[0], r[1], r[1]] : t === 3 ? e = r.concat(r[2]) : e = r;
  } else
    e = [r, r, r, r];
  return e;
}
function c8(r, e) {
  var t, n = Lo(e.r, 0), i = Lo(e.r0 || 0, 0), a = n > 0, o = i > 0;
  if (!(!a && !o)) {
    if (a || (n = i, i = 0), i > n) {
      var s = n;
      n = i, i = s;
    }
    var l = e.startAngle, u = e.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var f = e.cx, c = e.cy, h = !!e.clockwise, v = Pg(u - l), d = v > Ac && v % Ac;
      if (d > rr && (v = d), !(n > rr))
        r.moveTo(f, c);
      else if (v > Ac - rr)
        r.moveTo(f + n * ea(l), c + n * si(l)), r.arc(f, c, n, l, u, !h), i > rr && (r.moveTo(f + i * ea(u), c + i * si(u)), r.arc(f, c, i, u, l, h));
      else {
        var g = void 0, p = void 0, m = void 0, y = void 0, _ = void 0, S = void 0, b = void 0, w = void 0, x = void 0, C = void 0, T = void 0, E = void 0, D = void 0, I = void 0, L = void 0, N = void 0, P = n * ea(l), R = n * si(l), z = i * ea(u), O = i * si(u), B = v > rr;
        if (B) {
          var H = e.cornerRadius;
          H && (t = f8(H), g = t[0], p = t[1], m = t[2], y = t[3]);
          var q = Pg(n - i) / 2;
          if (_ = _r(q, m), S = _r(q, y), b = _r(q, g), w = _r(q, p), T = x = Lo(_, S), E = C = Lo(b, w), (x > rr || C > rr) && (D = n * ea(u), I = n * si(u), L = i * ea(l), N = i * si(l), v < O_)) {
            var Q = u8(P, R, L, N, D, I, z, O);
            if (Q) {
              var le = P - Q[0], ge = R - Q[1], Re = D - Q[0], Ce = I - Q[1], je = 1 / si(l8((le * Re + ge * Ce) / ($o(le * le + ge * ge) * $o(Re * Re + Ce * Ce))) / 2), Je = $o(Q[0] * Q[0] + Q[1] * Q[1]);
              T = _r(x, (n - Je) / (je + 1)), E = _r(C, (i - Je) / (je - 1));
            }
          }
        }
        if (!B)
          r.moveTo(f + P, c + R);
        else if (T > rr) {
          var Fe = _r(m, T), Ee = _r(y, T), J = al(L, N, P, R, n, Fe, h), ce = al(D, I, z, O, n, Ee, h);
          r.moveTo(f + J.cx + J.x0, c + J.cy + J.y0), T < x && Fe === Ee ? r.arc(f + J.cx, c + J.cy, T, Qe(J.y0, J.x0), Qe(ce.y0, ce.x0), !h) : (Fe > 0 && r.arc(f + J.cx, c + J.cy, Fe, Qe(J.y0, J.x0), Qe(J.y1, J.x1), !h), r.arc(f, c, n, Qe(J.cy + J.y1, J.cx + J.x1), Qe(ce.cy + ce.y1, ce.cx + ce.x1), !h), Ee > 0 && r.arc(f + ce.cx, c + ce.cy, Ee, Qe(ce.y1, ce.x1), Qe(ce.y0, ce.x0), !h));
        } else
          r.moveTo(f + P, c + R), r.arc(f, c, n, l, u, !h);
        if (!(i > rr) || !B)
          r.lineTo(f + z, c + O);
        else if (E > rr) {
          var Fe = _r(g, E), Ee = _r(p, E), J = al(z, O, D, I, i, -Ee, h), ce = al(P, R, L, N, i, -Fe, h);
          r.lineTo(f + J.cx + J.x0, c + J.cy + J.y0), E < C && Fe === Ee ? r.arc(f + J.cx, c + J.cy, E, Qe(J.y0, J.x0), Qe(ce.y0, ce.x0), !h) : (Ee > 0 && r.arc(f + J.cx, c + J.cy, Ee, Qe(J.y0, J.x0), Qe(J.y1, J.x1), !h), r.arc(f, c, i, Qe(J.cy + J.y1, J.cx + J.x1), Qe(ce.cy + ce.y1, ce.cx + ce.x1), h), Fe > 0 && r.arc(f + ce.cx, c + ce.cy, Fe, Qe(ce.y1, ce.x1), Qe(ce.y0, ce.x0), !h));
        } else
          r.lineTo(f + z, c + O), r.arc(f, c, i, u, l, h);
      }
      r.closePath();
    }
  }
}
var h8 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return r;
}(), k_ = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new h8();
  }, e.prototype.buildPath = function(t, n) {
    c8(t, n);
  }, e.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, e;
}(fe);
k_.prototype.type = "sector";
const nn = k_;
var v8 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return r;
}(), V_ = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new v8();
  }, e.prototype.buildPath = function(t, n) {
    var i = n.cx, a = n.cy, o = Math.PI * 2;
    t.moveTo(i + n.r, a), t.arc(i, a, n.r, 0, o, !1), t.moveTo(i + n.r0, a), t.arc(i, a, n.r0, 0, o, !0);
  }, e;
}(fe);
V_.prototype.type = "ring";
const B_ = V_;
function d8(r, e, t, n) {
  var i = [], a = [], o = [], s = [], l, u, f, c;
  if (n) {
    f = [1 / 0, 1 / 0], c = [-1 / 0, -1 / 0];
    for (var h = 0, v = r.length; h < v; h++)
      Ln(f, f, r[h]), Nn(c, c, r[h]);
    Ln(f, f, n[0]), Nn(c, c, n[1]);
  }
  for (var h = 0, v = r.length; h < v; h++) {
    var d = r[h];
    if (t)
      l = r[h ? h - 1 : v - 1], u = r[(h + 1) % v];
    else if (h === 0 || h === v - 1) {
      i.push(Ur(r[h]));
      continue;
    } else
      l = r[h - 1], u = r[h + 1];
    bi(a, u, l), zl(a, a, e);
    var g = Qh(d, l), p = Qh(d, u), m = g + p;
    m !== 0 && (g /= m, p /= m), zl(o, a, -g), zl(s, a, p);
    var y = xp([], d, o), _ = xp([], d, s);
    n && (Nn(y, y, f), Ln(y, y, c), Nn(_, _, f), Ln(_, _, c)), i.push(y), i.push(_);
  }
  return t && i.push(i.shift()), i;
}
function F_(r, e, t) {
  var n = e.smooth, i = e.points;
  if (i && i.length >= 2) {
    if (n) {
      var a = d8(i, n, t, e.smoothConstraint);
      r.moveTo(i[0][0], i[0][1]);
      for (var o = i.length, s = 0; s < (t ? o : o - 1); s++) {
        var l = a[s * 2], u = a[s * 2 + 1], f = i[(s + 1) % o];
        r.bezierCurveTo(l[0], l[1], u[0], u[1], f[0], f[1]);
      }
    } else {
      r.moveTo(i[0][0], i[0][1]);
      for (var s = 1, c = i.length; s < c; s++)
        r.lineTo(i[s][0], i[s][1]);
    }
    t && r.closePath();
  }
}
var p8 = /* @__PURE__ */ function() {
  function r() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), Un = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new p8();
  }, e.prototype.buildPath = function(t, n) {
    F_(t, n, !0);
  }, e;
}(fe);
Un.prototype.type = "polygon";
var g8 = /* @__PURE__ */ function() {
  function r() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), cn = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new g8();
  }, e.prototype.buildPath = function(t, n) {
    F_(t, n, !1);
  }, e;
}(fe);
cn.prototype.type = "polyline";
var m8 = {}, y8 = /* @__PURE__ */ function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return r;
}(), z_ = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new y8();
  }, e.prototype.buildPath = function(t, n) {
    var i, a, o, s;
    if (this.subPixelOptimize) {
      var l = d_(m8, n, this.style);
      i = l.x1, a = l.y1, o = l.x2, s = l.y2;
    } else
      i = n.x1, a = n.y1, o = n.x2, s = n.y2;
    var u = n.percent;
    u !== 0 && (t.moveTo(i, a), u < 1 && (o = i * (1 - u) + o * u, s = a * (1 - u) + s * u), t.lineTo(o, s));
  }, e.prototype.pointAt = function(t) {
    var n = this.shape;
    return [
      n.x1 * (1 - t) + n.x2 * t,
      n.y1 * (1 - t) + n.y2 * t
    ];
  }, e;
}(fe);
z_.prototype.type = "line";
const an = z_;
var pt = [], _8 = /* @__PURE__ */ function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return r;
}();
function Rg(r, e, t) {
  var n = r.cpx2, i = r.cpy2;
  return n != null || i != null ? [
    (t ? Op : ze)(r.x1, r.cpx1, r.cpx2, r.x2, e),
    (t ? Op : ze)(r.y1, r.cpy1, r.cpy2, r.y2, e)
  ] : [
    (t ? iv : We)(r.x1, r.cpx1, r.x2, e),
    (t ? iv : We)(r.y1, r.cpy1, r.y2, e)
  ];
}
var G_ = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new _8();
  }, e.prototype.buildPath = function(t, n) {
    var i = n.x1, a = n.y1, o = n.x2, s = n.y2, l = n.cpx1, u = n.cpy1, f = n.cpx2, c = n.cpy2, h = n.percent;
    h !== 0 && (t.moveTo(i, a), f == null || c == null ? (h < 1 && (os(i, l, o, h, pt), l = pt[1], o = pt[2], os(a, u, s, h, pt), u = pt[1], s = pt[2]), t.quadraticCurveTo(l, u, o, s)) : (h < 1 && (Hn(i, l, f, o, h, pt), l = pt[1], f = pt[2], o = pt[3], Hn(a, u, c, s, h, pt), u = pt[1], c = pt[2], s = pt[3]), t.bezierCurveTo(l, u, f, c, o, s)));
  }, e.prototype.pointAt = function(t) {
    return Rg(this.shape, t, !1);
  }, e.prototype.tangentAt = function(t) {
    var n = Rg(this.shape, t, !0);
    return Wa(n, n);
  }, e;
}(fe);
G_.prototype.type = "bezier-curve";
const Gd = G_;
var S8 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return r;
}(), H_ = function(r) {
  dist_k(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new S8();
  }, e.prototype.buildPath = function(t, n) {
    var i = n.cx, a = n.cy, o = Math.max(n.r, 0), s = n.startAngle, l = n.endAngle, u = n.clockwise, f = Math.cos(s), c = Math.sin(s);
    t.moveTo(f * o + i, c * o + a), t.arc(i, a, o, s, l, !u);
  }, e;
}(fe);
H_.prototype.type = "arc";
const Hd = H_;
var w8 = function(r) {
  dist_k(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.type = "compound", t;
  }
  return e.prototype._updatePathDirty = function() {
    for (var t = this.shape.paths, n = this.shapeChanged(), i = 0; i < t.length; i++)
      n = n || t[i].shapeChanged();
    n && this.dirtyShape();
  }, e.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var t = this.shape.paths || [], n = this.getGlobalScale(), i = 0; i < t.length; i++)
      t[i].path || t[i].createPathProxy(), t[i].path.setScale(n[0], n[1], t[i].segmentIgnoreThreshold);
  }, e.prototype.buildPath = function(t, n) {
    for (var i = n.paths || [], a = 0; a < i.length; a++)
      i[a].buildPath(t, i[a].shape, !0);
  }, e.prototype.afterBrush = function() {
    for (var t = this.shape.paths || [], n = 0; n < t.length; n++)
      t[n].pathUpdated();
  }, e.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), fe.prototype.getBoundingRect.call(this);
  }, e;
}(fe);
const $_ = w8;
var b8 = function() {
  function r(e) {
    this.colorStops = e || [];
  }
  return r.prototype.addColorStop = function(e, t) {
    this.colorStops.push({
      offset: e,
      color: t
    });
  }, r;
}();
const W_ = b8;
var vf = function(r) {
  dist_k(e, r);
  function e(t, n, i, a, o, s) {
    var l = r.call(this, o) || this;
    return l.x = t ?? 0, l.y = n ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return e;
}(W_), x8 = function(r) {
  dist_k(e, r);
  function e(t, n, i, a, o) {
    var s = r.call(this, a) || this;
    return s.x = t ?? 0.5, s.y = n ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = o || !1, s;
  }
  return e;
}(W_);
const U_ = x8;
var li = [0, 0], ui = [0, 0], ol = new dist_K(), sl = new dist_K(), _u = function() {
  function r(e, t) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new dist_K();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new dist_K();
    e && this.fromBoundingRect(e, t);
  }
  return r.prototype.fromBoundingRect = function(e, t) {
    var n = this._corners, i = this._axes, a = e.x, o = e.y, s = a + e.width, l = o + e.height;
    if (n[0].set(a, o), n[1].set(s, o), n[2].set(s, l), n[3].set(a, l), t)
      for (var u = 0; u < 4; u++)
        n[u].transform(t);
    dist_K.sub(i[0], n[1], n[0]), dist_K.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = i[u].dot(n[0]);
  }, r.prototype.intersect = function(e, t) {
    var n = !0, i = !t;
    return ol.set(1 / 0, 1 / 0), sl.set(0, 0), !this._intersectCheckOneSide(this, e, ol, sl, i, 1) && (n = !1, i) || !this._intersectCheckOneSide(e, this, ol, sl, i, -1) && (n = !1, i) || i || dist_K.copy(t, n ? ol : sl), n;
  }, r.prototype._intersectCheckOneSide = function(e, t, n, i, a, o) {
    for (var s = !0, l = 0; l < 2; l++) {
      var u = this._axes[l];
      if (this._getProjMinMaxOnAxis(l, e._corners, li), this._getProjMinMaxOnAxis(l, t._corners, ui), li[1] < ui[0] || li[0] > ui[1]) {
        if (s = !1, a)
          return s;
        var f = Math.abs(ui[0] - li[1]), c = Math.abs(li[0] - ui[1]);
        Math.min(f, c) > i.len() && (f < c ? dist_K.scale(i, u, -f * o) : dist_K.scale(i, u, c * o));
      } else if (n) {
        var f = Math.abs(ui[0] - li[1]), c = Math.abs(li[0] - ui[1]);
        Math.min(f, c) < n.len() && (f < c ? dist_K.scale(n, u, f * o) : dist_K.scale(n, u, -c * o));
      }
    }
    return s;
  }, r.prototype._getProjMinMaxOnAxis = function(e, t, n) {
    for (var i = this._axes[e], a = this._origin, o = t[0].dot(i) + a[e], s = o, l = o, u = 1; u < t.length; u++) {
      var f = t[u].dot(i) + a[e];
      s = Math.min(f, s), l = Math.max(f, l);
    }
    n[0] = s, n[1] = l;
  }, r;
}(), C8 = [], T8 = function(r) {
  dist_k(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.notClear = !0, t.incremental = !0, t._displayables = [], t._temporaryDisplayables = [], t._cursor = 0, t;
  }
  return e.prototype.traverse = function(t, n) {
    t.call(n, this);
  }, e.prototype.useStyle = function() {
    this.style = {};
  }, e.prototype.getCursor = function() {
    return this._cursor;
  }, e.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, e.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, e.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, e.prototype.addDisplayable = function(t, n) {
    n ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw();
  }, e.prototype.addDisplayables = function(t, n) {
    n = n || !1;
    for (var i = 0; i < t.length; i++)
      this.addDisplayable(t[i], n);
  }, e.prototype.getDisplayables = function() {
    return this._displayables;
  }, e.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, e.prototype.eachPendingDisplayable = function(t) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      t && t(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      t && t(this._temporaryDisplayables[n]);
  }, e.prototype.update = function() {
    this.updateTransform();
    for (var t = this._cursor; t < this._displayables.length; t++) {
      var n = this._displayables[t];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var t = 0; t < this._temporaryDisplayables.length; t++) {
      var n = this._temporaryDisplayables[t];
      n.parent = this, n.update(), n.parent = null;
    }
  }, e.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var t = new dist_ae(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var i = this._displayables[n], a = i.getBoundingRect().clone();
        i.needLocalTransform() && a.applyTransform(i.getLocalTransform(C8)), t.union(a);
      }
      this._rect = t;
    }
    return this._rect;
  }, e.prototype.contain = function(t, n) {
    var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
    if (a.contain(i[0], i[1]))
      for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(t, n))
          return !0;
      }
    return !1;
  }, e;
}(Wn);
const M8 = T8;
var Y_ = Me();
function df(r, e, t, n, i) {
  var a;
  if (e && e.ecModel) {
    var o = e.ecModel.getUpdatePayload();
    a = o && o.animation;
  }
  var s = e && e.isAnimationEnabled(), l = r === "update";
  if (s) {
    var u = void 0, f = void 0, c = void 0;
    n ? (u = dist_ne(n.duration, 200), f = dist_ne(n.easing, "cubicOut"), c = 0) : (u = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), f = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), c = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (f = a.easing), a.delay != null && (c = a.delay)), dist_j(c) && (c = c(t, i)), dist_j(u) && (u = u(t));
    var h = {
      duration: u || 0,
      delay: c,
      easing: f
    };
    return h;
  } else
    return null;
}
function $d(r, e, t, n, i, a, o) {
  var s = !1, l;
  dist_j(i) ? (o = a, a = i, i = null) : dist_X(i) && (a = i.cb, o = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
  var u = r === "leave";
  u || e.stopAnimation("leave");
  var f = df(r, n, i, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(e, i) : null);
  if (f && f.duration > 0) {
    var c = f.duration, h = f.delay, v = f.easing, d = {
      duration: c,
      delay: h || 0,
      easing: v,
      done: a,
      force: !!a || !!o,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: r,
      during: o
    };
    s ? e.animateFrom(t, d) : e.animateTo(t, d);
  } else
    e.stopAnimation(), !s && e.attr(t), o && o(1), a && a();
}
function Pe(r, e, t, n, i, a) {
  $d("update", r, e, t, n, i, a);
}
function Ze(r, e, t, n, i, a) {
  $d("enter", r, e, t, n, i, a);
}
function Ta(r) {
  if (!r.__zr)
    return !0;
  for (var e = 0; e < r.animators.length; e++) {
    var t = r.animators[e];
    if (t.scope === "leave")
      return !0;
  }
  return !1;
}
function Su(r, e, t, n, i, a) {
  Ta(r) || $d("leave", r, e, t, n, i, a);
}
function Og(r, e, t, n) {
  r.removeTextContent(), r.removeTextGuideLine(), Su(r, {
    style: {
      opacity: 0
    }
  }, e, t, n);
}
function wu(r, e, t) {
  function n() {
    r.parent && r.parent.remove(r);
  }
  r.isGroup ? r.traverse(function(i) {
    i.isGroup || Og(i, e, t, n);
  }) : Og(r, e, t, n);
}
function Wd(r) {
  Y_(r).oldStyle = r.style;
}
function D8(r) {
  return Y_(r).oldStyle;
}
var bu = Math.max, xu = Math.min, Cv = {};
function E8(r) {
  return fe.extend(r);
}
var A8 = i8;
function I8(r, e) {
  return A8(r, e);
}
function dr(r, e) {
  Cv[r] = e;
}
function L8(r) {
  if (Cv.hasOwnProperty(r))
    return Cv[r];
}
function Ud(r, e, t, n) {
  var i = N_(r, e);
  return t && (n === "center" && (t = Z_(t, i.getBoundingRect())), q_(i, t)), i;
}
function X_(r, e, t) {
  var n = new un({
    style: {
      image: r,
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    onload: function(i) {
      if (t === "center") {
        var a = {
          width: i.width,
          height: i.height
        };
        n.setStyle(Z_(e, a));
      }
    }
  });
  return n;
}
function Z_(r, e) {
  var t = e.width / e.height, n = r.height * t, i;
  n <= r.width ? i = r.height : (n = r.width, i = n / t);
  var a = r.x + r.width / 2, o = r.y + r.height / 2;
  return {
    x: a - n / 2,
    y: o - i / 2,
    width: n,
    height: i
  };
}
var N8 = a8;
function q_(r, e) {
  if (r.applyTransform) {
    var t = r.getBoundingRect(), n = t.calculateTransform(e);
    r.applyTransform(n);
  }
}
function cs(r, e) {
  return d_(r, r, {
    lineWidth: e
  }), r;
}
function P8(r) {
  return p_(r.shape, r.shape, r.style), r;
}
var R8 = Ci;
function Wo(r, e) {
  for (var t = rf([]); r && r !== e; )
    Xr(t, r.getLocalTransform(), t), r = r.parent;
  return t;
}
function Bn(r, e, t) {
  return e && !ct(e) && (e = Fr.getLocalTransform(e)), t && (e = Ua([], e)), Xe([], r, e);
}
function Yd(r, e, t) {
  var n = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), i = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), a = [r === "left" ? -n : r === "right" ? n : 0, r === "top" ? -i : r === "bottom" ? i : 0];
  return a = Bn(a, e, t), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function kg(r) {
  return !r.isGroup;
}
function O8(r) {
  return r.shape != null;
}
function K_(r, e, t) {
  if (!r || !e)
    return;
  function n(o) {
    var s = {};
    return o.traverse(function(l) {
      kg(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function i(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation
    };
    return O8(o) && (s.shape = dist_V({}, o.shape)), s;
  }
  var a = n(r);
  e.traverse(function(o) {
    if (kg(o) && o.anid) {
      var s = a[o.anid];
      if (s) {
        var l = i(o);
        o.attr(i(s)), Pe(o, l, t, dist_ie(o).dataIndex);
      }
    }
  });
}
function k8(r, e) {
  return dist_$(r, function(t) {
    var n = t[0];
    n = bu(n, e.x), n = xu(n, e.x + e.width);
    var i = t[1];
    return i = bu(i, e.y), i = xu(i, e.y + e.height), [n, i];
  });
}
function V8(r, e) {
  var t = bu(r.x, e.x), n = xu(r.x + r.width, e.x + e.width), i = bu(r.y, e.y), a = xu(r.y + r.height, e.y + e.height);
  if (n >= t && a >= i)
    return {
      x: t,
      y: i,
      width: n - t,
      height: a - i
    };
}
function Xd(r, e, t) {
  var n = dist_V({
    rectHover: !0
  }, e), i = n.style = {
    strokeNoScale: !0
  };
  if (t = t || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, r)
    return r.indexOf("image://") === 0 ? (i.image = r.slice(8), dist_se(i, t), new un(n)) : Ud(r.replace("path://", ""), n, t, "center");
}
function B8(r, e, t, n, i) {
  for (var a = 0, o = i[i.length - 1]; a < i.length; a++) {
    var s = i[a];
    if (j_(r, e, t, n, s[0], s[1], o[0], o[1]))
      return !0;
    o = s;
  }
}
function j_(r, e, t, n, i, a, o, s) {
  var l = t - r, u = n - e, f = o - i, c = s - a, h = Ic(f, c, l, u);
  if (F8(h))
    return !1;
  var v = r - i, d = e - a, g = Ic(v, d, l, u) / h;
  if (g < 0 || g > 1)
    return !1;
  var p = Ic(v, d, f, c) / h;
  return !(p < 0 || p > 1);
}
function Ic(r, e, t, n) {
  return r * n - t * e;
}
function F8(r) {
  return r <= 1e-6 && r >= -1e-6;
}
function pf(r) {
  var e = r.itemTooltipOption, t = r.componentModel, n = r.itemName, i = dist_U(e) ? {
    formatter: e
  } : e, a = t.mainType, o = t.componentIndex, s = {
    componentType: a,
    name: n,
    $vars: ["name"]
  };
  s[a + "Index"] = o;
  var l = r.formatterParamsExtra;
  l && dist_M(we(l), function(f) {
    xt(s, f) || (s[f] = l[f], s.$vars.push(f));
  });
  var u = dist_ie(r.el);
  u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
    name: n,
    option: dist_se({
      content: n,
      formatterParams: s
    }, i)
  };
}
function Vg(r, e) {
  var t;
  r.isGroup && (t = e(r)), t || r.traverse(e);
}
function Is(r, e) {
  if (r)
    if (dist_F(r))
      for (var t = 0; t < r.length; t++)
        Vg(r[t], e);
    else
      Vg(r, e);
}
dr("circle", As);
dr("ellipse", zd);
dr("sector", nn);
dr("ring", B_);
dr("polygon", Un);
dr("polyline", cn);
dr("rect", xe);
dr("line", an);
dr("bezierCurve", Gd);
dr("arc", Hd);
const z8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: Hd,
  BezierCurve: Gd,
  BoundingRect: dist_ae,
  Circle: As,
  CompoundPath: $_,
  Ellipse: zd,
  Group: dist_oe,
  Image: un,
  IncrementalDisplayable: M8,
  Line: an,
  LinearGradient: vf,
  OrientedBoundingRect: _u,
  Path: fe,
  Point: dist_K,
  Polygon: Un,
  Polyline: cn,
  RadialGradient: U_,
  Rect: xe,
  Ring: B_,
  Sector: nn,
  Text: Ne,
  applyTransform: Bn,
  clipPointsByRect: k8,
  clipRectByRect: V8,
  createIcon: Xd,
  extendPath: I8,
  extendShape: E8,
  getShapeClass: L8,
  getTransform: Wo,
  groupTransition: K_,
  initProps: Ze,
  isElementRemoved: Ta,
  lineLineIntersect: j_,
  linePolygonIntersect: B8,
  makeImage: X_,
  makePath: Ud,
  mergePath: N8,
  registerShape: dr,
  removeElement: Su,
  removeElementWithFadeOut: wu,
  resizePath: q_,
  setTooltipConfig: pf,
  subPixelOptimize: R8,
  subPixelOptimizeLine: cs,
  subPixelOptimizeRect: P8,
  transformDirection: Yd,
  traverseElements: Is,
  updateProps: Pe
}, Symbol.toStringTag, { value: "Module" }));
var gf = {};
function J_(r, e) {
  for (var t = 0; t < Ct.length; t++) {
    var n = Ct[t], i = e[n], a = r.ensureState(n);
    a.style = a.style || {}, a.style.text = i;
  }
  var o = r.currentStates.slice();
  r.clearStates(!0), r.setStyle({
    text: e.normal
  }), r.useStates(o, !0);
}
function Tv(r, e, t) {
  var n = r.labelFetcher, i = r.labelDataIndex, a = r.labelDimIndex, o = e.normal, s;
  n && (s = n.getFormattedLabel(i, "normal", null, a, o && o.get("formatter"), t != null ? {
    interpolatedValue: t
  } : null)), s == null && (s = dist_j(r.defaultText) ? r.defaultText(i, r, t) : r.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < Ct.length; u++) {
    var f = Ct[u], c = e[f];
    l[f] = dist_ne(n ? n.getFormattedLabel(i, f, null, a, c && c.get("formatter")) : null, s);
  }
  return l;
}
function Yn(r, e, t, n) {
  t = t || gf;
  for (var i = r instanceof Ne, a = !1, o = 0; o < gu.length; o++) {
    var s = e[gu[o]];
    if (s && s.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = i ? r : r.getTextContent();
  if (a) {
    i || (l || (l = new Ne(), r.setTextContent(l)), r.stateProxy && (l.stateProxy = r.stateProxy));
    var u = Tv(t, e), f = e.normal, c = !!f.getShallow("show"), h = Lt(f, n && n.normal, t, !1, !i);
    h.text = u.normal, i || r.setTextConfig(Bg(f, t, !1));
    for (var o = 0; o < Ct.length; o++) {
      var v = Ct[o], s = e[v];
      if (s) {
        var d = l.ensureState(v), g = !!dist_ne(s.getShallow("show"), c);
        if (g !== c && (d.ignore = !g), d.style = Lt(s, n && n[v], t, !0, !i), d.style.text = u[v], !i) {
          var p = r.ensureState(v);
          p.textConfig = Bg(s, t, !0);
        }
      }
    }
    l.silent = !!f.getShallow("silent"), l.style.x != null && (h.x = l.style.x), l.style.y != null && (h.y = l.style.y), l.ignore = !c, l.useStyle(h), l.dirty(), t.enableTextSetter && (Ya(l).setLabelText = function(m) {
      var y = Tv(t, e, m);
      J_(l, y);
    });
  } else
    l && (l.ignore = !0);
  r.dirty();
}
function hn(r, e) {
  e = e || "label";
  for (var t = {
    normal: r.getModel(e)
  }, n = 0; n < Ct.length; n++) {
    var i = Ct[n];
    t[i] = r.getModel([i, e]);
  }
  return t;
}
function Lt(r, e, t, n, i) {
  var a = {};
  return G8(a, r, t, n, i), e && dist_V(a, e), a;
}
function Bg(r, e, t) {
  e = e || {};
  var n = {}, i, a = r.getShallow("rotate"), o = dist_ne(r.getShallow("distance"), t ? null : 5), s = r.getShallow("offset");
  return i = r.getShallow("position") || (t ? null : "inside"), i === "outside" && (i = e.defaultOutsidePosition || "top"), i != null && (n.position = i), s != null && (n.offset = s), a != null && (a *= Math.PI / 180, n.rotation = a), o != null && (n.distance = o), n.outsideFill = r.get("color") === "inherit" ? e.inheritColor || null : "auto", n;
}
function G8(r, e, t, n, i) {
  t = t || gf;
  var a = e.ecModel, o = a && a.option.textStyle, s = H8(e), l;
  if (s) {
    l = {};
    for (var u in s)
      if (s.hasOwnProperty(u)) {
        var f = e.getModel(["rich", u]);
        Hg(l[u] = {}, f, o, t, n, i, !1, !0);
      }
  }
  l && (r.rich = l);
  var c = e.get("overflow");
  c && (r.overflow = c);
  var h = e.get("minMargin");
  h != null && (r.margin = h), Hg(r, e, o, t, n, i, !0, !1);
}
function H8(r) {
  for (var e; r && r !== r.ecModel; ) {
    var t = (r.option || gf).rich;
    if (t) {
      e = e || {};
      for (var n = we(t), i = 0; i < n.length; i++) {
        var a = n[i];
        e[a] = 1;
      }
    }
    r = r.parentModel;
  }
  return e;
}
var Fg = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], zg = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], Gg = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function Hg(r, e, t, n, i, a, o, s) {
  t = !i && t || gf;
  var l = n && n.inheritColor, u = e.getShallow("color"), f = e.getShallow("textBorderColor"), c = dist_ne(e.getShallow("opacity"), t.opacity);
  (u === "inherit" || u === "auto") && ( false && 0, l ? u = l : u = null), (f === "inherit" || f === "auto") && ( false && 0, l ? f = l : f = null), a || (u = u || t.color, f = f || t.textBorderColor), u != null && (r.fill = u), f != null && (r.stroke = f);
  var h = dist_ne(e.getShallow("textBorderWidth"), t.textBorderWidth);
  h != null && (r.lineWidth = h);
  var v = dist_ne(e.getShallow("textBorderType"), t.textBorderType);
  v != null && (r.lineDash = v);
  var d = dist_ne(e.getShallow("textBorderDashOffset"), t.textBorderDashOffset);
  d != null && (r.lineDashOffset = d), !i && c == null && !s && (c = n && n.defaultOpacity), c != null && (r.opacity = c), !i && !a && r.fill == null && n.inheritColor && (r.fill = n.inheritColor);
  for (var g = 0; g < Fg.length; g++) {
    var p = Fg[g], m = dist_ne(e.getShallow(p), t[p]);
    m != null && (r[p] = m);
  }
  for (var g = 0; g < zg.length; g++) {
    var p = zg[g], m = e.getShallow(p);
    m != null && (r[p] = m);
  }
  if (r.verticalAlign == null) {
    var y = e.getShallow("baseline");
    y != null && (r.verticalAlign = y);
  }
  if (!o || !n.disableBox) {
    for (var g = 0; g < Gg.length; g++) {
      var p = Gg[g], m = e.getShallow(p);
      m != null && (r[p] = m);
    }
    var _ = e.getShallow("borderType");
    _ != null && (r.borderDash = _), (r.backgroundColor === "auto" || r.backgroundColor === "inherit") && l && ( false && 0, r.backgroundColor = l), (r.borderColor === "auto" || r.borderColor === "inherit") && l && ( false && 0, r.borderColor = l);
  }
}
function $8(r, e) {
  var t = e && e.getModel("textStyle");
  return or([
    // FIXME in node-canvas fontWeight is before fontStyle
    r.fontStyle || t && t.getShallow("fontStyle") || "",
    r.fontWeight || t && t.getShallow("fontWeight") || "",
    (r.fontSize || t && t.getShallow("fontSize") || 12) + "px",
    r.fontFamily || t && t.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var Ya = Me();
function W8(r, e, t, n) {
  if (r) {
    var i = Ya(r);
    i.prevValue = i.value, i.value = t;
    var a = e.normal;
    i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = n, i.statesModels = e);
  }
}
function U8(r, e, t, n, i) {
  var a = Ya(r);
  if (!a.valueAnimation || a.prevValue === a.value)
    return;
  var o = a.defaultInterpolatedText, s = dist_ne(a.interpolatedValue, a.prevValue), l = a.value;
  function u(f) {
    var c = t_(t, a.precision, s, l, f);
    a.interpolatedValue = f === 1 ? null : c;
    var h = Tv({
      labelDataIndex: e,
      labelFetcher: i,
      defaultText: o ? o(c) : c + ""
    }, a.statesModels, c);
    J_(r, h);
  }
  r.percent = 0, (a.prevValue == null ? Ze : Pe)(r, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, n, e, null, u);
}
var Y8 = ["textStyle", "color"], Lc = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], Nc = new Ne(), X8 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getTextColor = function(e) {
      var t = this.ecModel;
      return this.getShallow("color") || (!e && t ? t.get(Y8) : null);
    }, r.prototype.getFont = function() {
      return $8({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, r.prototype.getTextRect = function(e) {
      for (var t = {
        text: e,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < Lc.length; n++)
        t[Lc[n]] = this.getShallow(Lc[n]);
      return Nc.useStyle(t), Nc.update(), Nc.getBoundingRect();
    }, r;
  }()
);
const Z8 = X8;
var Q_ = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], q8 = fs(Q_), K8 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getLineStyle = function(e) {
      return q8(this, e);
    }, r;
  }()
), e4 = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], j8 = fs(e4), J8 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getItemStyle = function(e, t) {
      return j8(this, e, t);
    }, r;
  }()
), zi = (
  /** @class */
  function() {
    function r(e, t, n) {
      this.parentModel = t, this.ecModel = n, this.option = e;
    }
    return r.prototype.init = function(e, t, n) {
    }, r.prototype.mergeOption = function(e, t) {
      he(this.option, e, !0);
    }, r.prototype.get = function(e, t) {
      return e == null ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel);
    }, r.prototype.getShallow = function(e, t) {
      var n = this.option, i = n == null ? n : n[e];
      if (i == null && !t) {
        var a = this.parentModel;
        a && (i = a.getShallow(e));
      }
      return i;
    }, r.prototype.getModel = function(e, t) {
      var n = e != null, i = n ? this.parsePath(e) : null, a = n ? this._doGet(i) : this.option;
      return t = t || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new r(a, t, this.ecModel);
    }, r.prototype.isEmpty = function() {
      return this.option == null;
    }, r.prototype.restoreData = function() {
    }, r.prototype.clone = function() {
      var e = this.constructor;
      return new e(dist_te(this.option));
    }, r.prototype.parsePath = function(e) {
      return typeof e == "string" ? e.split(".") : e;
    }, r.prototype.resolveParentPath = function(e) {
      return e;
    }, r.prototype.isAnimationEnabled = function() {
      if (!dist_ee.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, r.prototype._doGet = function(e, t) {
      var n = this.option;
      if (!e)
        return n;
      for (var i = 0; i < e.length && !(e[i] && (n = n && typeof n == "object" ? n[e[i]] : null, n == null)); i++)
        ;
      return n == null && t && (n = t._doGet(this.resolveParentPath(e), t.parentModel)), n;
    }, r;
  }()
);
Ld(zi);
zC(zi);
Ot(zi, K8);
Ot(zi, J8);
Ot(zi, UC);
Ot(zi, Z8);
const He = zi;
var Q8 = Math.round(Math.random() * 10);
function Ls(r) {
  return [r || "", Q8++].join("_");
}
function eM(r) {
  var e = {};
  r.registerSubTypeDefaulter = function(t, n) {
    var i = Tr(t);
    e[i.main] = n;
  }, r.determineSubType = function(t, n) {
    var i = n.type;
    if (!i) {
      var a = Tr(t).main;
      r.hasSubTypes(t) && e[a] && (i = e[a](n));
    }
    return i;
  };
}
function tM(r, e) {
  r.topologicalTravel = function(a, o, s, l) {
    if (!a.length)
      return;
    var u = t(o), f = u.graph, c = u.noEntryList, h = {};
    for (dist_M(a, function(y) {
      h[y] = !0;
    }); c.length; ) {
      var v = c.pop(), d = f[v], g = !!h[v];
      g && (s.call(l, v, d.originalDeps.slice()), delete h[v]), dist_M(d.successor, g ? m : p);
    }
    dist_M(h, function() {
      var y = "";
      throw  false && (0), new Error(y);
    });
    function p(y) {
      f[y].entryCount--, f[y].entryCount === 0 && c.push(y);
    }
    function m(y) {
      h[y] = !0, p(y);
    }
  };
  function t(a) {
    var o = {}, s = [];
    return dist_M(a, function(l) {
      var u = n(o, l), f = u.originalDeps = e(l), c = i(f, a);
      u.entryCount = c.length, u.entryCount === 0 && s.push(l), dist_M(c, function(h) {
        ye(u.predecessor, h) < 0 && u.predecessor.push(h);
        var v = n(o, h);
        ye(v.successor, h) < 0 && v.successor.push(l);
      });
    }), {
      graph: o,
      noEntryList: s
    };
  }
  function n(a, o) {
    return a[o] || (a[o] = {
      predecessor: [],
      successor: []
    }), a[o];
  }
  function i(a, o) {
    var s = [];
    return dist_M(a, function(l) {
      ye(o, l) >= 0 && s.push(l);
    }), s;
  }
}
function Xa(r, e) {
  return he(he({}, r, !0), e, !0);
}
const rM = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, nM = {
  time: {
    month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
    dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
  },
  legend: {
    selector: {
      all: "全选",
      inverse: "反选"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "矩形选择",
        polygon: "圈选",
        lineX: "横向选择",
        lineY: "纵向选择",
        keep: "保持选择",
        clear: "清除选择"
      }
    },
    dataView: {
      title: "数据视图",
      lang: ["数据视图", "关闭", "刷新"]
    },
    dataZoom: {
      title: {
        zoom: "区域缩放",
        back: "区域缩放还原"
      }
    },
    magicType: {
      title: {
        line: "切换为折线图",
        bar: "切换为柱状图",
        stack: "切换为堆叠",
        tiled: "切换为平铺"
      }
    },
    restore: {
      title: "还原"
    },
    saveAsImage: {
      title: "保存为图片",
      lang: ["右键另存为图片"]
    }
  },
  series: {
    typeNames: {
      pie: "饼图",
      bar: "柱状图",
      line: "折线图",
      scatter: "散点图",
      effectScatter: "涟漪散点图",
      radar: "雷达图",
      tree: "树图",
      treemap: "矩形树图",
      boxplot: "箱型图",
      candlestick: "K线图",
      k: "K线图",
      heatmap: "热力图",
      map: "地图",
      parallel: "平行坐标图",
      lines: "线图",
      graph: "关系图",
      sankey: "桑基图",
      funnel: "漏斗图",
      gauge: "仪表盘图",
      pictorialBar: "象形柱图",
      themeRiver: "主题河流图",
      sunburst: "旭日图",
      custom: "自定义图表",
      chart: "图表"
    }
  },
  aria: {
    general: {
      withTitle: "这是一个关于“{title}”的图表。",
      withoutTitle: "这是一个图表，"
    },
    series: {
      single: {
        prefix: "",
        withName: "图表类型是{seriesType}，表示{seriesName}。",
        withoutName: "图表类型是{seriesType}。"
      },
      multiple: {
        prefix: "它由{seriesCount}个图表系列组成。",
        withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
        withoutName: "第{seriesId}个系列是一个{seriesType}，",
        separator: {
          middle: "；",
          end: "。"
        }
      }
    },
    data: {
      allData: "其数据是——",
      partialData: "其中，前{displayCnt}项是——",
      withName: "{name}的数据是{value}",
      withoutName: "{value}",
      separator: {
        middle: "，",
        end: ""
      }
    }
  }
};
var Cu = "ZH", Zd = "EN", Ma = Zd, ql = {}, qd = {}, t4 = dist_ee.domSupported ? function() {
  var r = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || Ma).toUpperCase()
  );
  return r.indexOf(Cu) > -1 ? Cu : Ma;
}() : Ma;
function r4(r, e) {
  r = r.toUpperCase(), qd[r] = new He(e), ql[r] = e;
}
function iM(r) {
  if (dist_U(r)) {
    var e = ql[r.toUpperCase()] || {};
    return r === Cu || r === Zd ? dist_te(e) : he(dist_te(e), dist_te(ql[Ma]), !1);
  } else
    return he(dist_te(r), dist_te(ql[Ma]), !1);
}
function aM(r) {
  return qd[r];
}
function oM() {
  return qd[Ma];
}
r4(Zd, rM);
r4(Cu, nM);
var Kd = 1e3, jd = Kd * 60, Uo = jd * 60, Yt = Uo * 24, $g = Yt * 365, No = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, ll = "{yyyy}-{MM}-{dd}", Wg = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: ll,
  hour: ll + " " + No.hour,
  minute: ll + " " + No.minute,
  second: ll + " " + No.second,
  millisecond: No.none
}, Pc = ["year", "month", "day", "hour", "minute", "second", "millisecond"], n4 = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function mn(r, e) {
  return r += "", "0000".substr(0, e - r.length) + r;
}
function Da(r) {
  switch (r) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return r;
  }
}
function sM(r) {
  return r === Da(r);
}
function lM(r) {
  switch (r) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function mf(r, e, t, n) {
  var i = en(r), a = i[Jd(t)](), o = i[Ea(t)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = i[yf(t)](), u = i["get" + (t ? "UTC" : "") + "Day"](), f = i[hs(t)](), c = (f - 1) % 12 + 1, h = i[_f(t)](), v = i[Sf(t)](), d = i[wf(t)](), g = n instanceof He ? n : aM(n || t4) || oM(), p = g.getModel("time"), m = p.get("month"), y = p.get("monthAbbr"), _ = p.get("dayOfWeek"), S = p.get("dayOfWeekAbbr");
  return (e || "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, mn(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, m[o - 1]).replace(/{MMM}/g, y[o - 1]).replace(/{MM}/g, mn(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, mn(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, _[u]).replace(/{ee}/g, S[u]).replace(/{e}/g, u + "").replace(/{HH}/g, mn(f, 2)).replace(/{H}/g, f + "").replace(/{hh}/g, mn(c + "", 2)).replace(/{h}/g, c + "").replace(/{mm}/g, mn(h, 2)).replace(/{m}/g, h + "").replace(/{ss}/g, mn(v, 2)).replace(/{s}/g, v + "").replace(/{SSS}/g, mn(d, 3)).replace(/{S}/g, d + "");
}
function uM(r, e, t, n, i) {
  var a = null;
  if (dist_U(t))
    a = t;
  else if (dist_j(t))
    a = t(r.value, e, {
      level: r.level
    });
  else {
    var o = dist_V({}, No);
    if (r.level > 0)
      for (var s = 0; s < Pc.length; ++s)
        o[Pc[s]] = "{primary|" + o[Pc[s]] + "}";
    var l = t ? t.inherit === !1 ? t : dist_se(t, o) : o, u = i4(r.value, i);
    if (l[u])
      a = l[u];
    else if (l.inherit) {
      for (var f = n4.indexOf(u), s = f - 1; s >= 0; --s)
        if (l[u]) {
          a = l[u];
          break;
        }
      a = a || o.none;
    }
    if (dist_F(a)) {
      var c = r.level == null ? 0 : r.level >= 0 ? r.level : a.length + r.level;
      c = Math.min(c, a.length - 1), a = a[c];
    }
  }
  return mf(new Date(r.value), a, i, n);
}
function i4(r, e) {
  var t = en(r), n = t[Ea(e)]() + 1, i = t[yf(e)](), a = t[hs(e)](), o = t[_f(e)](), s = t[Sf(e)](), l = t[wf(e)](), u = l === 0, f = u && s === 0, c = f && o === 0, h = c && a === 0, v = h && i === 1, d = v && n === 1;
  return d ? "year" : v ? "month" : h ? "day" : c ? "hour" : f ? "minute" : u ? "second" : "millisecond";
}
function Ug(r, e, t) {
  var n = ve(r) ? en(r) : r;
  switch (e = e || i4(r, t), e) {
    case "year":
      return n[Jd(t)]();
    case "half-year":
      return n[Ea(t)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((n[Ea(t)]() + 1) / 4);
    case "month":
      return n[Ea(t)]();
    case "day":
      return n[yf(t)]();
    case "half-day":
      return n[hs(t)]() / 24;
    case "hour":
      return n[hs(t)]();
    case "minute":
      return n[_f(t)]();
    case "second":
      return n[Sf(t)]();
    case "millisecond":
      return n[wf(t)]();
  }
}
function Jd(r) {
  return r ? "getUTCFullYear" : "getFullYear";
}
function Ea(r) {
  return r ? "getUTCMonth" : "getMonth";
}
function yf(r) {
  return r ? "getUTCDate" : "getDate";
}
function hs(r) {
  return r ? "getUTCHours" : "getHours";
}
function _f(r) {
  return r ? "getUTCMinutes" : "getMinutes";
}
function Sf(r) {
  return r ? "getUTCSeconds" : "getSeconds";
}
function wf(r) {
  return r ? "getUTCMilliseconds" : "getMilliseconds";
}
function fM(r) {
  return r ? "setUTCFullYear" : "setFullYear";
}
function a4(r) {
  return r ? "setUTCMonth" : "setMonth";
}
function o4(r) {
  return r ? "setUTCDate" : "setDate";
}
function s4(r) {
  return r ? "setUTCHours" : "setHours";
}
function l4(r) {
  return r ? "setUTCMinutes" : "setMinutes";
}
function u4(r) {
  return r ? "setUTCSeconds" : "setSeconds";
}
function f4(r) {
  return r ? "setUTCMilliseconds" : "setMilliseconds";
}
function c4(r) {
  if (!q3(r))
    return dist_U(r) ? r : "-";
  var e = (r + "").split(".");
  return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "");
}
function h4(r, e) {
  return r = (r || "").toLowerCase().replace(/-(.)/g, function(t, n) {
    return n.toUpperCase();
  }), e && r && (r = r.charAt(0).toUpperCase() + r.slice(1)), r;
}
var Ns = _3;
function Mv(r, e, t) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function i(f) {
    return f && or(f) ? f : "-";
  }
  function a(f) {
    return !!(f != null && !isNaN(f) && isFinite(f));
  }
  var o = e === "time", s = r instanceof Date;
  if (o || s) {
    var l = o ? en(r) : r;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else
      return mf(l, n, t);
  }
  if (e === "ordinal")
    return ou(r) ? i(r) : ve(r) && a(r) ? r + "" : "-";
  var u = $n(r);
  return a(u) ? c4(u) : ou(r) ? i(r) : typeof r == "boolean" ? r + "" : "-";
}
var Yg = ["a", "b", "c", "d", "e", "f", "g"], Rc = function(r, e) {
  return "{" + r + (e ?? "") + "}";
};
function v4(r, e, t) {
  dist_F(e) || (e = [e]);
  var n = e.length;
  if (!n)
    return "";
  for (var i = e[0].$vars || [], a = 0; a < i.length; a++) {
    var o = Yg[a];
    r = r.replace(Rc(o), Rc(o, 0));
  }
  for (var s = 0; s < n; s++)
    for (var l = 0; l < i.length; l++) {
      var u = e[s][i[l]];
      r = r.replace(Rc(Yg[l], s), t ? Wt(u) : u);
    }
  return r;
}
function cM(r, e) {
  var t = dist_U(r) ? {
    color: r,
    extraCssText: e
  } : r || {}, n = t.color, i = t.type;
  e = t.extraCssText;
  var a = t.renderMode || "html";
  if (!n)
    return "";
  if (a === "html")
    return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Wt(n) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Wt(n) + ";" + (e || "") + '"></span>';
  var o = t.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + o + "|}  ",
    style: i === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function Bi(r, e) {
  return e = e || "transparent", dist_U(r) ? r : dist_X(r) && r.colorStops && (r.colorStops[0] || {}).color || e;
}
function Xg(r, e) {
  if (e === "_blank" || e === "blank") {
    var t = window.open();
    t.opener = null, t.location.href = r;
  } else
    window.open(r, e);
}
var Kl = dist_M, hM = ["left", "right", "top", "bottom", "width", "height"], ul = [["width", "left", "right"], ["height", "top", "bottom"]];
function Qd(r, e, t, n, i) {
  var a = 0, o = 0;
  n == null && (n = 1 / 0), i == null && (i = 1 / 0);
  var s = 0;
  e.eachChild(function(l, u) {
    var f = l.getBoundingRect(), c = e.childAt(u + 1), h = c && c.getBoundingRect(), v, d;
    if (r === "horizontal") {
      var g = f.width + (h ? -h.x + f.x : 0);
      v = a + g, v > n || l.newline ? (a = 0, v = g, o += s + t, s = f.height) : s = Math.max(s, f.height);
    } else {
      var p = f.height + (h ? -h.y + f.y : 0);
      d = o + p, d > i || l.newline ? (a += s + t, o = 0, d = p, s = f.width) : s = Math.max(s, f.width);
    }
    l.newline || (l.x = a, l.y = o, l.markRedraw(), r === "horizontal" ? a = v + t : o = d + t);
  });
}
var Aa = Qd;
Te(Qd, "vertical");
Te(Qd, "horizontal");
function cr(r, e, t) {
  t = Ns(t || 0);
  var n = e.width, i = e.height, a = me(r.left, n), o = me(r.top, i), s = me(r.right, n), l = me(r.bottom, i), u = me(r.width, n), f = me(r.height, i), c = t[2] + t[0], h = t[1] + t[3], v = r.aspect;
  switch (isNaN(u) && (u = n - s - h - a), isNaN(f) && (f = i - l - c - o), v != null && (isNaN(u) && isNaN(f) && (v > n / i ? u = n * 0.8 : f = i * 0.8), isNaN(u) && (u = v * f), isNaN(f) && (f = u / v)), isNaN(a) && (a = n - s - u - h), isNaN(o) && (o = i - l - f - c), r.left || r.right) {
    case "center":
      a = n / 2 - u / 2 - t[3];
      break;
    case "right":
      a = n - u - h;
      break;
  }
  switch (r.top || r.bottom) {
    case "middle":
    case "center":
      o = i / 2 - f / 2 - t[0];
      break;
    case "bottom":
      o = i - f - c;
      break;
  }
  a = a || 0, o = o || 0, isNaN(u) && (u = n - h - a - (s || 0)), isNaN(f) && (f = i - c - o - (l || 0));
  var d = new dist_ae(a + t[3], o + t[0], u, f);
  return d.margin = t, d;
}
function vM(r, e, t, n, i, a) {
  var o = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
  if (a = a || r, a.x = r.x, a.y = r.y, !o && !s)
    return !1;
  var u;
  if (l === "raw")
    u = r.type === "group" ? new dist_ae(0, 0, +e.width || 0, +e.height || 0) : r.getBoundingRect();
  else if (u = r.getBoundingRect(), r.needLocalTransform()) {
    var f = r.getLocalTransform();
    u = u.clone(), u.applyTransform(f);
  }
  var c = cr(dist_se({
    width: u.width,
    height: u.height
  }, e), t, n), h = o ? c.x - u.x : 0, v = s ? c.y - u.y : 0;
  return l === "raw" ? (a.x = h, a.y = v) : (a.x += h, a.y += v), a === r && r.markRedraw(), !0;
}
function vs(r) {
  var e = r.layoutMode || r.constructor.layoutMode;
  return dist_X(e) ? e : e ? {
    type: e
  } : null;
}
function ka(r, e, t) {
  var n = t && t.ignoreSize;
  !dist_F(n) && (n = [n, n]);
  var i = o(ul[0], 0), a = o(ul[1], 1);
  u(ul[0], r, i), u(ul[1], r, a);
  function o(f, c) {
    var h = {}, v = 0, d = {}, g = 0, p = 2;
    if (Kl(f, function(_) {
      d[_] = r[_];
    }), Kl(f, function(_) {
      s(e, _) && (h[_] = d[_] = e[_]), l(h, _) && v++, l(d, _) && g++;
    }), n[c])
      return l(e, f[1]) ? d[f[2]] = null : l(e, f[2]) && (d[f[1]] = null), d;
    if (g === p || !v)
      return d;
    if (v >= p)
      return h;
    for (var m = 0; m < f.length; m++) {
      var y = f[m];
      if (!s(h, y) && s(r, y)) {
        h[y] = r[y];
        break;
      }
    }
    return h;
  }
  function s(f, c) {
    return f.hasOwnProperty(c);
  }
  function l(f, c) {
    return f[c] != null && f[c] !== "auto";
  }
  function u(f, c, h) {
    Kl(f, function(v) {
      c[v] = h[v];
    });
  }
}
function Ps(r) {
  return dM({}, r);
}
function dM(r, e) {
  return e && r && Kl(hM, function(t) {
    e.hasOwnProperty(t) && (r[t] = e[t]);
  }), r;
}
var pM = Me(), Za = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i) {
      var a = r.call(this, t, n, i) || this;
      return a.uid = Ls("ec_cpt_model"), a;
    }
    return e.prototype.init = function(t, n, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.mergeDefaultAndTheme = function(t, n) {
      var i = vs(this), a = i ? Ps(t) : {}, o = n.getTheme();
      he(t, o.get(this.mainType)), he(t, this.getDefaultOption()), i && ka(t, a, i);
    }, e.prototype.mergeOption = function(t, n) {
      he(this.option, t, !0);
      var i = vs(this);
      i && ka(this.option, t, i);
    }, e.prototype.optionUpdated = function(t, n) {
    }, e.prototype.getDefaultOption = function() {
      var t = this.constructor;
      if (!VC(t))
        return t.defaultOption;
      var n = pM(this);
      if (!n.defaultOption) {
        for (var i = [], a = t; a; ) {
          var o = a.prototype.defaultOption;
          o && i.push(o), a = a.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--)
          s = he(s, i[l], !0);
        n.defaultOption = s;
      }
      return n.defaultOption;
    }, e.prototype.getReferringComponents = function(t, n) {
      var i = t + "Index", a = t + "Id";
      return Es(this.ecModel, t, {
        index: this.get(i, !0),
        id: this.get(a, !0)
      }, n);
    }, e.prototype.getBoxLayoutParams = function() {
      var t = this;
      return {
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      };
    }, e.prototype.getZLevelKey = function() {
      return "";
    }, e.prototype.setZLevel = function(t) {
      this.option.zlevel = t;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0;
    }(), e;
  }(He)
);
n_(Za, He);
sf(Za);
eM(Za);
tM(Za, gM);
function gM(r) {
  var e = [];
  return dist_M(Za.getClassesByMainType(r), function(t) {
    e = e.concat(t.dependencies || t.prototype.dependencies || []);
  }), e = dist_$(e, function(t) {
    return Tr(t).main;
  }), r !== "dataset" && ye(e, "dataset") <= 0 && e.unshift("dataset"), e;
}
const Se = Za;
var d4 = "";
typeof navigator < "u" && (d4 = navigator.platform || "");
var ta = "rgba(0, 0, 0, 0.2)";
const mM = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: ta,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: ta,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: ta,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: ta,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: ta,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: ta,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: d4.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var Dv = dist_W(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Jt = "original", vt = "arrayRows", Qt = "objectRows", Nr = "keyedColumns", qr = "typedArray", p4 = "unknown", Er = "column", qa = "row", Ye = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, g4 = Me();
function yM(r) {
  g4(r).datasetMap = dist_W();
}
function _M(r, e, t) {
  var n = {}, i = e0(e);
  if (!i || !r)
    return n;
  var a = [], o = [], s = e.ecModel, l = g4(s).datasetMap, u = i.uid + "_" + t.seriesLayoutBy, f, c;
  r = r.slice(), dist_M(r, function(g, p) {
    var m = dist_X(g) ? g : r[p] = {
      name: g
    };
    m.type === "ordinal" && f == null && (f = p, c = d(m)), n[m.name] = [];
  });
  var h = l.get(u) || l.set(u, {
    categoryWayDim: c,
    valueWayDim: 0
  });
  dist_M(r, function(g, p) {
    var m = g.name, y = d(g);
    if (f == null) {
      var _ = h.valueWayDim;
      v(n[m], _, y), v(o, _, y), h.valueWayDim += y;
    } else if (f === p)
      v(n[m], 0, y), v(a, 0, y);
    else {
      var _ = h.categoryWayDim;
      v(n[m], _, y), v(o, _, y), h.categoryWayDim += y;
    }
  });
  function v(g, p, m) {
    for (var y = 0; y < m; y++)
      g.push(p + y);
  }
  function d(g) {
    var p = g.dimsDef;
    return p ? p.length : 1;
  }
  return a.length && (n.itemName = a), o.length && (n.seriesName = o), n;
}
function m4(r, e, t) {
  var n = {}, i = e0(r);
  if (!i)
    return n;
  var a = e.sourceFormat, o = e.dimensionsDefine, s;
  (a === Qt || a === Nr) && dist_M(o, function(f, c) {
    (dist_X(f) ? f.name : f) === "name" && (s = c);
  });
  var l = function() {
    for (var f = {}, c = {}, h = [], v = 0, d = Math.min(5, t); v < d; v++) {
      var g = _4(e.data, a, e.seriesLayoutBy, o, e.startIndex, v);
      h.push(g);
      var p = g === Ye.Not;
      if (p && f.v == null && v !== s && (f.v = v), (f.n == null || f.n === f.v || !p && h[f.n] === Ye.Not) && (f.n = v), m(f) && h[f.n] !== Ye.Not)
        return f;
      p || (g === Ye.Might && c.v == null && v !== s && (c.v = v), (c.n == null || c.n === c.v) && (c.n = v));
    }
    function m(y) {
      return y.v != null && y.n != null;
    }
    return m(f) ? f : m(c) ? c : null;
  }();
  if (l) {
    n.value = [l.v];
    var u = s ?? l.n;
    n.itemName = [u], n.seriesName = [u];
  }
  return n;
}
function e0(r) {
  var e = r.get("data", !0);
  if (!e)
    return Es(r.ecModel, "dataset", {
      index: r.get("datasetIndex", !0),
      id: r.get("datasetId", !0)
    }, ft).models[0];
}
function SM(r) {
  return !r.get("transform", !0) && !r.get("fromTransformResult", !0) ? [] : Es(r.ecModel, "dataset", {
    index: r.get("fromDatasetIndex", !0),
    id: r.get("fromDatasetId", !0)
  }, ft).models;
}
function y4(r, e) {
  return _4(r.data, r.sourceFormat, r.seriesLayoutBy, r.dimensionsDefine, r.startIndex, e);
}
function _4(r, e, t, n, i, a) {
  var o, s = 5;
  if (ht(r))
    return Ye.Not;
  var l, u;
  if (n) {
    var f = n[a];
    dist_X(f) ? (l = f.name, u = f.type) : dist_U(f) && (l = f);
  }
  if (u != null)
    return u === "ordinal" ? Ye.Must : Ye.Not;
  if (e === vt) {
    var c = r;
    if (t === qa) {
      for (var h = c[a], v = 0; v < (h || []).length && v < s; v++)
        if ((o = S(h[i + v])) != null)
          return o;
    } else
      for (var v = 0; v < c.length && v < s; v++) {
        var d = c[i + v];
        if (d && (o = S(d[a])) != null)
          return o;
      }
  } else if (e === Qt) {
    var g = r;
    if (!l)
      return Ye.Not;
    for (var v = 0; v < g.length && v < s; v++) {
      var p = g[v];
      if (p && (o = S(p[l])) != null)
        return o;
    }
  } else if (e === Nr) {
    var m = r;
    if (!l)
      return Ye.Not;
    var h = m[l];
    if (!h || ht(h))
      return Ye.Not;
    for (var v = 0; v < h.length && v < s; v++)
      if ((o = S(h[v])) != null)
        return o;
  } else if (e === Jt)
    for (var y = r, v = 0; v < y.length && v < s; v++) {
      var p = y[v], _ = Ds(p);
      if (!dist_F(_))
        return Ye.Not;
      if ((o = S(_[a])) != null)
        return o;
    }
  function S(b) {
    var w = dist_U(b);
    if (b != null && isFinite(b) && b !== "")
      return w ? Ye.Might : Ye.Not;
    if (w && b !== "-")
      return Ye.Must;
  }
  return Ye.Not;
}
var wM = dist_W();
function bM(r, e, t) {
  var n = wM.get(e);
  if (!n)
    return t;
  var i = n(r);
  if (!i)
    return t;
  if (false)
    { var a; }
  return t.concat(i);
}
var Zg = Me();
Me();
var t0 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getColorFromPalette = function(e, t, n) {
      var i = Ae(this.get("color", !0)), a = this.get("colorLayer", !0);
      return CM(this, Zg, i, a, e, t, n);
    }, r.prototype.clearColorPalette = function() {
      TM(this, Zg);
    }, r;
  }()
);
function xM(r, e) {
  for (var t = r.length, n = 0; n < t; n++)
    if (r[n].length > e)
      return r[n];
  return r[t - 1];
}
function CM(r, e, t, n, i, a, o) {
  a = a || r;
  var s = e(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(i))
    return u[i];
  var f = o == null || !n ? t : xM(n, o);
  if (f = f || t, !(!f || !f.length)) {
    var c = f[l];
    return i && (u[i] = c), s.paletteIdx = (l + 1) % f.length, c;
  }
}
function TM(r, e) {
  e(r).paletteIdx = 0, e(r).paletteNameMap = {};
}
var fl, lo, qg, Oc = "\0_ec_inner", Kg = 1, MM = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, DM = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, Tu = {};
function EM(r) {
  dist_M(r, function(e, t) {
    if (!Se.hasClass(t)) {
      var n = MM[t];
      n && !Tu[n] && (Ke("Component " + t + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), Tu[n] = !0);
    }
  });
}
var r0 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, n, i, a, o, s) {
      a = a || {}, this.option = null, this._theme = new He(a), this._locale = new He(o), this._optionManager = s;
    }, e.prototype.setOption = function(t, n, i) {
       false && (0);
      var a = Qg(n);
      this._optionManager.setOption(t, i, a), this._resetOption(null, a);
    }, e.prototype.resetOption = function(t, n) {
      return this._resetOption(t, Qg(n));
    }, e.prototype._resetOption = function(t, n) {
      var i = !1, a = this._optionManager;
      if (!t || t === "recreate") {
        var o = a.mountOption(t === "recreate");
         false && 0, !this.option || t === "recreate" ? qg(this, o) : (this.restoreData(), this._mergeOption(o, n)), i = !0;
      }
      if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") {
        var s = a.getTimelineOption(this);
        s && (i = !0, this._mergeOption(s, n));
      }
      if (!t || t === "recreate" || t === "media") {
        var l = a.getMediaOption(this);
        l.length && dist_M(l, function(u) {
          i = !0, this._mergeOption(u, n);
        }, this);
      }
      return i;
    }, e.prototype.mergeOption = function(t) {
      this._mergeOption(t, null);
    }, e.prototype._mergeOption = function(t, n) {
      var i = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = dist_W(), u = n && n.replaceMergeMainTypeMap;
      yM(this), dist_M(t, function(c, h) {
        c != null && (Se.hasClass(h) ? h && (s.push(h), l.set(h, !0)) : i[h] = i[h] == null ? dist_te(c) : he(i[h], c, !0));
      }), u && u.each(function(c, h) {
        Se.hasClass(h) && !l.get(h) && (s.push(h), l.set(h, !0));
      }), Se.topologicalTravel(s, Se.getAllClassMainTypes(), f, this);
      function f(c) {
        var h = bM(this, c, Ae(t[c])), v = a.get(c), d = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          v ? u && u.get(c) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = wC(v, h, d);
        EC(g, c, Se), i[c] = null, a.set(c, null), o.set(c, 0);
        var p = [], m = [], y = 0, _, S;
        dist_M(g, function(b, w) {
          var x = b.existing, C = b.newOption;
          if (!C)
            x && (x.mergeOption({}, this), x.optionUpdated({}, !1));
          else {
            var T = c === "series", E = Se.getClass(
              c,
              b.keyInfo.subType,
              !T
              // Give a more detailed warn later if series don't exists
            );
            if (!E) {
              if (false) { var D, I; }
              return;
            }
            if (c === "tooltip") {
              if (_) {
                 false && (0);
                return;
              }
              _ = !0;
            }
            if (x && x.constructor === E)
              x.name = b.keyInfo.name, x.mergeOption(C, this), x.optionUpdated(C, !1);
            else {
              var L = dist_V({
                componentIndex: w
              }, b.keyInfo);
              x = new E(C, this, this, L), dist_V(x, L), b.brandNew && (x.__requireNewView = !0), x.init(C, this, this), x.optionUpdated(null, !0);
            }
          }
          x ? (p.push(x.option), m.push(x), y++) : (p.push(void 0), m.push(void 0));
        }, this), i[c] = p, a.set(c, m), o.set(c, y), c === "series" && fl(this);
      }
      this._seriesIndices || fl(this);
    }, e.prototype.getOption = function() {
      var t = dist_te(this.option);
      return dist_M(t, function(n, i) {
        if (Se.hasClass(i)) {
          for (var a = Ae(n), o = a.length, s = !1, l = o - 1; l >= 0; l--)
            a[l] && !Na(a[l]) ? s = !0 : (a[l] = null, !s && o--);
          a.length = o, t[i] = a;
        }
      }), delete t[Oc], t;
    }, e.prototype.getTheme = function() {
      return this._theme;
    }, e.prototype.getLocaleModel = function() {
      return this._locale;
    }, e.prototype.setUpdatePayload = function(t) {
      this._payload = t;
    }, e.prototype.getUpdatePayload = function() {
      return this._payload;
    }, e.prototype.getComponent = function(t, n) {
      var i = this._componentsMap.get(t);
      if (i) {
        var a = i[n || 0];
        if (a)
          return a;
        if (n == null) {
          for (var o = 0; o < i.length; o++)
            if (i[o])
              return i[o];
        }
      }
    }, e.prototype.queryComponents = function(t) {
      var n = t.mainType;
      if (!n)
        return [];
      var i = t.index, a = t.id, o = t.name, s = this._componentsMap.get(n);
      if (!s || !s.length)
        return [];
      var l;
      return i != null ? (l = [], dist_M(Ae(i), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = jg("id", a, s) : o != null ? l = jg("name", o, s) : l = ke(s, function(u) {
        return !!u;
      }), Jg(l, t);
    }, e.prototype.findComponents = function(t) {
      var n = t.query, i = t.mainType, a = s(n), o = a ? this.queryComponents(a) : ke(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(Jg(o, t));
      function s(u) {
        var f = i + "Index", c = i + "Id", h = i + "Name";
        return u && (u[f] != null || u[c] != null || u[h] != null) ? {
          mainType: i,
          // subType will be filtered finally.
          index: u[f],
          id: u[c],
          name: u[h]
        } : null;
      }
      function l(u) {
        return t.filter ? ke(u, t.filter) : u;
      }
    }, e.prototype.eachComponent = function(t, n, i) {
      var a = this._componentsMap;
      if (dist_j(t)) {
        var o = n, s = t;
        a.each(function(c, h) {
          for (var v = 0; c && v < c.length; v++) {
            var d = c[v];
            d && s.call(o, h, d, d.componentIndex);
          }
        });
      } else
        for (var l = dist_U(t) ? a.get(t) : dist_X(t) ? this.findComponents(t) : null, u = 0; l && u < l.length; u++) {
          var f = l[u];
          f && n.call(i, f, f.componentIndex);
        }
    }, e.prototype.getSeriesByName = function(t) {
      var n = Zt(t, null);
      return ke(this._componentsMap.get("series"), function(i) {
        return !!i && n != null && i.name === n;
      });
    }, e.prototype.getSeriesByIndex = function(t) {
      return this._componentsMap.get("series")[t];
    }, e.prototype.getSeriesByType = function(t) {
      return ke(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === t;
      });
    }, e.prototype.getSeries = function() {
      return ke(this._componentsMap.get("series"), function(t) {
        return !!t;
      });
    }, e.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, e.prototype.eachSeries = function(t, n) {
      lo(this), dist_M(this._seriesIndices, function(i) {
        var a = this._componentsMap.get("series")[i];
        t.call(n, a, i);
      }, this);
    }, e.prototype.eachRawSeries = function(t, n) {
      dist_M(this._componentsMap.get("series"), function(i) {
        i && t.call(n, i, i.componentIndex);
      });
    }, e.prototype.eachSeriesByType = function(t, n, i) {
      lo(this), dist_M(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === t && n.call(i, o, a);
      }, this);
    }, e.prototype.eachRawSeriesByType = function(t, n, i) {
      return dist_M(this.getSeriesByType(t), n, i);
    }, e.prototype.isSeriesFiltered = function(t) {
      return lo(this), this._seriesIndicesMap.get(t.componentIndex) == null;
    }, e.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, e.prototype.filterSeries = function(t, n) {
      lo(this);
      var i = [];
      dist_M(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        t.call(n, o, a) && i.push(a);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = dist_W(i);
    }, e.prototype.restoreData = function(t) {
      fl(this);
      var n = this._componentsMap, i = [];
      n.each(function(a, o) {
        Se.hasClass(o) && i.push(o);
      }), Se.topologicalTravel(i, Se.getAllClassMainTypes(), function(a) {
        dist_M(n.get(a), function(o) {
          o && (a !== "series" || !AM(o, t)) && o.restoreData();
        });
      });
    }, e.internalField = function() {
      fl = function(t) {
        var n = t._seriesIndices = [];
        dist_M(t._componentsMap.get("series"), function(i) {
          i && n.push(i.componentIndex);
        }), t._seriesIndicesMap = dist_W(n);
      }, lo = function(t) {
        if (false)
          {}
      }, qg = function(t, n) {
        t.option = {}, t.option[Oc] = Kg, t._componentsMap = dist_W({
          series: []
        }), t._componentsCount = dist_W();
        var i = n.aria;
        dist_X(i) && i.enabled == null && (i.enabled = !0), IM(n, t._theme.option), he(n, mM, !1), t._mergeOption(n, null);
      };
    }(), e;
  }(He)
);
function AM(r, e) {
  if (e) {
    var t = e.seriesIndex, n = e.seriesId, i = e.seriesName;
    return t != null && r.componentIndex !== t || n != null && r.id !== n || i != null && r.name !== i;
  }
}
function IM(r, e) {
  var t = r.color && !r.colorLayer;
  dist_M(e, function(n, i) {
    i === "colorLayer" && t || Se.hasClass(i) || (typeof n == "object" ? r[i] = r[i] ? he(r[i], n, !1) : dist_te(n) : r[i] == null && (r[i] = n));
  });
}
function jg(r, e, t) {
  if (dist_F(e)) {
    var n = dist_W();
    return dist_M(e, function(a) {
      if (a != null) {
        var o = Zt(a, null);
        o != null && n.set(a, !0);
      }
    }), ke(t, function(a) {
      return a && n.get(a[r]);
    });
  } else {
    var i = Zt(e, null);
    return ke(t, function(a) {
      return a && i != null && a[r] === i;
    });
  }
}
function Jg(r, e) {
  return e.hasOwnProperty("subType") ? ke(r, function(t) {
    return t && t.subType === e.subType;
  }) : r;
}
function Qg(r) {
  var e = dist_W();
  return r && dist_M(Ae(r.replaceMerge), function(t) {
     false && 0, e.set(t, !0);
  }), {
    replaceMergeMainTypeMap: e
  };
}
Ot(r0, t0);
var LM = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], NM = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      dist_M(LM, function(t) {
        this[t] = dist_Z(e[t], e);
      }, this);
    }
    return r;
  }()
);
const S4 = NM;
var kc = {}, Rs = (
  /** @class */
  function() {
    function r() {
      this._coordinateSystems = [];
    }
    return r.prototype.create = function(e, t) {
      var n = [];
      dist_M(kc, function(i, a) {
        var o = i.create(e, t);
        n = n.concat(o || []);
      }), this._coordinateSystems = n;
    }, r.prototype.update = function(e, t) {
      dist_M(this._coordinateSystems, function(n) {
        n.update && n.update(e, t);
      });
    }, r.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, r.register = function(e, t) {
      kc[e] = t;
    }, r.get = function(e) {
      return kc[e];
    }, r;
  }()
), PM = /^(min|max)?(.+)$/, RM = (
  /** @class */
  function() {
    function r(e) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e;
    }
    return r.prototype.setOption = function(e, t, n) {
      e && (dist_M(Ae(e.series), function(o) {
        o && o.data && ht(o.data) && su(o.data);
      }), dist_M(Ae(e.dataset), function(o) {
        o && o.source && ht(o.source) && su(o.source);
      })), e = dist_te(e);
      var i = this._optionBackup, a = OM(e, t, !i);
      this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, r.prototype.mountOption = function(e) {
      var t = this._optionBackup;
      return this._timelineOptions = t.timelineOptions, this._mediaList = t.mediaList, this._mediaDefault = t.mediaDefault, this._currentMediaIndices = [], dist_te(e ? t.baseOption : this._newBaseOption);
    }, r.prototype.getTimelineOption = function(e) {
      var t, n = this._timelineOptions;
      if (n.length) {
        var i = e.getComponent("timeline");
        i && (t = dist_te(
          // FIXME:TS as TimelineModel or quivlant interface
          n[i.getCurrentIndex()]
        ));
      }
      return t;
    }, r.prototype.getMediaOption = function(e) {
      var t = this._api.getWidth(), n = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!i.length && !a)
        return s;
      for (var l = 0, u = i.length; l < u; l++)
        kM(i[l].query, t, n) && o.push(l);
      return !o.length && a && (o = [-1]), o.length && !BM(o, this._currentMediaIndices) && (s = dist_$(o, function(f) {
        return dist_te(f === -1 ? a.option : i[f].option);
      })), this._currentMediaIndices = o, s;
    }, r;
  }()
);
function OM(r, e, t) {
  var n = [], i, a, o = r.baseOption, s = r.timeline, l = r.options, u = r.media, f = !!r.media, c = !!(l || s || o && o.timeline);
  o ? (a = o, a.timeline || (a.timeline = s)) : ((c || f) && (r.options = r.media = null), a = r), f && (dist_F(u) ? dist_M(u, function(v) {
     false && 0, v && v.option && (v.query ? n.push(v) : i || (i = v));
  }) :  false && 0), h(a), dist_M(l, function(v) {
    return h(v);
  }), dist_M(n, function(v) {
    return h(v.option);
  });
  function h(v) {
    dist_M(e, function(d) {
      d(v, t);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: i,
    mediaList: n
  };
}
function kM(r, e, t) {
  var n = {
    width: e,
    height: t,
    aspectratio: e / t
    // lower case for convenience.
  }, i = !0;
  return dist_M(r, function(a, o) {
    var s = o.match(PM);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      VM(n[u], a, l) || (i = !1);
    }
  }), i;
}
function VM(r, e, t) {
  return t === "min" ? r >= e : t === "max" ? r <= e : r === e;
}
function BM(r, e) {
  return r.join(",") === e.join(",");
}
const FM = RM;
var kt = dist_M, ds = dist_X, e1 = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function Vc(r) {
  var e = r && r.itemStyle;
  if (e)
    for (var t = 0, n = e1.length; t < n; t++) {
      var i = e1[t], a = e.normal, o = e.emphasis;
      a && a[i] && ( false && 0, r[i] = r[i] || {}, r[i].normal ? he(r[i].normal, a[i]) : r[i].normal = a[i], a[i] = null), o && o[i] && ( false && 0, r[i] = r[i] || {}, r[i].emphasis ? he(r[i].emphasis, o[i]) : r[i].emphasis = o[i], o[i] = null);
    }
}
function tt(r, e, t) {
  if (r && r[e] && (r[e].normal || r[e].emphasis)) {
    var n = r[e].normal, i = r[e].emphasis;
    n && ( false && 0, t ? (r[e].normal = r[e].emphasis = null, dist_se(r[e], n)) : r[e] = n), i && ( false && 0, r.emphasis = r.emphasis || {}, r.emphasis[e] = i, i.focus && (r.emphasis.focus = i.focus), i.blurScope && (r.emphasis.blurScope = i.blurScope));
  }
}
function Po(r) {
  tt(r, "itemStyle"), tt(r, "lineStyle"), tt(r, "areaStyle"), tt(r, "label"), tt(r, "labelLine"), tt(r, "upperLabel"), tt(r, "edgeLabel");
}
function Oe(r, e) {
  var t = ds(r) && r[e], n = ds(t) && t.textStyle;
  if (n) {
     false && 0;
    for (var i = 0, a = rg.length; i < a; i++) {
      var o = rg[i];
      n.hasOwnProperty(o) && (t[o] = n[o]);
    }
  }
}
function Ht(r) {
  r && (Po(r), Oe(r, "label"), r.emphasis && Oe(r.emphasis, "label"));
}
function zM(r) {
  if (ds(r)) {
    Vc(r), Po(r), Oe(r, "label"), Oe(r, "upperLabel"), Oe(r, "edgeLabel"), r.emphasis && (Oe(r.emphasis, "label"), Oe(r.emphasis, "upperLabel"), Oe(r.emphasis, "edgeLabel"));
    var e = r.markPoint;
    e && (Vc(e), Ht(e));
    var t = r.markLine;
    t && (Vc(t), Ht(t));
    var n = r.markArea;
    n && Ht(n);
    var i = r.data;
    if (r.type === "graph") {
      i = i || r.nodes;
      var a = r.links || r.edges;
      if (a && !ht(a))
        for (var o = 0; o < a.length; o++)
          Ht(a[o]);
      dist_M(r.categories, function(u) {
        Po(u);
      });
    }
    if (i && !ht(i))
      for (var o = 0; o < i.length; o++)
        Ht(i[o]);
    if (e = r.markPoint, e && e.data)
      for (var s = e.data, o = 0; o < s.length; o++)
        Ht(s[o]);
    if (t = r.markLine, t && t.data)
      for (var l = t.data, o = 0; o < l.length; o++)
        dist_F(l[o]) ? (Ht(l[o][0]), Ht(l[o][1])) : Ht(l[o]);
    r.type === "gauge" ? (Oe(r, "axisLabel"), Oe(r, "title"), Oe(r, "detail")) : r.type === "treemap" ? (tt(r.breadcrumb, "itemStyle"), dist_M(r.levels, function(u) {
      Po(u);
    })) : r.type === "tree" && Po(r.leaves);
  }
}
function kr(r) {
  return dist_F(r) ? r : r ? [r] : [];
}
function t1(r) {
  return (dist_F(r) ? r[0] : r) || {};
}
function GM(r, e) {
  kt(kr(r.series), function(n) {
    ds(n) && zM(n);
  });
  var t = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  e && t.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), kt(t, function(n) {
    kt(kr(r[n]), function(i) {
      i && (Oe(i, "axisLabel"), Oe(i.axisPointer, "label"));
    });
  }), kt(kr(r.parallel), function(n) {
    var i = n && n.parallelAxisDefault;
    Oe(i, "axisLabel"), Oe(i && i.axisPointer, "label");
  }), kt(kr(r.calendar), function(n) {
    tt(n, "itemStyle"), Oe(n, "dayLabel"), Oe(n, "monthLabel"), Oe(n, "yearLabel");
  }), kt(kr(r.radar), function(n) {
    Oe(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name,  false && 0), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap,  false && 0),  false && 0;
  }), kt(kr(r.geo), function(n) {
    ds(n) && (Ht(n), kt(kr(n.regions), function(i) {
      Ht(i);
    }));
  }), kt(kr(r.timeline), function(n) {
    Ht(n), tt(n, "label"), tt(n, "itemStyle"), tt(n, "controlStyle", !0);
    var i = n.data;
    dist_F(i) && dist_M(i, function(a) {
      dist_X(a) && (tt(a, "label"), tt(a, "itemStyle"));
    });
  }), kt(kr(r.toolbox), function(n) {
    tt(n, "iconStyle"), kt(n.feature, function(i) {
      tt(i, "iconStyle");
    });
  }), Oe(t1(r.axisPointer), "label"), Oe(t1(r.tooltip).axisPointer, "label");
}
function HM(r, e) {
  for (var t = e.split(","), n = r, i = 0; i < t.length && (n = n && n[t[i]], n != null); i++)
    ;
  return n;
}
function $M(r, e, t, n) {
  for (var i = e.split(","), a = r, o, s = 0; s < i.length - 1; s++)
    o = i[s], a[o] == null && (a[o] = {}), a = a[o];
  (n || a[i[s]] == null) && (a[i[s]] = t);
}
function r1(r) {
  r && dist_M(WM, function(e) {
    e[0] in r && !(e[1] in r) && (r[e[1]] = r[e[0]]);
  });
}
var WM = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], UM = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], Bc = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function uo(r) {
  var e = r && r.itemStyle;
  if (e)
    for (var t = 0; t < Bc.length; t++) {
      var n = Bc[t][1], i = Bc[t][0];
      e[n] != null && (e[i] = e[n],  false && 0);
    }
}
function n1(r) {
  r && r.alignTo === "edge" && r.margin != null && r.edgeDistance == null && ( false && 0, r.edgeDistance = r.margin);
}
function i1(r) {
  r && r.downplay && !r.blur && (r.blur = r.downplay,  false && 0);
}
function YM(r) {
  r && r.focusNodeAdjacency != null && (r.emphasis = r.emphasis || {}, r.emphasis.focus == null && ( false && 0, r.emphasis.focus = "adjacency"));
}
function w4(r, e) {
  if (r)
    for (var t = 0; t < r.length; t++)
      e(r[t]), r[t] && w4(r[t].children, e);
}
function b4(r, e) {
  GM(r, e), r.series = Ae(r.series), dist_M(r.series, function(t) {
    if (dist_X(t)) {
      var n = t.type;
      if (n === "line")
        t.clipOverflow != null && (t.clip = t.clipOverflow,  false && 0);
      else if (n === "pie" || n === "gauge") {
        t.clockWise != null && (t.clockwise = t.clockWise,  false && 0), n1(t.label);
        var i = t.data;
        if (i && !ht(i))
          for (var a = 0; a < i.length; a++)
            n1(i[a]);
        t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && ( false && 0, t.emphasis.scaleSize = t.hoverOffset));
      } else if (n === "gauge") {
        var o = HM(t, "pointer.color");
        o != null && $M(t, "itemStyle.color", o);
      } else if (n === "bar") {
        uo(t), uo(t.backgroundStyle), uo(t.emphasis);
        var i = t.data;
        if (i && !ht(i))
          for (var a = 0; a < i.length; a++)
            typeof i[a] == "object" && (uo(i[a]), uo(i[a] && i[a].emphasis));
      } else if (n === "sunburst") {
        var s = t.highlightPolicy;
        s && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = s,  false && 0)), i1(t), w4(t.data, i1);
      } else
        n === "graph" || n === "sankey" ? YM(t) : n === "map" && (t.mapType && !t.map && ( false && 0, t.map = t.mapType), t.mapLocation && ( false && 0, dist_se(t, t.mapLocation)));
      t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && ( false && 0, t.emphasis.scale = t.hoverAnimation)), r1(t);
    }
  }), r.dataRange && (r.visualMap = r.dataRange), dist_M(UM, function(t) {
    var n = r[t];
    n && (dist_F(n) || (n = [n]), dist_M(n, function(i) {
      r1(i);
    }));
  });
}
function XM(r) {
  var e = dist_W();
  r.eachSeries(function(t) {
    var n = t.get("stack");
    if (n) {
      var i = e.get(n) || e.set(n, []), a = t.getData(), o = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: t
      };
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return;
      i.length && a.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(o);
    }
  }), e.each(ZM);
}
function ZM(r) {
  dist_M(r, function(e, t) {
    var n = [], i = [NaN, NaN], a = [e.stackResultDimension, e.stackedOverDimension], o = e.data, s = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign";
    o.modify(a, function(u, f, c) {
      var h = o.get(e.stackedDimension, c);
      if (isNaN(h))
        return i;
      var v, d;
      s ? d = o.getRawIndex(c) : v = o.get(e.stackedByDimension, c);
      for (var g = NaN, p = t - 1; p >= 0; p--) {
        var m = r[p];
        if (s || (d = m.data.rawIndexOf(m.stackedByDimension, v)), d >= 0) {
          var y = m.data.getByRawIndex(m.stackResultDimension, d);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && h >= 0 && y > 0 || l === "samesign" && h <= 0 && y < 0) {
            h = dC(h, y), g = y;
            break;
          }
        }
      }
      return n[0] = h, n[1] = g, n;
    });
  });
}
var bf = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.data = e.data || (e.sourceFormat === Nr ? {} : []), this.sourceFormat = e.sourceFormat || p4, this.seriesLayoutBy = e.seriesLayoutBy || Er, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption;
      var t = this.dimensionsDefine = e.dimensionsDefine;
      if (t)
        for (var n = 0; n < t.length; n++) {
          var i = t[n];
          i.type == null && y4(this, n) === Ye.Must && (i.type = "ordinal");
        }
    }
    return r;
  }()
);
function n0(r) {
  return r instanceof bf;
}
function Ev(r, e, t) {
  t = t || x4(r);
  var n = e.seriesLayoutBy, i = KM(r, t, n, e.sourceHeader, e.dimensions), a = new bf({
    data: r,
    sourceFormat: t,
    seriesLayoutBy: n,
    dimensionsDefine: i.dimensionsDefine,
    startIndex: i.startIndex,
    dimensionsDetectedCount: i.dimensionsDetectedCount,
    metaRawOption: dist_te(e)
  });
  return a;
}
function i0(r) {
  return new bf({
    data: r,
    sourceFormat: ht(r) ? qr : Jt
  });
}
function qM(r) {
  return new bf({
    data: r.data,
    sourceFormat: r.sourceFormat,
    seriesLayoutBy: r.seriesLayoutBy,
    dimensionsDefine: dist_te(r.dimensionsDefine),
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount
  });
}
function x4(r) {
  var e = p4;
  if (ht(r))
    e = qr;
  else if (dist_F(r)) {
    r.length === 0 && (e = vt);
    for (var t = 0, n = r.length; t < n; t++) {
      var i = r[t];
      if (i != null) {
        if (dist_F(i) || ht(i)) {
          e = vt;
          break;
        } else if (dist_X(i)) {
          e = Qt;
          break;
        }
      }
    }
  } else if (dist_X(r)) {
    for (var a in r)
      if (xt(r, a) && ct(r[a])) {
        e = Nr;
        break;
      }
  }
  return e;
}
function KM(r, e, t, n, i) {
  var a, o;
  if (!r)
    return {
      dimensionsDefine: a1(i),
      startIndex: o,
      dimensionsDetectedCount: a
    };
  if (e === vt) {
    var s = r;
    n === "auto" || n == null ? o1(function(u) {
      u != null && u !== "-" && (dist_U(u) ? o == null && (o = 1) : o = 0);
    }, t, s, 10) : o = ve(n) ? n : n ? 1 : 0, !i && o === 1 && (i = [], o1(function(u, f) {
      i[f] = u != null ? u + "" : "";
    }, t, s, 1 / 0)), a = i ? i.length : t === qa ? s.length : s[0] ? s[0].length : null;
  } else if (e === Qt)
    i || (i = jM(r));
  else if (e === Nr)
    i || (i = [], dist_M(r, function(u, f) {
      i.push(f);
    }));
  else if (e === Jt) {
    var l = Ds(r[0]);
    a = dist_F(l) && l.length || 1;
  } else
    e === qr && "production" !== "production" && 0;
  return {
    startIndex: o,
    dimensionsDefine: a1(i),
    dimensionsDetectedCount: a
  };
}
function jM(r) {
  for (var e = 0, t; e < r.length && !(t = r[e++]); )
    ;
  if (t)
    return we(t);
}
function a1(r) {
  if (r) {
    var e = dist_W();
    return dist_$(r, function(t, n) {
      t = dist_X(t) ? t : {
        name: t
      };
      var i = {
        name: t.name,
        displayName: t.displayName,
        type: t.type
      };
      if (i.name == null)
        return i;
      i.name += "", i.displayName == null && (i.displayName = i.name);
      var a = e.get(i.name);
      return a ? i.name += "-" + a.count++ : e.set(i.name, {
        count: 1
      }), i;
    });
  }
}
function o1(r, e, t, n) {
  if (e === qa)
    for (var i = 0; i < t.length && i < n; i++)
      r(t[i] ? t[i][0] : null, i);
  else
    for (var a = t[0] || [], i = 0; i < a.length && i < n; i++)
      r(a[i], i);
}
function C4(r) {
  var e = r.sourceFormat;
  return e === Qt || e === Nr;
}
var fi, ci, hi, s1, l1, T4 = (
  /** @class */
  function() {
    function r(e, t) {
      var n = n0(e) ? e : i0(e);
      this._source = n;
      var i = this._data = n.data;
      if (n.sourceFormat === qr) {
        if (false)
          {}
        this._offset = 0, this._dimSize = t, this._data = i;
      }
      l1(this, i, n);
    }
    return r.prototype.getSource = function() {
      return this._source;
    }, r.prototype.count = function() {
      return 0;
    }, r.prototype.getItem = function(e, t) {
    }, r.prototype.appendData = function(e) {
    }, r.prototype.clean = function() {
    }, r.protoInitialize = function() {
      var e = r.prototype;
      e.pure = !1, e.persistent = !0;
    }(), r.internalField = function() {
      var e;
      l1 = function(o, s, l) {
        var u = l.sourceFormat, f = l.seriesLayoutBy, c = l.startIndex, h = l.dimensionsDefine, v = s1[a0(u, f)];
        if ( false && 0, dist_V(o, v), u === qr)
          o.getItem = t, o.count = i, o.fillStorage = n;
        else {
          var d = M4(u, f);
          o.getItem = dist_Z(d, null, s, c, h);
          var g = D4(u, f);
          o.count = dist_Z(g, null, s, c, h);
        }
      };
      var t = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, f = u * o, c = 0; c < u; c++)
          s[c] = l[f + c];
        return s;
      }, n = function(o, s, l, u) {
        for (var f = this._data, c = this._dimSize, h = 0; h < c; h++) {
          for (var v = u[h], d = v[0] == null ? 1 / 0 : v[0], g = v[1] == null ? -1 / 0 : v[1], p = s - o, m = l[h], y = 0; y < p; y++) {
            var _ = f[y * c + h];
            m[o + y] = _, _ < d && (d = _), _ > g && (g = _);
          }
          v[0] = d, v[1] = g;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      s1 = (e = {}, e[vt + "_" + Er] = {
        pure: !0,
        appendData: a
      }, e[vt + "_" + qa] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, e[Qt] = {
        pure: !0,
        appendData: a
      }, e[Nr] = {
        pure: !0,
        appendData: function(o) {
          var s = this._data;
          dist_M(o, function(l, u) {
            for (var f = s[u] || (s[u] = []), c = 0; c < (l || []).length; c++)
              f.push(l[c]);
          });
        }
      }, e[Jt] = {
        appendData: a
      }, e[qr] = {
        persistent: !1,
        pure: !0,
        appendData: function(o) {
           false && 0, this._data = o;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, e);
      function a(o) {
        for (var s = 0; s < o.length; s++)
          this._data.push(o[s]);
      }
    }(), r;
  }()
), u1 = function(r, e, t, n) {
  return r[n];
}, JM = (fi = {}, fi[vt + "_" + Er] = function(r, e, t, n) {
  return r[n + e];
}, fi[vt + "_" + qa] = function(r, e, t, n, i) {
  n += e;
  for (var a = i || [], o = r, s = 0; s < o.length; s++) {
    var l = o[s];
    a[s] = l ? l[n] : null;
  }
  return a;
}, fi[Qt] = u1, fi[Nr] = function(r, e, t, n, i) {
  for (var a = i || [], o = 0; o < t.length; o++) {
    var s = t[o].name;
    if (false)
      {}
    var l = r[s];
    a[o] = l ? l[n] : null;
  }
  return a;
}, fi[Jt] = u1, fi);
function M4(r, e) {
  var t = JM[a0(r, e)];
  return  false && 0, t;
}
var f1 = function(r, e, t) {
  return r.length;
}, QM = (ci = {}, ci[vt + "_" + Er] = function(r, e, t) {
  return Math.max(0, r.length - e);
}, ci[vt + "_" + qa] = function(r, e, t) {
  var n = r[0];
  return n ? Math.max(0, n.length - e) : 0;
}, ci[Qt] = f1, ci[Nr] = function(r, e, t) {
  var n = t[0].name;
  if (false)
    {}
  var i = r[n];
  return i ? i.length : 0;
}, ci[Jt] = f1, ci);
function D4(r, e) {
  var t = QM[a0(r, e)];
  return  false && 0, t;
}
var Fc = function(r, e, t) {
  return r[e];
}, eD = (hi = {}, hi[vt] = Fc, hi[Qt] = function(r, e, t) {
  return r[t];
}, hi[Nr] = Fc, hi[Jt] = function(r, e, t) {
  var n = Ds(r);
  return n instanceof Array ? n[e] : n;
}, hi[qr] = Fc, hi);
function E4(r) {
  var e = eD[r];
  return  false && 0, e;
}
function a0(r, e) {
  return r === vt ? r + "_" + e : r;
}
function Va(r, e, t) {
  if (r) {
    var n = r.getRawDataItem(e);
    if (n != null) {
      var i = r.getStore(), a = i.getSource().sourceFormat;
      if (t != null) {
        var o = r.getDimensionIndex(t), s = i.getDimensionProperty(o);
        return E4(a)(n, o, s);
      } else {
        var l = n;
        return a === Jt && (l = Ds(n)), l;
      }
    }
  }
}
var tD = /\{@(.+?)\}/g, rD = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getDataParams = function(e, t) {
      var n = this.getData(t), i = this.getRawValue(e, t), a = n.getRawIndex(e), o = n.getName(e), s = n.getRawDataItem(e), l = n.getItemVisual(e, "style"), u = l && l[n.getItemVisual(e, "drawType") || "fill"], f = l && l.stroke, c = this.mainType, h = c === "series", v = n.userOutput && n.userOutput.get();
      return {
        componentType: c,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: h ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: h ? this.id : null,
        seriesName: h ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: t,
        value: i,
        color: u,
        borderColor: f,
        dimensionNames: v ? v.fullDimensions : null,
        encode: v ? v.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, r.prototype.getFormattedLabel = function(e, t, n, i, a, o) {
      t = t || "normal";
      var s = this.getData(n), l = this.getDataParams(e, n);
      if (o && (l.value = o.interpolatedValue), i != null && dist_F(l.value) && (l.value = l.value[i]), !a) {
        var u = s.getItemModel(e);
        a = u.get(t === "normal" ? ["label", "formatter"] : [t, "label", "formatter"]);
      }
      if (dist_j(a))
        return l.status = t, l.dimensionIndex = i, a(l);
      if (dist_U(a)) {
        var f = v4(a, l);
        return f.replace(tD, function(c, h) {
          var v = h.length, d = h;
          d.charAt(0) === "[" && d.charAt(v - 1) === "]" && (d = +d.slice(1, v - 1),  false && 0);
          var g = Va(s, e, d);
          if (o && dist_F(o.interpolatedValue)) {
            var p = s.getDimensionIndex(d);
            p >= 0 && (g = o.interpolatedValue[p]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, r.prototype.getRawValue = function(e, t) {
      return Va(this.getData(t), e);
    }, r.prototype.formatTooltip = function(e, t, n) {
    }, r;
  }()
);
function c1(r) {
  var e, t;
  return dist_X(r) ? r.type ? t = r : "production" : e = r, {
    text: e,
    // markers: markers || markersExisting,
    frag: t
  };
}
function Yo(r) {
  return new nD(r);
}
var nD = (
  /** @class */
  function() {
    function r(e) {
      e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = !0;
    }
    return r.prototype.perform = function(e) {
      var t = this._upstream, n = e && e.skip;
      if (this._dirty && t) {
        var i = this.context;
        i.data = i.outputData = t.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var o = f(this._modBy), s = this._modDataCount || 0, l = f(e && e.modBy), u = e && e.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function f(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var c;
      (this._dirty || a === "reset") && (this._dirty = !1, c = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var h = e && e.step;
      if (t ? ( false && 0, this._dueEnd = t._outputDueEnd) : ( false && 0, this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var v = this._dueIndex, d = Math.min(h != null ? this._dueIndex + h : 1 / 0, this._dueEnd);
        if (!n && (c || v < d)) {
          var g = this._progress;
          if (dist_F(g))
            for (var p = 0; p < g.length; p++)
              this._doProgress(g[p], v, d, l, u);
          else
            this._doProgress(g, v, d, l, u);
        }
        this._dueIndex = d;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : d;
         false && 0, this._outputDueEnd = m;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, r.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, r.prototype._doProgress = function(e, t, n, i, a) {
      h1.reset(t, n, i, a), this._callingProgress = e, this._callingProgress({
        start: t,
        end: n,
        count: n - t,
        next: h1.next
      }, this.context);
    }, r.prototype._doReset = function(e) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var t, n;
      !e && this._reset && (t = this._reset(this.context), t && t.progress && (n = t.forceFirstProgress, t = t.progress), dist_F(t) && !t.length && (t = null)), this._progress = t, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), n;
    }, r.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, r.prototype.pipe = function(e) {
       false && 0, (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty());
    }, r.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, r.prototype.getUpstream = function() {
      return this._upstream;
    }, r.prototype.getDownstream = function() {
      return this._downstream;
    }, r.prototype.setOutputEnd = function(e) {
      this._outputDueEnd = this._settedOutputEnd = e;
    }, r;
  }()
), h1 = /* @__PURE__ */ function() {
  var r, e, t, n, i, a = {
    reset: function(l, u, f, c) {
      e = l, r = u, t = f, n = c, i = Math.ceil(n / t), a.next = t > 1 && n > 0 ? s : o;
    }
  };
  return a;
  function o() {
    return e < r ? e++ : null;
  }
  function s() {
    var l = e % i * t + Math.ceil(e / i), u = e >= r ? null : l < n ? l : e;
    return e++, u;
  }
}();
function jl(r, e) {
  var t = e && e.type;
  return t === "ordinal" ? r : (t === "time" && !ve(r) && r != null && r !== "-" && (r = +en(r)), r == null || r === "" ? NaN : +r);
}
var iD = dist_W({
  number: function(r) {
    return parseFloat(r);
  },
  time: function(r) {
    return +en(r);
  },
  trim: function(r) {
    return dist_U(r) ? or(r) : r;
  }
});
function A4(r) {
  return iD.get(r);
}
var I4 = {
  lt: function(r, e) {
    return r < e;
  },
  lte: function(r, e) {
    return r <= e;
  },
  gt: function(r, e) {
    return r > e;
  },
  gte: function(r, e) {
    return r >= e;
  }
}, aD = (
  /** @class */
  function() {
    function r(e, t) {
      if (!ve(t)) {
        var n = "";
         false && (0), de(n);
      }
      this._opFn = I4[e], this._rvalFloat = $n(t);
    }
    return r.prototype.evaluate = function(e) {
      return ve(e) ? this._opFn(e, this._rvalFloat) : this._opFn($n(e), this._rvalFloat);
    }, r;
  }()
), L4 = (
  /** @class */
  function() {
    function r(e, t) {
      var n = e === "desc";
      this._resultLT = n ? 1 : -1, t == null && (t = n ? "min" : "max"), this._incomparable = t === "min" ? -1 / 0 : 1 / 0;
    }
    return r.prototype.evaluate = function(e, t) {
      var n = ve(e) ? e : $n(e), i = ve(t) ? t : $n(t), a = isNaN(n), o = isNaN(i);
      if (a && (n = this._incomparable), o && (i = this._incomparable), a && o) {
        var s = dist_U(e), l = dist_U(t);
        s && (n = l ? e : 0), l && (i = s ? t : 0);
      }
      return n < i ? this._resultLT : n > i ? -this._resultLT : 0;
    }, r;
  }()
), oD = (
  /** @class */
  function() {
    function r(e, t) {
      this._rval = t, this._isEQ = e, this._rvalTypeof = typeof t, this._rvalFloat = $n(t);
    }
    return r.prototype.evaluate = function(e) {
      var t = e === this._rval;
      if (!t) {
        var n = typeof e;
        n !== this._rvalTypeof && (n === "number" || this._rvalTypeof === "number") && (t = $n(e) === this._rvalFloat);
      }
      return this._isEQ ? t : !t;
    }, r;
  }()
);
function sD(r, e) {
  return r === "eq" || r === "ne" ? new oD(r === "eq", e) : xt(I4, r) ? new aD(r, e) : null;
}
var lD = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getRawData = function() {
      throw new Error("not supported");
    }, r.prototype.getRawDataItem = function(e) {
      throw new Error("not supported");
    }, r.prototype.cloneRawData = function() {
    }, r.prototype.getDimensionInfo = function(e) {
    }, r.prototype.cloneAllDimensionInfo = function() {
    }, r.prototype.count = function() {
    }, r.prototype.retrieveValue = function(e, t) {
    }, r.prototype.retrieveValueFromItem = function(e, t) {
    }, r.prototype.convertValue = function(e, t) {
      return jl(e, t);
    }, r;
  }()
);
function uD(r, e) {
  var t = new lD(), n = r.data, i = t.sourceFormat = r.sourceFormat, a = r.startIndex, o = "";
  r.seriesLayoutBy !== Er && ( false && (0), de(o));
  var s = [], l = {}, u = r.dimensionsDefine;
  if (u)
    dist_M(u, function(g, p) {
      var m = g.name, y = {
        index: p,
        name: m,
        displayName: g.displayName
      };
      if (s.push(y), m != null) {
        var _ = "";
        xt(l, m) && ( false && (0), de(_)), l[m] = y;
      }
    });
  else
    for (var f = 0; f < r.dimensionsDetectedCount; f++)
      s.push({
        index: f
      });
  var c = M4(i, Er);
  e.__isBuiltIn && (t.getRawDataItem = function(g) {
    return c(n, a, s, g);
  }, t.getRawData = dist_Z(fD, null, r)), t.cloneRawData = dist_Z(cD, null, r);
  var h = D4(i, Er);
  t.count = dist_Z(h, null, n, a, s);
  var v = E4(i);
  t.retrieveValue = function(g, p) {
    var m = c(n, a, s, g);
    return d(m, p);
  };
  var d = t.retrieveValueFromItem = function(g, p) {
    if (g != null) {
      var m = s[p];
      if (m)
        return v(g, p, m.name);
    }
  };
  return t.getDimensionInfo = dist_Z(hD, null, s, l), t.cloneAllDimensionInfo = dist_Z(vD, null, s), t;
}
function fD(r) {
  var e = r.sourceFormat;
  if (!o0(e)) {
    var t = "";
     false && (0), de(t);
  }
  return r.data;
}
function cD(r) {
  var e = r.sourceFormat, t = r.data;
  if (!o0(e)) {
    var n = "";
     false && (0), de(n);
  }
  if (e === vt) {
    for (var i = [], a = 0, o = t.length; a < o; a++)
      i.push(t[a].slice());
    return i;
  } else if (e === Qt) {
    for (var i = [], a = 0, o = t.length; a < o; a++)
      i.push(dist_V({}, t[a]));
    return i;
  }
}
function hD(r, e, t) {
  if (t != null) {
    if (ve(t) || !isNaN(t) && !xt(e, t))
      return r[t];
    if (xt(e, t))
      return e[t];
  }
}
function vD(r) {
  return dist_te(r);
}
var N4 = dist_W();
function dD(r) {
  r = dist_te(r);
  var e = r.type, t = "";
  e || ( false && (0), de(t));
  var n = e.split(":");
  n.length !== 2 && ( false && (0), de(t));
  var i = !1;
  n[0] === "echarts" && (e = n[1], i = !0), r.__isBuiltIn = i, N4.set(e, r);
}
function pD(r, e, t) {
  var n = Ae(r), i = n.length, a = "";
  i || ( false && (0), de(a));
  for (var o = 0, s = i; o < s; o++) {
    var l = n[o];
    e = gD(l, e, t, i === 1 ? null : o), o !== s - 1 && (e.length = Math.max(e.length, 1));
  }
  return e;
}
function gD(r, e, t, n) {
  var i = "";
  e.length || ( false && (0), de(i)), dist_X(r) || ( false && (0), de(i));
  var a = r.type, o = N4.get(a);
  o || ( false && (0), de(i));
  var s = dist_$(e, function(f) {
    return uD(f, o);
  }), l = Ae(o.transform({
    upstream: s[0],
    upstreamList: s,
    config: dist_te(r.config)
  }));
  if (false) { var u; }
  return dist_$(l, function(f, c) {
    var h = "";
    dist_X(f) || ( false && (0), de(h)), f.data || ( false && (0), de(h));
    var v = x4(f.data);
    o0(v) || ( false && (0), de(h));
    var d, g = e[0];
    if (g && c === 0 && !f.dimensions) {
      var p = g.startIndex;
      p && (f.data = g.data.slice(0, p).concat(f.data)), d = {
        seriesLayoutBy: Er,
        sourceHeader: p,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      d = {
        seriesLayoutBy: Er,
        sourceHeader: 0,
        dimensions: f.dimensions
      };
    return Ev(f.data, d, null);
  });
}
function o0(r) {
  return r === vt || r === Qt;
}
var xf = "undefined", mD = typeof Uint32Array === xf ? Array : Uint32Array, yD = typeof Uint16Array === xf ? Array : Uint16Array, P4 = typeof Int32Array === xf ? Array : Int32Array, v1 = typeof Float64Array === xf ? Array : Float64Array, R4 = {
  float: v1,
  int: P4,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: v1
}, zc;
function fo(r) {
  return r > 65535 ? mD : yD;
}
function ra() {
  return [1 / 0, -1 / 0];
}
function _D(r) {
  var e = r.constructor;
  return e === Array ? r.slice() : new e(r);
}
function d1(r, e, t, n, i) {
  var a = R4[t || "float"];
  if (i) {
    var o = r[e], s = o && o.length;
    if (s !== n) {
      for (var l = new a(n), u = 0; u < s; u++)
        l[u] = o[u];
      r[e] = l;
    }
  } else
    r[e] = new a(n);
}
var Av = (
  /** @class */
  function() {
    function r() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = dist_W();
    }
    return r.prototype.initData = function(e, t, n) {
       false && 0, this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = e.getSource(), a = this.defaultDimValueGetter = zc[i.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [];
      var o = C4(i);
      this._dimensions = dist_$(t, function(s) {
        return  false && 0, {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, e.count());
    }, r.prototype.getProvider = function() {
      return this._provider;
    }, r.prototype.getSource = function() {
      return this._provider.getSource();
    }, r.prototype.ensureCalculationDimension = function(e, t) {
      var n = this._calcDimNameToIdx, i = this._dimensions, a = n.get(e);
      if (a != null) {
        if (i[a].type === t)
          return a;
      } else
        a = i.length;
      return i[a] = {
        type: t
      }, n.set(e, a), this._chunks[a] = new R4[t || "float"](this._rawCount), this._rawExtent[a] = ra(), a;
    }, r.prototype.collectOrdinalMeta = function(e, t) {
      var n = this._chunks[e], i = this._dimensions[e], a = this._rawExtent, o = i.ordinalOffset || 0, s = n.length;
      o === 0 && (a[e] = ra());
      for (var l = a[e], u = o; u < s; u++) {
        var f = n[u] = t.parseAndCollect(n[u]);
        isNaN(f) || (l[0] = Math.min(f, l[0]), l[1] = Math.max(f, l[1]));
      }
      i.ordinalMeta = t, i.ordinalOffset = s, i.type = "ordinal";
    }, r.prototype.getOrdinalMeta = function(e) {
      var t = this._dimensions[e], n = t.ordinalMeta;
      return n;
    }, r.prototype.getDimensionProperty = function(e) {
      var t = this._dimensions[e];
      return t && t.property;
    }, r.prototype.appendData = function(e) {
       false && 0;
      var t = this._provider, n = this.count();
      t.appendData(e);
      var i = t.count();
      return t.persistent || (i += n), n < i && this._initDataFromProvider(n, i, !0), [n, i];
    }, r.prototype.appendValues = function(e, t) {
      for (var n = this._chunks, i = this._dimensions, a = i.length, o = this._rawExtent, s = this.count(), l = s + Math.max(e.length, t || 0), u = 0; u < a; u++) {
        var f = i[u];
        d1(n, u, f.type, l, !0);
      }
      for (var c = [], h = s; h < l; h++)
        for (var v = h - s, d = 0; d < a; d++) {
          var f = i[d], g = zc.arrayRows.call(this, e[v] || c, f.property, v, d);
          n[d][h] = g;
          var p = o[d];
          g < p[0] && (p[0] = g), g > p[1] && (p[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, r.prototype._initDataFromProvider = function(e, t, n) {
      for (var i = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = dist_$(o, function(y) {
        return y.property;
      }), f = 0; f < s; f++) {
        var c = o[f];
        l[f] || (l[f] = ra()), d1(a, f, c.type, t, n);
      }
      if (i.fillStorage)
        i.fillStorage(e, t, a, l);
      else
        for (var h = [], v = e; v < t; v++) {
          h = i.getItem(v, h);
          for (var d = 0; d < s; d++) {
            var g = a[d], p = this._dimValueGetter(h, u[d], v, d);
            g[v] = p;
            var m = l[d];
            p < m[0] && (m[0] = p), p > m[1] && (m[1] = p);
          }
        }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = t, this._extent = [];
    }, r.prototype.count = function() {
      return this._count;
    }, r.prototype.get = function(e, t) {
      if (!(t >= 0 && t < this._count))
        return NaN;
      var n = this._chunks[e];
      return n ? n[this.getRawIndex(t)] : NaN;
    }, r.prototype.getValues = function(e, t) {
      var n = [], i = [];
      if (t == null) {
        t = e, e = [];
        for (var a = 0; a < this._dimensions.length; a++)
          i.push(a);
      } else
        i = e;
      for (var a = 0, o = i.length; a < o; a++)
        n.push(this.get(i[a], t));
      return n;
    }, r.prototype.getByRawIndex = function(e, t) {
      if (!(t >= 0 && t < this._rawCount))
        return NaN;
      var n = this._chunks[e];
      return n ? n[t] : NaN;
    }, r.prototype.getSum = function(e) {
      var t = this._chunks[e], n = 0;
      if (t)
        for (var i = 0, a = this.count(); i < a; i++) {
          var o = this.get(e, i);
          isNaN(o) || (n += o);
        }
      return n;
    }, r.prototype.getMedian = function(e) {
      var t = [];
      this.each([e], function(a) {
        isNaN(a) || t.push(a);
      });
      var n = t.sort(function(a, o) {
        return a - o;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2;
    }, r.prototype.indexOfRawIndex = function(e) {
      if (e >= this._rawCount || e < 0)
        return -1;
      if (!this._indices)
        return e;
      var t = this._indices, n = t[e];
      if (n != null && n < this._count && n === e)
        return e;
      for (var i = 0, a = this._count - 1; i <= a; ) {
        var o = (i + a) / 2 | 0;
        if (t[o] < e)
          i = o + 1;
        else if (t[o] > e)
          a = o - 1;
        else
          return o;
      }
      return -1;
    }, r.prototype.indicesOfNearest = function(e, t, n) {
      var i = this._chunks, a = i[e], o = [];
      if (!a)
        return o;
      n == null && (n = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, f = 0, c = this.count(); f < c; f++) {
        var h = this.getRawIndex(f), v = t - a[h], d = Math.abs(v);
        d <= n && ((d < s || d === s && v >= 0 && l < 0) && (s = d, l = v, u = 0), v === l && (o[u++] = f));
      }
      return o.length = u, o;
    }, r.prototype.getIndices = function() {
      var e, t = this._indices;
      if (t) {
        var n = t.constructor, i = this._count;
        if (n === Array) {
          e = new n(i);
          for (var a = 0; a < i; a++)
            e[a] = t[a];
        } else
          e = new n(t.buffer, 0, i);
      } else {
        var n = fo(this._rawCount);
        e = new n(this.count());
        for (var a = 0; a < e.length; a++)
          e[a] = a;
      }
      return e;
    }, r.prototype.filter = function(e, t) {
      if (!this._count)
        return this;
      for (var n = this.clone(), i = n.count(), a = fo(n._rawCount), o = new a(i), s = [], l = e.length, u = 0, f = e[0], c = n._chunks, h = 0; h < i; h++) {
        var v = void 0, d = n.getRawIndex(h);
        if (l === 0)
          v = t(h);
        else if (l === 1) {
          var g = c[f][d];
          v = t(g, h);
        } else {
          for (var p = 0; p < l; p++)
            s[p] = c[e[p]][d];
          s[p] = h, v = t.apply(null, s);
        }
        v && (o[u++] = d);
      }
      return u < i && (n._indices = o), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, r.prototype.selectRange = function(e) {
      var t = this.clone(), n = t._count;
      if (!n)
        return this;
      var i = we(e), a = i.length;
      if (!a)
        return this;
      var o = t.count(), s = fo(t._rawCount), l = new s(o), u = 0, f = i[0], c = e[f][0], h = e[f][1], v = t._chunks, d = !1;
      if (!t._indices) {
        var g = 0;
        if (a === 1) {
          for (var p = v[i[0]], m = 0; m < n; m++) {
            var y = p[m];
            (y >= c && y <= h || isNaN(y)) && (l[u++] = g), g++;
          }
          d = !0;
        } else if (a === 2) {
          for (var p = v[i[0]], _ = v[i[1]], S = e[i[1]][0], b = e[i[1]][1], m = 0; m < n; m++) {
            var y = p[m], w = _[m];
            (y >= c && y <= h || isNaN(y)) && (w >= S && w <= b || isNaN(w)) && (l[u++] = g), g++;
          }
          d = !0;
        }
      }
      if (!d)
        if (a === 1)
          for (var m = 0; m < o; m++) {
            var x = t.getRawIndex(m), y = v[i[0]][x];
            (y >= c && y <= h || isNaN(y)) && (l[u++] = x);
          }
        else
          for (var m = 0; m < o; m++) {
            for (var C = !0, x = t.getRawIndex(m), T = 0; T < a; T++) {
              var E = i[T], y = v[E][x];
              (y < e[E][0] || y > e[E][1]) && (C = !1);
            }
            C && (l[u++] = t.getRawIndex(m));
          }
      return u < o && (t._indices = l), t._count = u, t._extent = [], t._updateGetRawIdx(), t;
    }, r.prototype.map = function(e, t) {
      var n = this.clone(e);
      return this._updateDims(n, e, t), n;
    }, r.prototype.modify = function(e, t) {
      this._updateDims(this, e, t);
    }, r.prototype._updateDims = function(e, t, n) {
      for (var i = e._chunks, a = [], o = t.length, s = e.count(), l = [], u = e._rawExtent, f = 0; f < t.length; f++)
        u[t[f]] = ra();
      for (var c = 0; c < s; c++) {
        for (var h = e.getRawIndex(c), v = 0; v < o; v++)
          l[v] = i[t[v]][h];
        l[o] = c;
        var d = n && n.apply(null, l);
        if (d != null) {
          typeof d != "object" && (a[0] = d, d = a);
          for (var f = 0; f < d.length; f++) {
            var g = t[f], p = d[f], m = u[g], y = i[g];
            y && (y[h] = p), p < m[0] && (m[0] = p), p > m[1] && (m[1] = p);
          }
        }
      }
    }, r.prototype.lttbDownSample = function(e, t) {
      var n = this.clone([e], !0), i = n._chunks, a = i[e], o = this.count(), s = 0, l = Math.floor(1 / t), u = this.getRawIndex(0), f, c, h, v = new (fo(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      v[s++] = u;
      for (var d = 1; d < o - 1; d += l) {
        for (var g = Math.min(d + l, o - 1), p = Math.min(d + l * 2, o), m = (p + g) / 2, y = 0, _ = g; _ < p; _++) {
          var S = this.getRawIndex(_), b = a[S];
          isNaN(b) || (y += b);
        }
        y /= p - g;
        var w = d, x = Math.min(d + l, o), C = d - 1, T = a[u];
        f = -1, h = w;
        for (var E = -1, D = 0, _ = w; _ < x; _++) {
          var S = this.getRawIndex(_), b = a[S];
          if (isNaN(b)) {
            D++, E < 0 && (E = S);
            continue;
          }
          c = Math.abs((C - m) * (b - T) - (C - _) * (y - T)), c > f && (f = c, h = S);
        }
        D > 0 && D < x - w && (v[s++] = Math.min(E, h), h = Math.max(E, h)), v[s++] = h, u = h;
      }
      return v[s++] = this.getRawIndex(o - 1), n._count = s, n._indices = v, n.getRawIndex = this._getRawIdx, n;
    }, r.prototype.downSample = function(e, t, n, i) {
      for (var a = this.clone([e], !0), o = a._chunks, s = [], l = Math.floor(1 / t), u = o[e], f = this.count(), c = a._rawExtent[e] = ra(), h = new (fo(this._rawCount))(Math.ceil(f / l)), v = 0, d = 0; d < f; d += l) {
        l > f - d && (l = f - d, s.length = l);
        for (var g = 0; g < l; g++) {
          var p = this.getRawIndex(d + g);
          s[g] = u[p];
        }
        var m = n(s), y = this.getRawIndex(Math.min(d + i(s, m) || 0, f - 1));
        u[y] = m, m < c[0] && (c[0] = m), m > c[1] && (c[1] = m), h[v++] = y;
      }
      return a._count = v, a._indices = h, a._updateGetRawIdx(), a;
    }, r.prototype.each = function(e, t) {
      if (this._count)
        for (var n = e.length, i = this._chunks, a = 0, o = this.count(); a < o; a++) {
          var s = this.getRawIndex(a);
          switch (n) {
            case 0:
              t(a);
              break;
            case 1:
              t(i[e[0]][s], a);
              break;
            case 2:
              t(i[e[0]][s], i[e[1]][s], a);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = i[e[l]][s];
              u[l] = a, t.apply(null, u);
          }
        }
    }, r.prototype.getDataExtent = function(e) {
      var t = this._chunks[e], n = ra();
      if (!t)
        return n;
      var i = this.count(), a = !this._indices, o;
      if (a)
        return this._rawExtent[e].slice();
      if (o = this._extent[e], o)
        return o.slice();
      o = n;
      for (var s = o[0], l = o[1], u = 0; u < i; u++) {
        var f = this.getRawIndex(u), c = t[f];
        c < s && (s = c), c > l && (l = c);
      }
      return o = [s, l], this._extent[e] = o, o;
    }, r.prototype.getRawDataItem = function(e) {
      var t = this.getRawIndex(e);
      if (this._provider.persistent)
        return this._provider.getItem(t);
      for (var n = [], i = this._chunks, a = 0; a < i.length; a++)
        n.push(i[a][t]);
      return n;
    }, r.prototype.clone = function(e, t) {
      var n = new r(), i = this._chunks, a = e && Jr(e, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (a)
        for (var o = 0; o < i.length; o++)
          n._chunks[o] = a[o] ? _D(i[o]) : i[o];
      else
        n._chunks = i;
      return this._copyCommonProps(n), t || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, r.prototype._copyCommonProps = function(e) {
      e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = dist_te(this._extent), e._rawExtent = dist_te(this._rawExtent);
    }, r.prototype._cloneIndices = function() {
      if (this._indices) {
        var e = this._indices.constructor, t = void 0;
        if (e === Array) {
          var n = this._indices.length;
          t = new e(n);
          for (var i = 0; i < n; i++)
            t[i] = this._indices[i];
        } else
          t = new e(this._indices);
        return t;
      }
      return null;
    }, r.prototype._getRawIdxIdentity = function(e) {
      return e;
    }, r.prototype._getRawIdx = function(e) {
      return e < this._count && e >= 0 ? this._indices[e] : -1;
    }, r.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, r.internalField = function() {
      function e(t, n, i, a) {
        return jl(t[a], this._dimensions[a]);
      }
      zc = {
        arrayRows: e,
        objectRows: function(t, n, i, a) {
          return jl(t[n], this._dimensions[a]);
        },
        keyedColumns: e,
        original: function(t, n, i, a) {
          var o = t && (t.value == null ? t : t.value);
          return jl(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(t, n, i, a) {
          return t[a];
        }
      };
    }(), r;
  }()
), O4 = (
  /** @class */
  function() {
    function r(e) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = e;
    }
    return r.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, r.prototype._setLocalSource = function(e, t) {
      this._sourceList = e, this._upstreamSignList = t, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, r.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, r.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, r.prototype._createSource = function() {
      this._setLocalSource([], []);
      var e = this._sourceHost, t = this._getUpstreamSourceManagers(), n = !!t.length, i, a;
      if (co(e)) {
        var o = e, s = void 0, l = void 0, u = void 0;
        if (n) {
          var f = t[0];
          f.prepareSource(), u = f.getSource(), s = u.data, l = u.sourceFormat, a = [f._getVersionSign()];
        } else
          s = o.get("data", !0), l = ht(s) ? qr : Jt, a = [];
        var c = this._getSourceMetaRawOption() || {}, h = u && u.metaRawOption || {}, v = dist_ne(c.seriesLayoutBy, h.seriesLayoutBy) || null, d = dist_ne(c.sourceHeader, h.sourceHeader), g = dist_ne(c.dimensions, h.dimensions), p = v !== h.seriesLayoutBy || !!d != !!h.sourceHeader || g;
        i = p ? [Ev(s, {
          seriesLayoutBy: v,
          sourceHeader: d,
          dimensions: g
        }, l)] : [];
      } else {
        var m = e;
        if (n) {
          var y = this._applyTransform(t);
          i = y.sourceList, a = y.upstreamSignList;
        } else {
          var _ = m.get("source", !0);
          i = [Ev(_, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
       false && 0, this._setLocalSource(i, a);
    }, r.prototype._applyTransform = function(e) {
      var t = this._sourceHost, n = t.get("transform", !0), i = t.get("fromTransformResult", !0);
      if ( false && 0, i != null) {
        var a = "";
        e.length !== 1 && ( false && (0), g1(a));
      }
      var o, s = [], l = [];
      return dist_M(e, function(u) {
        u.prepareSource();
        var f = u.getSource(i || 0), c = "";
        i != null && !f && ( false && (0), g1(c)), s.push(f), l.push(u._getVersionSign());
      }), n ? o = pD(n, s, {
        datasetIndex: t.componentIndex
      }) : i != null && (o = [qM(s[0])]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, r.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) {
        var n = e[t];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[t] !== n._getVersionSign()
        )
          return !0;
      }
    }, r.prototype.getSource = function(e) {
      e = e || 0;
      var t = this._sourceList[e];
      if (!t) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(e);
      }
      return t;
    }, r.prototype.getSharedDataStore = function(e) {
       false && 0;
      var t = e.makeStoreSchema();
      return this._innerGetDataStore(t.dimensions, e.source, t.hash);
    }, r.prototype._innerGetDataStore = function(e, t, n) {
      var i = 0, a = this._storeList, o = a[i];
      o || (o = a[i] = {});
      var s = o[n];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        co(this._sourceHost) && l ? s = l._innerGetDataStore(e, t, n) : (s = new Av(), s.initData(new T4(t, e.length), e)), o[n] = s;
      }
      return s;
    }, r.prototype._getUpstreamSourceManagers = function() {
      var e = this._sourceHost;
      if (co(e)) {
        var t = e0(e);
        return t ? [t.getSourceManager()] : [];
      } else
        return dist_$(SM(e), function(n) {
          return n.getSourceManager();
        });
    }, r.prototype._getSourceMetaRawOption = function() {
      var e = this._sourceHost, t, n, i;
      if (co(e))
        t = e.get("seriesLayoutBy", !0), n = e.get("sourceHeader", !0), i = e.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = e;
        t = a.get("seriesLayoutBy", !0), n = a.get("sourceHeader", !0), i = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: t,
        sourceHeader: n,
        dimensions: i
      };
    }, r;
  }()
);
function p1(r) {
  var e = r.option.transform;
  e && su(r.option.transform);
}
function co(r) {
  return r.mainType === "series";
}
function g1(r) {
  throw new Error(r);
}
var k4 = "line-height:1";
function V4(r, e) {
  var t = r.color || "#6e7079", n = r.fontSize || 12, i = r.fontWeight || "400", a = r.color || "#464646", o = r.fontSize || 14, s = r.fontWeight || "900";
  return e === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Wt(n + "") + "px;color:" + Wt(t) + ";font-weight:" + Wt(i + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Wt(o + "") + "px;color:" + Wt(a) + ";font-weight:" + Wt(s + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: t,
      fontWeight: i
    },
    valueStyle: {
      fontSize: o,
      fill: a,
      fontWeight: s
    }
  };
}
var SD = [0, 10, 20, 30], wD = ["", `
`, `

`, `


`];
function on(r, e) {
  return e.type = r, e;
}
function Iv(r) {
  return r.type === "section";
}
function B4(r) {
  return Iv(r) ? bD : xD;
}
function F4(r) {
  if (Iv(r)) {
    var e = 0, t = r.blocks.length, n = t > 1 || t > 0 && !r.noHeader;
    return dist_M(r.blocks, function(i) {
      var a = F4(i);
      a >= e && (e = a + +(n && // 0 always can not be readable gap level.
      (!a || Iv(i) && !i.noHeader)));
    }), e;
  }
  return 0;
}
function bD(r, e, t, n) {
  var i = e.noHeader, a = CD(F4(e)), o = [], s = e.blocks || [];
  dist_re(!s || dist_F(s)), s = s || [];
  var l = r.orderMode;
  if (e.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (xt(u, l)) {
      var f = new L4(u[l], null);
      s.sort(function(d, g) {
        return f.evaluate(d.sortParam, g.sortParam);
      });
    } else
      l === "seriesDesc" && s.reverse();
  }
  dist_M(s, function(d, g) {
    var p = e.valueFormatter, m = B4(d)(
      // Inherit valueFormatter
      p ? dist_V(dist_V({}, r), {
        valueFormatter: p
      }) : r,
      d,
      g > 0 ? a.html : 0,
      n
    );
    m != null && o.push(m);
  });
  var c = r.renderMode === "richText" ? o.join(a.richText) : Lv(o.join(""), i ? t : a.html);
  if (i)
    return c;
  var h = Mv(e.header, "ordinal", r.useUTC), v = V4(n, r.renderMode).nameStyle;
  return r.renderMode === "richText" ? z4(r, h, v) + a.richText + c : Lv('<div style="' + v + ";" + k4 + ';">' + Wt(h) + "</div>" + c, t);
}
function xD(r, e, t, n) {
  var i = r.renderMode, a = e.noName, o = e.noValue, s = !e.markerType, l = e.name, u = r.useUTC, f = e.valueFormatter || r.valueFormatter || function(S) {
    return S = dist_F(S) ? S : [S], dist_$(S, function(b, w) {
      return Mv(b, dist_F(v) ? v[w] : v, u);
    });
  };
  if (!(a && o)) {
    var c = s ? "" : r.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", i), h = a ? "" : Mv(l, "ordinal", u), v = e.valueType, d = o ? [] : f(e.value, e.dataIndex), g = !s || !a, p = !s && a, m = V4(n, i), y = m.nameStyle, _ = m.valueStyle;
    return i === "richText" ? (s ? "" : c) + (a ? "" : z4(r, h, y)) + (o ? "" : DD(r, d, g, p, _)) : Lv((s ? "" : c) + (a ? "" : TD(h, !s, y)) + (o ? "" : MD(d, g, p, _)), t);
  }
}
function m1(r, e, t, n, i, a) {
  if (r) {
    var o = B4(r), s = {
      useUTC: i,
      renderMode: t,
      orderMode: n,
      markupStyleCreator: e,
      valueFormatter: r.valueFormatter
    };
    return o(s, r, 0, a);
  }
}
function CD(r) {
  return {
    html: SD[r],
    richText: wD[r]
  };
}
function Lv(r, e) {
  var t = '<div style="clear:both"></div>', n = "margin: " + e + "px 0 0";
  return '<div style="' + n + ";" + k4 + ';">' + r + t + "</div>";
}
function TD(r, e, t) {
  var n = e ? "margin-left:2px" : "";
  return '<span style="' + t + ";" + n + '">' + Wt(r) + "</span>";
}
function MD(r, e, t, n) {
  var i = t ? "10px" : "20px", a = e ? "float:right;margin-left:" + i : "";
  return r = dist_F(r) ? r : [r], '<span style="' + a + ";" + n + '">' + dist_$(r, function(o) {
    return Wt(o);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function z4(r, e, t) {
  return r.markupStyleCreator.wrapRichTextStyle(e, t);
}
function DD(r, e, t, n, i) {
  var a = [i], o = n ? 10 : 20;
  return t && a.push({
    padding: [0, 0, 0, o],
    align: "right"
  }), r.markupStyleCreator.wrapRichTextStyle(dist_F(e) ? e.join("  ") : e, a);
}
function ED(r, e) {
  var t = r.getData().getItemVisual(e, "style"), n = t[r.visualDrawType];
  return Bi(n);
}
function G4(r, e) {
  var t = r.get("padding");
  return t ?? (e === "richText" ? [8, 10] : 10);
}
var Gc = (
  /** @class */
  function() {
    function r() {
      this.richTextStyles = {}, this._nextStyleNameId = K3();
    }
    return r.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, r.prototype.makeTooltipMarker = function(e, t, n) {
      var i = n === "richText" ? this._generateStyleName() : null, a = cM({
        color: t,
        type: e,
        renderMode: n,
        markerId: i
      });
      return dist_U(a) ? a : ( false && 0, this.richTextStyles[i] = a.style, a.content);
    }, r.prototype.wrapRichTextStyle = function(e, t) {
      var n = {};
      dist_F(t) ? dist_M(t, function(a) {
        return dist_V(n, a);
      }) : dist_V(n, t);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = n, "{" + i + "|" + e + "}";
    }, r;
  }()
);
function H4(r) {
  var e = r.series, t = r.dataIndex, n = r.multipleSeries, i = e.getData(), a = i.mapDimensionsAll("defaultedTooltip"), o = a.length, s = e.getRawValue(t), l = dist_F(s), u = ED(e, t), f, c, h, v;
  if (o > 1 || l && !o) {
    var d = AD(s, e, t, a, u);
    f = d.inlineValues, c = d.inlineValueTypes, h = d.blocks, v = d.inlineValues[0];
  } else if (o) {
    var g = i.getDimensionInfo(a[0]);
    v = f = Va(i, t, a[0]), c = g.type;
  } else
    v = f = l ? s[0] : s;
  var p = Ad(e), m = p && e.name || "", y = i.getName(t), _ = n ? m : y;
  return on("section", {
    header: m,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !p,
    sortParam: v,
    blocks: [on("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: _,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !or(_),
      value: f,
      valueType: c,
      dataIndex: t
    })].concat(h || [])
  });
}
function AD(r, e, t, n, i) {
  var a = e.getData(), o = Jr(r, function(c, h, v) {
    var d = a.getDimensionInfo(v);
    return c = c || d && d.tooltip !== !1 && d.displayName != null;
  }, !1), s = [], l = [], u = [];
  n.length ? dist_M(n, function(c) {
    f(Va(a, t, c), c);
  }) : dist_M(r, f);
  function f(c, h) {
    var v = a.getDimensionInfo(h);
    !v || v.otherDims.tooltip === !1 || (o ? u.push(on("nameValue", {
      markerType: "subItem",
      markerColor: i,
      name: v.displayName,
      value: c,
      valueType: v.type
    })) : (s.push(c), l.push(v.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var yn = Me();
function cl(r, e) {
  return r.getName(e) || r.getId(e);
}
var Jl = "__universalTransitionEnabled", Cf = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t._selectedDataIndicesMap = {}, t;
    }
    return e.prototype.init = function(t, n, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = Yo({
        count: LD,
        reset: ND
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(t, i);
      var a = yn(this).sourceManager = new O4(this);
      a.prepareSource();
      var o = this.getInitialData(t, i);
      _1(o, this), this.dataTask.context.data = o,  false && 0, yn(this).dataBeforeProcessed = o, y1(this), this._initSelectedMapFromData(o);
    }, e.prototype.mergeDefaultAndTheme = function(t, n) {
      var i = vs(this), a = i ? Ps(t) : {}, o = this.subType;
      Se.hasClass(o) && (o += "Series"), he(t, n.getTheme().get(this.subType)), he(t, this.getDefaultOption()), us(t, "label", ["show"]), this.fillDataTextStyle(t.data), i && ka(t, a, i);
    }, e.prototype.mergeOption = function(t, n) {
      t = he(this.option, t, !0), this.fillDataTextStyle(t.data);
      var i = vs(this);
      i && ka(this.option, t, i);
      var a = yn(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(t, n);
      _1(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, yn(this).dataBeforeProcessed = o, y1(this), this._initSelectedMapFromData(o);
    }, e.prototype.fillDataTextStyle = function(t) {
      if (t && !ht(t))
        for (var n = ["show"], i = 0; i < t.length; i++)
          t[i] && t[i].label && us(t[i], "label", n);
    }, e.prototype.getInitialData = function(t, n) {
    }, e.prototype.appendData = function(t) {
      var n = this.getRawData();
      n.appendData(t.data);
    }, e.prototype.getData = function(t) {
      var n = Nv(this);
      if (n) {
        var i = n.context.data;
        return t == null ? i : i.getLinkedData(t);
      } else
        return yn(this).data;
    }, e.prototype.getAllData = function() {
      var t = this.getData();
      return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{
        data: t
      }];
    }, e.prototype.setData = function(t) {
      var n = Nv(this);
      if (n) {
        var i = n.context;
        i.outputData = t, n !== this.dataTask && (i.data = t);
      }
      yn(this).data = t;
    }, e.prototype.getEncode = function() {
      var t = this.get("encode", !0);
      if (t)
        return dist_W(t);
    }, e.prototype.getSourceManager = function() {
      return yn(this).sourceManager;
    }, e.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, e.prototype.getRawData = function() {
      return yn(this).dataBeforeProcessed;
    }, e.prototype.getColorBy = function() {
      var t = this.get("colorBy");
      return t || "series";
    }, e.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, e.prototype.getBaseAxis = function() {
      var t = this.coordinateSystem;
      return t && t.getBaseAxis && t.getBaseAxis();
    }, e.prototype.formatTooltip = function(t, n, i) {
      return H4({
        series: this,
        dataIndex: t,
        multipleSeries: n
      });
    }, e.prototype.isAnimationEnabled = function() {
      var t = this.ecModel;
      if (dist_ee.node && !(t && t.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, e.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, e.prototype.getColorFromPalette = function(t, n, i) {
      var a = this.ecModel, o = t0.prototype.getColorFromPalette.call(this, t, n, i);
      return o || (o = a.getColorFromPalette(t, n, i)), o;
    }, e.prototype.coordDimToDataDim = function(t) {
      return this.getRawData().mapDimensionsAll(t);
    }, e.prototype.getProgressive = function() {
      return this.get("progressive");
    }, e.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, e.prototype.select = function(t, n) {
      this._innerSelect(this.getData(n), t);
    }, e.prototype.unselect = function(t, n) {
      var i = this.option.selectedMap;
      if (i) {
        var a = this.option.selectedMode, o = this.getData(n);
        if (a === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < t.length; s++) {
          var l = t[s], u = cl(o, l);
          i[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, e.prototype.toggleSelect = function(t, n) {
      for (var i = [], a = 0; a < t.length; a++)
        i[0] = t[a], this.isSelected(t[a], n) ? this.unselect(i, n) : this.select(i, n);
    }, e.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var t = this._selectedDataIndicesMap, n = we(t), i = [], a = 0; a < n.length; a++) {
        var o = t[n[a]];
        o >= 0 && i.push(o);
      }
      return i;
    }, e.prototype.isSelected = function(t, n) {
      var i = this.option.selectedMap;
      if (!i)
        return !1;
      var a = this.getData(n);
      return (i === "all" || i[cl(a, t)]) && !a.getItemModel(t).get(["select", "disabled"]);
    }, e.prototype.isUniversalTransitionEnabled = function() {
      if (this[Jl])
        return !0;
      var t = this.option.universalTransition;
      return t ? t === !0 ? !0 : t && t.enabled : !1;
    }, e.prototype._innerSelect = function(t, n) {
      var i, a, o = this.option, s = o.selectedMode, l = n.length;
      if (!(!s || !l)) {
        if (s === "series")
          o.selectedMap = "all";
        else if (s === "multiple") {
          dist_X(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, f = 0; f < l; f++) {
            var c = n[f], h = cl(t, c);
            u[h] = !0, this._selectedDataIndicesMap[h] = t.getRawIndex(c);
          }
        } else if (s === "single" || s === !0) {
          var v = n[l - 1], h = cl(t, v);
          o.selectedMap = (i = {}, i[h] = !0, i), this._selectedDataIndicesMap = (a = {}, a[h] = t.getRawIndex(v), a);
        }
      }
    }, e.prototype._initSelectedMapFromData = function(t) {
      if (!this.option.selectedMap) {
        var n = [];
        t.hasItemOption && t.each(function(i) {
          var a = t.getRawDataItem(i);
          a && a.selected && n.push(i);
        }), n.length > 0 && this._innerSelect(t, n);
      }
    }, e.registerClass = function(t) {
      return Se.registerClass(t);
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = !1, t.hasSymbolVisual = !1, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill";
    }(), e;
  }(Se)
);
Ot(Cf, rD);
Ot(Cf, t0);
n_(Cf, Se);
function y1(r) {
  var e = r.name;
  Ad(r) || (r.name = ID(r) || e);
}
function ID(r) {
  var e = r.getRawData(), t = e.mapDimensionsAll("seriesName"), n = [];
  return dist_M(t, function(i) {
    var a = e.getDimensionInfo(i);
    a.displayName && n.push(a.displayName);
  }), n.join(" ");
}
function LD(r) {
  return r.model.getRawData().count();
}
function ND(r) {
  var e = r.model;
  return e.setData(e.getRawData().cloneShallow()), PD;
}
function PD(r, e) {
  e.outputData && r.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
}
function _1(r, e) {
  dist_M(Kh(r.CHANGABLE_METHODS, r.DOWNSAMPLE_METHODS), function(t) {
    r.wrapMethod(t, Te(RD, e));
  });
}
function RD(r, e) {
  var t = Nv(r);
  return t && t.setOutputEnd((e || this).count()), e;
}
function Nv(r) {
  var e = (r.ecModel || {}).scheduler, t = e && e.getPipeline(r.uid);
  if (t) {
    var n = t.currentTask;
    if (n) {
      var i = n.agentStubMap;
      i && (n = i.get(r.uid));
    }
    return n;
  }
}
const jt = Cf;
var s0 = (
  /** @class */
  function() {
    function r() {
      this.group = new dist_oe(), this.uid = Ls("viewComponent");
    }
    return r.prototype.init = function(e, t) {
    }, r.prototype.render = function(e, t, n, i) {
    }, r.prototype.dispose = function(e, t) {
    }, r.prototype.updateView = function(e, t, n, i) {
    }, r.prototype.updateLayout = function(e, t, n, i) {
    }, r.prototype.updateVisual = function(e, t, n, i) {
    }, r.prototype.toggleBlurSeries = function(e, t, n) {
    }, r.prototype.eachRendered = function(e) {
      var t = this.group;
      t && t.traverse(e);
    }, r;
  }()
);
Ld(s0);
sf(s0);
const Pt = s0;
function Tf() {
  var r = Me();
  return function(e) {
    var t = r(e), n = e.pipelineContext, i = !!t.large, a = !!t.progressiveRender, o = t.large = !!(n && n.large), s = t.progressiveRender = !!(n && n.progressiveRender);
    return (i !== o || a !== s) && "reset";
  };
}
var $4 = Me(), OD = Tf(), l0 = (
  /** @class */
  function() {
    function r() {
      this.group = new dist_oe(), this.uid = Ls("viewChart"), this.renderTask = Yo({
        plan: kD,
        reset: VD
      }), this.renderTask.context = {
        view: this
      };
    }
    return r.prototype.init = function(e, t) {
    }, r.prototype.render = function(e, t, n, i) {
      if (false)
        {}
    }, r.prototype.highlight = function(e, t, n, i) {
      var a = e.getData(i && i.dataType);
      if (!a) {
         false && 0;
        return;
      }
      w1(a, i, "emphasis");
    }, r.prototype.downplay = function(e, t, n, i) {
      var a = e.getData(i && i.dataType);
      if (!a) {
         false && 0;
        return;
      }
      w1(a, i, "normal");
    }, r.prototype.remove = function(e, t) {
      this.group.removeAll();
    }, r.prototype.dispose = function(e, t) {
    }, r.prototype.updateView = function(e, t, n, i) {
      this.render(e, t, n, i);
    }, r.prototype.updateLayout = function(e, t, n, i) {
      this.render(e, t, n, i);
    }, r.prototype.updateVisual = function(e, t, n, i) {
      this.render(e, t, n, i);
    }, r.prototype.eachRendered = function(e) {
      Is(this.group, e);
    }, r.markUpdateMethod = function(e, t) {
      $4(e).updateMethod = t;
    }, r.protoInitialize = function() {
      var e = r.prototype;
      e.type = "chart";
    }(), r;
  }()
);
function S1(r, e, t) {
  r && Oa(r) && (e === "emphasis" ? Pa : Ra)(r, t);
}
function w1(r, e, t) {
  var n = Vi(r, e), i = e && e.highlightKey != null ? jT(e.highlightKey) : null;
  n != null ? dist_M(Ae(n), function(a) {
    S1(r.getItemGraphicEl(a), t, i);
  }) : r.eachItemGraphicEl(function(a) {
    S1(a, t, i);
  });
}
Ld(l0, ["dispose"]);
sf(l0);
function kD(r) {
  return OD(r.model);
}
function VD(r) {
  var e = r.model, t = r.ecModel, n = r.api, i = r.payload, a = e.pipelineContext.progressiveRender, o = r.view, s = i && $4(i).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
  return l !== "render" && o[l](e, t, n, i), BD[l];
}
var BD = {
  incrementalPrepareRender: {
    progress: function(r, e) {
      e.view.incrementalRender(r, e.model, e.ecModel, e.api, e.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(r, e) {
      e.view.render(e.model, e.ecModel, e.api, e.payload);
    }
  }
};
const bt = l0;
var Mu = "\0__throttleOriginMethod", b1 = "\0__throttleRate", x1 = "\0__throttleType";
function u0(r, e, t) {
  var n, i = 0, a = 0, o = null, s, l, u, f;
  e = e || 0;
  function c() {
    a = (/* @__PURE__ */ new Date()).getTime(), o = null, r.apply(l, u || []);
  }
  var h = function() {
    for (var v = [], d = 0; d < arguments.length; d++)
      v[d] = arguments[d];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = v;
    var g = f || e, p = f || t;
    f = null, s = n - (p ? i : a) - g, clearTimeout(o), p ? o = setTimeout(c, g) : s >= 0 ? c() : o = setTimeout(c, -s), i = n;
  };
  return h.clear = function() {
    o && (clearTimeout(o), o = null);
  }, h.debounceNextCall = function(v) {
    f = v;
  }, h;
}
function Mf(r, e, t, n) {
  var i = r[e];
  if (i) {
    var a = i[Mu] || i, o = i[x1], s = i[b1];
    if (s !== t || o !== n) {
      if (t == null || !n)
        return r[e] = a;
      i = r[e] = u0(a, t, n === "debounce"), i[Mu] = a, i[x1] = n, i[b1] = t;
    }
    return i;
  }
}
function Du(r, e) {
  var t = r[e];
  t && t[Mu] && (t.clear && t.clear(), r[e] = t[Mu]);
}
var C1 = Me(), T1 = {
  itemStyle: fs(e4, !0),
  lineStyle: fs(Q_, !0)
}, FD = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function W4(r, e) {
  var t = r.visualStyleMapper || T1[e];
  return t || T1.itemStyle;
}
function U4(r, e) {
  var t = r.visualDrawType || FD[e];
  return t || "fill";
}
var zD = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, e) {
    var t = r.getData(), n = r.visualStyleAccessPath || "itemStyle", i = r.getModel(n), a = W4(r, n), o = a(i), s = i.getShallow("decal");
    s && (t.setVisual("decal", s), s.dirty = !0);
    var l = U4(r, n), u = o[l], f = dist_j(u) ? u : null, c = o.fill === "auto" || o.stroke === "auto";
    if (!o[l] || f || c) {
      var h = r.getColorFromPalette(
        // TODO series count changed.
        r.name,
        null,
        e.getSeriesCount()
      );
      o[l] || (o[l] = h, t.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || dist_j(o.fill) ? h : o.fill, o.stroke = o.stroke === "auto" || dist_j(o.stroke) ? h : o.stroke;
    }
    if (t.setVisual("style", o), t.setVisual("drawType", l), !e.isSeriesFiltered(r) && f)
      return t.setVisual("colorFromPalette", !1), {
        dataEach: function(v, d) {
          var g = r.getDataParams(d), p = dist_V({}, o);
          p[l] = f(g), v.setItemVisual(d, "style", p);
        }
      };
  }
}, ho = new He(), GD = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, e) {
    if (!(r.ignoreStyleOnData || e.isSeriesFiltered(r))) {
      var t = r.getData(), n = r.visualStyleAccessPath || "itemStyle", i = W4(r, n), a = t.getVisual("drawType");
      return {
        dataEach: t.hasItemOption ? function(o, s) {
          var l = o.getRawDataItem(s);
          if (l && l[n]) {
            ho.option = l[n];
            var u = i(ho), f = o.ensureUniqueItemVisual(s, "style");
            dist_V(f, u), ho.option.decal && (o.setItemVisual(s, "decal", ho.option.decal), ho.option.decal.dirty = !0), a in u && o.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, HD = {
  performRawSeries: !0,
  overallReset: function(r) {
    var e = dist_W();
    r.eachSeries(function(t) {
      var n = t.getColorBy();
      if (!t.isColorBySeries()) {
        var i = t.type + "-" + n, a = e.get(i);
        a || (a = {}, e.set(i, a)), C1(t).scope = a;
      }
    }), r.eachSeries(function(t) {
      if (!(t.isColorBySeries() || r.isSeriesFiltered(t))) {
        var n = t.getRawData(), i = {}, a = t.getData(), o = C1(t).scope, s = t.visualStyleAccessPath || "itemStyle", l = U4(t, s);
        a.each(function(u) {
          var f = a.getRawIndex(u);
          i[f] = u;
        }), n.each(function(u) {
          var f = i[u], c = a.getItemVisual(f, "colorFromPalette");
          if (c) {
            var h = a.ensureUniqueItemVisual(f, "style"), v = n.getName(u) || u + "", d = n.count();
            h[l] = t.getColorFromPalette(v, o, d);
          }
        });
      }
    });
  }
}, hl = Math.PI;
function $D(r, e) {
  e = e || {}, dist_se(e, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var t = new dist_oe(), n = new xe({
    style: {
      fill: e.maskColor
    },
    zlevel: e.zlevel,
    z: 1e4
  });
  t.add(n);
  var i = new Ne({
    style: {
      text: e.text,
      fill: e.textColor,
      fontSize: e.fontSize,
      fontWeight: e.fontWeight,
      fontStyle: e.fontStyle,
      fontFamily: e.fontFamily
    },
    zlevel: e.zlevel,
    z: 10001
  }), a = new xe({
    style: {
      fill: "none"
    },
    textContent: i,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: e.zlevel,
    z: 10001
  });
  t.add(a);
  var o;
  return e.showSpinner && (o = new Hd({
    shape: {
      startAngle: -hl / 2,
      endAngle: -hl / 2 + 0.1,
      r: e.spinnerRadius
    },
    style: {
      stroke: e.color,
      lineCap: "round",
      lineWidth: e.lineWidth
    },
    zlevel: e.zlevel,
    z: 10001
  }), o.animateShape(!0).when(1e3, {
    endAngle: hl * 3 / 2
  }).start("circularInOut"), o.animateShape(!0).when(1e3, {
    startAngle: hl * 3 / 2
  }).delay(300).start("circularInOut"), t.add(o)), t.resize = function() {
    var s = i.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, u = (r.getWidth() - l * 2 - (e.showSpinner && s ? 10 : 0) - s) / 2 - (e.showSpinner && s ? 0 : 5 + s / 2) + (e.showSpinner ? 0 : s / 2) + (s ? 0 : l), f = r.getHeight() / 2;
    e.showSpinner && o.setShape({
      cx: u,
      cy: f
    }), a.setShape({
      x: u - l,
      y: f - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: r.getWidth(),
      height: r.getHeight()
    });
  }, t.resize(), t;
}
var Y4 = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      this._stageTaskMap = dist_W(), this.ecInstance = e, this.api = t, n = this._dataProcessorHandlers = n.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i);
    }
    return r.prototype.restoreData = function(e, t) {
      e.restoreData(t), this._stageTaskMap.each(function(n) {
        var i = n.overallTask;
        i && i.dirty();
      });
    }, r.prototype.getPerformArgs = function(e, t) {
      if (e.__pipeline) {
        var n = this._pipelineMap.get(e.__pipeline.id), i = n.context, a = !t && n.progressiveEnabled && (!i || i.progressiveRender) && e.__idxInPipeline > n.blockIndex, o = a ? n.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, r.prototype.getPipeline = function(e) {
      return this._pipelineMap.get(e);
    }, r.prototype.updateStreamModes = function(e, t) {
      var n = this._pipelineMap.get(e.uid), i = e.getData(), a = i.count(), o = n.progressiveEnabled && t.incrementalPrepareRender && a >= n.threshold, s = e.get("large") && a >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? a : null;
      e.pipelineContext = n.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, r.prototype.restorePipelines = function(e) {
      var t = this, n = t._pipelineMap = dist_W();
      e.eachSeries(function(i) {
        var a = i.getProgressive(), o = i.uid;
        n.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), t._pipe(i, i.dataTask);
      });
    }, r.prototype.prepareStageTasks = function() {
      var e = this._stageTaskMap, t = this.api.getModel(), n = this.api;
      dist_M(this._allHandlers, function(i) {
        var a = e.get(i.uid) || e.set(i.uid, {}), o = "";
         false && (0), dist_re(!(i.reset && i.overallReset), o), i.reset && this._createSeriesStageTask(i, a, t, n), i.overallReset && this._createOverallStageTask(i, a, t, n);
      }, this);
    }, r.prototype.prepareView = function(e, t, n, i) {
      var a = e.renderTask, o = a.context;
      o.model = t, o.ecModel = n, o.api = i, a.__block = !e.incrementalPrepareRender, this._pipe(t, a);
    }, r.prototype.performDataProcessorTasks = function(e, t) {
      this._performStageTasks(this._dataProcessorHandlers, e, t, {
        block: !0
      });
    }, r.prototype.performVisualTasks = function(e, t, n) {
      this._performStageTasks(this._visualHandlers, e, t, n);
    }, r.prototype._performStageTasks = function(e, t, n, i) {
      i = i || {};
      var a = !1, o = this;
      dist_M(e, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var f = o._stageTaskMap.get(l.uid), c = f.seriesTaskMap, h = f.overallTask;
          if (h) {
            var v, d = h.agentStubMap;
            d.each(function(p) {
              s(i, p) && (p.dirty(), v = !0);
            }), v && h.dirty(), o.updatePayload(h, n);
            var g = o.getPerformArgs(h, i.block);
            d.each(function(p) {
              p.perform(g);
            }), h.perform(g) && (a = !0);
          } else
            c && c.each(function(p, m) {
              s(i, p) && p.dirty();
              var y = o.getPerformArgs(p, i.block);
              y.skip = !l.performRawSeries && t.isSeriesFiltered(p.context.model), o.updatePayload(p, n), p.perform(y) && (a = !0);
            });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, r.prototype.performSeriesTasks = function(e) {
      var t;
      e.eachSeries(function(n) {
        t = n.dataTask.perform() || t;
      }), this.unfinished = t || this.unfinished;
    }, r.prototype.plan = function() {
      this._pipelineMap.each(function(e) {
        var t = e.tail;
        do {
          if (t.__block) {
            e.blockIndex = t.__idxInPipeline;
            break;
          }
          t = t.getUpstream();
        } while (t);
      });
    }, r.prototype.updatePayload = function(e, t) {
      t !== "remain" && (e.context.payload = t);
    }, r.prototype._createSeriesStageTask = function(e, t, n, i) {
      var a = this, o = t.seriesTaskMap, s = t.seriesTaskMap = dist_W(), l = e.seriesType, u = e.getTargetSeries;
      e.createOnAllSeries ? n.eachRawSeries(f) : l ? n.eachRawSeriesByType(l, f) : u && u(n, i).each(f);
      function f(c) {
        var h = c.uid, v = s.set(h, o && o.get(h) || Yo({
          plan: ZD,
          reset: qD,
          count: jD
        }));
        v.context = {
          model: c,
          ecModel: n,
          api: i,
          // PENDING: `useClearVisual` not used?
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: a
        }, a._pipe(c, v);
      }
    }, r.prototype._createOverallStageTask = function(e, t, n, i) {
      var a = this, o = t.overallTask = t.overallTask || Yo({
        reset: WD
      });
      o.context = {
        ecModel: n,
        api: i,
        overallReset: e.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = dist_W(), u = e.seriesType, f = e.getTargetSeries, c = !0, h = !1, v = "";
       false && (0), dist_re(!e.createOnAllSeries, v), u ? n.eachRawSeriesByType(u, d) : f ? f(n, i).each(d) : (c = !1, dist_M(n.getSeries(), d));
      function d(g) {
        var p = g.uid, m = l.set(p, s && s.get(p) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (h = !0, Yo({
          reset: UD,
          onDirty: XD
        })));
        m.context = {
          model: g,
          overallProgress: c
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, m.agent = o, m.__block = c, a._pipe(g, m);
      }
      h && o.dirty();
    }, r.prototype._pipe = function(e, t) {
      var n = e.uid, i = this._pipelineMap.get(n);
      !i.head && (i.head = t), i.tail && i.tail.pipe(t), i.tail = t, t.__idxInPipeline = i.count++, t.__pipeline = i;
    }, r.wrapStageHandler = function(e, t) {
      return dist_j(e) && (e = {
        overallReset: e,
        seriesType: JD(e)
      }), e.uid = Ls("stageHandler"), t && (e.visualType = t), e;
    }, r;
  }()
);
function WD(r) {
  r.overallReset(r.ecModel, r.api, r.payload);
}
function UD(r) {
  return r.overallProgress && YD;
}
function YD() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function XD() {
  this.agent && this.agent.dirty();
}
function ZD(r) {
  return r.plan ? r.plan(r.model, r.ecModel, r.api, r.payload) : null;
}
function qD(r) {
  r.useClearVisual && r.data.clearAllVisual();
  var e = r.resetDefines = Ae(r.reset(r.model, r.ecModel, r.api, r.payload));
  return e.length > 1 ? dist_$(e, function(t, n) {
    return X4(n);
  }) : KD;
}
var KD = X4(0);
function X4(r) {
  return function(e, t) {
    var n = t.data, i = t.resetDefines[r];
    if (i && i.dataEach)
      for (var a = e.start; a < e.end; a++)
        i.dataEach(n, a);
    else
      i && i.progress && i.progress(e, n);
  };
}
function jD(r) {
  return r.data.count();
}
function JD(r) {
  Eu = null;
  try {
    r(ps, Z4);
  } catch {
  }
  return Eu;
}
var ps = {}, Z4 = {}, Eu;
q4(ps, r0);
q4(Z4, S4);
ps.eachSeriesByType = ps.eachRawSeriesByType = function(r) {
  Eu = r;
};
ps.eachComponent = function(r) {
  r.mainType === "series" && r.subType && (Eu = r.subType);
};
function q4(r, e) {
  for (var t in e.prototype)
    r[t] = Ue;
}
var M1 = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const QD = {
  color: M1,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], M1]
};
var ot = "#B9B8CE", D1 = "#100C2A", vl = function() {
  return {
    axisLine: {
      lineStyle: {
        color: ot
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, E1 = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], K4 = {
  darkMode: !0,
  color: E1,
  backgroundColor: D1,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: ot
    }
  },
  textStyle: {
    color: ot
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: ot
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: ot
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: ot
    }
  },
  timeline: {
    lineStyle: {
      color: ot
    },
    label: {
      color: ot
    },
    controlStyle: {
      color: ot,
      borderColor: ot
    }
  },
  calendar: {
    itemStyle: {
      color: D1
    },
    dayLabel: {
      color: ot
    },
    monthLabel: {
      color: ot
    },
    yearLabel: {
      color: ot
    }
  },
  timeAxis: vl(),
  logAxis: vl(),
  valueAxis: vl(),
  categoryAxis: vl(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: E1
  },
  gauge: {
    title: {
      color: ot
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: ot
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
K4.categoryAxis.splitLine.show = !1;
const eE = K4;
var tE = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.normalizeQuery = function(e) {
      var t = {}, n = {}, i = {};
      if (dist_U(e)) {
        var a = Tr(e);
        t.mainType = a.main || null, t.subType = a.sub || null;
      } else {
        var o = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        dist_M(e, function(l, u) {
          for (var f = !1, c = 0; c < o.length; c++) {
            var h = o[c], v = u.lastIndexOf(h);
            if (v > 0 && v === u.length - h.length) {
              var d = u.slice(0, v);
              d !== "data" && (t.mainType = d, t[h.toLowerCase()] = l, f = !0);
            }
          }
          s.hasOwnProperty(u) && (n[u] = l, f = !0), f || (i[u] = l);
        });
      }
      return {
        cptQuery: t,
        dataQuery: n,
        otherQuery: i
      };
    }, r.prototype.filter = function(e, t) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var i = n.targetEl, a = n.packedEvent, o = n.model, s = n.view;
      if (!o || !s)
        return !0;
      var l = t.cptQuery, u = t.dataQuery;
      return f(l, o, "mainType") && f(l, o, "subType") && f(l, o, "index", "componentIndex") && f(l, o, "name") && f(l, o, "id") && f(u, a, "name") && f(u, a, "dataIndex") && f(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(e, t.otherQuery, i, a));
      function f(c, h, v, d) {
        return c[v] == null || h[d || v] === c[v];
      }
    }, r.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, r;
  }()
), Pv = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], A1 = Pv.concat(["symbolKeepAspect"]), rE = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, e) {
    var t = r.getData();
    if (r.legendIcon && t.setVisual("legendIcon", r.legendIcon), !r.hasSymbolVisual)
      return;
    for (var n = {}, i = {}, a = !1, o = 0; o < Pv.length; o++) {
      var s = Pv[o], l = r.get(s);
      dist_j(l) ? (a = !0, i[s] = l) : n[s] = l;
    }
    if (n.symbol = n.symbol || r.defaultSymbol, t.setVisual(dist_V({
      legendIcon: r.legendIcon || n.symbol,
      symbolKeepAspect: r.get("symbolKeepAspect")
    }, n)), e.isSeriesFiltered(r))
      return;
    var u = we(i);
    function f(c, h) {
      for (var v = r.getRawValue(h), d = r.getDataParams(h), g = 0; g < u.length; g++) {
        var p = u[g];
        c.setItemVisual(h, p, i[p](v, d));
      }
    }
    return {
      dataEach: a ? f : null
    };
  }
}, nE = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, e) {
    if (!r.hasSymbolVisual || e.isSeriesFiltered(r))
      return;
    var t = r.getData();
    function n(i, a) {
      for (var o = i.getItemModel(a), s = 0; s < A1.length; s++) {
        var l = A1[s], u = o.getShallow(l, !0);
        u != null && i.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: t.hasItemOption ? n : null
    };
  }
};
function j4(r, e, t) {
  switch (t) {
    case "color":
      var n = r.getItemVisual(e, "style");
      return n[r.getVisual("drawType")];
    case "opacity":
      return r.getItemVisual(e, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getItemVisual(e, t);
    default:
      "production";
  }
}
function J4(r, e) {
  switch (e) {
    case "color":
      var t = r.getVisual("style");
      return t[r.getVisual("drawType")];
    case "opacity":
      return r.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getVisual(e);
    default:
      "production";
  }
}
function iE(r, e, t, n) {
  switch (t) {
    case "color":
      var i = r.ensureUniqueItemVisual(e, "style");
      i[r.getVisual("drawType")] = n, r.setItemVisual(e, "colorFromPalette", !1);
      break;
    case "opacity":
      r.ensureUniqueItemVisual(e, "style").opacity = n;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      r.setItemVisual(e, t, n);
      break;
    default:
      "production";
  }
}
function Q4(r, e) {
  function t(n, i) {
    var a = [];
    return n.eachComponent({
      mainType: "series",
      subType: r,
      query: i
    }, function(o) {
      a.push(o.seriesIndex);
    }), a;
  }
  dist_M([[r + "ToggleSelect", "toggleSelect"], [r + "Select", "select"], [r + "UnSelect", "unselect"]], function(n) {
    e(n[0], function(i, a, o) {
      i = dist_V({}, i),  false && 0, o.dispatchAction(dist_V(i, {
        type: n[1],
        seriesIndex: t(a, i)
      }));
    });
  });
}
function na(r, e, t, n, i) {
  var a = r + e;
  t.isSilent(a) || ( false && 0, n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(o) {
    for (var s = o.seriesIndex, l = o.option.selectedMap, u = i.selected, f = 0; f < u.length; f++)
      if (u[f].seriesIndex === s) {
        var c = o.getData(), h = Vi(c, i.fromActionPayload);
        t.trigger(a, {
          type: a,
          seriesId: o.id,
          name: dist_F(h) ? c.getName(h[0]) : c.getName(h),
          selected: dist_U(l) ? l : dist_V({}, l)
        });
      }
  }));
}
function aE(r, e, t) {
  r.on("selectchanged", function(n) {
    var i = t.getModel();
    n.isFromClick ? (na("map", "selectchanged", e, i, n), na("pie", "selectchanged", e, i, n)) : n.fromAction === "select" ? (na("map", "selected", e, i, n), na("pie", "selected", e, i, n)) : n.fromAction === "unselect" && (na("map", "unselected", e, i, n), na("pie", "unselected", e, i, n));
  });
}
function Ti(r, e, t) {
  for (var n; r && !(e(r) && (n = r, t)); )
    r = r.__hostTarget || r.parent;
  return n;
}
var oE = Math.round(Math.random() * 9), sE = typeof Object.defineProperty == "function", lE = function() {
  function r() {
    this._id = "__ec_inner_" + oE++;
  }
  return r.prototype.get = function(e) {
    return this._guard(e)[this._id];
  }, r.prototype.set = function(e, t) {
    var n = this._guard(e);
    return sE ? Object.defineProperty(n, this._id, {
      value: t,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = t, this;
  }, r.prototype.delete = function(e) {
    return this.has(e) ? (delete this._guard(e)[this._id], !0) : !1;
  }, r.prototype.has = function(e) {
    return !!this._guard(e)[this._id];
  }, r.prototype._guard = function(e) {
    if (e !== Object(e))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return e;
  }, r;
}(), uE = fe.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.cx, n = e.cy, i = e.width / 2, a = e.height / 2;
    r.moveTo(t, n - a), r.lineTo(t + i, n + a), r.lineTo(t - i, n + a), r.closePath();
  }
}), fE = fe.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.cx, n = e.cy, i = e.width / 2, a = e.height / 2;
    r.moveTo(t, n - a), r.lineTo(t + i, n), r.lineTo(t, n + a), r.lineTo(t - i, n), r.closePath();
  }
}), cE = fe.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.x, n = e.y, i = e.width / 5 * 3, a = Math.max(i, e.height), o = i / 2, s = o * o / (a - o), l = n - a + o + s, u = Math.asin(s / o), f = Math.cos(u) * o, c = Math.sin(u), h = Math.cos(u), v = o * 0.6, d = o * 0.7;
    r.moveTo(t - f, l + s), r.arc(t, l, o, Math.PI - u, Math.PI * 2 + u), r.bezierCurveTo(t + f - c * v, l + s + h * v, t, n - d, t, n), r.bezierCurveTo(t, n - d, t - f + c * v, l + s + h * v, t - f, l + s), r.closePath();
  }
}), hE = fe.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.height, n = e.width, i = e.x, a = e.y, o = n / 3 * 2;
    r.moveTo(i, a), r.lineTo(i + o, a + t), r.lineTo(i, a + t / 4 * 3), r.lineTo(i - o, a + t), r.lineTo(i, a), r.closePath();
  }
}), vE = {
  line: an,
  rect: xe,
  roundRect: xe,
  square: xe,
  circle: As,
  diamond: fE,
  pin: cE,
  arrow: hE,
  triangle: uE
}, dE = {
  line: function(r, e, t, n, i) {
    i.x1 = r, i.y1 = e + n / 2, i.x2 = r + t, i.y2 = e + n / 2;
  },
  rect: function(r, e, t, n, i) {
    i.x = r, i.y = e, i.width = t, i.height = n;
  },
  roundRect: function(r, e, t, n, i) {
    i.x = r, i.y = e, i.width = t, i.height = n, i.r = Math.min(t, n) / 4;
  },
  square: function(r, e, t, n, i) {
    var a = Math.min(t, n);
    i.x = r, i.y = e, i.width = a, i.height = a;
  },
  circle: function(r, e, t, n, i) {
    i.cx = r + t / 2, i.cy = e + n / 2, i.r = Math.min(t, n) / 2;
  },
  diamond: function(r, e, t, n, i) {
    i.cx = r + t / 2, i.cy = e + n / 2, i.width = t, i.height = n;
  },
  pin: function(r, e, t, n, i) {
    i.x = r + t / 2, i.y = e + n / 2, i.width = t, i.height = n;
  },
  arrow: function(r, e, t, n, i) {
    i.x = r + t / 2, i.y = e + n / 2, i.width = t, i.height = n;
  },
  triangle: function(r, e, t, n, i) {
    i.cx = r + t / 2, i.cy = e + n / 2, i.width = t, i.height = n;
  }
}, Au = {};
dist_M(vE, function(r, e) {
  Au[e] = new r();
});
var pE = fe.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(r, e, t) {
    var n = vu(r, e, t), i = this.shape;
    return i && i.symbolType === "pin" && e.position === "inside" && (n.y = t.y + t.height * 0.4), n;
  },
  buildPath: function(r, e, t) {
    var n = e.symbolType;
    if (n !== "none") {
      var i = Au[n];
      i || (n = "rect", i = Au[n]), dE[n](e.x, e.y, e.width, e.height, i.shape), i.buildPath(r, i.shape, t);
    }
  }
});
function gE(r, e) {
  if (this.type !== "image") {
    var t = this.style;
    this.__isEmptyBrush ? (t.stroke = r, t.fill = e || "#fff", t.lineWidth = 2) : this.shape.symbolType === "line" ? t.stroke = r : t.fill = r, this.markRedraw();
  }
}
function dt(r, e, t, n, i, a, o) {
  var s = r.indexOf("empty") === 0;
  s && (r = r.substr(5, 1).toLowerCase() + r.substr(6));
  var l;
  return r.indexOf("image://") === 0 ? l = X_(r.slice(8), new dist_ae(e, t, n, i), o ? "center" : "cover") : r.indexOf("path://") === 0 ? l = Ud(r.slice(7), {}, new dist_ae(e, t, n, i), o ? "center" : "cover") : l = new pE({
    shape: {
      symbolType: r,
      x: e,
      y: t,
      width: n,
      height: i
    }
  }), l.__isEmptyBrush = s, l.setColor = gE, a && l.setColor(a), l;
}
function Df(r) {
  return dist_F(r) || (r = [+r, +r]), [r[0] || 0, r[1] || 0];
}
function Os(r, e) {
  if (r != null)
    return dist_F(r) || (r = [r, r]), [me(r[0], e[0]) || 0, me(dist_ne(r[1], r[0]), e[1]) || 0];
}
function Mi(r) {
  return isFinite(r);
}
function mE(r, e, t) {
  var n = e.x == null ? 0 : e.x, i = e.x2 == null ? 1 : e.x2, a = e.y == null ? 0 : e.y, o = e.y2 == null ? 0 : e.y2;
  e.global || (n = n * t.width + t.x, i = i * t.width + t.x, a = a * t.height + t.y, o = o * t.height + t.y), n = Mi(n) ? n : 0, i = Mi(i) ? i : 1, a = Mi(a) ? a : 0, o = Mi(o) ? o : 0;
  var s = r.createLinearGradient(n, a, i, o);
  return s;
}
function yE(r, e, t) {
  var n = t.width, i = t.height, a = Math.min(n, i), o = e.x == null ? 0.5 : e.x, s = e.y == null ? 0.5 : e.y, l = e.r == null ? 0.5 : e.r;
  e.global || (o = o * n + t.x, s = s * i + t.y, l = l * a), o = Mi(o) ? o : 0.5, s = Mi(s) ? s : 0.5, l = l >= 0 && Mi(l) ? l : 0.5;
  var u = r.createRadialGradient(o, s, 0, o, s, l);
  return u;
}
function Rv(r, e, t) {
  for (var n = e.type === "radial" ? yE(r, e, t) : mE(r, e, t), i = e.colorStops, a = 0; a < i.length; a++)
    n.addColorStop(i[a].offset, i[a].color);
  return n;
}
function _E(r, e) {
  if (r === e || !r && !e)
    return !1;
  if (!r || !e || r.length !== e.length)
    return !0;
  for (var t = 0; t < r.length; t++)
    if (r[t] !== e[t])
      return !0;
  return !1;
}
function dl(r) {
  return parseInt(r, 10);
}
function pl(r, e, t) {
  var n = ["width", "height"][e], i = ["clientWidth", "clientHeight"][e], a = ["paddingLeft", "paddingTop"][e], o = ["paddingRight", "paddingBottom"][e];
  if (t[n] != null && t[n] !== "auto")
    return parseFloat(t[n]);
  var s = document.defaultView.getComputedStyle(r);
  return (r[i] || dl(s[n]) || dl(r.style[n])) - (dl(s[a]) || 0) - (dl(s[o]) || 0) | 0;
}
function SE(r, e) {
  return !r || r === "solid" || !(e > 0) ? null : r === "dashed" ? [4 * e, 2 * e] : r === "dotted" ? [e] : ve(r) ? [r] : dist_F(r) ? r : null;
}
function e6(r) {
  var e = r.style, t = e.lineDash && e.lineWidth > 0 && SE(e.lineDash, e.lineWidth), n = e.lineDashOffset;
  if (t) {
    var i = e.strokeNoScale && r.getLineScale ? r.getLineScale() : 1;
    i && i !== 1 && (t = dist_$(t, function(a) {
      return a / i;
    }), n /= i);
  }
  return [t, n];
}
var wE = new tn(!0);
function Iu(r) {
  var e = r.stroke;
  return !(e == null || e === "none" || !(r.lineWidth > 0));
}
function I1(r) {
  return typeof r == "string" && r !== "none";
}
function Lu(r) {
  var e = r.fill;
  return e != null && e !== "none";
}
function L1(r, e) {
  if (e.fillOpacity != null && e.fillOpacity !== 1) {
    var t = r.globalAlpha;
    r.globalAlpha = e.fillOpacity * e.opacity, r.fill(), r.globalAlpha = t;
  } else
    r.fill();
}
function N1(r, e) {
  if (e.strokeOpacity != null && e.strokeOpacity !== 1) {
    var t = r.globalAlpha;
    r.globalAlpha = e.strokeOpacity * e.opacity, r.stroke(), r.globalAlpha = t;
  } else
    r.stroke();
}
function Ov(r, e, t) {
  var n = i_(e.image, e.__image, t);
  if (lf(n)) {
    var i = r.createPattern(n, e.repeat || "repeat");
    if (typeof DOMMatrix == "function" && i && i.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(e.x || 0, e.y || 0), a.rotateSelf(0, 0, (e.rotation || 0) * jx), a.scaleSelf(e.scaleX || 1, e.scaleY || 1), i.setTransform(a);
    }
    return i;
  }
}
function bE(r, e, t, n) {
  var i, a = Iu(t), o = Lu(t), s = t.strokePercent, l = s < 1, u = !e.path;
  (!e.silent || l) && u && e.createPathProxy();
  var f = e.path || wE, c = e.__dirty;
  if (!n) {
    var h = t.fill, v = t.stroke, d = o && !!h.colorStops, g = a && !!v.colorStops, p = o && !!h.image, m = a && !!v.image, y = void 0, _ = void 0, S = void 0, b = void 0, w = void 0;
    (d || g) && (w = e.getBoundingRect()), d && (y = c ? Rv(r, h, w) : e.__canvasFillGradient, e.__canvasFillGradient = y), g && (_ = c ? Rv(r, v, w) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = _), p && (S = c || !e.__canvasFillPattern ? Ov(r, h, e) : e.__canvasFillPattern, e.__canvasFillPattern = S), m && (b = c || !e.__canvasStrokePattern ? Ov(r, v, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = S), d ? r.fillStyle = y : p && (S ? r.fillStyle = S : o = !1), g ? r.strokeStyle = _ : m && (b ? r.strokeStyle = b : a = !1);
  }
  var x = e.getGlobalScale();
  f.setScale(x[0], x[1], e.segmentIgnoreThreshold);
  var C, T;
  r.setLineDash && t.lineDash && (i = e6(e), C = i[0], T = i[1]);
  var E = !0;
  (u || c & ma) && (f.setDPR(r.dpr), l ? f.setContext(null) : (f.setContext(r), E = !1), f.reset(), e.buildPath(f, e.shape, n), f.toStatic(), e.pathUpdated()), E && f.rebuildPath(r, l ? s : 1), C && (r.setLineDash(C), r.lineDashOffset = T), n || (t.strokeFirst ? (a && N1(r, t), o && L1(r, t)) : (o && L1(r, t), a && N1(r, t))), C && r.setLineDash([]);
}
function xE(r, e, t) {
  var n = e.__image = i_(t.image, e.__image, e, e.onload);
  if (!(!n || !lf(n))) {
    var i = t.x || 0, a = t.y || 0, o = e.getWidth(), s = e.getHeight(), l = n.width / n.height;
    if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = n.width, s = n.height), t.sWidth && t.sHeight) {
      var u = t.sx || 0, f = t.sy || 0;
      r.drawImage(n, u, f, t.sWidth, t.sHeight, i, a, o, s);
    } else if (t.sx && t.sy) {
      var u = t.sx, f = t.sy, c = o - u, h = s - f;
      r.drawImage(n, u, f, c, h, i, a, o, s);
    } else
      r.drawImage(n, i, a, o, s);
  }
}
function CE(r, e, t) {
  var n, i = t.text;
  if (i != null && (i += ""), i) {
    r.font = t.font || ki, r.textAlign = t.textAlign, r.textBaseline = t.textBaseline;
    var a = void 0, o = void 0;
    r.setLineDash && t.lineDash && (n = e6(e), a = n[0], o = n[1]), a && (r.setLineDash(a), r.lineDashOffset = o), t.strokeFirst ? (Iu(t) && r.strokeText(i, t.x, t.y), Lu(t) && r.fillText(i, t.x, t.y)) : (Lu(t) && r.fillText(i, t.x, t.y), Iu(t) && r.strokeText(i, t.x, t.y)), a && r.setLineDash([]);
  }
}
var P1 = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], R1 = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function t6(r, e, t, n, i) {
  var a = !1;
  if (!n && (t = t || {}, e === t))
    return !1;
  if (n || e.opacity !== t.opacity) {
    St(r, i), a = !0;
    var o = Math.max(Math.min(e.opacity, 1), 0);
    r.globalAlpha = isNaN(o) ? Li.opacity : o;
  }
  (n || e.blend !== t.blend) && (a || (St(r, i), a = !0), r.globalCompositeOperation = e.blend || Li.blend);
  for (var s = 0; s < P1.length; s++) {
    var l = P1[s];
    (n || e[l] !== t[l]) && (a || (St(r, i), a = !0), r[l] = r.dpr * (e[l] || 0));
  }
  return (n || e.shadowColor !== t.shadowColor) && (a || (St(r, i), a = !0), r.shadowColor = e.shadowColor || Li.shadowColor), a;
}
function O1(r, e, t, n, i) {
  var a = gs(e, i.inHover), o = n ? null : t && gs(t, i.inHover) || {};
  if (a === o)
    return !1;
  var s = t6(r, a, o, n, i);
  if ((n || a.fill !== o.fill) && (s || (St(r, i), s = !0), I1(a.fill) && (r.fillStyle = a.fill)), (n || a.stroke !== o.stroke) && (s || (St(r, i), s = !0), I1(a.stroke) && (r.strokeStyle = a.stroke)), (n || a.opacity !== o.opacity) && (s || (St(r, i), s = !0), r.globalAlpha = a.opacity == null ? 1 : a.opacity), e.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && e.getLineScale ? e.getLineScale() : 1);
    r.lineWidth !== u && (s || (St(r, i), s = !0), r.lineWidth = u);
  }
  for (var f = 0; f < R1.length; f++) {
    var c = R1[f], h = c[0];
    (n || a[h] !== o[h]) && (s || (St(r, i), s = !0), r[h] = a[h] || c[1]);
  }
  return s;
}
function TE(r, e, t, n, i) {
  return t6(r, gs(e, i.inHover), t && gs(t, i.inHover), n, i);
}
function r6(r, e) {
  var t = e.transform, n = r.dpr || 1;
  t ? r.setTransform(n * t[0], n * t[1], n * t[2], n * t[3], n * t[4], n * t[5]) : r.setTransform(n, 0, 0, n, 0, 0);
}
function ME(r, e, t) {
  for (var n = !1, i = 0; i < r.length; i++) {
    var a = r[i];
    n = n || a.isZeroArea(), r6(e, a), e.beginPath(), a.buildPath(e, a.shape), e.clip();
  }
  t.allClipped = n;
}
function DE(r, e) {
  return r && e ? r[0] !== e[0] || r[1] !== e[1] || r[2] !== e[2] || r[3] !== e[3] || r[4] !== e[4] || r[5] !== e[5] : !(!r && !e);
}
var k1 = 1, V1 = 2, B1 = 3, F1 = 4;
function EE(r) {
  var e = Lu(r), t = Iu(r);
  return !(r.lineDash || !(+e ^ +t) || e && typeof r.fill != "string" || t && typeof r.stroke != "string" || r.strokePercent < 1 || r.strokeOpacity < 1 || r.fillOpacity < 1);
}
function St(r, e) {
  e.batchFill && r.fill(), e.batchStroke && r.stroke(), e.batchFill = "", e.batchStroke = "";
}
function gs(r, e) {
  return e && r.__hoverStyle || r.style;
}
function n6(r, e) {
  Di(r, e, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Di(r, e, t, n) {
  var i = e.transform;
  if (!e.shouldBePainted(t.viewWidth, t.viewHeight, !1, !1)) {
    e.__dirty &= ~Et, e.__isRendered = !1;
    return;
  }
  var a = e.__clipPaths, o = t.prevElClipPaths, s = !1, l = !1;
  if ((!o || _E(a, o)) && (o && o.length && (St(r, t), r.restore(), l = s = !0, t.prevElClipPaths = null, t.allClipped = !1, t.prevEl = null), a && a.length && (St(r, t), r.save(), ME(a, r, t), s = !0), t.prevElClipPaths = a), t.allClipped) {
    e.__isRendered = !1;
    return;
  }
  e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
  var u = t.prevEl;
  u || (l = s = !0);
  var f = e instanceof fe && e.autoBatch && EE(e.style);
  s || DE(i, u.transform) ? (St(r, t), r6(r, e)) : f || St(r, t);
  var c = gs(e, t.inHover);
  e instanceof fe ? (t.lastDrawType !== k1 && (l = !0, t.lastDrawType = k1), O1(r, e, u, l, t), (!f || !t.batchFill && !t.batchStroke) && r.beginPath(), bE(r, e, c, f), f && (t.batchFill = c.fill || "", t.batchStroke = c.stroke || "")) : e instanceof pu ? (t.lastDrawType !== B1 && (l = !0, t.lastDrawType = B1), O1(r, e, u, l, t), CE(r, e, c)) : e instanceof un ? (t.lastDrawType !== V1 && (l = !0, t.lastDrawType = V1), TE(r, e, u, l, t), xE(r, e, c)) : e.getTemporalDisplayables && (t.lastDrawType !== F1 && (l = !0, t.lastDrawType = F1), AE(r, e, t)), f && n && St(r, t), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), t.prevEl = e, e.__dirty = 0, e.__isRendered = !0;
}
function AE(r, e, t) {
  var n = e.getDisplayables(), i = e.getTemporalDisplayables();
  r.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: t.viewWidth,
    viewHeight: t.viewHeight,
    inHover: t.inHover
  }, o, s;
  for (o = e.getCursor(), s = n.length; o < s; o++) {
    var l = n[o];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Di(r, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, f = i.length; u < f; u++) {
    var l = i[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Di(r, l, a, u === f - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  e.clearTemporalDisplayables(), e.notClear = !0, r.restore();
}
var Hc = new lE(), z1 = new Ms(100), G1 = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Nu(r, e) {
  if (r === "none")
    return null;
  var t = e.getDevicePixelRatio(), n = e.getZr(), i = n.painter.type === "svg";
  r.dirty && Hc.delete(r);
  var a = Hc.get(r);
  if (a)
    return a;
  var o = dist_se(r, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  o.backgroundColor === "none" && (o.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / t, Hc.set(r, s), r.dirty = !1, s;
  function l(u) {
    for (var f = [t], c = !0, h = 0; h < G1.length; ++h) {
      var v = o[G1[h]];
      if (v != null && !dist_F(v) && !dist_U(v) && !ve(v) && typeof v != "boolean") {
        c = !1;
        break;
      }
      f.push(v);
    }
    var d;
    if (c) {
      d = f.join(",") + (i ? "-svg" : "");
      var g = z1.get(d);
      g && (i ? u.svgElement = g : u.image = g);
    }
    var p = a6(o.dashArrayX), m = IE(o.dashArrayY), y = i6(o.symbol), _ = LE(p), S = o6(m), b = !i && Ha.createCanvas(), w = i && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, x = T(), C;
    b && (b.width = x.width * t, b.height = x.height * t, C = b.getContext("2d")), E(), c && z1.put(d, b || w), u.image = b, u.svgElement = w, u.svgWidth = x.width, u.svgHeight = x.height;
    function T() {
      for (var D = 1, I = 0, L = _.length; I < L; ++I)
        D = Qp(D, _[I]);
      for (var N = 1, I = 0, L = y.length; I < L; ++I)
        N = Qp(N, y[I].length);
      D *= N;
      var P = S * _.length * y.length;
      if (false) { var R; }
      return {
        width: Math.max(1, Math.min(D, o.maxTileWidth)),
        height: Math.max(1, Math.min(P, o.maxTileHeight))
      };
    }
    function E() {
      C && (C.clearRect(0, 0, b.width, b.height), o.backgroundColor && (C.fillStyle = o.backgroundColor, C.fillRect(0, 0, b.width, b.height)));
      for (var D = 0, I = 0; I < m.length; ++I)
        D += m[I];
      if (D <= 0)
        return;
      for (var L = -S, N = 0, P = 0, R = 0; L < x.height; ) {
        if (N % 2 === 0) {
          for (var z = P / 2 % y.length, O = 0, B = 0, H = 0; O < x.width * 2; ) {
            for (var q = 0, I = 0; I < p[R].length; ++I)
              q += p[R][I];
            if (q <= 0)
              break;
            if (B % 2 === 0) {
              var Q = (1 - o.symbolSize) * 0.5, le = O + p[R][B] * Q, ge = L + m[N] * Q, Re = p[R][B] * o.symbolSize, Ce = m[N] * o.symbolSize, je = H / 2 % y[z].length;
              Je(le, ge, Re, Ce, y[z][je]);
            }
            O += p[R][B], ++H, ++B, B === p[R].length && (B = 0);
          }
          ++R, R === p.length && (R = 0);
        }
        L += m[N], ++P, ++N, N === m.length && (N = 0);
      }
      function Je(Fe, Ee, J, ce, pr) {
        var $e = i ? 1 : t, vn = dt(pr, Fe * $e, Ee * $e, J * $e, ce * $e, o.color, o.symbolKeepAspect);
        if (i) {
          var Rr = n.painter.renderOneToVNode(vn);
          Rr && w.children.push(Rr);
        } else
          n6(C, vn);
      }
    }
  }
}
function i6(r) {
  if (!r || r.length === 0)
    return [["rect"]];
  if (dist_U(r))
    return [[r]];
  for (var e = !0, t = 0; t < r.length; ++t)
    if (!dist_U(r[t])) {
      e = !1;
      break;
    }
  if (e)
    return i6([r]);
  for (var n = [], t = 0; t < r.length; ++t)
    dist_U(r[t]) ? n.push([r[t]]) : n.push(r[t]);
  return n;
}
function a6(r) {
  if (!r || r.length === 0)
    return [[0, 0]];
  if (ve(r)) {
    var e = Math.ceil(r);
    return [[e, e]];
  }
  for (var t = !0, n = 0; n < r.length; ++n)
    if (!ve(r[n])) {
      t = !1;
      break;
    }
  if (t)
    return a6([r]);
  for (var i = [], n = 0; n < r.length; ++n)
    if (ve(r[n])) {
      var e = Math.ceil(r[n]);
      i.push([e, e]);
    } else {
      var e = dist_$(r[n], function(s) {
        return Math.ceil(s);
      });
      e.length % 2 === 1 ? i.push(e.concat(e)) : i.push(e);
    }
  return i;
}
function IE(r) {
  if (!r || typeof r == "object" && r.length === 0)
    return [0, 0];
  if (ve(r)) {
    var e = Math.ceil(r);
    return [e, e];
  }
  var t = dist_$(r, function(n) {
    return Math.ceil(n);
  });
  return r.length % 2 ? t.concat(t) : t;
}
function LE(r) {
  return dist_$(r, function(e) {
    return o6(e);
  });
}
function o6(r) {
  for (var e = 0, t = 0; t < r.length; ++t)
    e += r[t];
  return r.length % 2 === 1 ? e * 2 : e;
}
function NE(r, e) {
  r.eachRawSeries(function(t) {
    if (!r.isSeriesFiltered(t)) {
      var n = t.getData();
      n.hasItemVisual() && n.each(function(o) {
        var s = n.getItemVisual(o, "decal");
        if (s) {
          var l = n.ensureUniqueItemVisual(o, "style");
          l.decal = Nu(s, e);
        }
      });
      var i = n.getVisual("decal");
      if (i) {
        var a = n.getVisual("style");
        a.decal = Nu(i, e);
      }
    }
  });
}
var ir = new vr(), Pu = {};
function PE(r, e) {
   false && 0, Pu[r] = e;
}
function RE(r) {
  return  false && (0), Pu[r];
}
var OE = 1, kE = 800, VE = 900, BE = 1e3, FE = 2e3, zE = 5e3, s6 = 1e3, GE = 1100, f0 = 2e3, l6 = 3e3, HE = 4e3, Ef = 4500, $E = 4600, WE = 5e3, UE = 6e3, u6 = 7e3, YE = {
  PROCESSOR: {
    FILTER: BE,
    SERIES_FILTER: kE,
    STATISTIC: zE
  },
  VISUAL: {
    LAYOUT: s6,
    PROGRESSIVE_LAYOUT: GE,
    GLOBAL: f0,
    CHART: l6,
    POST_CHART_LAYOUT: $E,
    COMPONENT: HE,
    BRUSH: WE,
    CHART_ITEM: Ef,
    ARIA: UE,
    DECAL: u6
  }
}, et = "__flagInMainProcess", gt = "__pendingUpdate", $c = "__needsUpdateStatus", H1 = /^[a-zA-Z0-9_]+$/, Wc = "__connectUpdateStatus", $1 = 0, XE = 1, ZE = 2;
function f6(r) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    if (this.isDisposed()) {
      Dt(this.id);
      return;
    }
    return h6(this, r, e);
  };
}
function c6(r) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return h6(this, r, e);
  };
}
function h6(r, e, t) {
  return t[0] = t[0] && t[0].toLowerCase(), vr.prototype[e].apply(r, t);
}
var v6 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  }(vr)
), d6 = v6.prototype;
d6.on = c6("on");
d6.off = c6("off");
var ia, Uc, gl, _n, Yc, Xc, Zc, vo, po, W1, U1, qc, Y1, ml, X1, p6, Vt, Z1, g6 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i) {
      var a = r.call(this, new tE()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, dist_U(n) && (n = m6[n]), a._dom = t;
      var o = "canvas", s = "auto", l = !1;
      if (false) { var u; }
      i.ssr;
      var f = a._zr = Kp(t, {
        renderer: i.renderer || o,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: dist_ne(i.useDirtyRect, l),
        useCoarsePointer: dist_ne(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      a._ssr = i.ssr, a._throttledZrFlush = u0(dist_Z(f.flush, f), 17), n = dist_te(n), n && b4(n, !0), a._theme = n, a._locale = iM(i.locale || t4), a._coordSysMgr = new Rs();
      var c = a._api = X1(a);
      function h(v, d) {
        return v.__prio - d.__prio;
      }
      return Hl(Ou, h), Hl(kv, h), a._scheduler = new Y4(a, c, kv, Ou), a._messageCenter = new v6(), a._initEvents(), a.resize = dist_Z(a.resize, a), f.animation.on("frame", a._onframe, a), W1(f, a), U1(f, a), su(a), a;
    }
    return e.prototype._onframe = function() {
      if (!this._disposed) {
        Z1(this);
        var t = this._scheduler;
        if (this[gt]) {
          var n = this[gt].silent;
          this[et] = !0;
          try {
            ia(this), _n.update.call(this, null, this[gt].updateParams);
          } catch (l) {
            throw this[et] = !1, this[gt] = null, l;
          }
          this._zr.flush(), this[et] = !1, this[gt] = null, vo.call(this, n), po.call(this, n);
        } else if (t.unfinished) {
          var i = OE, a = this._model, o = this._api;
          t.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            t.performSeriesTasks(a), t.performDataProcessorTasks(a), Xc(this, a), t.performVisualTasks(a), ml(this, this._model, o, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && t.unfinished);
          t.unfinished || this._zr.flush();
        }
      }
    }, e.prototype.getDom = function() {
      return this._dom;
    }, e.prototype.getId = function() {
      return this.id;
    }, e.prototype.getZr = function() {
      return this._zr;
    }, e.prototype.isSSR = function() {
      return this._ssr;
    }, e.prototype.setOption = function(t, n, i) {
      if (this[et]) {
         false && 0;
        return;
      }
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      var a, o, s;
      if (dist_X(n) && (i = n.lazyUpdate, a = n.silent, o = n.replaceMerge, s = n.transition, n = n.notMerge), this[et] = !0, !this._model || n) {
        var l = new FM(this._api), u = this._theme, f = this._model = new r0();
        f.scheduler = this._scheduler, f.ssr = this._ssr, f.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(t, {
        replaceMerge: o
      }, Vv);
      var c = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (i)
        this[gt] = {
          silent: a,
          updateParams: c
        }, this[et] = !1, this.getZr().wakeUp();
      else {
        try {
          ia(this), _n.update.call(this, null, c);
        } catch (h) {
          throw this[gt] = null, this[et] = !1, h;
        }
        this._ssr || this._zr.flush(), this[gt] = null, this[et] = !1, vo.call(this, a), po.call(this, a);
      }
    }, e.prototype.setTheme = function() {
      fr("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, e.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, e.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, e.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || dist_ee.hasGlobalWindow && window.devicePixelRatio || 1;
    }, e.prototype.getRenderedCanvas = function(t) {
      return  false && 0, this.renderToCanvas(t);
    }, e.prototype.renderToCanvas = function(t) {
      t = t || {};
      var n = this._zr.painter;
      if (false)
        {}
      return n.getRenderedCanvas({
        backgroundColor: t.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
      });
    }, e.prototype.renderToSVGString = function(t) {
      t = t || {};
      var n = this._zr.painter;
      if (false)
        {}
      return n.renderToString({
        useViewBox: t.useViewBox
      });
    }, e.prototype.getSvgDataURL = function() {
      if (dist_ee.svgSupported) {
        var t = this._zr, n = t.storage.getDisplayList();
        return dist_M(n, function(i) {
          i.stopAnimation(null, !0);
        }), t.painter.toDataURL();
      }
    }, e.prototype.getDataURL = function(t) {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      t = t || {};
      var n = t.excludeComponents, i = this._model, a = [], o = this;
      dist_M(n, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var f = o._componentsMap[u.__viewId];
          f.group.ignore || (a.push(f), f.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png"));
      return dist_M(a, function(l) {
        l.group.ignore = !1;
      }), s;
    }, e.prototype.getConnectedDataURL = function(t) {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      var n = t.type === "svg", i = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (q1[i]) {
        var l = s, u = s, f = -s, c = -s, h = [], v = t && t.pixelRatio || this.getDevicePixelRatio();
        dist_M(Zo, function(_, S) {
          if (_.group === i) {
            var b = n ? _.getZr().painter.getSvgDom().innerHTML : _.renderToCanvas(dist_te(t)), w = _.getDom().getBoundingClientRect();
            l = a(w.left, l), u = a(w.top, u), f = o(w.right, f), c = o(w.bottom, c), h.push({
              dom: b,
              left: w.left,
              top: w.top
            });
          }
        }), l *= v, u *= v, f *= v, c *= v;
        var d = f - l, g = c - u, p = Ha.createCanvas(), m = Kp(p, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: d,
          height: g
        }), n) {
          var y = "";
          return dist_M(h, function(_) {
            var S = _.left - l, b = _.top - u;
            y += '<g transform="translate(' + S + "," + b + ')">' + _.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, t.connectedBackgroundColor && m.painter.setBackgroundColor(t.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else
          return t.connectedBackgroundColor && m.add(new xe({
            shape: {
              x: 0,
              y: 0,
              width: d,
              height: g
            },
            style: {
              fill: t.connectedBackgroundColor
            }
          })), dist_M(h, function(_) {
            var S = new un({
              style: {
                x: _.left * v - l,
                y: _.top * v - u,
                image: _.dom
              }
            });
            m.add(S);
          }), m.refreshImmediately(), p.toDataURL("image/" + (t && t.type || "png"));
      } else
        return this.getDataURL(t);
    }, e.prototype.convertToPixel = function(t, n) {
      return Yc(this, "convertToPixel", t, n);
    }, e.prototype.convertFromPixel = function(t, n) {
      return Yc(this, "convertFromPixel", t, n);
    }, e.prototype.containPixel = function(t, n) {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      var i = this._model, a, o = dc(i, t);
      return dist_M(o, function(s, l) {
        l.indexOf("Models") >= 0 && dist_M(s, function(u) {
          var f = u.coordinateSystem;
          if (f && f.containPoint)
            a = a || !!f.containPoint(n);
          else if (l === "seriesModels") {
            var c = this._chartsMap[u.__viewId];
            c && c.containPoint ? a = a || c.containPoint(n, u) :  false && 0;
          } else
             false && 0;
        }, this);
      }, this), !!a;
    }, e.prototype.getVisual = function(t, n) {
      var i = this._model, a = dc(i, t, {
        defaultMainType: "series"
      }), o = a.seriesModel;
       false && (0);
      var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? j4(s, l, n) : J4(s, n);
    }, e.prototype.getViewOfComponentModel = function(t) {
      return this._componentsMap[t.__viewId];
    }, e.prototype.getViewOfSeriesModel = function(t) {
      return this._chartsMap[t.__viewId];
    }, e.prototype._initEvents = function() {
      var t = this;
      dist_M(qE, function(n) {
        var i = function(a) {
          var o = t.getModel(), s = a.target, l, u = n === "globalout";
          if (u ? l = {} : s && Ti(s, function(d) {
            var g = dist_ie(d);
            if (g && g.dataIndex != null) {
              var p = g.dataModel || o.getSeriesByIndex(g.seriesIndex);
              return l = p && p.getDataParams(g.dataIndex, g.dataType, s) || {}, !0;
            } else if (g.eventData)
              return l = dist_V({}, g.eventData), !0;
          }, !0), l) {
            var f = l.componentType, c = l.componentIndex;
            (f === "markLine" || f === "markPoint" || f === "markArea") && (f = "series", c = l.seriesIndex);
            var h = f && c != null && o.getComponent(f, c), v = h && t[h.mainType === "series" ? "_chartsMap" : "_componentsMap"][h.__viewId];
             false && 0, l.event = a, l.type = n, t._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: h,
              view: v
            }, t.trigger(n, l);
          }
        };
        i.zrEventfulCallAtLast = !0, t._zr.on(n, i, t);
      }), dist_M(Xo, function(n, i) {
        t._messageCenter.on(i, function(a) {
          this.trigger(i, a);
        }, t);
      }), dist_M(["selectchanged"], function(n) {
        t._messageCenter.on(n, function(i) {
          this.trigger(n, i);
        }, t);
      }), aE(this._messageCenter, this, this._api);
    }, e.prototype.isDisposed = function() {
      return this._disposed;
    }, e.prototype.clear = function() {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, e.prototype.dispose = function() {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      this._disposed = !0;
      var t = this.getDom();
      t && e_(this.getDom(), h0, "");
      var n = this, i = n._api, a = n._model;
      dist_M(n._componentsViews, function(o) {
        o.dispose(a, i);
      }), dist_M(n._chartsViews, function(o) {
        o.dispose(a, i);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete Zo[n.id];
    }, e.prototype.resize = function(t) {
      if (this[et]) {
         false && 0;
        return;
      }
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      this._zr.resize(t);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var i = n.resetOption("media"), a = t && t.silent;
        this[gt] && (a == null && (a = this[gt].silent), i = !0, this[gt] = null), this[et] = !0;
        try {
          i && ia(this), _n.update.call(this, {
            type: "resize",
            animation: dist_V({
              // Disable animation
              duration: 0
            }, t && t.animation)
          });
        } catch (o) {
          throw this[et] = !1, o;
        }
        this[et] = !1, vo.call(this, a), po.call(this, a);
      }
    }, e.prototype.showLoading = function(t, n) {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      if (dist_X(t) && (n = t, t = ""), t = t || "default", this.hideLoading(), !Bv[t]) {
         false && 0;
        return;
      }
      var i = Bv[t](this._api, n), a = this._zr;
      this._loadingFX = i, a.add(i);
    }, e.prototype.hideLoading = function() {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, e.prototype.makeActionFromEvent = function(t) {
      var n = dist_V({}, t);
      return n.type = Xo[t.type], n;
    }, e.prototype.dispatchAction = function(t, n) {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      if (dist_X(n) || (n = {
        silent: !!n
      }), !!Ru[t.type] && this._model) {
        if (this[et]) {
          this._pendingActions.push(t);
          return;
        }
        var i = n.silent;
        Zc.call(this, t, i);
        var a = n.flush;
        a ? this._zr.flush() : a !== !1 && dist_ee.browser.weChat && this._throttledZrFlush(), vo.call(this, i), po.call(this, i);
      }
    }, e.prototype.updateLabelLayout = function() {
      ir.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, e.prototype.appendData = function(t) {
      if (this._disposed) {
        Dt(this.id);
        return;
      }
      var n = t.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(n);
       false && 0, a.appendData(t), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, e.internalField = function() {
      ia = function(c) {
        var h = c._scheduler;
        h.restorePipelines(c._model), h.prepareStageTasks(), Uc(c, !0), Uc(c, !1), h.plan();
      }, Uc = function(c, h) {
        for (var v = c._model, d = c._scheduler, g = h ? c._componentsViews : c._chartsViews, p = h ? c._componentsMap : c._chartsMap, m = c._zr, y = c._api, _ = 0; _ < g.length; _++)
          g[_].__alive = !1;
        h ? v.eachComponent(function(w, x) {
          w !== "series" && S(x);
        }) : v.eachSeries(S);
        function S(w) {
          var x = w.__requireNewView;
          w.__requireNewView = !1;
          var C = "_ec_" + w.id + "_" + w.type, T = !x && p[C];
          if (!T) {
            var E = Tr(w.type), D = h ? Pt.getClass(E.main, E.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              bt.getClass(E.sub)
            );
             false && 0, T = new D(), T.init(v, y), p[C] = T, g.push(T), m.add(T.group);
          }
          w.__viewId = T.__id = C, T.__alive = !0, T.__model = w, T.group.__ecComponentInfo = {
            mainType: w.mainType,
            index: w.componentIndex
          }, !h && d.prepareView(T, w, v, y);
        }
        for (var _ = 0; _ < g.length; ) {
          var b = g[_];
          b.__alive ? _++ : (!h && b.renderTask.dispose(), m.remove(b.group), b.dispose(v, y), g.splice(_, 1), p[b.__id] === b && delete p[b.__id], b.__id = b.group.__ecComponentInfo = null);
        }
      }, gl = function(c, h, v, d, g) {
        var p = c._model;
        if (p.setUpdatePayload(v), !d) {
          dist_M([].concat(c._componentsViews).concat(c._chartsViews), b);
          return;
        }
        var m = {};
        m[d + "Id"] = v[d + "Id"], m[d + "Index"] = v[d + "Index"], m[d + "Name"] = v[d + "Name"];
        var y = {
          mainType: d,
          query: m
        };
        g && (y.subType = g);
        var _ = v.excludeSeriesId, S;
        _ != null && (S = dist_W(), dist_M(Ae(_), function(w) {
          var x = Zt(w, null);
          x != null && S.set(x, !0);
        })), p && p.eachComponent(y, function(w) {
          var x = S && S.get(w.id) != null;
          if (!x)
            if (Eg(v))
              if (w instanceof jt)
                v.type === Ni && !v.notBlur && !w.get(["emphasis", "disabled"]) && HT(w, v, c._api);
              else {
                var C = Vd(w.mainType, w.componentIndex, v.name, c._api), T = C.focusSelf, E = C.dispatchers;
                v.type === Ni && T && !v.notBlur && wv(w.mainType, w.componentIndex, c._api), E && dist_M(E, function(D) {
                  v.type === Ni ? Pa(D) : Ra(D);
                });
              }
            else
              bv(v) && w instanceof jt && (UT(w, v, c._api), Mg(w), Vt(c));
        }, c), p && p.eachComponent(y, function(w) {
          var x = S && S.get(w.id) != null;
          x || b(c[d === "series" ? "_chartsMap" : "_componentsMap"][w.__viewId]);
        }, c);
        function b(w) {
          w && w.__alive && w[h] && w[h](w.__model, p, c._api, v);
        }
      }, _n = {
        prepareAndUpdate: function(c) {
          ia(this), _n.update.call(this, c, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: c.newOption != null
          });
        },
        update: function(c, h) {
          var v = this._model, d = this._api, g = this._zr, p = this._coordSysMgr, m = this._scheduler;
          if (v) {
            v.setUpdatePayload(c), m.restoreData(v, c), m.performSeriesTasks(v), p.create(v, d), m.performDataProcessorTasks(v, c), Xc(this, v), p.update(v, d), t(v), m.performVisualTasks(v, c), qc(this, v, d, c, h);
            var y = v.get("backgroundColor") || "transparent", _ = v.get("darkMode");
            g.setBackgroundColor(y), _ != null && _ !== "auto" && g.setDarkMode(_), ir.trigger("afterupdate", v, d);
          }
        },
        updateTransform: function(c) {
          var h = this, v = this._model, d = this._api;
          if (v) {
            v.setUpdatePayload(c);
            var g = [];
            v.eachComponent(function(m, y) {
              if (m !== "series") {
                var _ = h.getViewOfComponentModel(y);
                if (_ && _.__alive)
                  if (_.updateTransform) {
                    var S = _.updateTransform(y, v, d, c);
                    S && S.update && g.push(_);
                  } else
                    g.push(_);
              }
            });
            var p = dist_W();
            v.eachSeries(function(m) {
              var y = h._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var _ = y.updateTransform(m, v, d, c);
                _ && _.update && p.set(m.uid, 1);
              } else
                p.set(m.uid, 1);
            }), t(v), this._scheduler.performVisualTasks(v, c, {
              setDirty: !0,
              dirtyMap: p
            }), ml(this, v, d, c, {}, p), ir.trigger("afterupdate", v, d);
          }
        },
        updateView: function(c) {
          var h = this._model;
          h && (h.setUpdatePayload(c), bt.markUpdateMethod(c, "updateView"), t(h), this._scheduler.performVisualTasks(h, c, {
            setDirty: !0
          }), qc(this, h, this._api, c, {}), ir.trigger("afterupdate", h, this._api));
        },
        updateVisual: function(c) {
          var h = this, v = this._model;
          v && (v.setUpdatePayload(c), v.eachSeries(function(d) {
            d.getData().clearAllVisual();
          }), bt.markUpdateMethod(c, "updateVisual"), t(v), this._scheduler.performVisualTasks(v, c, {
            visualType: "visual",
            setDirty: !0
          }), v.eachComponent(function(d, g) {
            if (d !== "series") {
              var p = h.getViewOfComponentModel(g);
              p && p.__alive && p.updateVisual(g, v, h._api, c);
            }
          }), v.eachSeries(function(d) {
            var g = h._chartsMap[d.__viewId];
            g.updateVisual(d, v, h._api, c);
          }), ir.trigger("afterupdate", v, this._api));
        },
        updateLayout: function(c) {
          _n.update.call(this, c);
        }
      }, Yc = function(c, h, v, d) {
        if (c._disposed) {
          Dt(c.id);
          return;
        }
        for (var g = c._model, p = c._coordSysMgr.getCoordinateSystems(), m, y = dc(g, v), _ = 0; _ < p.length; _++) {
          var S = p[_];
          if (S[h] && (m = S[h](g, y, d)) != null)
            return m;
        }
         false && 0;
      }, Xc = function(c, h) {
        var v = c._chartsMap, d = c._scheduler;
        h.eachSeries(function(g) {
          d.updateStreamModes(g, v[g.__viewId]);
        });
      }, Zc = function(c, h) {
        var v = this, d = this.getModel(), g = c.type, p = c.escapeConnect, m = Ru[g], y = m.actionInfo, _ = (y.update || "update").split(":"), S = _.pop(), b = _[0] != null && Tr(_[0]);
        this[et] = !0;
        var w = [c], x = !1;
        c.batch && (x = !0, w = dist_$(c.batch, function(N) {
          return N = dist_se(dist_V({}, N), c), N.batch = null, N;
        }));
        var C = [], T, E = bv(c), D = Eg(c);
        if (D && D_(this._api), dist_M(w, function(N) {
          if (T = m.action(N, v._model, v._api), T = T || dist_V({}, N), T.type = y.event || T.type, C.push(T), D) {
            var P = Id(c), R = P.queryOptionMap, z = P.mainTypeSpecified, O = z ? R.keys()[0] : "series";
            gl(v, S, N, O), Vt(v);
          } else
            E ? (gl(v, S, N, "series"), Vt(v)) : b && gl(v, S, N, b.main, b.sub);
        }), S !== "none" && !D && !E && !b)
          try {
            this[gt] ? (ia(this), _n.update.call(this, c), this[gt] = null) : _n[S].call(this, c);
          } catch (N) {
            throw this[et] = !1, N;
          }
        if (x ? T = {
          type: y.event || g,
          escapeConnect: p,
          batch: C
        } : T = C[0], this[et] = !1, !h) {
          var I = this._messageCenter;
          if (I.trigger(T.type, T), E) {
            var L = {
              type: "selectchanged",
              escapeConnect: p,
              selected: YT(d),
              isFromClick: c.isFromClick || !1,
              fromAction: c.type,
              fromActionPayload: c
            };
            I.trigger(L.type, L);
          }
        }
      }, vo = function(c) {
        for (var h = this._pendingActions; h.length; ) {
          var v = h.shift();
          Zc.call(this, v, c);
        }
      }, po = function(c) {
        !c && this.trigger("updated");
      }, W1 = function(c, h) {
        c.on("rendered", function(v) {
          h.trigger("rendered", v), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          c.animation.isFinished() && !h[gt] && !h._scheduler.unfinished && !h._pendingActions.length && h.trigger("finished");
        });
      }, U1 = function(c, h) {
        c.on("mouseover", function(v) {
          var d = v.target, g = Ti(d, Oa);
          g && ($T(g, v, h._api), Vt(h));
        }).on("mouseout", function(v) {
          var d = v.target, g = Ti(d, Oa);
          g && (WT(g, v, h._api), Vt(h));
        }).on("click", function(v) {
          var d = v.target, g = Ti(d, function(y) {
            return dist_ie(y).dataIndex != null;
          }, !0);
          if (g) {
            var p = g.selected ? "unselect" : "select", m = dist_ie(g);
            h._api.dispatchAction({
              type: p,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function t(c) {
        c.clearColorPalette(), c.eachSeries(function(h) {
          h.clearColorPalette();
        });
      }
      function n(c) {
        var h = [], v = [], d = !1;
        if (c.eachComponent(function(y, _) {
          var S = _.get("zlevel") || 0, b = _.get("z") || 0, w = _.getZLevelKey();
          d = d || !!w, (y === "series" ? v : h).push({
            zlevel: S,
            z: b,
            idx: _.componentIndex,
            type: y,
            key: w
          });
        }), d) {
          var g = h.concat(v), p, m;
          Hl(g, function(y, _) {
            return y.zlevel === _.zlevel ? y.z - _.z : y.zlevel - _.zlevel;
          }), dist_M(g, function(y) {
            var _ = c.getComponent(y.type, y.idx), S = y.zlevel, b = y.key;
            p != null && (S = Math.max(p, S)), b ? (S === p && b !== m && S++, m = b) : m && (S === p && S++, m = ""), p = S, _.setZLevel(S);
          });
        }
      }
      qc = function(c, h, v, d, g) {
        n(h), Y1(c, h, v, d, g), dist_M(c._chartsViews, function(p) {
          p.__alive = !1;
        }), ml(c, h, v, d, g), dist_M(c._chartsViews, function(p) {
          p.__alive || p.remove(h, v);
        });
      }, Y1 = function(c, h, v, d, g, p) {
        dist_M(p || c._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, h, v, d), s(y, m), f(y, m);
        });
      }, ml = function(c, h, v, d, g, p) {
        var m = c._scheduler;
        g = dist_V(g || {}, {
          updatedSeries: h.getSeries()
        }), ir.trigger("series:beforeupdate", h, v, g);
        var y = !1;
        h.eachSeries(function(_) {
          var S = c._chartsMap[_.__viewId];
          S.__alive = !0;
          var b = S.renderTask;
          m.updatePayload(b, d), u(_, S), p && p.get(_.uid) && b.dirty(), b.perform(m.getPerformArgs(b)) && (y = !0), S.group.silent = !!_.get("silent"), o(_, S), Mg(_);
        }), m.unfinished = y || m.unfinished, ir.trigger("series:layoutlabels", h, v, g), ir.trigger("series:transition", h, v, g), h.eachSeries(function(_) {
          var S = c._chartsMap[_.__viewId];
          s(_, S), f(_, S);
        }), a(c, h), ir.trigger("series:afterupdate", h, v, g);
      }, Vt = function(c) {
        c[$c] = !0, c.getZr().wakeUp();
      }, Z1 = function(c) {
        c[$c] && (c.getZr().storage.traverse(function(h) {
          Ta(h) || i(h);
        }), c[$c] = !1);
      };
      function i(c) {
        for (var h = [], v = c.currentStates, d = 0; d < v.length; d++) {
          var g = v[d];
          g === "emphasis" || g === "blur" || g === "select" || h.push(g);
        }
        c.selected && c.states.select && h.push("select"), c.hoverState === cf && c.states.emphasis ? h.push("emphasis") : c.hoverState === ff && c.states.blur && h.push("blur"), c.useStates(h);
      }
      function a(c, h) {
        var v = c._zr, d = v.storage, g = 0;
        d.traverse(function(p) {
          p.isGroup || g++;
        }), g > h.get("hoverLayerThreshold") && !dist_ee.node && !dist_ee.worker && h.eachSeries(function(p) {
          if (!p.preventUsingHoverLayer) {
            var m = c._chartsMap[p.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function o(c, h) {
        var v = c.get("blendMode") || null;
        h.eachRendered(function(d) {
          d.isGroup || (d.style.blend = v);
        });
      }
      function s(c, h) {
        if (!c.preventAutoZ) {
          var v = c.get("z") || 0, d = c.get("zlevel") || 0;
          h.eachRendered(function(g) {
            return l(g, v, d, -1 / 0), !0;
          });
        }
      }
      function l(c, h, v, d) {
        var g = c.getTextContent(), p = c.getTextGuideLine(), m = c.isGroup;
        if (m)
          for (var y = c.childrenRef(), _ = 0; _ < y.length; _++)
            d = Math.max(l(y[_], h, v, d), d);
        else
          c.z = h, c.zlevel = v, d = Math.max(c.z2, d);
        if (g && (g.z = h, g.zlevel = v, isFinite(d) && (g.z2 = d + 2)), p) {
          var S = c.textGuideLineConfig;
          p.z = h, p.zlevel = v, isFinite(d) && (p.z2 = d + (S && S.showAbove ? 1 : -1));
        }
        return d;
      }
      function u(c, h) {
        h.eachRendered(function(v) {
          if (!Ta(v)) {
            var d = v.getTextContent(), g = v.getTextGuideLine();
            v.stateTransition && (v.stateTransition = null), d && d.stateTransition && (d.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), v.hasState() ? (v.prevStates = v.currentStates, v.clearStates()) : v.prevStates && (v.prevStates = null);
          }
        });
      }
      function f(c, h) {
        var v = c.getModel("stateAnimation"), d = c.isAnimationEnabled(), g = v.get("duration"), p = g > 0 ? {
          duration: g,
          delay: v.get("delay"),
          easing: v.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        h.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (Ta(m))
              return;
            if (m instanceof fe && JT(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (d) {
              m.stateTransition = p;
              var _ = m.getTextContent(), S = m.getTextGuideLine();
              _ && (_.stateTransition = p), S && (S.stateTransition = p);
            }
            m.__dirty && i(m);
          }
        });
      }
      X1 = function(c) {
        return new /** @class */
        (function(h) {
          dist_k(v, h);
          function v() {
            return h !== null && h.apply(this, arguments) || this;
          }
          return v.prototype.getCoordinateSystems = function() {
            return c._coordSysMgr.getCoordinateSystems();
          }, v.prototype.getComponentByElement = function(d) {
            for (; d; ) {
              var g = d.__ecComponentInfo;
              if (g != null)
                return c._model.getComponent(g.mainType, g.index);
              d = d.parent;
            }
          }, v.prototype.enterEmphasis = function(d, g) {
            Pa(d, g), Vt(c);
          }, v.prototype.leaveEmphasis = function(d, g) {
            Ra(d, g), Vt(c);
          }, v.prototype.enterBlur = function(d) {
            GT(d), Vt(c);
          }, v.prototype.leaveBlur = function(d) {
            x_(d), Vt(c);
          }, v.prototype.enterSelect = function(d) {
            C_(d), Vt(c);
          }, v.prototype.leaveSelect = function(d) {
            T_(d), Vt(c);
          }, v.prototype.getModel = function() {
            return c.getModel();
          }, v.prototype.getViewOfComponentModel = function(d) {
            return c.getViewOfComponentModel(d);
          }, v.prototype.getViewOfSeriesModel = function(d) {
            return c.getViewOfSeriesModel(d);
          }, v;
        }(S4))(c);
      }, p6 = function(c) {
        function h(v, d) {
          for (var g = 0; g < v.length; g++) {
            var p = v[g];
            p[Wc] = d;
          }
        }
        dist_M(Xo, function(v, d) {
          c._messageCenter.on(d, function(g) {
            if (q1[c.group] && c[Wc] !== $1) {
              if (g && g.escapeConnect)
                return;
              var p = c.makeActionFromEvent(g), m = [];
              dist_M(Zo, function(y) {
                y !== c && y.group === c.group && m.push(y);
              }), h(m, $1), dist_M(m, function(y) {
                y[Wc] !== XE && y.dispatchAction(p);
              }), h(m, ZE);
            }
          });
        });
      };
    }(), e;
  }(vr)
), c0 = g6.prototype;
c0.on = f6("on");
c0.off = f6("off");
c0.one = function(r, e, t) {
  var n = this;
  fr("ECharts#one is deprecated.");
  function i() {
    for (var a = [], o = 0; o < arguments.length; o++)
      a[o] = arguments[o];
    e && e.apply && e.apply(this, a), n.off(r, i);
  }
  this.on.call(this, r, i, t);
};
var qE = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function Dt(r) {
   false && 0;
}
var Ru = {}, Xo = {}, kv = [], Vv = [], Ou = [], m6 = {}, Bv = {}, Zo = {}, q1 = {}, KE = +/* @__PURE__ */ new Date() - 0, h0 = "_echarts_instance_";
function jE(r, e, t) {
  var n = !(t && t.ssr);
  if (n) {
    if (false)
      {}
    var i = y6(r);
    if (i)
      return  false && 0, i;
     false && 0;
  }
  var a = new g6(r, e, t);
  return a.id = "ec_" + KE++, Zo[a.id] = a, n && e_(r, h0, a.id), p6(a), ir.trigger("afterinit", a), a;
}
function y6(r) {
  return Zo[PC(r, h0)];
}
function _6(r, e) {
  m6[r] = e;
}
function S6(r) {
  ye(Vv, r) < 0 && Vv.push(r);
}
function w6(r, e) {
  d0(kv, r, e, FE);
}
function JE(r) {
  v0("afterinit", r);
}
function QE(r) {
  v0("afterupdate", r);
}
function v0(r, e) {
  ir.on(r, e);
}
function Gi(r, e, t) {
  dist_j(e) && (t = e, e = "");
  var n = dist_X(r) ? r.type : [r, r = {
    event: e
  }][0];
  r.event = (r.event || n).toLowerCase(), e = r.event, !Xo[e] && (dist_re(H1.test(n) && H1.test(e)), Ru[n] || (Ru[n] = {
    action: t,
    actionInfo: r
  }), Xo[e] = n);
}
function eA(r, e) {
  Rs.register(r, e);
}
function tA(r, e) {
  d0(Ou, r, e, s6, "layout");
}
function Hi(r, e) {
  d0(Ou, r, e, l6, "visual");
}
var K1 = [];
function d0(r, e, t, n, i) {
  if ((dist_j(e) || dist_X(e)) && (t = e, e = n), "production" !== "production") {
    if (isNaN(e) || e == null)
      throw new Error("Illegal priority");
    dist_M(r, function(o) {
      dist_re(o.__raw !== t);
    });
  }
  if (!(ye(K1, t) >= 0)) {
    K1.push(t);
    var a = Y4.wrapStageHandler(t, i);
    a.__prio = e, a.__raw = t, r.push(a);
  }
}
function b6(r, e) {
  Bv[r] = e;
}
function rA(r, e, t) {
  var n = RE("registerMap");
  n && n(r, e, t);
}
var nA = dD;
Hi(f0, zD);
Hi(Ef, GD);
Hi(Ef, HD);
Hi(f0, rE);
Hi(Ef, nE);
Hi(u6, NE);
S6(b4);
w6(VE, XM);
b6("default", $D);
Gi({
  type: Ni,
  event: Ni,
  update: Ni
}, Ue);
Gi({
  type: Xl,
  event: Xl,
  update: Xl
}, Ue);
Gi({
  type: Go,
  event: Go,
  update: Go
}, Ue);
Gi({
  type: Zl,
  event: Zl,
  update: Zl
}, Ue);
Gi({
  type: Ho,
  event: Ho,
  update: Ho
}, Ue);
_6("light", QD);
_6("dark", eE);
function go(r) {
  return r == null ? 0 : r.length || 1;
}
function j1(r) {
  return r;
}
var Fv = (
  /** @class */
  function() {
    function r(e, t, n, i, a, o) {
      this._old = e, this._new = t, this._oldKeyGetter = n || j1, this._newKeyGetter = i || j1, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return r.prototype.add = function(e) {
      return this._add = e, this;
    }, r.prototype.update = function(e) {
      return this._update = e, this;
    }, r.prototype.updateManyToOne = function(e) {
      return this._updateManyToOne = e, this;
    }, r.prototype.updateOneToMany = function(e) {
      return this._updateOneToMany = e, this;
    }, r.prototype.updateManyToMany = function(e) {
      return this._updateManyToMany = e, this;
    }, r.prototype.remove = function(e) {
      return this._remove = e, this;
    }, r.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, r.prototype._executeOneToOne = function() {
      var e = this._old, t = this._new, n = {}, i = new Array(e.length), a = new Array(t.length);
      this._initIndexMap(e, null, i, "_oldKeyGetter"), this._initIndexMap(t, n, a, "_newKeyGetter");
      for (var o = 0; o < e.length; o++) {
        var s = i[o], l = n[s], u = go(l);
        if (u > 1) {
          var f = l.shift();
          l.length === 1 && (n[s] = l[0]), this._update && this._update(f, o);
        } else
          u === 1 ? (n[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, n);
    }, r.prototype._executeMultiple = function() {
      var e = this._old, t = this._new, n = {}, i = {}, a = [], o = [];
      this._initIndexMap(e, n, a, "_oldKeyGetter"), this._initIndexMap(t, i, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = n[l], f = i[l], c = go(u), h = go(f);
        if (c > 1 && h === 1)
          this._updateManyToOne && this._updateManyToOne(f, u), i[l] = null;
        else if (c === 1 && h > 1)
          this._updateOneToMany && this._updateOneToMany(f, u), i[l] = null;
        else if (c === 1 && h === 1)
          this._update && this._update(f, u), i[l] = null;
        else if (c > 1 && h > 1)
          this._updateManyToMany && this._updateManyToMany(f, u), i[l] = null;
        else if (c > 1)
          for (var v = 0; v < c; v++)
            this._remove && this._remove(u[v]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(o, i);
    }, r.prototype._performRestAdd = function(e, t) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n], a = t[i], o = go(a);
        if (o > 1)
          for (var s = 0; s < o; s++)
            this._add && this._add(a[s]);
        else
          o === 1 && this._add && this._add(a);
        t[i] = null;
      }
    }, r.prototype._initIndexMap = function(e, t, n, i) {
      for (var a = this._diffModeMultiple, o = 0; o < e.length; o++) {
        var s = "_ec_" + this[i](e[o], o);
        if (a || (n[o] = s), !!t) {
          var l = t[s], u = go(l);
          u === 0 ? (t[s] = o, a && n.push(s)) : u === 1 ? t[s] = [l, o] : l.push(o);
        }
      }
    }, r;
  }()
), iA = (
  /** @class */
  function() {
    function r(e, t) {
      this._encode = e, this._schema = t;
    }
    return r.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, r.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, r;
  }()
);
function aA(r, e) {
  var t = {}, n = t.encode = {}, i = dist_W(), a = [], o = [], s = {};
  dist_M(r.dimensions, function(h) {
    var v = r.getDimensionInfo(h), d = v.coordDim;
    if (d) {
       false && 0;
      var g = v.coordDimIndex;
      Kc(n, d)[g] = h, v.isExtraCoord || (i.set(d, 1), sA(v.type) && (a[0] = h), Kc(s, d)[g] = r.getDimensionIndex(v.name)), v.defaultTooltip && o.push(h);
    }
    Dv.each(function(p, m) {
      var y = Kc(n, m), _ = v.otherDims[m];
      _ != null && _ !== !1 && (y[_] = v.name);
    });
  });
  var l = [], u = {};
  i.each(function(h, v) {
    var d = n[v];
    u[v] = d[0], l = l.concat(d);
  }), t.dataDimsOnCoord = l, t.dataDimIndicesOnCoord = dist_$(l, function(h) {
    return r.getDimensionInfo(h).storeDimIndex;
  }), t.encodeFirstDimNotExtra = u;
  var f = n.label;
  f && f.length && (a = f.slice());
  var c = n.tooltip;
  return c && c.length ? o = c.slice() : o.length || (o = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = o, t.userOutput = new iA(s, e), t;
}
function Kc(r, e) {
  return r.hasOwnProperty(e) || (r[e] = []), r[e];
}
function oA(r) {
  return r === "category" ? "ordinal" : r === "time" ? "time" : "float";
}
function sA(r) {
  return !(r === "ordinal" || r === "time");
}
var Ql = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.otherDims = {}, e != null && dist_V(this, e);
    }
    return r;
  }()
), lA = Me(), uA = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, x6 = (
  /** @class */
  function() {
    function r(e) {
      this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted);
    }
    return r.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, r.prototype._updateDimOmitted = function(e) {
      this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = M6(this.source)));
    }, r.prototype.getSourceDimensionIndex = function(e) {
      return dist_ne(this._dimNameMap.get(e), -1);
    }, r.prototype.getSourceDimension = function(e) {
      var t = this.source.dimensionsDefine;
      if (t)
        return t[e];
    }, r.prototype.makeStoreSchema = function() {
      for (var e = this._fullDimCount, t = C4(this.source), n = !D6(e), i = "", a = [], o = 0, s = 0; o < e; o++) {
        var l = void 0, u = void 0, f = void 0, c = this.dimensions[s];
        if (c && c.storeDimIndex === o)
          l = t ? c.name : null, u = c.type, f = c.ordinalMeta, s++;
        else {
          var h = this.getSourceDimension(o);
          h && (l = t ? h.name : null, u = h.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: f
        }), t && l != null && (!c || !c.isCalculationCoord) && (i += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += uA[u] || "f", f && (i += f.uid), i += "$";
      }
      var v = this.source, d = [v.seriesLayoutBy, v.startIndex, i].join("$$");
      return {
        dimensions: a,
        hash: d
      };
    }, r.prototype.makeOutputDimensionNames = function() {
      for (var e = [], t = 0, n = 0; t < this._fullDimCount; t++) {
        var i = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === t)
          a.isCalculationCoord || (i = a.name), n++;
        else {
          var o = this.getSourceDimension(t);
          o && (i = o.name);
        }
        e.push(i);
      }
      return e;
    }, r.prototype.appendCalculationDimension = function(e) {
      this.dimensions.push(e), e.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, r;
  }()
);
function C6(r) {
  return r instanceof x6;
}
function T6(r) {
  for (var e = dist_W(), t = 0; t < (r || []).length; t++) {
    var n = r[t], i = dist_X(n) ? n.name : n;
    i != null && e.get(i) == null && e.set(i, t);
  }
  return e;
}
function M6(r) {
  var e = lA(r);
  return e.dimNameMap || (e.dimNameMap = T6(r.dimensionsDefine));
}
function D6(r) {
  return r > 30;
}
var mo = dist_X, Sn = dist_$, fA = typeof Int32Array > "u" ? Array : Int32Array, cA = "e\0\0", J1 = -1, hA = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], vA = ["_approximateExtent"], Q1, yl, yo, aa, jc, _l, Jc, Ba = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
      var n, i = !1;
      C6(e) ? (n = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (i = !0, n = e), n = n || ["x", "y"];
      for (var a = {}, o = [], s = {}, l = !1, u = {}, f = 0; f < n.length; f++) {
        var c = n[f], h = dist_U(c) ? new Ql({
          name: c
        }) : c instanceof Ql ? c : new Ql(c), v = h.name;
        h.type = h.type || "float", h.coordDim || (h.coordDim = v, h.coordDimIndex = 0);
        var d = h.otherDims = h.otherDims || {};
        o.push(v), a[v] = h, u[v] != null && (l = !0), h.createInvertedIndices && (s[v] = []), d.itemName === 0 && (this._nameDimIdx = f), d.itemId === 0 && (this._idDimIdx = f),  false && 0, i && (h.storeDimIndex = f);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = t, this._invertedIndicesMap = s, this._dimOmitted) {
        var g = this._dimIdxToName = dist_W();
        dist_M(o, function(p) {
          g.set(a[p].storeDimIndex, p);
        });
      }
    }
    return r.prototype.getDimension = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t == null)
        return e;
      if (t = e, !this._dimOmitted)
        return this.dimensions[t];
      var n = this._dimIdxToName.get(t);
      if (n != null)
        return n;
      var i = this._schema.getSourceDimension(t);
      if (i)
        return i.name;
    }, r.prototype.getDimensionIndex = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t != null)
        return t;
      if (e == null)
        return -1;
      var n = this._getDimInfo(e);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1;
    }, r.prototype._recognizeDimIndex = function(e) {
      if (ve(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0))
        return +e;
    }, r.prototype._getStoreDimIndex = function(e) {
      var t = this.getDimensionIndex(e);
      if (false)
        {}
      return t;
    }, r.prototype.getDimensionInfo = function(e) {
      return this._getDimInfo(this.getDimension(e));
    }, r.prototype._initGetDimensionInfo = function(e) {
      var t = this._dimInfos;
      this._getDimInfo = e ? function(n) {
        return t.hasOwnProperty(n) ? t[n] : void 0;
      } : function(n) {
        return t[n];
      };
    }, r.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, r.prototype.mapDimension = function(e, t) {
      var n = this._dimSummary;
      if (t == null)
        return n.encodeFirstDimNotExtra[e];
      var i = n.encode[e];
      return i ? i[t] : null;
    }, r.prototype.mapDimensionsAll = function(e) {
      var t = this._dimSummary, n = t.encode[e];
      return (n || []).slice();
    }, r.prototype.getStore = function() {
      return this._store;
    }, r.prototype.initData = function(e, t, n) {
      var i = this, a;
      if (e instanceof Av && (a = e), !a) {
        var o = this.dimensions, s = n0(e) || ct(e) ? new T4(e, o.length) : e;
        a = new Av();
        var l = Sn(o, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, n);
      }
      this._store = a, this._nameList = (t || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = aA(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, r.prototype.appendData = function(e) {
      var t = this._store.appendData(e);
      this._doInit(t[0], t[1]);
    }, r.prototype.appendValues = function(e, t) {
      var n = this._store.appendValues(e, t.length), i = n.start, a = n.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), t)
        for (var s = i; s < a; s++) {
          var l = s - i;
          this._nameList[s] = t[l], o && Jc(this, s);
        }
    }, r.prototype._updateOrdinalMeta = function() {
      for (var e = this._store, t = this.dimensions, n = 0; n < t.length; n++) {
        var i = this._dimInfos[t[n]];
        i.ordinalMeta && e.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, r.prototype._shouldMakeIdFromName = function() {
      var e = this._store.getProvider();
      return this._idDimIdx == null && e.getSource().sourceFormat !== qr && !e.fillStorage;
    }, r.prototype._doInit = function(e, t) {
      if (!(e >= t)) {
        var n = this._store, i = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = i.getSource().sourceFormat, l = s === Jt;
        if (l && !i.pure)
          for (var u = [], f = e; f < t; f++) {
            var c = i.getItem(f, u);
            if (!this.hasItemOption && SC(c) && (this.hasItemOption = !0), c) {
              var h = c.name;
              a[f] == null && h != null && (a[f] = Zt(h, null));
              var v = c.id;
              o[f] == null && v != null && (o[f] = Zt(v, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var f = e; f < t; f++)
            Jc(this, f);
        Q1(this);
      }
    }, r.prototype.getApproximateExtent = function(e) {
      return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e));
    }, r.prototype.setApproximateExtent = function(e, t) {
      t = this.getDimension(t), this._approximateExtent[t] = e.slice();
    }, r.prototype.getCalculationInfo = function(e) {
      return this._calculationInfo[e];
    }, r.prototype.setCalculationInfo = function(e, t) {
      mo(e) ? dist_V(this._calculationInfo, e) : this._calculationInfo[e] = t;
    }, r.prototype.getName = function(e) {
      var t = this.getRawIndex(e), n = this._nameList[t];
      return n == null && this._nameDimIdx != null && (n = yo(this, this._nameDimIdx, t)), n == null && (n = ""), n;
    }, r.prototype._getCategory = function(e, t) {
      var n = this._store.get(e, t), i = this._store.getOrdinalMeta(e);
      return i ? i.categories[n] : n;
    }, r.prototype.getId = function(e) {
      return yl(this, this.getRawIndex(e));
    }, r.prototype.count = function() {
      return this._store.count();
    }, r.prototype.get = function(e, t) {
      var n = this._store, i = this._dimInfos[e];
      if (i)
        return n.get(i.storeDimIndex, t);
    }, r.prototype.getByRawIndex = function(e, t) {
      var n = this._store, i = this._dimInfos[e];
      if (i)
        return n.getByRawIndex(i.storeDimIndex, t);
    }, r.prototype.getIndices = function() {
      return this._store.getIndices();
    }, r.prototype.getDataExtent = function(e) {
      return this._store.getDataExtent(this._getStoreDimIndex(e));
    }, r.prototype.getSum = function(e) {
      return this._store.getSum(this._getStoreDimIndex(e));
    }, r.prototype.getMedian = function(e) {
      return this._store.getMedian(this._getStoreDimIndex(e));
    }, r.prototype.getValues = function(e, t) {
      var n = this, i = this._store;
      return dist_F(e) ? i.getValues(Sn(e, function(a) {
        return n._getStoreDimIndex(a);
      }), t) : i.getValues(e);
    }, r.prototype.hasValue = function(e) {
      for (var t = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = t.length; n < i; n++)
        if (isNaN(this._store.get(t[n], e)))
          return !1;
      return !0;
    }, r.prototype.indexOfName = function(e) {
      for (var t = 0, n = this._store.count(); t < n; t++)
        if (this.getName(t) === e)
          return t;
      return -1;
    }, r.prototype.getRawIndex = function(e) {
      return this._store.getRawIndex(e);
    }, r.prototype.indexOfRawIndex = function(e) {
      return this._store.indexOfRawIndex(e);
    }, r.prototype.rawIndexOf = function(e, t) {
      var n = e && this._invertedIndicesMap[e];
      if (false)
        {}
      var i = n[t];
      return i == null || isNaN(i) ? J1 : i;
    }, r.prototype.indicesOfNearest = function(e, t, n) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(e), t, n);
    }, r.prototype.each = function(e, t, n) {
      dist_j(e) && (n = t, t = e, e = []);
      var i = n || this, a = Sn(aa(e), this._getStoreDimIndex, this);
      this._store.each(a, i ? dist_Z(t, i) : t);
    }, r.prototype.filterSelf = function(e, t, n) {
      dist_j(e) && (n = t, t = e, e = []);
      var i = n || this, a = Sn(aa(e), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, i ? dist_Z(t, i) : t), this;
    }, r.prototype.selectRange = function(e) {
      var t = this, n = {}, i = we(e);
      return dist_M(i, function(a) {
        var o = t._getStoreDimIndex(a);
        n[o] = e[a];
      }), this._store = this._store.selectRange(n), this;
    }, r.prototype.mapArray = function(e, t, n) {
      dist_j(e) && (n = t, t = e, e = []), n = n || this;
      var i = [];
      return this.each(e, function() {
        i.push(t && t.apply(this, arguments));
      }, n), i;
    }, r.prototype.map = function(e, t, n, i) {
      var a = n || i || this, o = Sn(aa(e), this._getStoreDimIndex, this), s = _l(this);
      return s._store = this._store.map(o, a ? dist_Z(t, a) : t), s;
    }, r.prototype.modify = function(e, t, n, i) {
      var a = this, o = n || i || this;
       false && 0;
      var s = Sn(aa(e), this._getStoreDimIndex, this);
      this._store.modify(s, o ? dist_Z(t, o) : t);
    }, r.prototype.downSample = function(e, t, n, i) {
      var a = _l(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(e), t, n, i), a;
    }, r.prototype.lttbDownSample = function(e, t) {
      var n = _l(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(e), t), n;
    }, r.prototype.getRawDataItem = function(e) {
      return this._store.getRawDataItem(e);
    }, r.prototype.getItemModel = function(e) {
      var t = this.hostModel, n = this.getRawDataItem(e);
      return new He(n, t, t && t.ecModel);
    }, r.prototype.diff = function(e) {
      var t = this;
      return new Fv(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return yl(e, n);
      }, function(n) {
        return yl(t, n);
      });
    }, r.prototype.getVisual = function(e) {
      var t = this._visual;
      return t && t[e];
    }, r.prototype.setVisual = function(e, t) {
      this._visual = this._visual || {}, mo(e) ? dist_V(this._visual, e) : this._visual[e] = t;
    }, r.prototype.getItemVisual = function(e, t) {
      var n = this._itemVisuals[e], i = n && n[t];
      return i ?? this.getVisual(t);
    }, r.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, r.prototype.ensureUniqueItemVisual = function(e, t) {
      var n = this._itemVisuals, i = n[e];
      i || (i = n[e] = {});
      var a = i[t];
      return a == null && (a = this.getVisual(t), dist_F(a) ? a = a.slice() : mo(a) && (a = dist_V({}, a)), i[t] = a), a;
    }, r.prototype.setItemVisual = function(e, t, n) {
      var i = this._itemVisuals[e] || {};
      this._itemVisuals[e] = i, mo(t) ? dist_V(i, t) : i[t] = n;
    }, r.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, r.prototype.setLayout = function(e, t) {
      mo(e) ? dist_V(this._layout, e) : this._layout[e] = t;
    }, r.prototype.getLayout = function(e) {
      return this._layout[e];
    }, r.prototype.getItemLayout = function(e) {
      return this._itemLayouts[e];
    }, r.prototype.setItemLayout = function(e, t, n) {
      this._itemLayouts[e] = n ? dist_V(this._itemLayouts[e] || {}, t) : t;
    }, r.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, r.prototype.setItemGraphicEl = function(e, t) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      PT(n, this.dataType, e, t), this._graphicEls[e] = t;
    }, r.prototype.getItemGraphicEl = function(e) {
      return this._graphicEls[e];
    }, r.prototype.eachItemGraphicEl = function(e, t) {
      dist_M(this._graphicEls, function(n, i) {
        n && e && e.call(t, n, i);
      });
    }, r.prototype.cloneShallow = function(e) {
      return e || (e = new r(this._schema ? this._schema : Sn(this.dimensions, this._getDimInfo, this), this.hostModel)), jc(e, this), e._store = this._store, e;
    }, r.prototype.wrapMethod = function(e, t) {
      var n = this[e];
      dist_j(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function() {
        var i = n.apply(this, arguments);
        return t.apply(this, [i].concat(bd(arguments)));
      });
    }, r.internalField = function() {
      Q1 = function(e) {
        var t = e._invertedIndicesMap;
        dist_M(t, function(n, i) {
          var a = e._dimInfos[i], o = a.ordinalMeta, s = e._store;
          if (o) {
            n = t[i] = new fA(o.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = J1;
            for (var l = 0; l < s.count(); l++)
              n[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, yo = function(e, t, n) {
        return Zt(e._getCategory(t, n), null);
      }, yl = function(e, t) {
        var n = e._idList[t];
        return n == null && e._idDimIdx != null && (n = yo(e, e._idDimIdx, t)), n == null && (n = cA + t), n;
      }, aa = function(e) {
        return dist_F(e) || (e = e != null ? [e] : []), e;
      }, _l = function(e) {
        var t = new r(e._schema ? e._schema : Sn(e.dimensions, e._getDimInfo, e), e.hostModel);
        return jc(t, e), t;
      }, jc = function(e, t) {
        dist_M(hA.concat(t.__wrappedMethods || []), function(n) {
          t.hasOwnProperty(n) && (e[n] = t[n]);
        }), e.__wrappedMethods = t.__wrappedMethods, dist_M(vA, function(n) {
          e[n] = dist_te(t[n]);
        }), e._calculationInfo = dist_V({}, t._calculationInfo);
      }, Jc = function(e, t) {
        var n = e._nameList, i = e._idList, a = e._nameDimIdx, o = e._idDimIdx, s = n[t], l = i[t];
        if (s == null && a != null && (n[t] = s = yo(e, a, t)), l == null && o != null && (i[t] = l = yo(e, o, t)), l == null && s != null) {
          var u = e._nameRepeatCount, f = u[s] = (u[s] || 0) + 1;
          l = s, f > 1 && (l += "__ec__" + f), i[t] = l;
        }
      };
    }(), r;
  }()
);
function p0(r, e) {
  n0(r) || (r = i0(r)), e = e || {};
  var t = e.coordDimensions || [], n = e.dimensionsDefine || r.dimensionsDefine || [], i = dist_W(), a = [], o = pA(r, t, n, e.dimensionsCount), s = e.canOmitUnusedDimensions && D6(o), l = n === r.dimensionsDefine, u = l ? M6(r) : T6(n), f = e.encodeDefine;
  !f && e.encodeDefaulter && (f = e.encodeDefaulter(r, o));
  for (var c = dist_W(f), h = new P4(o), v = 0; v < h.length; v++)
    h[v] = -1;
  function d(T) {
    var E = h[T];
    if (E < 0) {
      var D = n[T], I = dist_X(D) ? D : {
        name: D
      }, L = new Ql(), N = I.name;
      N != null && u.get(N) != null && (L.name = L.displayName = N), I.type != null && (L.type = I.type), I.displayName != null && (L.displayName = I.displayName);
      var P = a.length;
      return h[T] = P, L.storeDimIndex = T, a.push(L), L;
    }
    return a[E];
  }
  if (!s)
    for (var v = 0; v < o; v++)
      d(v);
  c.each(function(T, E) {
    var D = Ae(T).slice();
    if (D.length === 1 && !dist_U(D[0]) && D[0] < 0) {
      c.set(E, !1);
      return;
    }
    var I = c.set(E, []);
    dist_M(D, function(L, N) {
      var P = dist_U(L) ? u.get(L) : L;
      P != null && P < o && (I[N] = P, p(d(P), E, N));
    });
  });
  var g = 0;
  dist_M(t, function(T) {
    var E, D, I, L;
    if (dist_U(T))
      E = T, L = {};
    else {
      L = T, E = L.name;
      var N = L.ordinalMeta;
      L.ordinalMeta = null, L = dist_V({}, L), L.ordinalMeta = N, D = L.dimsDef, I = L.otherDims, L.name = L.coordDim = L.coordDimIndex = L.dimsDef = L.otherDims = null;
    }
    var P = c.get(E);
    if (P !== !1) {
      if (P = Ae(P), !P.length)
        for (var R = 0; R < (D && D.length || 1); R++) {
          for (; g < o && d(g).coordDim != null; )
            g++;
          g < o && P.push(g++);
        }
      dist_M(P, function(z, O) {
        var B = d(z);
        if (l && L.type != null && (B.type = L.type), p(dist_se(B, L), E, O), B.name == null && D) {
          var H = D[O];
          !dist_X(H) && (H = {
            name: H
          }), B.name = B.displayName = H.name, B.defaultTooltip = H.defaultTooltip;
        }
        I && dist_se(B.otherDims, I);
      });
    }
  });
  function p(T, E, D) {
    Dv.get(E) != null ? T.otherDims[E] = D : (T.coordDim = E, T.coordDimIndex = D, i.set(E, !0));
  }
  var m = e.generateCoord, y = e.generateCoordCount, _ = y != null;
  y = m ? y || 1 : 0;
  var S = m || "value";
  function b(T) {
    T.name == null && (T.name = T.coordDim);
  }
  if (s)
    dist_M(a, function(T) {
      b(T);
    }), a.sort(function(T, E) {
      return T.storeDimIndex - E.storeDimIndex;
    });
  else
    for (var w = 0; w < o; w++) {
      var x = d(w), C = x.coordDim;
      C == null && (x.coordDim = gA(S, i, _), x.coordDimIndex = 0, (!m || y <= 0) && (x.isExtraCoord = !0), y--), b(x), x.type == null && (y4(r, w) === Ye.Must || x.isExtraCoord && (x.otherDims.itemName != null || x.otherDims.seriesName != null)) && (x.type = "ordinal");
    }
  return dA(a), new x6({
    source: r,
    dimensions: a,
    fullDimensionCount: o,
    dimensionOmitted: s
  });
}
function dA(r) {
  for (var e = dist_W(), t = 0; t < r.length; t++) {
    var n = r[t], i = n.name, a = e.get(i) || 0;
    a > 0 && (n.name = i + (a - 1)), a++, e.set(i, a);
  }
}
function pA(r, e, t, n) {
  var i = Math.max(r.dimensionsDetectedCount || 1, e.length, t.length, n || 0);
  return dist_M(e, function(a) {
    var o;
    dist_X(a) && (o = a.dimsDef) && (i = Math.max(i, o.length));
  }), i;
}
function gA(r, e, t) {
  if (t || e.hasKey(r)) {
    for (var n = 0; e.hasKey(r + n); )
      n++;
    r += n;
  }
  return e.set(r, !0), r;
}
var mA = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.coordSysDims = [], this.axisMap = dist_W(), this.categoryAxisMap = dist_W(), this.coordSysName = e;
    }
    return r;
  }()
);
function yA(r) {
  var e = r.get("coordinateSystem"), t = new mA(e), n = _A[e];
  if (n)
    return n(r, t, t.axisMap, t.categoryAxisMap), t;
}
var _A = {
  cartesian2d: function(r, e, t, n) {
    var i = r.getReferringComponents("xAxis", ft).models[0], a = r.getReferringComponents("yAxis", ft).models[0];
    if (false) {}
    e.coordSysDims = ["x", "y"], t.set("x", i), t.set("y", a), oa(i) && (n.set("x", i), e.firstCategoryDimIndex = 0), oa(a) && (n.set("y", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  singleAxis: function(r, e, t, n) {
    var i = r.getReferringComponents("singleAxis", ft).models[0];
    if (false)
      {}
    e.coordSysDims = ["single"], t.set("single", i), oa(i) && (n.set("single", i), e.firstCategoryDimIndex = 0);
  },
  polar: function(r, e, t, n) {
    var i = r.getReferringComponents("polar", ft).models[0], a = i.findAxisModel("radiusAxis"), o = i.findAxisModel("angleAxis");
    if (false) {}
    e.coordSysDims = ["radius", "angle"], t.set("radius", a), t.set("angle", o), oa(a) && (n.set("radius", a), e.firstCategoryDimIndex = 0), oa(o) && (n.set("angle", o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  geo: function(r, e, t, n) {
    e.coordSysDims = ["lng", "lat"];
  },
  parallel: function(r, e, t, n) {
    var i = r.ecModel, a = i.getComponent("parallel", r.get("parallelIndex")), o = e.coordSysDims = a.dimensions.slice();
    dist_M(a.parallelAxisIndex, function(s, l) {
      var u = i.getComponent("parallelAxis", s), f = o[l];
      t.set(f, u), oa(u) && (n.set(f, u), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l));
    });
  }
};
function oa(r) {
  return r.get("type") === "category";
}
function SA(r, e, t) {
  t = t || {};
  var n = t.byIndex, i = t.stackedCoordDimension, a, o, s;
  wA(e) ? a = e : (o = e.schema, a = o.dimensions, s = e.store);
  var l = !!(r && r.get("stack")), u, f, c, h;
  if (dist_M(a, function(y, _) {
    dist_U(y) && (a[_] = y = {
      name: y
    }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !f && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (f = y));
  }), f && !n && !u && (n = !0), f) {
    c = "__\0ecstackresult_" + r.id, h = "__\0ecstackedover_" + r.id, u && (u.createInvertedIndices = !0);
    var v = f.coordDim, d = f.type, g = 0;
    dist_M(a, function(y) {
      y.coordDim === v && g++;
    });
    var p = {
      name: c,
      coordDim: v,
      coordDimIndex: g,
      type: d,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, m = {
      name: h,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: h,
      coordDimIndex: g + 1,
      type: d,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    o ? (s && (p.storeDimIndex = s.ensureCalculationDimension(h, d), m.storeDimIndex = s.ensureCalculationDimension(c, d)), o.appendCalculationDimension(p), o.appendCalculationDimension(m)) : (a.push(p), a.push(m));
  }
  return {
    stackedDimension: f && f.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: h,
    stackResultDimension: c
  };
}
function wA(r) {
  return !C6(r.schema);
}
function Fa(r, e) {
  return !!e && e === r.getCalculationInfo("stackedDimension");
}
function bA(r, e) {
  return Fa(r, e) ? r.getCalculationInfo("stackResultDimension") : e;
}
function xA(r, e) {
  var t = r.get("coordinateSystem"), n = Rs.get(t), i;
  return e && e.coordSysDims && (i = dist_$(e.coordSysDims, function(a) {
    var o = {
      name: a
    }, s = e.axisMap.get(a);
    if (s) {
      var l = s.get("type");
      o.type = oA(l);
    }
    return o;
  })), i || (i = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), i;
}
function CA(r, e, t) {
  var n, i;
  return t && dist_M(r, function(a, o) {
    var s = a.coordDim, l = t.categoryAxisMap.get(s);
    l && (n == null && (n = o), a.ordinalMeta = l.getOrdinalMeta(), e && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (i = !0);
  }), !i && n != null && (r[n].otherDims.itemName = 0), n;
}
function ks(r, e, t) {
  t = t || {};
  var n = e.getSourceManager(), i, a = !1;
  r ? (a = !0, i = i0(r)) : (i = n.getSource(), a = i.sourceFormat === Jt);
  var o = yA(e), s = xA(e, o), l = t.useEncodeDefaulter, u = dist_j(l) ? l : l ? Te(_M, s, e) : null, f = {
    coordDimensions: s,
    generateCoord: t.generateCoord,
    encodeDefine: e.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, c = p0(i, f), h = CA(c.dimensions, t.createInvertedIndices, o), v = a ? null : n.getSharedDataStore(c), d = SA(e, {
    schema: c,
    store: v
  }), g = new Ba(c, e);
  g.setCalculationInfo(d);
  var p = h != null && TA(i) ? function(m, y, _, S) {
    return S === h ? _ : this.defaultDimValueGetter(m, y, _, S);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? i : v,
    null,
    p
  ), g;
}
function TA(r) {
  if (r.sourceFormat === Jt) {
    var e = MA(r.data || []);
    return !dist_F(Ds(e));
  }
}
function MA(r) {
  for (var e = 0; e < r.length && r[e] == null; )
    e++;
  return r[e];
}
var Pr = (
  /** @class */
  function() {
    function r(e) {
      this._setting = e || {}, this._extent = [1 / 0, -1 / 0];
    }
    return r.prototype.getSetting = function(e) {
      return this._setting[e];
    }, r.prototype.unionExtent = function(e) {
      var t = this._extent;
      e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]);
    }, r.prototype.unionExtentFromData = function(e, t) {
      this.unionExtent(e.getApproximateExtent(t));
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.setExtent = function(e, t) {
      var n = this._extent;
      isNaN(e) || (n[0] = e), isNaN(t) || (n[1] = t);
    }, r.prototype.isInExtentRange = function(e) {
      return this._extent[0] <= e && this._extent[1] >= e;
    }, r.prototype.isBlank = function() {
      return this._isBlank;
    }, r.prototype.setBlank = function(e) {
      this._isBlank = e;
    }, r;
  }()
);
sf(Pr);
var DA = 0, zv = (
  /** @class */
  function() {
    function r(e) {
      this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++DA;
    }
    return r.createByAxisModel = function(e) {
      var t = e.option, n = t.data, i = n && dist_$(n, EA);
      return new r({
        categories: i,
        needCollect: !i,
        // deduplication is default in axis.
        deduplication: t.dedplication !== !1
      });
    }, r.prototype.getOrdinal = function(e) {
      return this._getOrCreateMap().get(e);
    }, r.prototype.parseAndCollect = function(e) {
      var t, n = this._needCollect;
      if (!dist_U(e) && !n)
        return e;
      if (n && !this._deduplication)
        return t = this.categories.length, this.categories[t] = e, t;
      var i = this._getOrCreateMap();
      return t = i.get(e), t == null && (n ? (t = this.categories.length, this.categories[t] = e, i.set(e, t)) : t = NaN), t;
    }, r.prototype._getOrCreateMap = function() {
      return this._map || (this._map = dist_W(this.categories));
    }, r;
  }()
);
function EA(r) {
  return dist_X(r) && r.value != null ? r.value : r + "";
}
function AA(r) {
  var e = Math.pow(10, af(Math.abs(r))), t = Math.abs(r / e);
  return t === 0 || t === 1 || t === 2 || t === 3 || t === 5;
}
function Gv(r) {
  return r.type === "interval" || r.type === "log";
}
function IA(r, e, t, n) {
  var i = {}, a = r[1] - r[0], o = i.interval = Z3(a / e, !0);
  t != null && o < t && (o = i.interval = t), n != null && o > n && (o = i.interval = n);
  var s = i.intervalPrecision = E6(o), l = i.niceTickExtent = [Be(Math.ceil(r[0] / o) * o, s), Be(Math.floor(r[1] / o) * o, s)];
  return LA(l, r), i;
}
function Qc(r) {
  var e = Math.pow(10, af(r)), t = r / e;
  return t ? t === 2 ? t = 3 : t === 3 ? t = 5 : t *= 2 : t = 1, Be(t * e);
}
function E6(r) {
  return zr(r) + 2;
}
function e2(r, e, t) {
  r[e] = Math.max(Math.min(r[e], t[1]), t[0]);
}
function LA(r, e) {
  !isFinite(r[0]) && (r[0] = e[0]), !isFinite(r[1]) && (r[1] = e[1]), e2(r, 0, e), e2(r, 1, e), r[0] > r[1] && (r[0] = r[1]);
}
function Af(r, e) {
  return r >= e[0] && r <= e[1];
}
function If(r, e) {
  return e[1] === e[0] ? 0.5 : (r - e[0]) / (e[1] - e[0]);
}
function Lf(r, e) {
  return r * (e[1] - e[0]) + e[0];
}
var A6 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      n.type = "ordinal";
      var i = n.getSetting("ordinalMeta");
      return i || (i = new zv({})), dist_F(i) && (i = new zv({
        categories: dist_$(i, function(a) {
          return dist_X(a) ? a.value : a;
        })
      })), n._ordinalMeta = i, n._extent = n.getSetting("extent") || [0, i.categories.length - 1], n;
    }
    return e.prototype.parse = function(t) {
      return t == null ? NaN : dist_U(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
    }, e.prototype.contain = function(t) {
      return t = this.parse(t), Af(t, this._extent) && this._ordinalMeta.categories[t] != null;
    }, e.prototype.normalize = function(t) {
      return t = this._getTickNumber(this.parse(t)), If(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = Math.round(Lf(t, this._extent)), this.getRawOrdinalNumber(t);
    }, e.prototype.getTicks = function() {
      for (var t = [], n = this._extent, i = n[0]; i <= n[1]; )
        t.push({
          value: i
        }), i++;
      return t;
    }, e.prototype.getMinorTicks = function(t) {
    }, e.prototype.setSortInfo = function(t) {
      if (t == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var n = t.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, n.length); o < l; ++o) {
        var u = n[o];
        i[o] = u, a[u] = o;
      }
      for (var f = 0; o < s; ++o) {
        for (; a[f] != null; )
          f++;
        i.push(f), a[f] = o;
      }
    }, e.prototype._getTickNumber = function(t) {
      var n = this._ticksByOrdinalNumber;
      return n && t >= 0 && t < n.length ? n[t] : t;
    }, e.prototype.getRawOrdinalNumber = function(t) {
      var n = this._ordinalNumbersByTick;
      return n && t >= 0 && t < n.length ? n[t] : t;
    }, e.prototype.getLabel = function(t) {
      if (!this.isBlank()) {
        var n = this.getRawOrdinalNumber(t.value), i = this._ordinalMeta.categories[n];
        return i == null ? "" : i + "";
      }
    }, e.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, e.prototype.unionExtentFromData = function(t, n) {
      this.unionExtent(t.getApproximateExtent(n));
    }, e.prototype.isInExtentRange = function(t) {
      return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, e.prototype.calcNiceTicks = function() {
    }, e.prototype.calcNiceExtent = function() {
    }, e.type = "ordinal", e;
  }(Pr)
);
Pr.registerClass(A6);
const I6 = A6;
var vi = Be, L6 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t;
    }
    return e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return Af(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return If(t, this._extent);
    }, e.prototype.scale = function(t) {
      return Lf(t, this._extent);
    }, e.prototype.setExtent = function(t, n) {
      var i = this._extent;
      isNaN(t) || (i[0] = parseFloat(t)), isNaN(n) || (i[1] = parseFloat(n));
    }, e.prototype.unionExtent = function(t) {
      var n = this._extent;
      t[0] < n[0] && (n[0] = t[0]), t[1] > n[1] && (n[1] = t[1]), this.setExtent(n[0], n[1]);
    }, e.prototype.getInterval = function() {
      return this._interval;
    }, e.prototype.setInterval = function(t) {
      this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = E6(t);
    }, e.prototype.getTicks = function(t) {
      var n = this._interval, i = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
      if (!n)
        return s;
      var l = 1e4;
      i[0] < a[0] && (t ? s.push({
        value: vi(a[0] - n, o)
      }) : s.push({
        value: i[0]
      }));
      for (var u = a[0]; u <= a[1] && (s.push({
        value: u
      }), u = vi(u + n, o), u !== s[s.length - 1].value); )
        if (s.length > l)
          return [];
      var f = s.length ? s[s.length - 1].value : a[1];
      return i[1] > f && (t ? s.push({
        value: vi(f + n, o)
      }) : s.push({
        value: i[1]
      })), s;
    }, e.prototype.getMinorTicks = function(t) {
      for (var n = this.getTicks(!0), i = [], a = this.getExtent(), o = 1; o < n.length; o++) {
        for (var s = n[o], l = n[o - 1], u = 0, f = [], c = s.value - l.value, h = c / t; u < t - 1; ) {
          var v = vi(l.value + (u + 1) * h);
          v > a[0] && v < a[1] && f.push(v), u++;
        }
        i.push(f);
      }
      return i;
    }, e.prototype.getLabel = function(t, n) {
      if (t == null)
        return "";
      var i = n && n.precision;
      i == null ? i = zr(t.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var a = vi(t.value, i, !0);
      return c4(a);
    }, e.prototype.calcNiceTicks = function(t, n, i) {
      t = t || 5;
      var a = this._extent, o = a[1] - a[0];
      if (isFinite(o)) {
        o < 0 && (o = -o, a.reverse());
        var s = IA(a, t, n, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      var n = this._extent;
      if (n[0] === n[1])
        if (n[0] !== 0) {
          var i = Math.abs(n[0]);
          t.fixMax || (n[1] += i / 2), n[0] -= i / 2;
        } else
          n[1] = 1;
      var a = n[1] - n[0];
      isFinite(a) || (n[0] = 0, n[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
      var o = this._interval;
      t.fixMin || (n[0] = vi(Math.floor(n[0] / o) * o)), t.fixMax || (n[1] = vi(Math.ceil(n[1] / o) * o));
    }, e.prototype.setNiceExtent = function(t, n) {
      this._niceExtent = [t, n];
    }, e.type = "interval", e;
  }(Pr)
);
Pr.registerClass(L6);
const Vs = L6;
var N6 = typeof Float32Array < "u", NA = N6 ? Float32Array : Array;
function Hr(r) {
  return dist_F(r) ? N6 ? new Float32Array(r) : r : new NA(r);
}
var PA = "__ec_stack_";
function g0(r) {
  return r.get("stack") || PA + r.seriesIndex;
}
function m0(r) {
  return r.dim + r.index;
}
function P6(r, e) {
  var t = [];
  return e.eachSeriesByType(r, function(n) {
    O6(n) && t.push(n);
  }), t;
}
function RA(r) {
  var e = {};
  dist_M(r, function(l) {
    var u = l.coordinateSystem, f = u.getBaseAxis();
    if (!(f.type !== "time" && f.type !== "value"))
      for (var c = l.getData(), h = f.dim + "_" + f.index, v = c.getDimensionIndex(c.mapDimension(f.dim)), d = c.getStore(), g = 0, p = d.count(); g < p; ++g) {
        var m = d.get(v, g);
        e[h] ? e[h].push(m) : e[h] = [m];
      }
  });
  var t = {};
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var i = e[n];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, o = 1; o < i.length; ++o) {
          var s = i[o] - i[o - 1];
          s > 0 && (a = a === null ? s : Math.min(a, s));
        }
        t[n] = a;
      }
    }
  return t;
}
function R6(r) {
  var e = RA(r), t = [];
  return dist_M(r, function(n) {
    var i = n.coordinateSystem, a = i.getBaseAxis(), o = a.getExtent(), s;
    if (a.type === "category")
      s = a.getBandWidth();
    else if (a.type === "value" || a.type === "time") {
      var l = a.dim + "_" + a.index, u = e[l], f = Math.abs(o[1] - o[0]), c = a.scale.getExtent(), h = Math.abs(c[1] - c[0]);
      s = u ? f / h * u : f;
    } else {
      var v = n.getData();
      s = Math.abs(o[1] - o[0]) / v.count();
    }
    var d = me(n.get("barWidth"), s), g = me(n.get("barMaxWidth"), s), p = me(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      n.get("barMinWidth") || (k6(n) ? 0.5 : 1),
      s
    ), m = n.get("barGap"), y = n.get("barCategoryGap");
    t.push({
      bandWidth: s,
      barWidth: d,
      barMaxWidth: g,
      barMinWidth: p,
      barGap: m,
      barCategoryGap: y,
      axisKey: m0(a),
      stackId: g0(n)
    });
  }), OA(t);
}
function OA(r) {
  var e = {};
  dist_M(r, function(n, i) {
    var a = n.axisKey, o = n.bandWidth, s = e[a] || {
      bandWidth: o,
      remainedWidth: o,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, l = s.stacks;
    e[a] = s;
    var u = n.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var f = n.barWidth;
    f && !l[u].width && (l[u].width = f, f = Math.min(s.remainedWidth, f), s.remainedWidth -= f);
    var c = n.barMaxWidth;
    c && (l[u].maxWidth = c);
    var h = n.barMinWidth;
    h && (l[u].minWidth = h);
    var v = n.barGap;
    v != null && (s.gap = v);
    var d = n.barCategoryGap;
    d != null && (s.categoryGap = d);
  });
  var t = {};
  return dist_M(e, function(n, i) {
    t[i] = {};
    var a = n.stacks, o = n.bandWidth, s = n.categoryGap;
    if (s == null) {
      var l = we(a).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = me(s, o), f = me(n.gap, 1), c = n.remainedWidth, h = n.autoWidthCount, v = (c - u) / (h + (h - 1) * f);
    v = Math.max(v, 0), dist_M(a, function(m) {
      var y = m.maxWidth, _ = m.minWidth;
      if (m.width) {
        var S = m.width;
        y && (S = Math.min(S, y)), _ && (S = Math.max(S, _)), m.width = S, c -= S + f * S, h--;
      } else {
        var S = v;
        y && y < S && (S = Math.min(y, c)), _ && _ > S && (S = _), S !== v && (m.width = S, c -= S + f * S, h--);
      }
    }), v = (c - u) / (h + (h - 1) * f), v = Math.max(v, 0);
    var d = 0, g;
    dist_M(a, function(m, y) {
      m.width || (m.width = v), g = m, d += m.width * (1 + f);
    }), g && (d -= g.width * f);
    var p = -d / 2;
    dist_M(a, function(m, y) {
      t[i][y] = t[i][y] || {
        bandWidth: o,
        offset: p,
        width: m.width
      }, p += m.width * (1 + f);
    });
  }), t;
}
function kA(r, e, t) {
  if (r && e) {
    var n = r[m0(e)];
    return n != null && t != null ? n[g0(t)] : n;
  }
}
function VA(r, e) {
  var t = P6(r, e), n = R6(t);
  dist_M(t, function(i) {
    var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = g0(i), u = n[m0(s)][l], f = u.offset, c = u.width;
    a.setLayout({
      bandWidth: u.bandWidth,
      offset: f,
      size: c
    });
  });
}
function BA(r) {
  return {
    seriesType: r,
    plan: Tf(),
    reset: function(e) {
      if (O6(e)) {
        var t = e.getData(), n = e.coordinateSystem, i = n.getBaseAxis(), a = n.getOtherAxis(i), o = t.getDimensionIndex(t.mapDimension(a.dim)), s = t.getDimensionIndex(t.mapDimension(i.dim)), l = e.get("showBackground", !0), u = t.mapDimension(a.dim), f = t.getCalculationInfo("stackResultDimension"), c = Fa(t, u) && !!t.getCalculationInfo("stackedOnSeries"), h = a.isHorizontal(), v = FA(i, a), d = k6(e), g = e.get("barMinHeight") || 0, p = f && t.getDimensionIndex(f), m = t.getLayout("size"), y = t.getLayout("offset");
        return {
          progress: function(_, S) {
            for (var b = _.count, w = d && Hr(b * 3), x = d && l && Hr(b * 3), C = d && Hr(b), T = n.master.getRect(), E = h ? T.width : T.height, D, I = S.getStore(), L = 0; (D = _.next()) != null; ) {
              var N = I.get(c ? p : o, D), P = I.get(s, D), R = v, z = void 0;
              c && (z = +N - I.get(o, D));
              var O = void 0, B = void 0, H = void 0, q = void 0;
              if (h) {
                var Q = n.dataToPoint([N, P]);
                if (c) {
                  var le = n.dataToPoint([z, P]);
                  R = le[0];
                }
                O = R, B = Q[1] + y, H = Q[0] - R, q = m, Math.abs(H) < g && (H = (H < 0 ? -1 : 1) * g);
              } else {
                var Q = n.dataToPoint([P, N]);
                if (c) {
                  var le = n.dataToPoint([P, z]);
                  R = le[1];
                }
                O = Q[0] + y, B = R, H = m, q = Q[1] - R, Math.abs(q) < g && (q = (q <= 0 ? -1 : 1) * g);
              }
              d ? (w[L] = O, w[L + 1] = B, w[L + 2] = h ? H : q, x && (x[L] = h ? T.x : O, x[L + 1] = h ? B : T.y, x[L + 2] = E), C[D] = D) : S.setItemLayout(D, {
                x: O,
                y: B,
                width: H,
                height: q
              }), L += 3;
            }
            d && S.setLayout({
              largePoints: w,
              largeDataIndices: C,
              largeBackgroundPoints: x,
              valueAxisHorizontal: h
            });
          }
        };
      }
    }
  };
}
function O6(r) {
  return r.coordinateSystem && r.coordinateSystem.type === "cartesian2d";
}
function k6(r) {
  return r.pipelineContext && r.pipelineContext.large;
}
function FA(r, e) {
  return e.toGlobalCoord(e.dataToCoord(e.type === "log" ? 1 : 0));
}
var zA = function(r, e, t, n) {
  for (; t < n; ) {
    var i = t + n >>> 1;
    r[i][1] < e ? t = i + 1 : n = i;
  }
  return t;
}, V6 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "time", n;
    }
    return e.prototype.getLabel = function(t) {
      var n = this.getSetting("useUTC");
      return mf(t.value, Wg[lM(Da(this._minLevelUnit))] || Wg.second, n, this.getSetting("locale"));
    }, e.prototype.getFormattedLabel = function(t, n, i) {
      var a = this.getSetting("useUTC"), o = this.getSetting("locale");
      return uM(t, n, i, o, a);
    }, e.prototype.getTicks = function() {
      var t = this._interval, n = this._extent, i = [];
      if (!t)
        return i;
      i.push({
        value: n[0],
        level: 0
      });
      var a = this.getSetting("useUTC"), o = XA(this._minLevelUnit, this._approxInterval, a, n);
      return i = i.concat(o), i.push({
        value: n[1],
        level: 0
      }), i;
    }, e.prototype.calcNiceExtent = function(t) {
      var n = this._extent;
      if (n[0] === n[1] && (n[0] -= Yt, n[1] += Yt), n[1] === -1 / 0 && n[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        n[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), n[0] = n[1] - Yt;
      }
      this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
    }, e.prototype.calcNiceTicks = function(t, n, i) {
      t = t || 10;
      var a = this._extent, o = a[1] - a[0];
      this._approxInterval = o / t, n != null && this._approxInterval < n && (this._approxInterval = n), i != null && this._approxInterval > i && (this._approxInterval = i);
      var s = Sl.length, l = Math.min(zA(Sl, this._approxInterval, 0, s), s - 1);
      this._interval = Sl[l][1], this._minLevelUnit = Sl[Math.max(l - 1, 0)][0];
    }, e.prototype.parse = function(t) {
      return ve(t) ? t : +en(t);
    }, e.prototype.contain = function(t) {
      return Af(this.parse(t), this._extent);
    }, e.prototype.normalize = function(t) {
      return If(this.parse(t), this._extent);
    }, e.prototype.scale = function(t) {
      return Lf(t, this._extent);
    }, e.type = "time", e;
  }(Vs)
), Sl = [
  // Format                           interval
  ["second", Kd],
  ["minute", jd],
  ["hour", Uo],
  ["quarter-day", Uo * 6],
  ["half-day", Uo * 12],
  ["day", Yt * 1.2],
  ["half-week", Yt * 3.5],
  ["week", Yt * 7],
  ["month", Yt * 31],
  ["quarter", Yt * 95],
  ["half-year", $g / 2],
  ["year", $g]
  // 1Y
];
function GA(r, e, t, n) {
  var i = en(e), a = en(t), o = function(d) {
    return Ug(i, d, n) === Ug(a, d, n);
  }, s = function() {
    return o("year");
  }, l = function() {
    return s() && o("month");
  }, u = function() {
    return l() && o("day");
  }, f = function() {
    return u() && o("hour");
  }, c = function() {
    return f() && o("minute");
  }, h = function() {
    return c() && o("second");
  }, v = function() {
    return h() && o("millisecond");
  };
  switch (r) {
    case "year":
      return s();
    case "month":
      return l();
    case "day":
      return u();
    case "hour":
      return f();
    case "minute":
      return c();
    case "second":
      return h();
    case "millisecond":
      return v();
  }
}
function HA(r, e) {
  return r /= Yt, r > 16 ? 16 : r > 7.5 ? 7 : r > 3.5 ? 4 : r > 1.5 ? 2 : 1;
}
function $A(r) {
  var e = 30 * Yt;
  return r /= e, r > 6 ? 6 : r > 3 ? 3 : r > 2 ? 2 : 1;
}
function WA(r) {
  return r /= Uo, r > 12 ? 12 : r > 6 ? 6 : r > 3.5 ? 4 : r > 2 ? 2 : 1;
}
function t2(r, e) {
  return r /= e ? jd : Kd, r > 30 ? 30 : r > 20 ? 20 : r > 15 ? 15 : r > 10 ? 10 : r > 5 ? 5 : r > 2 ? 2 : 1;
}
function UA(r) {
  return Z3(r, !0);
}
function YA(r, e, t) {
  var n = new Date(r);
  switch (Da(e)) {
    case "year":
    case "month":
      n[a4(t)](0);
    case "day":
      n[o4(t)](1);
    case "hour":
      n[s4(t)](0);
    case "minute":
      n[l4(t)](0);
    case "second":
      n[u4(t)](0), n[f4(t)](0);
  }
  return n.getTime();
}
function XA(r, e, t, n) {
  var i = 1e4, a = n4, o = 0;
  function s(E, D, I, L, N, P, R) {
    for (var z = new Date(D), O = D, B = z[L](); O < I && O <= n[1]; )
      R.push({
        value: O
      }), B += E, z[N](B), O = z.getTime();
    R.push({
      value: O,
      notAdd: !0
    });
  }
  function l(E, D, I) {
    var L = [], N = !D.length;
    if (!GA(Da(E), n[0], n[1], t)) {
      N && (D = [{
        // TODO Optimize. Not include so may ticks.
        value: YA(new Date(n[0]), E, t)
      }, {
        value: n[1]
      }]);
      for (var P = 0; P < D.length - 1; P++) {
        var R = D[P].value, z = D[P + 1].value;
        if (R !== z) {
          var O = void 0, B = void 0, H = void 0, q = !1;
          switch (E) {
            case "year":
              O = Math.max(1, Math.round(e / Yt / 365)), B = Jd(t), H = fM(t);
              break;
            case "half-year":
            case "quarter":
            case "month":
              O = $A(e), B = Ea(t), H = a4(t);
              break;
            case "week":
            case "half-week":
            case "day":
              O = HA(e), B = yf(t), H = o4(t), q = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              O = WA(e), B = hs(t), H = s4(t);
              break;
            case "minute":
              O = t2(e, !0), B = _f(t), H = l4(t);
              break;
            case "second":
              O = t2(e, !1), B = Sf(t), H = u4(t);
              break;
            case "millisecond":
              O = UA(e), B = wf(t), H = f4(t);
              break;
          }
          s(O, R, z, B, H, q, L), E === "year" && I.length > 1 && P === 0 && I.unshift({
            value: I[0].value - O
          });
        }
      }
      for (var P = 0; P < L.length; P++)
        I.push(L[P]);
      return L;
    }
  }
  for (var u = [], f = [], c = 0, h = 0, v = 0; v < a.length && o++ < i; ++v) {
    var d = Da(a[v]);
    if (sM(a[v])) {
      l(a[v], u[u.length - 1] || [], f);
      var g = a[v + 1] ? Da(a[v + 1]) : null;
      if (d !== g) {
        if (f.length) {
          h = c, f.sort(function(E, D) {
            return E.value - D.value;
          });
          for (var p = [], m = 0; m < f.length; ++m) {
            var y = f[m].value;
            (m === 0 || f[m - 1].value !== y) && (p.push(f[m]), y >= n[0] && y <= n[1] && c++);
          }
          var _ = (n[1] - n[0]) / e;
          if (c > _ * 1.5 && h > _ / 1.5 || (u.push(p), c > _ || r === a[v]))
            break;
        }
        f = [];
      }
    }
  }
   false && 0;
  for (var S = ke(dist_$(u, function(E) {
    return ke(E, function(D) {
      return D.value >= n[0] && D.value <= n[1] && !D.notAdd;
    });
  }), function(E) {
    return E.length > 0;
  }), b = [], w = S.length - 1, v = 0; v < S.length; ++v)
    for (var x = S[v], C = 0; C < x.length; ++C)
      b.push({
        value: x[C].value,
        level: w - v
      });
  b.sort(function(E, D) {
    return E.value - D.value;
  });
  for (var T = [], v = 0; v < b.length; ++v)
    (v === 0 || b[v].value !== b[v - 1].value) && T.push(b[v]);
  return T;
}
Pr.registerClass(V6);
const ZA = V6;
var r2 = Pr.prototype, qo = Vs.prototype, qA = Be, KA = Math.floor, jA = Math.ceil, wl = Math.pow, er = Math.log, y0 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "log", t.base = 10, t._originalScale = new Vs(), t._interval = 0, t;
    }
    return e.prototype.getTicks = function(t) {
      var n = this._originalScale, i = this._extent, a = n.getExtent(), o = qo.getTicks.call(this, t);
      return dist_$(o, function(s) {
        var l = s.value, u = Be(wl(this.base, l));
        return u = l === i[0] && this._fixMin ? bl(u, a[0]) : u, u = l === i[1] && this._fixMax ? bl(u, a[1]) : u, {
          value: u
        };
      }, this);
    }, e.prototype.setExtent = function(t, n) {
      var i = er(this.base);
      t = er(Math.max(0, t)) / i, n = er(Math.max(0, n)) / i, qo.setExtent.call(this, t, n);
    }, e.prototype.getExtent = function() {
      var t = this.base, n = r2.getExtent.call(this);
      n[0] = wl(t, n[0]), n[1] = wl(t, n[1]);
      var i = this._originalScale, a = i.getExtent();
      return this._fixMin && (n[0] = bl(n[0], a[0])), this._fixMax && (n[1] = bl(n[1], a[1])), n;
    }, e.prototype.unionExtent = function(t) {
      this._originalScale.unionExtent(t);
      var n = this.base;
      t[0] = er(t[0]) / er(n), t[1] = er(t[1]) / er(n), r2.unionExtent.call(this, t);
    }, e.prototype.unionExtentFromData = function(t, n) {
      this.unionExtent(t.getApproximateExtent(n));
    }, e.prototype.calcNiceTicks = function(t) {
      t = t || 10;
      var n = this._extent, i = n[1] - n[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var a = gC(i), o = t / i * a;
        for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; )
          a *= 10;
        var s = [Be(jA(n[0] / a) * a), Be(KA(n[1] / a) * a)];
        this._interval = a, this._niceExtent = s;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      qo.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax;
    }, e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return t = er(t) / er(this.base), Af(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return t = er(t) / er(this.base), If(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = Lf(t, this._extent), wl(this.base, t);
    }, e.type = "log", e;
  }(Pr)
), B6 = y0.prototype;
B6.getMinorTicks = qo.getMinorTicks;
B6.getLabel = qo.getLabel;
function bl(r, e) {
  return qA(r, zr(e));
}
Pr.registerClass(y0);
const JA = y0;
var QA = (
  /** @class */
  function() {
    function r(e, t, n) {
      this._prepareParams(e, t, n);
    }
    return r.prototype._prepareParams = function(e, t, n) {
      n[1] < n[0] && (n = [NaN, NaN]), this._dataMin = n[0], this._dataMax = n[1];
      var i = this._isOrdinal = e.type === "ordinal";
      this._needCrossZero = e.type === "interval" && t.getNeedCrossZero && t.getNeedCrossZero();
      var a = this._modelMinRaw = t.get("min", !0);
      dist_j(a) ? this._modelMinNum = xl(e, a({
        min: n[0],
        max: n[1]
      })) : a !== "dataMin" && (this._modelMinNum = xl(e, a));
      var o = this._modelMaxRaw = t.get("max", !0);
      if (dist_j(o) ? this._modelMaxNum = xl(e, o({
        min: n[0],
        max: n[1]
      })) : o !== "dataMax" && (this._modelMaxNum = xl(e, o)), i)
        this._axisDataLen = t.getCategories().length;
      else {
        var s = t.get("boundaryGap"), l = dist_F(s) ? s : [s || 0, s || 0];
        typeof l[0] == "boolean" || typeof l[1] == "boolean" ? ("production", this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [Lr(l[0], 1), Lr(l[1], 1)];
      }
    }, r.prototype.calculate = function() {
      var e = this._isOrdinal, t = this._dataMin, n = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, o = e ? null : n - t || Math.abs(t), s = this._modelMinRaw === "dataMin" ? t : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? n : this._modelMaxNum, u = s != null, f = l != null;
      s == null && (s = e ? i ? 0 : NaN : t - a[0] * o), l == null && (l = e ? i ? i - 1 : NaN : n + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var c = as(s) || as(l) || e && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !f && (l = 0));
      var h = this._determinedMin, v = this._determinedMax;
      return h != null && (s = h, u = !0), v != null && (l = v, f = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: f,
        isBlank: c
      };
    }, r.prototype.modifyDataMinMax = function(e, t) {
       false && 0, this[tI[e]] = t;
    }, r.prototype.setDeterminedMinMax = function(e, t) {
      var n = eI[e];
       false && 0, this[n] = t;
    }, r.prototype.freeze = function() {
      this.frozen = !0;
    }, r;
  }()
), eI = {
  min: "_determinedMin",
  max: "_determinedMax"
}, tI = {
  min: "_dataMin",
  max: "_dataMax"
};
function F6(r, e, t) {
  var n = r.rawExtentInfo;
  return n || (n = new QA(r, e, t), r.rawExtentInfo = n, n);
}
function xl(r, e) {
  return e == null ? null : as(e) ? NaN : r.parse(e);
}
function z6(r, e) {
  var t = r.type, n = F6(r, e, r.getExtent()).calculate();
  r.setBlank(n.isBlank);
  var i = n.min, a = n.max, o = e.ecModel;
  if (o && t === "time") {
    var s = P6("bar", o), l = !1;
    if (dist_M(s, function(c) {
      l = l || c.getBaseAxis() === e.axis;
    }), l) {
      var u = R6(s), f = rI(i, a, e, u);
      i = f.min, a = f.max;
    }
  }
  return {
    extent: [i, a],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: n.minFixed,
    fixMax: n.maxFixed
  };
}
function rI(r, e, t, n) {
  var i = t.axis.getExtent(), a = i[1] - i[0], o = kA(n, t.axis);
  if (o === void 0)
    return {
      min: r,
      max: e
    };
  var s = 1 / 0;
  dist_M(o, function(v) {
    s = Math.min(v.offset, s);
  });
  var l = -1 / 0;
  dist_M(o, function(v) {
    l = Math.max(v.offset + v.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, f = e - r, c = 1 - (s + l) / a, h = f / c - f;
  return e += h * (l / u), r -= h * (s / u), {
    min: r,
    max: e
  };
}
function n2(r, e) {
  var t = e, n = z6(r, t), i = n.extent, a = t.get("splitNumber");
  r instanceof JA && (r.base = t.get("logBase"));
  var o = r.type, s = t.get("interval"), l = o === "interval" || o === "time";
  r.setExtent(i[0], i[1]), r.calcNiceExtent({
    splitNumber: a,
    fixMin: n.fixMin,
    fixMax: n.fixMax,
    minInterval: l ? t.get("minInterval") : null,
    maxInterval: l ? t.get("maxInterval") : null
  }), s != null && r.setInterval && r.setInterval(s);
}
function nI(r, e) {
  if (e = e || r.get("type"), e)
    switch (e) {
      case "category":
        return new I6({
          ordinalMeta: r.getOrdinalMeta ? r.getOrdinalMeta() : r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new ZA({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new (Pr.getClass(e) || Vs)();
    }
}
function iI(r) {
  var e = r.scale.getExtent(), t = e[0], n = e[1];
  return !(t > 0 && n > 0 || t < 0 && n < 0);
}
function Bs(r) {
  var e = r.getLabelModel().get("formatter"), t = r.type === "category" ? r.scale.getExtent()[0] : null;
  return r.scale.type === "time" ? /* @__PURE__ */ function(n) {
    return function(i, a) {
      return r.scale.getFormattedLabel(i, a, n);
    };
  }(e) : dist_U(e) ? /* @__PURE__ */ function(n) {
    return function(i) {
      var a = r.scale.getLabel(i), o = n.replace("{value}", a ?? "");
      return o;
    };
  }(e) : dist_j(e) ? /* @__PURE__ */ function(n) {
    return function(i, a) {
      return t != null && (a = i.value - t), n(_0(r, i), a, i.level != null ? {
        level: i.level
      } : null);
    };
  }(e) : function(n) {
    return r.scale.getLabel(n);
  };
}
function _0(r, e) {
  return r.type === "category" ? r.scale.getLabel(e) : e.value;
}
function aI(r) {
  var e = r.model, t = r.scale;
  if (!(!e.get(["axisLabel", "show"]) || t.isBlank())) {
    var n, i, a = t.getExtent();
    t instanceof I6 ? i = t.count() : (n = t.getTicks(), i = n.length);
    var o = r.getLabelModel(), s = Bs(r), l, u = 1;
    i > 40 && (u = Math.ceil(i / 40));
    for (var f = 0; f < i; f += u) {
      var c = n ? n[f] : {
        value: a[0] + f
      }, h = s(c, f), v = o.getTextRect(h), d = oI(v, o.get("rotate") || 0);
      l ? l.union(d) : l = d;
    }
    return l;
  }
}
function oI(r, e) {
  var t = e * Math.PI / 180, n = r.width, i = r.height, a = n * Math.abs(Math.cos(t)) + Math.abs(i * Math.sin(t)), o = n * Math.abs(Math.sin(t)) + Math.abs(i * Math.cos(t)), s = new dist_ae(r.x, r.y, a, o);
  return s;
}
function S0(r) {
  var e = r.get("interval");
  return e ?? "auto";
}
function G6(r) {
  return r.type === "category" && S0(r.getLabelModel()) === 0;
}
function H6(r, e) {
  var t = {};
  return dist_M(r.mapDimensionsAll(e), function(n) {
    t[bA(r, n)] = !0;
  }), we(t);
}
function sI(r, e, t) {
  e && dist_M(H6(e, t), function(n) {
    var i = e.getApproximateExtent(n);
    i[0] < r[0] && (r[0] = i[0]), i[1] > r[1] && (r[1] = i[1]);
  });
}
var lI = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getNeedCrossZero = function() {
      var e = this.option;
      return !e.scale;
    }, r.prototype.getCoordSysModel = function() {
    }, r;
  }()
), i2 = [], uI = {
  registerPreprocessor: S6,
  registerProcessor: w6,
  registerPostInit: JE,
  registerPostUpdate: QE,
  registerUpdateLifecycle: v0,
  registerAction: Gi,
  registerCoordinateSystem: eA,
  registerLayout: tA,
  registerVisual: Hi,
  registerTransform: nA,
  registerLoading: b6,
  registerMap: rA,
  registerImpl: PE,
  PRIORITY: YE,
  ComponentModel: Se,
  ComponentView: Pt,
  SeriesModel: jt,
  ChartView: bt,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(r) {
    Se.registerClass(r);
  },
  registerComponentView: function(r) {
    Pt.registerClass(r);
  },
  registerSeriesModel: function(r) {
    jt.registerClass(r);
  },
  registerChartView: function(r) {
    bt.registerClass(r);
  },
  registerSubTypeDefaulter: function(r, e) {
    Se.registerSubTypeDefaulter(r, e);
  },
  registerPainter: function(r, e) {
    cC(r, e);
  }
};
function Rt(r) {
  if (dist_F(r)) {
    dist_M(r, function(e) {
      Rt(e);
    });
    return;
  }
  ye(i2, r) >= 0 || (i2.push(r), dist_j(r) && (r = {
    install: r
  }), r.install(uI));
}
var fI = 1e-8;
function a2(r, e) {
  return Math.abs(r - e) < fI;
}
function o2(r, e, t) {
  var n = 0, i = r[0];
  if (!i)
    return !1;
  for (var a = 1; a < r.length; a++) {
    var o = r[a];
    n += Br(i[0], i[1], o[0], o[1], e, t), i = o;
  }
  var s = r[0];
  return (!a2(i[0], s[0]) || !a2(i[1], s[1])) && (n += Br(i[0], i[1], s[0], s[1], e, t)), n !== 0;
}
var cI = [];
function eh(r, e) {
  for (var t = 0; t < r.length; t++)
    Xe(r[t], r[t], e);
}
function s2(r, e, t, n) {
  for (var i = 0; i < r.length; i++) {
    var a = r[i];
    n && (a = n.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Ln(e, e, a), Nn(t, t, a));
  }
}
function hI(r) {
  for (var e = 0, t = 0, n = 0, i = r.length, a = r[i - 1][0], o = r[i - 1][1], s = 0; s < i; s++) {
    var l = r[s][0], u = r[s][1], f = a * u - l * o;
    e += f, t += (a + l) * f, n += (o + u) * f, a = l, o = u;
  }
  return e ? [t / e / 3, n / e / 3, e] : [r[0][0] || 0, r[0][1] || 0];
}
var $6 = (
  /** @class */
  function() {
    function r(e) {
      this.name = e;
    }
    return r.prototype.setCenter = function(e) {
      this._center = e;
    }, r.prototype.getCenter = function() {
      var e = this._center;
      return e || (e = this._center = this.calcCenter()), e;
    }, r;
  }()
), l2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t) {
      this.type = "polygon", this.exterior = e, this.interiors = t;
    }
    return r;
  }()
), u2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.type = "linestring", this.points = e;
    }
    return r;
  }()
), W6 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i) {
      var a = r.call(this, t) || this;
      return a.type = "geoJSON", a.geometries = n, a._center = i && [i[0], i[1]], a;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this.geometries, n, i = 0, a = 0; a < t.length; a++) {
        var o = t[a], s = o.exterior, l = s && s.length;
        l > i && (n = o, i = l);
      }
      if (n)
        return hI(n.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, e.prototype.getBoundingRect = function(t) {
      var n = this._rect;
      if (n && !t)
        return n;
      var i = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries;
      return dist_M(o, function(s) {
        s.type === "polygon" ? s2(s.exterior, i, a, t) : dist_M(s.points, function(l) {
          s2(l, i, a, t);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), n = new dist_ae(i[0], i[1], a[0] - i[0], a[1] - i[1]), t || (this._rect = n), n;
    }, e.prototype.contain = function(t) {
      var n = this.getBoundingRect(), i = this.geometries;
      if (!n.contain(t[0], t[1]))
        return !1;
      e:
        for (var a = 0, o = i.length; a < o; a++) {
          var s = i[a];
          if (s.type === "polygon") {
            var l = s.exterior, u = s.interiors;
            if (o2(l, t[0], t[1])) {
              for (var f = 0; f < (u ? u.length : 0); f++)
                if (o2(u[f], t[0], t[1]))
                  continue e;
              return !0;
            }
          }
        }
      return !1;
    }, e.prototype.transformTo = function(t, n, i, a) {
      var o = this.getBoundingRect(), s = o.width / o.height;
      i ? a || (a = i / s) : i = s * a;
      for (var l = new dist_ae(t, n, i, a), u = o.calculateTransform(l), f = this.geometries, c = 0; c < f.length; c++) {
        var h = f[c];
        h.type === "polygon" ? (eh(h.exterior, u), dist_M(h.interiors, function(v) {
          eh(v, u);
        })) : dist_M(h.points, function(v) {
          eh(v, u);
        });
      }
      o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2];
    }, e.prototype.cloneShallow = function(t) {
      t == null && (t = this.name);
      var n = new e(t, this.geometries, this._center);
      return n._rect = this._rect, n.transformTo = null, n;
    }, e;
  }($6)
), vI = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n) {
      var i = r.call(this, t) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = n, i;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this._elOnlyForCalculate, n = t.getBoundingRect(), i = [n.x + n.width / 2, n.y + n.height / 2], a = rf(cI), o = t; o && !o.isGeoSVGGraphicRoot; )
        Xr(a, o.getLocalTransform(), a), o = o.parent;
      return Ua(a, a), Xe(i, i, a), i;
    }, e;
  }($6)
);
function dI(r) {
  if (!r.UTF8Encoding)
    return r;
  var e = r, t = e.UTF8Scale;
  t == null && (t = 1024);
  var n = e.features;
  return dist_M(n, function(i) {
    var a = i.geometry, o = a.encodeOffsets, s = a.coordinates;
    if (o)
      switch (a.type) {
        case "LineString":
          a.coordinates = U6(s, o, t);
          break;
        case "Polygon":
          th(s, o, t);
          break;
        case "MultiLineString":
          th(s, o, t);
          break;
        case "MultiPolygon":
          dist_M(s, function(l, u) {
            return th(l, o[u], t);
          });
      }
  }), e.UTF8Encoding = !1, e;
}
function th(r, e, t) {
  for (var n = 0; n < r.length; n++)
    r[n] = U6(r[n], e[n], t);
}
function U6(r, e, t) {
  for (var n = [], i = e[0], a = e[1], o = 0; o < r.length; o += 2) {
    var s = r.charCodeAt(o) - 64, l = r.charCodeAt(o + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += a, i = s, a = l, n.push([s / t, l / t]);
  }
  return n;
}
function pI(r, e) {
  return r = dI(r), dist_$(ke(r.features, function(t) {
    return t.geometry && t.properties && t.geometry.coordinates.length > 0;
  }), function(t) {
    var n = t.properties, i = t.geometry, a = [];
    switch (i.type) {
      case "Polygon":
        var o = i.coordinates;
        a.push(new l2(o[0], o.slice(1)));
        break;
      case "MultiPolygon":
        dist_M(i.coordinates, function(l) {
          l[0] && a.push(new l2(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        a.push(new u2([i.coordinates]));
        break;
      case "MultiLineString":
        a.push(new u2(i.coordinates));
    }
    var s = new W6(n[e || "name"], a, n.cp);
    return s.properties = n, s;
  });
}
var ms = Me();
function gI(r) {
  return r.type === "category" ? yI(r) : SI(r);
}
function mI(r, e) {
  return r.type === "category" ? _I(r, e) : {
    ticks: dist_$(r.scale.getTicks(), function(t) {
      return t.value;
    })
  };
}
function yI(r) {
  var e = r.getLabelModel(), t = Y6(r, e);
  return !e.get("show") || r.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: t.labelCategoryInterval
  } : t;
}
function Y6(r, e) {
  var t = X6(r, "labels"), n = S0(e), i = Z6(t, n);
  if (i)
    return i;
  var a, o;
  return dist_j(n) ? a = j6(r, n) : (o = n === "auto" ? wI(r) : n, a = K6(r, o)), q6(t, n, {
    labels: a,
    labelCategoryInterval: o
  });
}
function _I(r, e) {
  var t = X6(r, "ticks"), n = S0(e), i = Z6(t, n);
  if (i)
    return i;
  var a, o;
  if ((!e.get("show") || r.scale.isBlank()) && (a = []), dist_j(n))
    a = j6(r, n, !0);
  else if (n === "auto") {
    var s = Y6(r, r.getLabelModel());
    o = s.labelCategoryInterval, a = dist_$(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    o = n, a = K6(r, o, !0);
  return q6(t, n, {
    ticks: a,
    tickCategoryInterval: o
  });
}
function SI(r) {
  var e = r.scale.getTicks(), t = Bs(r);
  return {
    labels: dist_$(e, function(n, i) {
      return {
        level: n.level,
        formattedLabel: t(n, i),
        rawLabel: r.scale.getLabel(n),
        tickValue: n.value
      };
    })
  };
}
function X6(r, e) {
  return ms(r)[e] || (ms(r)[e] = []);
}
function Z6(r, e) {
  for (var t = 0; t < r.length; t++)
    if (r[t].key === e)
      return r[t].value;
}
function q6(r, e, t) {
  return r.push({
    key: e,
    value: t
  }), t;
}
function wI(r) {
  var e = ms(r).autoInterval;
  return e ?? (ms(r).autoInterval = r.calculateCategoryInterval());
}
function bI(r) {
  var e = xI(r), t = Bs(r), n = (e.axisRotate - e.labelRotate) / 180 * Math.PI, i = r.scale, a = i.getExtent(), o = i.count();
  if (a[1] - a[0] < 1)
    return 0;
  var s = 1;
  o > 40 && (s = Math.max(1, Math.floor(o / 40)));
  for (var l = a[0], u = r.dataToCoord(l + 1) - r.dataToCoord(l), f = Math.abs(u * Math.cos(n)), c = Math.abs(u * Math.sin(n)), h = 0, v = 0; l <= a[1]; l += s) {
    var d = 0, g = 0, p = Md(t({
      value: l
    }), e.font, "center", "top");
    d = p.width * 1.3, g = p.height * 1.3, h = Math.max(h, d, 7), v = Math.max(v, g, 7);
  }
  var m = h / f, y = v / c;
  isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0);
  var _ = Math.max(0, Math.floor(Math.min(m, y))), S = ms(r.model), b = r.getExtent(), w = S.lastAutoInterval, x = S.lastTickCount;
  return w != null && x != null && Math.abs(w - _) <= 1 && Math.abs(x - o) <= 1 && w > _ && S.axisExtent0 === b[0] && S.axisExtent1 === b[1] ? _ = w : (S.lastTickCount = o, S.lastAutoInterval = _, S.axisExtent0 = b[0], S.axisExtent1 = b[1]), _;
}
function xI(r) {
  var e = r.getLabelModel();
  return {
    axisRotate: r.getRotate ? r.getRotate() : r.isHorizontal && !r.isHorizontal() ? 90 : 0,
    labelRotate: e.get("rotate") || 0,
    font: e.getFont()
  };
}
function K6(r, e, t) {
  var n = Bs(r), i = r.scale, a = i.getExtent(), o = r.getLabelModel(), s = [], l = Math.max((e || 0) + 1, 1), u = a[0], f = i.count();
  u !== 0 && l > 1 && f / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var c = G6(r), h = o.get("showMinLabel") || c, v = o.get("showMaxLabel") || c;
  h && u !== a[0] && g(a[0]);
  for (var d = u; d <= a[1]; d += l)
    g(d);
  v && d - l !== a[1] && g(a[1]);
  function g(p) {
    var m = {
      value: p
    };
    s.push(t ? p : {
      formattedLabel: n(m),
      rawLabel: i.getLabel(m),
      tickValue: p
    });
  }
  return s;
}
function j6(r, e, t) {
  var n = r.scale, i = Bs(r), a = [];
  return dist_M(n.getTicks(), function(o) {
    var s = n.getLabel(o), l = o.value;
    e(o.value, s) && a.push(t ? l : {
      formattedLabel: i(o),
      rawLabel: s,
      tickValue: l
    });
  }), a;
}
var f2 = [0, 1], CI = (
  /** @class */
  function() {
    function r(e, t, n) {
      this.onBand = !1, this.inverse = !1, this.dim = e, this.scale = t, this._extent = n || [0, 0];
    }
    return r.prototype.contain = function(e) {
      var t = this._extent, n = Math.min(t[0], t[1]), i = Math.max(t[0], t[1]);
      return e >= n && e <= i;
    }, r.prototype.containData = function(e) {
      return this.scale.contain(e);
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.getPixelPrecision = function(e) {
      return Y3(e || this.scale.getExtent(), this._extent);
    }, r.prototype.setExtent = function(e, t) {
      var n = this._extent;
      n[0] = e, n[1] = t;
    }, r.prototype.dataToCoord = function(e, t) {
      var n = this._extent, i = this.scale;
      return e = i.normalize(e), this.onBand && i.type === "ordinal" && (n = n.slice(), c2(n, i.count())), De(e, f2, n, t);
    }, r.prototype.coordToData = function(e, t) {
      var n = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (n = n.slice(), c2(n, i.count()));
      var a = De(e, n, f2, t);
      return this.scale.scale(a);
    }, r.prototype.pointToData = function(e, t) {
    }, r.prototype.getTicksCoords = function(e) {
      e = e || {};
      var t = e.tickModel || this.getTickModel(), n = mI(this, t), i = n.ticks, a = dist_$(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), o = t.get("alignWithLabel");
      return TI(this, a, o, e.clamp), a;
    }, r.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var e = this.model.getModel("minorTick"), t = e.get("splitNumber");
      t > 0 && t < 100 || (t = 5);
      var n = this.scale.getMinorTicks(t), i = dist_$(n, function(a) {
        return dist_$(a, function(o) {
          return {
            coord: this.dataToCoord(o),
            tickValue: o
          };
        }, this);
      }, this);
      return i;
    }, r.prototype.getViewLabels = function() {
      return gI(this).labels;
    }, r.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, r.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, r.prototype.getBandWidth = function() {
      var e = this._extent, t = this.scale.getExtent(), n = t[1] - t[0] + (this.onBand ? 1 : 0);
      n === 0 && (n = 1);
      var i = Math.abs(e[1] - e[0]);
      return Math.abs(i) / n;
    }, r.prototype.calculateCategoryInterval = function() {
      return bI(this);
    }, r;
  }()
);
function c2(r, e) {
  var t = r[1] - r[0], n = e, i = t / n / 2;
  r[0] += i, r[1] -= i;
}
function TI(r, e, t, n) {
  var i = e.length;
  if (!r.onBand || t || !i)
    return;
  var a = r.getExtent(), o, s;
  if (i === 1)
    e[0].coord = a[0], o = e[1] = {
      coord: a[1]
    };
  else {
    var l = e[i - 1].tickValue - e[0].tickValue, u = (e[i - 1].coord - e[0].coord) / l;
    dist_M(e, function(v) {
      v.coord -= u / 2;
    });
    var f = r.scale.getExtent();
    s = 1 + f[1] - e[i - 1].tickValue, o = {
      coord: e[i - 1].coord + u * s
    }, e.push(o);
  }
  var c = a[0] > a[1];
  h(e[0].coord, a[0]) && (n ? e[0].coord = a[0] : e.shift()), n && h(a[0], e[0].coord) && e.unshift({
    coord: a[0]
  }), h(a[1], o.coord) && (n ? o.coord = a[1] : e.pop()), n && h(o.coord, a[1]) && e.push({
    coord: a[1]
  });
  function h(v, d) {
    return v = Be(v), d = Be(d), c ? v > d : v < d;
  }
}
const MI = CI;
var _o = Math.PI * 2, di = tn.CMD, DI = ["top", "right", "bottom", "left"];
function EI(r, e, t, n, i) {
  var a = t.width, o = t.height;
  switch (r) {
    case "top":
      n.set(t.x + a / 2, t.y - e), i.set(0, -1);
      break;
    case "bottom":
      n.set(t.x + a / 2, t.y + o + e), i.set(0, 1);
      break;
    case "left":
      n.set(t.x - e, t.y + o / 2), i.set(-1, 0);
      break;
    case "right":
      n.set(t.x + a + e, t.y + o / 2), i.set(1, 0);
      break;
  }
}
function AI(r, e, t, n, i, a, o, s, l) {
  o -= r, s -= e;
  var u = Math.sqrt(o * o + s * s);
  o /= u, s /= u;
  var f = o * t + r, c = s * t + e;
  if (Math.abs(n - i) % _o < 1e-4)
    return l[0] = f, l[1] = c, u - t;
  if (a) {
    var h = n;
    n = Gr(i), i = Gr(h);
  } else
    n = Gr(n), i = Gr(i);
  n > i && (i += _o);
  var v = Math.atan2(s, o);
  if (v < 0 && (v += _o), v >= n && v <= i || v + _o >= n && v + _o <= i)
    return l[0] = f, l[1] = c, u - t;
  var d = t * Math.cos(n) + r, g = t * Math.sin(n) + e, p = t * Math.cos(i) + r, m = t * Math.sin(i) + e, y = (d - o) * (d - o) + (g - s) * (g - s), _ = (p - o) * (p - o) + (m - s) * (m - s);
  return y < _ ? (l[0] = d, l[1] = g, Math.sqrt(y)) : (l[0] = p, l[1] = m, Math.sqrt(_));
}
function ku(r, e, t, n, i, a, o, s) {
  var l = i - r, u = a - e, f = t - r, c = n - e, h = Math.sqrt(f * f + c * c);
  f /= h, c /= h;
  var v = l * f + u * c, d = v / h;
  s && (d = Math.min(Math.max(d, 0), 1)), d *= h;
  var g = o[0] = r + d * f, p = o[1] = e + d * c;
  return Math.sqrt((g - i) * (g - i) + (p - a) * (p - a));
}
function J6(r, e, t, n, i, a, o) {
  t < 0 && (r = r + t, t = -t), n < 0 && (e = e + n, n = -n);
  var s = r + t, l = e + n, u = o[0] = Math.min(Math.max(i, r), s), f = o[1] = Math.min(Math.max(a, e), l);
  return Math.sqrt((u - i) * (u - i) + (f - a) * (f - a));
}
var ar = [];
function II(r, e, t) {
  var n = J6(e.x, e.y, e.width, e.height, r.x, r.y, ar);
  return t.set(ar[0], ar[1]), n;
}
function LI(r, e, t) {
  for (var n = 0, i = 0, a = 0, o = 0, s, l, u = 1 / 0, f = e.data, c = r.x, h = r.y, v = 0; v < f.length; ) {
    var d = f[v++];
    v === 1 && (n = f[v], i = f[v + 1], a = n, o = i);
    var g = u;
    switch (d) {
      case di.M:
        a = f[v++], o = f[v++], n = a, i = o;
        break;
      case di.L:
        g = ku(n, i, f[v], f[v + 1], c, h, ar, !0), n = f[v++], i = f[v++];
        break;
      case di.C:
        g = P3(n, i, f[v++], f[v++], f[v++], f[v++], f[v], f[v + 1], c, h, ar), n = f[v++], i = f[v++];
        break;
      case di.Q:
        g = O3(n, i, f[v++], f[v++], f[v], f[v + 1], c, h, ar), n = f[v++], i = f[v++];
        break;
      case di.A:
        var p = f[v++], m = f[v++], y = f[v++], _ = f[v++], S = f[v++], b = f[v++];
        v += 1;
        var w = !!(1 - f[v++]);
        s = Math.cos(S) * y + p, l = Math.sin(S) * _ + m, v <= 1 && (a = s, o = l);
        var x = (c - p) * _ / y + p;
        g = AI(p, m, _, S, S + b, w, x, h, ar), n = Math.cos(S + b) * y + p, i = Math.sin(S + b) * _ + m;
        break;
      case di.R:
        a = n = f[v++], o = i = f[v++];
        var C = f[v++], T = f[v++];
        g = J6(a, o, C, T, c, h, ar);
        break;
      case di.Z:
        g = ku(n, i, a, o, c, h, ar, !0), n = a, i = o;
        break;
    }
    g < u && (u = g, t.set(ar[0], ar[1]));
  }
  return u;
}
var sr = new dist_K(), be = new dist_K(), Ie = new dist_K(), Mr = new dist_K(), xr = new dist_K();
function h2(r, e) {
  if (r) {
    var t = r.getTextGuideLine(), n = r.getTextContent();
    if (n && t) {
      var i = r.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = i.candidates || DI, s = n.getBoundingRect().clone();
      s.applyTransform(n.getComputedTransform());
      var l = 1 / 0, u = i.anchor, f = r.getComputedTransform(), c = f && Ua([], f), h = e.get("length2") || 0;
      u && Ie.copy(u);
      for (var v = 0; v < o.length; v++) {
        var d = o[v];
        EI(d, 0, s, sr, Mr), dist_K.scaleAndAdd(be, sr, Mr, h), be.transform(c);
        var g = r.getBoundingRect(), p = u ? u.distance(be) : r instanceof fe ? LI(be, r.path, Ie) : II(be, g, Ie);
        p < l && (l = p, be.transform(f), Ie.transform(f), Ie.toArray(a[0]), be.toArray(a[1]), sr.toArray(a[2]));
      }
      Q6(a, e.get("minTurnAngle")), t.setShape({
        points: a
      });
    }
  }
}
var Vu = [], ut = new dist_K();
function Q6(r, e) {
  if (e <= 180 && e > 0) {
    e = e / 180 * Math.PI, sr.fromArray(r[0]), be.fromArray(r[1]), Ie.fromArray(r[2]), dist_K.sub(Mr, sr, be), dist_K.sub(xr, Ie, be);
    var t = Mr.len(), n = xr.len();
    if (!(t < 1e-3 || n < 1e-3)) {
      Mr.scale(1 / t), xr.scale(1 / n);
      var i = Mr.dot(xr), a = Math.cos(e);
      if (a < i) {
        var o = ku(be.x, be.y, Ie.x, Ie.y, sr.x, sr.y, Vu, !1);
        ut.fromArray(Vu), ut.scaleAndAdd(xr, o / Math.tan(Math.PI - e));
        var s = Ie.x !== be.x ? (ut.x - be.x) / (Ie.x - be.x) : (ut.y - be.y) / (Ie.y - be.y);
        if (isNaN(s))
          return;
        s < 0 ? dist_K.copy(ut, be) : s > 1 && dist_K.copy(ut, Ie), ut.toArray(r[1]);
      }
    }
  }
}
function NI(r, e, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, sr.fromArray(r[0]), be.fromArray(r[1]), Ie.fromArray(r[2]), dist_K.sub(Mr, be, sr), dist_K.sub(xr, Ie, be);
    var n = Mr.len(), i = xr.len();
    if (!(n < 1e-3 || i < 1e-3)) {
      Mr.scale(1 / n), xr.scale(1 / i);
      var a = Mr.dot(e), o = Math.cos(t);
      if (a < o) {
        var s = ku(be.x, be.y, Ie.x, Ie.y, sr.x, sr.y, Vu, !1);
        ut.fromArray(Vu);
        var l = Math.PI / 2, u = Math.acos(xr.dot(e)), f = l + u - t;
        if (f >= l)
          dist_K.copy(ut, Ie);
        else {
          ut.scaleAndAdd(xr, s / Math.tan(Math.PI / 2 - f));
          var c = Ie.x !== be.x ? (ut.x - be.x) / (Ie.x - be.x) : (ut.y - be.y) / (Ie.y - be.y);
          if (isNaN(c))
            return;
          c < 0 ? dist_K.copy(ut, be) : c > 1 && dist_K.copy(ut, Ie);
        }
        ut.toArray(r[1]);
      }
    }
  }
}
function rh(r, e, t, n) {
  var i = t === "normal", a = i ? r : r.ensureState(t);
  a.ignore = e;
  var o = n.get("smooth");
  o && o === !0 && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
  var s = n.getModel("lineStyle").getLineStyle();
  i ? r.useStyle(s) : a.style = s;
}
function PI(r, e) {
  var t = e.smooth, n = e.points;
  if (n)
    if (r.moveTo(n[0][0], n[0][1]), t > 0 && n.length >= 3) {
      var i = In(n[0], n[1]), a = In(n[1], n[2]);
      if (!i || !a) {
        r.lineTo(n[1][0], n[1][1]), r.lineTo(n[2][0], n[2][1]);
        return;
      }
      var o = Math.min(i, a) * t, s = Gl([], n[1], n[0], o / i), l = Gl([], n[1], n[2], o / a), u = Gl([], s, l, 0.5);
      r.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), r.bezierCurveTo(l[0], l[1], l[0], l[1], n[2][0], n[2][1]);
    } else
      for (var f = 1; f < n.length; f++)
        r.lineTo(n[f][0], n[f][1]);
}
function e5(r, e, t) {
  var n = r.getTextGuideLine(), i = r.getTextContent();
  if (!i) {
    n && r.removeTextGuideLine();
    return;
  }
  for (var a = e.normal, o = a.get("show"), s = i.ignore, l = 0; l < gu.length; l++) {
    var u = gu[l], f = e[u], c = u === "normal";
    if (f) {
      var h = f.get("show"), v = c ? s : dist_ne(i.states[u] && i.states[u].ignore, s);
      if (v || !dist_ne(h, o)) {
        var d = c ? n : n && n.states[u];
        d && (d.ignore = !0), n && rh(n, !0, u, f);
        continue;
      }
      n || (n = new cn(), r.setTextGuideLine(n), !c && (s || !o) && rh(n, !0, "normal", e.normal), r.stateProxy && (n.stateProxy = r.stateProxy)), rh(n, !1, u, f);
    }
  }
  if (n) {
    dist_se(n.style, t), n.style.fill = null;
    var g = a.get("showAbove"), p = r.textGuideLineConfig = r.textGuideLineConfig || {};
    p.showAbove = g || !1, n.buildPath = PI;
  }
}
function t5(r, e) {
  e = e || "labelLine";
  for (var t = {
    normal: r.getModel(e)
  }, n = 0; n < Ct.length; n++) {
    var i = Ct[n];
    t[i] = r.getModel([i, e]);
  }
  return t;
}
function r5(r) {
  for (var e = [], t = 0; t < r.length; t++) {
    var n = r[t];
    if (!n.defaultAttr.ignore) {
      var i = n.label, a = i.getComputedTransform(), o = i.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = i.style.margin || 0, u = o.clone();
      u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
      var f = s ? new _u(o, a) : null;
      e.push({
        label: i,
        labelLine: n.labelLine,
        rect: u,
        localRect: o,
        obb: f,
        priority: n.priority,
        defaultAttr: n.defaultAttr,
        layoutOption: n.computedLayoutOption,
        axisAligned: s,
        transform: a
      });
    }
  }
  return e;
}
function n5(r, e, t, n, i, a) {
  var o = r.length;
  if (o < 2)
    return;
  r.sort(function(C, T) {
    return C.rect[e] - T.rect[e];
  });
  for (var s = 0, l, u = !1, f = 0, c = 0; c < o; c++) {
    var h = r[c], v = h.rect;
    l = v[e] - s, l < 0 && (v[e] -= l, h.label[e] -= l, u = !0);
    var d = Math.max(-l, 0);
    f += d, s = v[e] + v[t];
  }
  f > 0 && a && b(-f / o, 0, o);
  var g = r[0], p = r[o - 1], m, y;
  _(), m < 0 && w(-m, 0.8), y < 0 && w(y, 0.8), _(), S(m, y, 1), S(y, m, -1), _(), m < 0 && x(-m), y < 0 && x(y);
  function _() {
    m = g.rect[e] - n, y = i - p.rect[e] - p.rect[t];
  }
  function S(C, T, E) {
    if (C < 0) {
      var D = Math.min(T, -C);
      if (D > 0) {
        b(D * E, 0, o);
        var I = D + C;
        I < 0 && w(-I * E, 1);
      } else
        w(-C * E, 1);
    }
  }
  function b(C, T, E) {
    C !== 0 && (u = !0);
    for (var D = T; D < E; D++) {
      var I = r[D], L = I.rect;
      L[e] += C, I.label[e] += C;
    }
  }
  function w(C, T) {
    for (var E = [], D = 0, I = 1; I < o; I++) {
      var L = r[I - 1].rect, N = Math.max(r[I].rect[e] - L[e] - L[t], 0);
      E.push(N), D += N;
    }
    if (D) {
      var P = Math.min(Math.abs(C) / D, T);
      if (C > 0)
        for (var I = 0; I < o - 1; I++) {
          var R = E[I] * P;
          b(R, 0, I + 1);
        }
      else
        for (var I = o - 1; I > 0; I--) {
          var R = E[I - 1] * P;
          b(-R, I, o);
        }
    }
  }
  function x(C) {
    var T = C < 0 ? -1 : 1;
    C = Math.abs(C);
    for (var E = Math.ceil(C / (o - 1)), D = 0; D < o - 1; D++)
      if (T > 0 ? b(E, 0, D + 1) : b(-E, o - D - 1, o), C -= E, C <= 0)
        return;
  }
  return u;
}
function RI(r, e, t, n) {
  return n5(r, "x", "width", e, t, n);
}
function i5(r, e, t, n) {
  return n5(r, "y", "height", e, t, n);
}
function a5(r) {
  var e = [];
  r.sort(function(g, p) {
    return p.priority - g.priority;
  });
  var t = new dist_ae(0, 0, 0, 0);
  function n(g) {
    if (!g.ignore) {
      var p = g.ensureState("emphasis");
      p.ignore == null && (p.ignore = !1);
    }
    g.ignore = !0;
  }
  for (var i = 0; i < r.length; i++) {
    var a = r[i], o = a.axisAligned, s = a.localRect, l = a.transform, u = a.label, f = a.labelLine;
    t.copy(a.rect), t.width -= 0.1, t.height -= 0.1, t.x += 0.05, t.y += 0.05;
    for (var c = a.obb, h = !1, v = 0; v < e.length; v++) {
      var d = e[v];
      if (t.intersect(d.rect)) {
        if (o && d.axisAligned) {
          h = !0;
          break;
        }
        if (d.obb || (d.obb = new _u(d.localRect, d.transform)), c || (c = new _u(s, l)), c.intersect(d.obb)) {
          h = !0;
          break;
        }
      }
    }
    h ? (n(u), f && n(f)) : (u.attr("ignore", a.defaultAttr.ignore), f && f.attr("ignore", a.defaultAttr.labelGuideIgnore), e.push(a));
  }
}
function OI(r) {
  if (r) {
    for (var e = [], t = 0; t < r.length; t++)
      e.push(r[t].slice());
    return e;
  }
}
function kI(r, e) {
  var t = r.label, n = e && e.getTextGuideLine();
  return {
    dataIndex: r.dataIndex,
    dataType: r.dataType,
    seriesIndex: r.seriesModel.seriesIndex,
    text: r.label.style.text,
    rect: r.hostRect,
    labelRect: r.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: t.style.align,
    verticalAlign: t.style.verticalAlign,
    labelLinePoints: OI(n && n.shape.points)
  };
}
var v2 = ["align", "verticalAlign", "width", "height", "fontSize"], dist_at = new Fr(), nh = Me(), VI = Me();
function Cl(r, e, t) {
  for (var n = 0; n < t.length; n++) {
    var i = t[n];
    e[i] != null && (r[i] = e[i]);
  }
}
var Tl = ["x", "y", "rotation"], BI = (
  /** @class */
  function() {
    function r() {
      this._labelList = [], this._chartViewList = [];
    }
    return r.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, r.prototype._addLabel = function(e, t, n, i, a) {
      var o = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), f = i.getBoundingRect().plain();
      dist_ae.applyTransform(f, f, u), u ? dist_at.setLocalTransform(u) : (dist_at.x = dist_at.y = dist_at.rotation = dist_at.originX = dist_at.originY = 0, dist_at.scaleX = dist_at.scaleY = 1), dist_at.rotation = Gr(dist_at.rotation);
      var c = i.__hostTarget, h;
      if (c) {
        h = c.getBoundingRect().plain();
        var v = c.getComputedTransform();
        dist_ae.applyTransform(h, h, v);
      }
      var d = h && c.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: d,
        seriesModel: n,
        dataIndex: e,
        dataType: t,
        layoutOption: a,
        computedLayoutOption: null,
        rect: f,
        hostRect: h,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: h ? h.width * h.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: d && d.ignore,
          x: dist_at.x,
          y: dist_at.y,
          scaleX: dist_at.scaleX,
          scaleY: dist_at.scaleY,
          rotation: dist_at.rotation,
          style: {
            x: o.x,
            y: o.y,
            align: o.align,
            verticalAlign: o.verticalAlign,
            width: o.width,
            height: o.height,
            fontSize: o.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, r.prototype.addLabelsOfSeries = function(e) {
      var t = this;
      this._chartViewList.push(e);
      var n = e.__model, i = n.get("labelLayout");
      (dist_j(i) || we(i).length) && e.group.traverse(function(a) {
        if (a.ignore)
          return !0;
        var o = a.getTextContent(), s = dist_ie(a);
        o && !o.disableLabelLayout && t._addLabel(s.dataIndex, s.dataType, n, o, i);
      });
    }, r.prototype.updateLayoutConfig = function(e) {
      var t = e.getWidth(), n = e.getHeight();
      function i(_, S) {
        return function() {
          h2(_, S);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, f = void 0;
        dist_j(o.layoutOption) ? f = o.layoutOption(kI(o, l)) : f = o.layoutOption, f = f || {}, o.computedLayoutOption = f;
        var c = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: f.x != null || f.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: f.rotate != null ? f.rotate * c : u.attachedRot,
          offset: [f.dx || 0, f.dy || 0]
        });
        var h = !1;
        if (f.x != null ? (s.x = me(f.x, t), s.setStyle("x", 0), h = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), f.y != null ? (s.y = me(f.y, n), s.setStyle("y", 0), h = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), f.labelLinePoints) {
          var v = l.getTextGuideLine();
          v && (v.setShape({
            points: f.labelLinePoints
          }), h = !1);
        }
        var d = nh(s);
        d.needsUpdateLabelLine = h, s.rotation = f.rotate != null ? f.rotate * c : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var g = 0; g < v2.length; g++) {
          var p = v2[g];
          s.setStyle(p, f[p] != null ? f[p] : u.style[p]);
        }
        if (f.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var m = o.seriesModel;
            if (o.dataIndex != null) {
              var y = o.seriesModel.getData(o.dataType);
              m = y.getItemModel(o.dataIndex);
            }
            s.on("drag", i(l, m.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, r.prototype.layout = function(e) {
      var t = e.getWidth(), n = e.getHeight(), i = r5(this._labelList), a = ke(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), o = ke(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      RI(a, 0, t), i5(o, 0, n);
      var s = ke(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      a5(s);
    }, r.prototype.processLabelsOverall = function() {
      var e = this;
      dist_M(this._chartViewList, function(t) {
        var n = t.__model, i = t.ignoreLabelLineUpdate, a = n.isAnimationEnabled();
        t.group.traverse(function(o) {
          if (o.ignore && !o.forceLabelAnimation)
            return !0;
          var s = !i, l = o.getTextContent();
          !s && l && (s = nh(l).needsUpdateLabelLine), s && e._updateLabelLine(o, n), a && e._animateLabels(o, n);
        });
      });
    }, r.prototype._updateLabelLine = function(e, t) {
      var n = e.getTextContent(), i = dist_ie(e), a = i.dataIndex;
      if (n && a != null) {
        var o = t.getData(i.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
        if (u) {
          var f = o.getVisual("drawType");
          l.stroke = u[f];
        }
        var c = s.getModel("labelLine");
        e5(e, t5(s), l), h2(e, c);
      }
    }, r.prototype._animateLabels = function(e, t) {
      var n = e.getTextContent(), i = e.getTextGuideLine();
      if (n && (e.forceLabelAnimation || !n.ignore && !n.invisible && !e.disableLabelAnimation && !Ta(e))) {
        var a = nh(n), o = a.oldLayout, s = dist_ie(e), l = s.dataIndex, u = {
          x: n.x,
          y: n.y,
          rotation: n.rotation
        }, f = t.getData(s.dataType);
        if (o) {
          n.attr(o);
          var h = e.prevStates;
          h && (ye(h, "select") >= 0 && n.attr(a.oldLayoutSelect), ye(h, "emphasis") >= 0 && n.attr(a.oldLayoutEmphasis)), Pe(n, u, t, l);
        } else if (n.attr(u), !Ya(n).valueAnimation) {
          var c = dist_ne(n.style.opacity, 1);
          n.style.opacity = 0, Ze(n, {
            style: {
              opacity: c
            }
          }, t, l);
        }
        if (a.oldLayout = u, n.states.select) {
          var v = a.oldLayoutSelect = {};
          Cl(v, u, Tl), Cl(v, n.states.select, Tl);
        }
        if (n.states.emphasis) {
          var d = a.oldLayoutEmphasis = {};
          Cl(d, u, Tl), Cl(d, n.states.emphasis, Tl);
        }
        U8(n, l, f, t, t);
      }
      if (i && !i.ignore && !i.invisible) {
        var a = VI(i), o = a.oldLayout, g = {
          points: i.shape.points
        };
        o ? (i.attr({
          shape: o
        }), Pe(i, {
          shape: g
        }, t)) : (i.setShape(g), i.style.strokePercent = 0, Ze(i, {
          style: {
            strokePercent: 1
          }
        }, t)), a.oldLayout = g;
      }
    }, r;
  }()
), ih = Me();
function FI(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(e, t, n) {
    var i = ih(t).labelManager;
    i || (i = ih(t).labelManager = new BI()), i.clearLabels();
  }), r.registerUpdateLifecycle("series:layoutlabels", function(e, t, n) {
    var i = ih(t).labelManager;
    n.updatedSeries.forEach(function(a) {
      i.addLabelsOfSeries(t.getViewOfSeriesModel(a));
    }), i.updateLayoutConfig(t), i.layout(t), i.processLabelsOverall();
  });
}
var zI = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      if (false) { var n; }
      return ks(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getLegendIcon = function(t) {
      var n = new dist_oe(), i = dt("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1);
      n.add(i), i.setStyle(t.lineStyle);
      var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = t.itemHeight * 0.8, u = dt(s, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill);
      n.add(u), u.setStyle(t.itemStyle);
      var f = t.iconRotate === "inherit" ? o : t.iconRotate || 0;
      return u.rotation = f * Math.PI / 180, u.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), n;
    }, e.type = "series.line", e.dependencies = ["grid", "polar"], e.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, e;
  }(jt)
);
const GI = zI;
function w0(r, e) {
  var t = r.mapDimensionsAll("defaultedLabel"), n = t.length;
  if (n === 1) {
    var i = Va(r, e, t[0]);
    return i != null ? i + "" : null;
  } else if (n) {
    for (var a = [], o = 0; o < t.length; o++)
      a.push(Va(r, e, t[o]));
    return a.join(" ");
  }
}
function o5(r, e) {
  var t = r.mapDimensionsAll("defaultedLabel");
  if (!dist_F(e))
    return e + "";
  for (var n = [], i = 0; i < t.length; i++) {
    var a = r.getDimensionIndex(t[i]);
    a >= 0 && n.push(e[a]);
  }
  return n.join(" ");
}
var Nf = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i, a) {
      var o = r.call(this) || this;
      return o.updateData(t, n, i, a), o;
    }
    return e.prototype._createSymbol = function(t, n, i, a, o) {
      this.removeAll();
      var s = dt(t, -1, -1, 2, 2, null, o);
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), s.drift = HI, this._symbolType = t, this.add(s);
    }, e.prototype.stopSymbolAnimation = function(t) {
      this.childAt(0).stopAnimation(null, t);
    }, e.prototype.getSymbolType = function() {
      return this._symbolType;
    }, e.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, e.prototype.highlight = function() {
      Pa(this.childAt(0));
    }, e.prototype.downplay = function() {
      Ra(this.childAt(0));
    }, e.prototype.setZ = function(t, n) {
      var i = this.childAt(0);
      i.zlevel = t, i.z = n;
    }, e.prototype.setDraggable = function(t, n) {
      var i = this.childAt(0);
      i.draggable = t, i.cursor = !n && t ? "move" : i.cursor;
    }, e.prototype.updateData = function(t, n, i, a) {
      this.silent = !1;
      var o = t.getItemVisual(n, "symbol") || "circle", s = t.hostModel, l = e.getSymbolSize(t, n), u = o !== this._symbolType, f = a && a.disableAnimation;
      if (u) {
        var c = t.getItemVisual(n, "symbolKeepAspect");
        this._createSymbol(o, t, n, l, c);
      } else {
        var h = this.childAt(0);
        h.silent = !1;
        var v = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        f ? h.attr(v) : Pe(h, v, s, n), Wd(h);
      }
      if (this._updateCommon(t, n, l, i, a), u) {
        var h = this.childAt(0);
        if (!f) {
          var v = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: h.style.opacity
            }
          };
          h.scaleX = h.scaleY = 0, h.style.opacity = 0, Ze(h, v, s, n);
        }
      }
      f && this.childAt(0).stopAnimation("leave");
    }, e.prototype._updateCommon = function(t, n, i, a, o) {
      var s = this.childAt(0), l = t.hostModel, u, f, c, h, v, d, g, p, m;
      if (a && (u = a.emphasisItemStyle, f = a.blurItemStyle, c = a.selectItemStyle, h = a.focus, v = a.blurScope, g = a.labelStatesModels, p = a.hoverScale, m = a.cursorStyle, d = a.emphasisDisabled), !a || t.hasItemOption) {
        var y = a && a.itemModel ? a.itemModel : t.getItemModel(n), _ = y.getModel("emphasis");
        u = _.getModel("itemStyle").getItemStyle(), c = y.getModel(["select", "itemStyle"]).getItemStyle(), f = y.getModel(["blur", "itemStyle"]).getItemStyle(), h = _.get("focus"), v = _.get("blurScope"), d = _.get("disabled"), g = hn(y), p = _.getShallow("scale"), m = y.getShallow("cursor");
      }
      var S = t.getItemVisual(n, "symbolRotate");
      s.attr("rotation", (S || 0) * Math.PI / 180 || 0);
      var b = Os(t.getItemVisual(n, "symbolOffset"), i);
      b && (s.x = b[0], s.y = b[1]), m && s.attr("cursor", m);
      var w = t.getItemVisual(n, "style"), x = w.fill;
      if (s instanceof un) {
        var C = s.style;
        s.useStyle(dist_V({
          // TODO other properties like x, y ?
          image: C.image,
          x: C.x,
          y: C.y,
          width: C.width,
          height: C.height
        }, w));
      } else
        s.__isEmptyBrush ? s.useStyle(dist_V({}, w)) : s.useStyle(w), s.style.decal = null, s.setColor(x, o && o.symbolInnerColor), s.style.strokeNoScale = !0;
      var T = t.getItemVisual(n, "liftZ"), E = this._z2;
      T != null ? E == null && (this._z2 = s.z2, s.z2 += T) : E != null && (s.z2 = E, this._z2 = null);
      var D = o && o.useNameLabel;
      Yn(s, g, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: I,
        inheritColor: x,
        defaultOpacity: w.opacity
      });
      function I(P) {
        return D ? t.getName(P) : w0(t, P);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var L = s.ensureState("emphasis");
      L.style = u, s.ensureState("select").style = c, s.ensureState("blur").style = f;
      var N = p == null || p === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(p) && p > 0 ? +p : 1;
      L.scaleX = this._sizeX * N, L.scaleY = this._sizeY * N, this.setSymbolScale(1), rn(this, h, v, d);
    }, e.prototype.setSymbolScale = function(t) {
      this.scaleX = this.scaleY = t;
    }, e.prototype.fadeOut = function(t, n, i) {
      var a = this.childAt(0), o = dist_ie(this).dataIndex, s = i && i.animation;
      if (this.silent = a.silent = !0, i && i.fadeLabel) {
        var l = a.getTextContent();
        l && Su(l, {
          style: {
            opacity: 0
          }
        }, n, {
          dataIndex: o,
          removeOpt: s,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else
        a.removeTextContent();
      Su(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, n, {
        dataIndex: o,
        cb: t,
        removeOpt: s
      });
    }, e.getSymbolSize = function(t, n) {
      return Df(t.getItemVisual(n, "symbolSize"));
    }, e;
  }(dist_oe)
);
function HI(r, e) {
  this.parent.drift(r, e);
}
function ah(r, e, t, n) {
  return e && !isNaN(e[0]) && !isNaN(e[1]) && !(n.isIgnore && n.isIgnore(t)) && !(n.clipShape && !n.clipShape.contain(e[0], e[1])) && r.getItemVisual(t, "symbol") !== "none";
}
function d2(r) {
  return r != null && !dist_X(r) && (r = {
    isIgnore: r
  }), r || {};
}
function p2(r) {
  var e = r.hostModel, t = e.getModel("emphasis");
  return {
    emphasisItemStyle: t.getModel("itemStyle").getItemStyle(),
    blurItemStyle: e.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: e.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: t.get("focus"),
    blurScope: t.get("blurScope"),
    emphasisDisabled: t.get("disabled"),
    hoverScale: t.get("scale"),
    labelStatesModels: hn(e),
    cursorStyle: e.get("cursor")
  };
}
var b0 = (
  /** @class */
  function() {
    function r(e) {
      this.group = new dist_oe(), this._SymbolCtor = e || Nf;
    }
    return r.prototype.updateData = function(e, t) {
      this._progressiveEls = null, t = d2(t);
      var n = this.group, i = e.hostModel, a = this._data, o = this._SymbolCtor, s = t.disableAnimation, l = p2(e), u = {
        disableAnimation: s
      }, f = t.getSymbolPoint || function(c) {
        return e.getItemLayout(c);
      };
      a || n.removeAll(), e.diff(a).add(function(c) {
        var h = f(c);
        if (ah(e, h, c, t)) {
          var v = new o(e, c, l, u);
          v.setPosition(h), e.setItemGraphicEl(c, v), n.add(v);
        }
      }).update(function(c, h) {
        var v = a.getItemGraphicEl(h), d = f(c);
        if (!ah(e, d, c, t)) {
          n.remove(v);
          return;
        }
        var g = e.getItemVisual(c, "symbol") || "circle", p = v && v.getSymbolType && v.getSymbolType();
        if (!v || p && p !== g)
          n.remove(v), v = new o(e, c, l, u), v.setPosition(d);
        else {
          v.updateData(e, c, l, u);
          var m = {
            x: d[0],
            y: d[1]
          };
          s ? v.attr(m) : Pe(v, m, i);
        }
        n.add(v), e.setItemGraphicEl(c, v);
      }).remove(function(c) {
        var h = a.getItemGraphicEl(c);
        h && h.fadeOut(function() {
          n.remove(h);
        }, i);
      }).execute(), this._getSymbolPoint = f, this._data = e;
    }, r.prototype.updateLayout = function() {
      var e = this, t = this._data;
      t && t.eachItemGraphicEl(function(n, i) {
        var a = e._getSymbolPoint(i);
        n.setPosition(a), n.markRedraw();
      });
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = p2(e), this._data = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(e, t, n) {
      this._progressiveEls = [], n = d2(n);
      function i(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var a = e.start; a < e.end; a++) {
        var o = t.getItemLayout(a);
        if (ah(t, o, a, n)) {
          var s = new this._SymbolCtor(t, a, this._seriesScope);
          s.traverse(i), s.setPosition(o), this.group.add(s), t.setItemGraphicEl(a, s), this._progressiveEls.push(s);
        }
      }
    }, r.prototype.eachRendered = function(e) {
      Is(this._progressiveEls || this.group, e);
    }, r.prototype.remove = function(e) {
      var t = this.group, n = this._data;
      n && e ? n.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          t.remove(i);
        }, n.hostModel);
      }) : t.removeAll();
    }, r;
  }()
);
function s5(r, e, t) {
  var n = r.getBaseAxis(), i = r.getOtherAxis(n), a = $I(i, t), o = n.dim, s = i.dim, l = e.mapDimension(s), u = e.mapDimension(o), f = s === "x" || s === "radius" ? 1 : 0, c = dist_$(r.dimensions, function(d) {
    return e.mapDimension(d);
  }), h = !1, v = e.getCalculationInfo("stackResultDimension");
  return Fa(
    e,
    c[0]
    /* , dims[1] */
  ) && (h = !0, c[0] = v), Fa(
    e,
    c[1]
    /* , dims[0] */
  ) && (h = !0, c[1] = v), {
    dataDimsForPoint: c,
    valueStart: a,
    valueAxisDim: s,
    baseAxisDim: o,
    stacked: !!h,
    valueDim: l,
    baseDim: u,
    baseDataOffset: f,
    stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
  };
}
function $I(r, e) {
  var t = 0, n = r.scale.getExtent();
  return e === "start" ? t = n[0] : e === "end" ? t = n[1] : ve(e) && !isNaN(e) ? t = e : n[0] > 0 ? t = n[0] : n[1] < 0 && (t = n[1]), t;
}
function l5(r, e, t, n) {
  var i = NaN;
  r.stacked && (i = t.get(t.getCalculationInfo("stackedOverDimension"), n)), isNaN(i) && (i = r.valueStart);
  var a = r.baseDataOffset, o = [];
  return o[a] = t.get(r.baseDim, n), o[1 - a] = i, e.dataToPoint(o);
}
function WI(r, e) {
  var t = [];
  return e.diff(r).add(function(n) {
    t.push({
      cmd: "+",
      idx: n
    });
  }).update(function(n, i) {
    t.push({
      cmd: "=",
      idx: i,
      idx1: n
    });
  }).remove(function(n) {
    t.push({
      cmd: "-",
      idx: n
    });
  }).execute(), t;
}
function UI(r, e, t, n, i, a, o, s) {
  for (var l = WI(r, e), u = [], f = [], c = [], h = [], v = [], d = [], g = [], p = s5(i, e, o), m = r.getLayout("points") || [], y = e.getLayout("points") || [], _ = 0; _ < l.length; _++) {
    var S = l[_], b = !0, w = void 0, x = void 0;
    switch (S.cmd) {
      case "=":
        w = S.idx * 2, x = S.idx1 * 2;
        var C = m[w], T = m[w + 1], E = y[x], D = y[x + 1];
        (isNaN(C) || isNaN(T)) && (C = E, T = D), u.push(C, T), f.push(E, D), c.push(t[w], t[w + 1]), h.push(n[x], n[x + 1]), g.push(e.getRawIndex(S.idx1));
        break;
      case "+":
        var I = S.idx, L = p.dataDimsForPoint, N = i.dataToPoint([e.get(L[0], I), e.get(L[1], I)]);
        x = I * 2, u.push(N[0], N[1]), f.push(y[x], y[x + 1]);
        var P = l5(p, i, e, I);
        c.push(P[0], P[1]), h.push(n[x], n[x + 1]), g.push(e.getRawIndex(I));
        break;
      case "-":
        b = !1;
    }
    b && (v.push(S), d.push(d.length));
  }
  d.sort(function(Re, Ce) {
    return g[Re] - g[Ce];
  });
  for (var R = u.length, z = Hr(R), O = Hr(R), B = Hr(R), H = Hr(R), q = [], _ = 0; _ < d.length; _++) {
    var Q = d[_], le = _ * 2, ge = Q * 2;
    z[le] = u[ge], z[le + 1] = u[ge + 1], O[le] = f[ge], O[le + 1] = f[ge + 1], B[le] = c[ge], B[le + 1] = c[ge + 1], H[le] = h[ge], H[le + 1] = h[ge + 1], q[_] = v[Q];
  }
  return {
    current: z,
    next: O,
    stackedOnCurrent: B,
    stackedOnNext: H,
    status: q
  };
}
var wn = Math.min, bn = Math.max;
function Pi(r, e) {
  return isNaN(r) || isNaN(e);
}
function Hv(r, e, t, n, i, a, o, s, l) {
  for (var u, f, c, h, v, d, g = t, p = 0; p < n; p++) {
    var m = e[g * 2], y = e[g * 2 + 1];
    if (g >= i || g < 0)
      break;
    if (Pi(m, y)) {
      if (l) {
        g += a;
        continue;
      }
      break;
    }
    if (g === t)
      r[a > 0 ? "moveTo" : "lineTo"](m, y), c = m, h = y;
    else {
      var _ = m - u, S = y - f;
      if (_ * _ + S * S < 0.5) {
        g += a;
        continue;
      }
      if (o > 0) {
        for (var b = g + a, w = e[b * 2], x = e[b * 2 + 1]; w === m && x === y && p < n; )
          p++, b += a, g += a, w = e[b * 2], x = e[b * 2 + 1], m = e[g * 2], y = e[g * 2 + 1], _ = m - u, S = y - f;
        var C = p + 1;
        if (l)
          for (; Pi(w, x) && C < n; )
            C++, b += a, w = e[b * 2], x = e[b * 2 + 1];
        var T = 0.5, E = 0, D = 0, I = void 0, L = void 0;
        if (C >= n || Pi(w, x))
          v = m, d = y;
        else {
          E = w - u, D = x - f;
          var N = m - u, P = w - m, R = y - f, z = x - y, O = void 0, B = void 0;
          if (s === "x") {
            O = Math.abs(N), B = Math.abs(P);
            var H = E > 0 ? 1 : -1;
            v = m - H * O * o, d = y, I = m + H * B * o, L = y;
          } else if (s === "y") {
            O = Math.abs(R), B = Math.abs(z);
            var q = D > 0 ? 1 : -1;
            v = m, d = y - q * O * o, I = m, L = y + q * B * o;
          } else
            O = Math.sqrt(N * N + R * R), B = Math.sqrt(P * P + z * z), T = B / (B + O), v = m - E * o * (1 - T), d = y - D * o * (1 - T), I = m + E * o * T, L = y + D * o * T, I = wn(I, bn(w, m)), L = wn(L, bn(x, y)), I = bn(I, wn(w, m)), L = bn(L, wn(x, y)), E = I - m, D = L - y, v = m - E * O / B, d = y - D * O / B, v = wn(v, bn(u, m)), d = wn(d, bn(f, y)), v = bn(v, wn(u, m)), d = bn(d, wn(f, y)), E = m - v, D = y - d, I = m + E * B / O, L = y + D * B / O;
        }
        r.bezierCurveTo(c, h, v, d, m, y), c = I, h = L;
      } else
        r.lineTo(m, y);
    }
    u = m, f = y, g += a;
  }
  return p;
}
var u5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return r;
  }()
), YI = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "ec-polyline", n;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new u5();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.points, a = 0, o = i.length / 2;
      if (n.connectNulls) {
        for (; o > 0 && Pi(i[o * 2 - 2], i[o * 2 - 1]); o--)
          ;
        for (; a < o && Pi(i[a * 2], i[a * 2 + 1]); a++)
          ;
      }
      for (; a < o; )
        a += Hv(t, i, a, o, o, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1;
    }, e.prototype.getPointOn = function(t, n) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, a = i.data, o = tn.CMD, s, l, u = n === "x", f = [], c = 0; c < a.length; ) {
        var h = a[c++], v = void 0, d = void 0, g = void 0, p = void 0, m = void 0, y = void 0, _ = void 0;
        switch (h) {
          case o.M:
            s = a[c++], l = a[c++];
            break;
          case o.L:
            if (v = a[c++], d = a[c++], _ = u ? (t - s) / (v - s) : (t - l) / (d - l), _ <= 1 && _ >= 0) {
              var S = u ? (d - l) * _ + l : (v - s) * _ + s;
              return u ? [t, S] : [S, t];
            }
            s = v, l = d;
            break;
          case o.C:
            v = a[c++], d = a[c++], g = a[c++], p = a[c++], m = a[c++], y = a[c++];
            var b = u ? fu(s, v, g, m, t, f) : fu(l, d, p, y, t, f);
            if (b > 0)
              for (var w = 0; w < b; w++) {
                var x = f[w];
                if (x <= 1 && x >= 0) {
                  var S = u ? ze(l, d, p, y, x) : ze(s, v, g, m, x);
                  return u ? [t, S] : [S, t];
                }
              }
            s = m, l = y;
            break;
        }
      }
    }, e;
  }(fe)
), XI = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  }(u5)
), ZI = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "ec-polygon", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new XI();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.points, a = n.stackedOnPoints, o = 0, s = i.length / 2, l = n.smoothMonotone;
      if (n.connectNulls) {
        for (; s > 0 && Pi(i[s * 2 - 2], i[s * 2 - 1]); s--)
          ;
        for (; o < s && Pi(i[o * 2], i[o * 2 + 1]); o++)
          ;
      }
      for (; o < s; ) {
        var u = Hv(t, i, o, s, s, 1, n.smooth, l, n.connectNulls);
        Hv(t, a, o + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls), o += u + 1, t.closePath();
      }
    }, e;
  }(fe)
);
function f5(r, e, t, n, i) {
  var a = r.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, f = t.get(["lineStyle", "width"]) || 2;
  o -= f / 2, s -= f / 2, l += f, u += f, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++);
  var c = new xe({
    shape: {
      x: o,
      y: s,
      width: l,
      height: u
    }
  });
  if (e) {
    var h = r.getBaseAxis(), v = h.isHorizontal(), d = h.inverse;
    v ? (d && (c.shape.x += l), c.shape.width = 0) : (d || (c.shape.y += u), c.shape.height = 0);
    var g = dist_j(i) ? function(p) {
      i(p, c);
    } : null;
    Ze(c, {
      shape: {
        width: l,
        height: u,
        x: o,
        y: s
      }
    }, t, null, n, g);
  }
  return c;
}
function c5(r, e, t) {
  var n = r.getArea(), i = Be(n.r0, 1), a = Be(n.r, 1), o = new nn({
    shape: {
      cx: Be(r.cx, 1),
      cy: Be(r.cy, 1),
      r0: i,
      r: a,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    }
  });
  if (e) {
    var s = r.getBaseAxis().dim === "angle";
    s ? o.shape.endAngle = n.startAngle : o.shape.r = i, Ze(o, {
      shape: {
        endAngle: n.endAngle,
        r: a
      }
    }, t);
  }
  return o;
}
function h5(r, e, t, n, i) {
  if (r) {
    if (r.type === "polar")
      return c5(r, e, t);
    if (r.type === "cartesian2d")
      return f5(r, e, t, n, i);
  } else
    return null;
  return null;
}
function x0(r, e) {
  return r.type === e;
}
function g2(r, e) {
  if (r.length === e.length) {
    for (var t = 0; t < r.length; t++)
      if (r[t] !== e[t])
        return;
    return !0;
  }
}
function m2(r) {
  for (var e = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0; a < r.length; ) {
    var o = r[a++], s = r[a++];
    isNaN(o) || (e = Math.min(o, e), n = Math.max(o, n)), isNaN(s) || (t = Math.min(s, t), i = Math.max(s, i));
  }
  return [[e, t], [n, i]];
}
function y2(r, e) {
  var t = m2(r), n = t[0], i = t[1], a = m2(e), o = a[0], s = a[1];
  return Math.max(Math.abs(n[0] - o[0]), Math.abs(n[1] - o[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
}
function _2(r) {
  return ve(r) ? r : r ? 0.5 : 0;
}
function qI(r, e, t) {
  if (!t.valueDim)
    return [];
  for (var n = e.count(), i = Hr(n * 2), a = 0; a < n; a++) {
    var o = l5(t, r, e, a);
    i[a * 2] = o[0], i[a * 2 + 1] = o[1];
  }
  return i;
}
function xn(r, e, t, n) {
  var i = e.getBaseAxis(), a = i.dim === "x" || i.dim === "radius" ? 0 : 1, o = [], s = 0, l = [], u = [], f = [], c = [];
  if (n) {
    for (s = 0; s < r.length; s += 2)
      !isNaN(r[s]) && !isNaN(r[s + 1]) && c.push(r[s], r[s + 1]);
    r = c;
  }
  for (s = 0; s < r.length - 2; s += 2)
    switch (f[0] = r[s + 2], f[1] = r[s + 3], u[0] = r[s], u[1] = r[s + 1], o.push(u[0], u[1]), t) {
      case "end":
        l[a] = f[a], l[1 - a] = u[1 - a], o.push(l[0], l[1]);
        break;
      case "middle":
        var h = (u[a] + f[a]) / 2, v = [];
        l[a] = v[a] = h, l[1 - a] = u[1 - a], v[1 - a] = f[1 - a], o.push(l[0], l[1]), o.push(v[0], v[1]);
        break;
      default:
        l[a] = u[a], l[1 - a] = f[1 - a], o.push(l[0], l[1]);
    }
  return o.push(r[s++], r[s++]), o;
}
function KI(r, e) {
  var t = [], n = r.length, i, a;
  function o(f, c, h) {
    var v = f.coord, d = (h - v) / (c.coord - v), g = k7(d, [f.color, c.color]);
    return {
      coord: h,
      color: g
    };
  }
  for (var s = 0; s < n; s++) {
    var l = r[s], u = l.coord;
    if (u < 0)
      i = l;
    else if (u > e) {
      a ? t.push(o(a, l, e)) : i && t.push(o(i, l, 0), o(i, l, e));
      break;
    } else
      i && (t.push(o(i, l, 0)), i = null), t.push(l), a = l;
  }
  return t;
}
function jI(r, e, t) {
  var n = r.getVisual("visualMeta");
  if (!(!n || !n.length || !r.count())) {
    if (e.type !== "cartesian2d") {
      "production";
      return;
    }
    for (var i, a, o = n.length - 1; o >= 0; o--) {
      var s = r.getDimensionInfo(n[o].dimension);
      if (i = s && s.coordDim, i === "x" || i === "y") {
        a = n[o];
        break;
      }
    }
    if (!a) {
      "production";
      return;
    }
    var l = e.getAxis(i), u = dist_$(a.stops, function(_) {
      return {
        coord: l.toGlobalCoord(l.dataToCoord(_.value)),
        color: _.color
      };
    }), f = u.length, c = a.outerColors.slice();
    f && u[0].coord > u[f - 1].coord && (u.reverse(), c.reverse());
    var h = KI(u, i === "x" ? t.getWidth() : t.getHeight()), v = h.length;
    if (!v && f)
      return u[0].coord < 0 ? c[1] ? c[1] : u[f - 1].color : c[0] ? c[0] : u[0].color;
    var d = 10, g = h[0].coord - d, p = h[v - 1].coord + d, m = p - g;
    if (m < 1e-3)
      return "transparent";
    dist_M(h, function(_) {
      _.offset = (_.coord - g) / m;
    }), h.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: v ? h[v - 1].offset : 0.5,
      color: c[1] || "transparent"
    }), h.unshift({
      offset: v ? h[0].offset : 0.5,
      color: c[0] || "transparent"
    });
    var y = new vf(0, 0, 0, 0, h, !0);
    return y[i] = g, y[i + "2"] = p, y;
  }
}
function JI(r, e, t) {
  var n = r.get("showAllSymbol"), i = n === "auto";
  if (!(n && !i)) {
    var a = t.getAxesByScale("ordinal")[0];
    if (a && !(i && QI(a, e))) {
      var o = e.mapDimension(a.dim), s = {};
      return dist_M(a.getViewLabels(), function(l) {
        var u = a.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(e.get(o, l));
      };
    }
  }
}
function QI(r, e) {
  var t = r.getExtent(), n = Math.abs(t[1] - t[0]) / r.scale.count();
  isNaN(n) && (n = 0);
  for (var i = e.count(), a = Math.max(1, Math.round(i / 5)), o = 0; o < i; o += a)
    if (Nf.getSymbolSize(
      e,
      o
      // Only for cartesian, where `isHorizontal` exists.
    )[r.isHorizontal() ? 1 : 0] * 1.5 > n)
      return !1;
  return !0;
}
function eL(r, e) {
  return isNaN(r) || isNaN(e);
}
function tL(r) {
  for (var e = r.length / 2; e > 0 && eL(r[e * 2 - 2], r[e * 2 - 1]); e--)
    ;
  return e - 1;
}
function S2(r, e) {
  return [r[e * 2], r[e * 2 + 1]];
}
function rL(r, e, t) {
  for (var n = r.length / 2, i = t === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < n; u++)
    if (o = r[u * 2 + i], !(isNaN(o) || isNaN(r[u * 2 + 1 - i]))) {
      if (u === 0) {
        a = o;
        continue;
      }
      if (a <= e && o >= e || a >= e && o <= e) {
        l = u;
        break;
      }
      s = u, a = o;
    }
  return {
    range: [s, l],
    t: (e - a) / (o - a)
  };
}
function v5(r) {
  if (r.get(["endLabel", "show"]))
    return !0;
  for (var e = 0; e < Ct.length; e++)
    if (r.get([Ct[e], "endLabel", "show"]))
      return !0;
  return !1;
}
function oh(r, e, t, n) {
  if (x0(e, "cartesian2d")) {
    var i = n.getModel("endLabel"), a = i.get("valueAnimation"), o = n.getData(), s = {
      lastFrameIndex: 0
    }, l = v5(n) ? function(v, d) {
      r._endLabelOnDuring(v, d, o, s, a, i, e);
    } : null, u = e.getBaseAxis().isHorizontal(), f = f5(e, t, n, function() {
      var v = r._endLabel;
      v && t && s.originalX != null && v.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!n.get("clip", !0)) {
      var c = f.shape, h = Math.max(c.width, c.height);
      u ? (c.y -= h, c.height += h * 2) : (c.x -= h, c.width += h * 2);
    }
    return l && l(1, f), f;
  } else
    return  false && 0, c5(e, t, n);
}
function nL(r, e) {
  var t = e.getBaseAxis(), n = t.isHorizontal(), i = t.inverse, a = n ? i ? "right" : "left" : "center", o = n ? "middle" : i ? "top" : "bottom";
  return {
    normal: {
      align: r.get("align") || a,
      verticalAlign: r.get("verticalAlign") || o
    }
  };
}
var iL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      var t = new dist_oe(), n = new b0();
      this.group.add(n.group), this._symbolDraw = n, this._lineGroup = t;
    }, e.prototype.render = function(t, n, i) {
      var a = this, o = t.coordinateSystem, s = this.group, l = t.getData(), u = t.getModel("lineStyle"), f = t.getModel("areaStyle"), c = l.getLayout("points") || [], h = o.type === "polar", v = this._coordSys, d = this._symbolDraw, g = this._polyline, p = this._polygon, m = this._lineGroup, y = !n.ssr && t.get("animation"), _ = !f.isEmpty(), S = f.get("origin"), b = s5(o, l, S), w = _ && qI(o, l, b), x = t.get("showSymbol"), C = t.get("connectNulls"), T = x && !h && JI(t, l, o), E = this._data;
      E && E.eachItemGraphicEl(function(Ce, je) {
        Ce.__temp && (s.remove(Ce), E.setItemGraphicEl(je, null));
      }), x || d.remove(), s.add(m);
      var D = h ? !1 : t.get("step"), I;
      o && o.getArea && t.get("clip", !0) && (I = o.getArea(), I.width != null ? (I.x -= 0.1, I.y -= 0.1, I.width += 0.2, I.height += 0.2) : I.r0 && (I.r0 -= 0.5, I.r += 0.5)), this._clipShapeForSymbol = I;
      var L = jI(l, o, i) || l.getVisual("style")[l.getVisual("drawType")];
      if (!(g && v.type === o.type && D === this._step))
        x && d.updateData(l, {
          isIgnore: T,
          clipShape: I,
          disableAnimation: !0,
          getSymbolPoint: function(Ce) {
            return [c[Ce * 2], c[Ce * 2 + 1]];
          }
        }), y && this._initSymbolLabelAnimation(l, o, I), D && (c = xn(c, o, D, C), w && (w = xn(w, o, D, C))), g = this._newPolyline(c), _ ? p = this._newPolygon(c, w) : p && (m.remove(p), p = this._polygon = null), h || this._initOrUpdateEndLabel(t, o, Bi(L)), m.setClipPath(oh(this, o, !0, t));
      else {
        _ && !p ? p = this._newPolygon(c, w) : p && !_ && (m.remove(p), p = this._polygon = null), h || this._initOrUpdateEndLabel(t, o, Bi(L));
        var N = m.getClipPath();
        if (N) {
          var P = oh(this, o, !1, t);
          Ze(N, {
            shape: P.shape
          }, t);
        } else
          m.setClipPath(oh(this, o, !0, t));
        x && d.updateData(l, {
          isIgnore: T,
          clipShape: I,
          disableAnimation: !0,
          getSymbolPoint: function(Ce) {
            return [c[Ce * 2], c[Ce * 2 + 1]];
          }
        }), (!g2(this._stackedOnPoints, w) || !g2(this._points, c)) && (y ? this._doUpdateAnimation(l, w, o, i, D, S, C) : (D && (c = xn(c, o, D, C), w && (w = xn(w, o, D, C))), g.setShape({
          points: c
        }), p && p.setShape({
          points: c,
          stackedOnPoints: w
        })));
      }
      var R = t.getModel("emphasis"), z = R.get("focus"), O = R.get("blurScope"), B = R.get("disabled");
      if (g.useStyle(dist_se(
        // Use color in lineStyle first
        u.getLineStyle(),
        {
          fill: "none",
          stroke: L,
          lineJoin: "bevel"
        }
      )), yu(g, t, "lineStyle"), g.style.lineWidth > 0 && t.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var H = g.getState("emphasis").style;
        H.lineWidth = +g.style.lineWidth + 1;
      }
      dist_ie(g).seriesIndex = t.seriesIndex, rn(g, z, O, B);
      var q = _2(t.get("smooth")), Q = t.get("smoothMonotone");
      if (g.setShape({
        smooth: q,
        smoothMonotone: Q,
        connectNulls: C
      }), p) {
        var le = l.getCalculationInfo("stackedOnSeries"), ge = 0;
        p.useStyle(dist_se(f.getAreaStyle(), {
          fill: L,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: l.getVisual("style").decal
        })), le && (ge = _2(le.get("smooth"))), p.setShape({
          smooth: q,
          stackedOnSmooth: ge,
          smoothMonotone: Q,
          connectNulls: C
        }), yu(p, t, "areaStyle"), dist_ie(p).seriesIndex = t.seriesIndex, rn(p, z, O, B);
      }
      var Re = function(Ce) {
        a._changePolyState(Ce);
      };
      l.eachItemGraphicEl(function(Ce) {
        Ce && (Ce.onHoverStateChange = Re);
      }), this._polyline.onHoverStateChange = Re, this._data = l, this._coordSys = o, this._stackedOnPoints = w, this._points = c, this._step = D, this._valueOrigin = S, t.get("triggerLineEvent") && (this.packEventData(t, g), p && this.packEventData(t, p));
    }, e.prototype.packEventData = function(t, n) {
      dist_ie(n).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: t.componentIndex,
        seriesIndex: t.seriesIndex,
        seriesName: t.name,
        seriesType: "line"
      };
    }, e.prototype.highlight = function(t, n, i, a) {
      var o = t.getData(), s = Vi(o, a);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
        if (!u) {
          var f = l[s * 2], c = l[s * 2 + 1];
          if (isNaN(f) || isNaN(c) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(f, c))
            return;
          var h = t.get("zlevel") || 0, v = t.get("z") || 0;
          u = new Nf(o, s), u.x = f, u.y = c, u.setZ(h, v);
          var d = u.getSymbolPath().getTextContent();
          d && (d.zlevel = h, d.z = v, d.z2 = this._polyline.z2 + 1), u.__temp = !0, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        bt.prototype.highlight.call(this, t, n, i, a);
    }, e.prototype.downplay = function(t, n, i, a) {
      var o = t.getData(), s = Vi(o, a);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = o.getItemGraphicEl(s);
        l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        bt.prototype.downplay.call(this, t, n, i, a);
    }, e.prototype._changePolyState = function(t) {
      var n = this._polygon;
      _v(this._polyline, t), n && _v(n, t);
    }, e.prototype._newPolyline = function(t) {
      var n = this._polyline;
      return n && this._lineGroup.remove(n), n = new YI({
        shape: {
          points: t
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(n), this._polyline = n, n;
    }, e.prototype._newPolygon = function(t, n) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new ZI({
        shape: {
          points: t,
          stackedOnPoints: n
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, e.prototype._initSymbolLabelAnimation = function(t, n, i) {
      var a, o, s = n.getBaseAxis(), l = s.inverse;
      n.type === "cartesian2d" ? (a = s.isHorizontal(), o = !1) : n.type === "polar" && (a = s.dim === "angle", o = !0);
      var u = t.hostModel, f = u.get("animationDuration");
      dist_j(f) && (f = f(null));
      var c = u.get("animationDelay") || 0, h = dist_j(c) ? c(null) : c;
      t.eachItemGraphicEl(function(v, d) {
        var g = v;
        if (g) {
          var p = [v.x, v.y], m = void 0, y = void 0, _ = void 0;
          if (i)
            if (o) {
              var S = i, b = n.pointToCoord(p);
              a ? (m = S.startAngle, y = S.endAngle, _ = -b[1] / 180 * Math.PI) : (m = S.r0, y = S.r, _ = b[0]);
            } else {
              var w = i;
              a ? (m = w.x, y = w.x + w.width, _ = v.x) : (m = w.y + w.height, y = w.y, _ = v.y);
            }
          var x = y === m ? 0 : (_ - m) / (y - m);
          l && (x = 1 - x);
          var C = dist_j(c) ? c(d) : f * x + h, T = g.getSymbolPath(), E = T.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: C
          }), E && E.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: C
          }), T.disableLabelAnimation = !0;
        }
      });
    }, e.prototype._initOrUpdateEndLabel = function(t, n, i) {
      var a = t.getModel("endLabel");
      if (v5(t)) {
        var o = t.getData(), s = this._polyline, l = o.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new Ne({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var f = tL(l);
        f >= 0 && (Yn(s, hn(t, "endLabel"), {
          inheritColor: i,
          labelFetcher: t,
          labelDataIndex: f,
          defaultText: function(c, h, v) {
            return v != null ? o5(o, v) : w0(o, c);
          },
          enableTextSetter: !0
        }, nL(a, n)), s.textConfig.position = null);
      } else
        this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, e.prototype._endLabelOnDuring = function(t, n, i, a, o, s, l) {
      var u = this._endLabel, f = this._polyline;
      if (u) {
        t < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var c = i.getLayout("points"), h = i.hostModel, v = h.get("connectNulls"), d = s.get("precision"), g = s.get("distance") || 0, p = l.getBaseAxis(), m = p.isHorizontal(), y = p.inverse, _ = n.shape, S = y ? m ? _.x : _.y + _.height : m ? _.x + _.width : _.y, b = (m ? g : 0) * (y ? -1 : 1), w = (m ? 0 : -g) * (y ? -1 : 1), x = m ? "x" : "y", C = rL(c, S, x), T = C.range, E = T[1] - T[0], D = void 0;
        if (E >= 1) {
          if (E > 1 && !v) {
            var I = S2(c, T[0]);
            u.attr({
              x: I[0] + b,
              y: I[1] + w
            }), o && (D = h.getRawValue(T[0]));
          } else {
            var I = f.getPointOn(S, x);
            I && u.attr({
              x: I[0] + b,
              y: I[1] + w
            });
            var L = h.getRawValue(T[0]), N = h.getRawValue(T[1]);
            o && (D = t_(i, d, L, N, C.t));
          }
          a.lastFrameIndex = T[0];
        } else {
          var P = t === 1 || a.lastFrameIndex > 0 ? T[0] : 0, I = S2(c, P);
          o && (D = h.getRawValue(P)), u.attr({
            x: I[0] + b,
            y: I[1] + w
          });
        }
        if (o) {
          var R = Ya(u);
          typeof R.setLabelText == "function" && R.setLabelText(D);
        }
      }
    }, e.prototype._doUpdateAnimation = function(t, n, i, a, o, s, l) {
      var u = this._polyline, f = this._polygon, c = t.hostModel, h = UI(this._data, t, this._stackedOnPoints, n, this._coordSys, i, this._valueOrigin), v = h.current, d = h.stackedOnCurrent, g = h.next, p = h.stackedOnNext;
      if (o && (v = xn(h.current, i, o, l), d = xn(h.stackedOnCurrent, i, o, l), g = xn(h.next, i, o, l), p = xn(h.stackedOnNext, i, o, l)), y2(v, g) > 3e3 || f && y2(d, p) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), f && (f.stopAnimation(), f.setShape({
          points: g,
          stackedOnPoints: p
        }));
        return;
      }
      u.shape.__points = h.current, u.shape.points = v;
      var m = {
        shape: {
          points: g
        }
      };
      h.current !== v && (m.shape.__points = h.next), u.stopAnimation(), Pe(u, m, c), f && (f.setShape({
        // Reuse the points with polyline.
        points: v,
        stackedOnPoints: d
      }), f.stopAnimation(), Pe(f, {
        shape: {
          stackedOnPoints: p
        }
      }, c), u.shape.points !== f.shape.points && (f.shape.points = u.shape.points));
      for (var y = [], _ = h.status, S = 0; S < _.length; S++) {
        var b = _[S].cmd;
        if (b === "=") {
          var w = t.getItemGraphicEl(_[S].idx1);
          w && y.push({
            el: w,
            ptIdx: S
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        f && f.dirtyShape();
        for (var x = u.shape.__points, C = 0; C < y.length; C++) {
          var T = y[C].el, E = y[C].ptIdx * 2;
          T.x = x[E], T.y = x[E + 1], T.markRedraw();
        }
      });
    }, e.prototype.remove = function(t) {
      var n = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(a, o) {
        a.__temp && (n.remove(a), i.setItemGraphicEl(o, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, e.type = "line", e;
  }(bt)
);
const aL = iL;
function C0(r, e) {
  return {
    seriesType: r,
    plan: Tf(),
    reset: function(t) {
      var n = t.getData(), i = t.coordinateSystem, a = t.pipelineContext, o = e || a.large;
      if (i) {
        var s = dist_$(i.dimensions, function(v) {
          return n.mapDimension(v);
        }).slice(0, 2), l = s.length, u = n.getCalculationInfo("stackResultDimension");
        Fa(n, s[0]) && (s[0] = u), Fa(n, s[1]) && (s[1] = u);
        var f = n.getStore(), c = n.getDimensionIndex(s[0]), h = n.getDimensionIndex(s[1]);
        return l && {
          progress: function(v, d) {
            for (var g = v.end - v.start, p = o && Hr(g * l), m = [], y = [], _ = v.start, S = 0; _ < v.end; _++) {
              var b = void 0;
              if (l === 1) {
                var w = f.get(c, _);
                b = i.dataToPoint(w, null, y);
              } else
                m[0] = f.get(c, _), m[1] = f.get(h, _), b = i.dataToPoint(m, null, y);
              o ? (p[S++] = b[0], p[S++] = b[1]) : d.setItemLayout(_, b.slice());
            }
            o && d.setLayout("points", p);
          }
        };
      }
    }
  };
}
var oL = {
  average: function(r) {
    for (var e = 0, t = 0, n = 0; n < r.length; n++)
      isNaN(r[n]) || (e += r[n], t++);
    return t === 0 ? NaN : e / t;
  },
  sum: function(r) {
    for (var e = 0, t = 0; t < r.length; t++)
      e += r[t] || 0;
    return e;
  },
  max: function(r) {
    for (var e = -1 / 0, t = 0; t < r.length; t++)
      r[t] > e && (e = r[t]);
    return isFinite(e) ? e : NaN;
  },
  min: function(r) {
    for (var e = 1 / 0, t = 0; t < r.length; t++)
      r[t] < e && (e = r[t]);
    return isFinite(e) ? e : NaN;
  },
  minmax: function(r) {
    for (var e = -1 / 0, t = -1 / 0, n = 0; n < r.length; n++) {
      var i = r[n], a = Math.abs(i);
      a > e && (e = a, t = i);
    }
    return isFinite(t) ? t : NaN;
  },
  // TODO
  // Median
  nearest: function(r) {
    return r[0];
  }
}, sL = function(r) {
  return Math.round(r.length / 2);
};
function d5(r) {
  return {
    seriesType: r,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(e, t, n) {
      var i = e.getData(), a = e.get("sampling"), o = e.coordinateSystem, s = i.count();
      if (s > 10 && o.type === "cartesian2d" && a) {
        var l = o.getBaseAxis(), u = o.getOtherAxis(l), f = l.getExtent(), c = n.getDevicePixelRatio(), h = Math.abs(f[1] - f[0]) * (c || 1), v = Math.round(s / h);
        if (isFinite(v) && v > 1) {
          a === "lttb" && e.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / v));
          var d = void 0;
          dist_U(a) ? d = oL[a] : dist_j(a) && (d = a), d && e.setData(i.downSample(i.mapDimension(u.dim), 1 / v, d, sL));
        }
      }
    }
  };
}
function lL(r) {
  r.registerChartView(aL), r.registerSeriesModel(GI), r.registerLayout(C0("line", !0)), r.registerVisual({
    seriesType: "line",
    reset: function(e) {
      var t = e.getData(), n = e.getModel("lineStyle").getLineStyle();
      n && !n.stroke && (n.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", n);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, d5("line"));
}
var $v = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      return ks(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getMarkerPosition = function(t, n, i) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var o = a.clampData(t), s = a.dataToPoint(o);
        if (i)
          dist_M(a.getAxes(), function(h, v) {
            if (h.type === "category" && n != null) {
              var d = h.getTicksCoords(), g = h.getTickModel().get("alignWithLabel"), p = o[v], m = n[v] === "x1" || n[v] === "y1";
              if (m && !g && (p += 1), d.length < 2)
                return;
              if (d.length === 2) {
                s[v] = h.toGlobalCoord(h.getExtent()[m ? 1 : 0]);
                return;
              }
              for (var y = void 0, _ = void 0, S = 1, b = 0; b < d.length; b++) {
                var w = d[b].coord, x = b === d.length - 1 ? d[b - 1].tickValue + S : d[b].tickValue;
                if (x === p) {
                  _ = w;
                  break;
                } else if (x < p)
                  y = w;
                else if (y != null && x > p) {
                  _ = (w + y) / 2;
                  break;
                }
                b === 1 && (S = x - d[0].tickValue);
              }
              _ == null && (y ? y && (_ = d[d.length - 1].coord) : _ = d[0].coord), s[v] = h.toGlobalCoord(_);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), f = l.getLayout("size"), c = a.getBaseAxis().isHorizontal() ? 0 : 1;
          s[c] += u + f / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, e.type = "series.__base_bar__", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, e;
  }(jt)
);
jt.registerClass($v);
var uL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function() {
      return ks(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, e.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.get("progressiveThreshold"), n = this.get("largeThreshold");
      return n > t && (t = n), t;
    }, e.prototype.brushSelector = function(t, n, i) {
      return i.rect(n.getItemLayout(t));
    }, e.type = "series.bar", e.dependencies = ["grid", "polar"], e.defaultOption = Xa($v.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), e;
  }($v)
);
const fL = uL;
var cL = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return r;
  }()
), w2 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "sausage", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new cL();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.cx, a = n.cy, o = Math.max(n.r0 || 0, 0), s = Math.max(n.r, 0), l = (s - o) * 0.5, u = o + l, f = n.startAngle, c = n.endAngle, h = n.clockwise, v = Math.PI * 2, d = h ? c - f < v : f - c < v;
      d || (f = c - (h ? v : -v));
      var g = Math.cos(f), p = Math.sin(f), m = Math.cos(c), y = Math.sin(c);
      d ? (t.moveTo(g * o + i, p * o + a), t.arc(g * u + i, p * u + a, l, -Math.PI + f, f, !h)) : t.moveTo(g * s + i, p * s + a), t.arc(i, a, s, f, c, !h), t.arc(m * u + i, y * u + a, l, c - Math.PI * 2, c - Math.PI, !h), o !== 0 && t.arc(i, a, o, c, f, h);
    }, e;
  }(fe)
);
function hL(r, e) {
  e = e || {};
  var t = e.isRoundCap;
  return function(n, i, a) {
    var o = i.position;
    if (!o || o instanceof Array)
      return vu(n, i, a);
    var s = r(o), l = i.distance != null ? i.distance : 5, u = this.shape, f = u.cx, c = u.cy, h = u.r, v = u.r0, d = (h + v) / 2, g = u.startAngle, p = u.endAngle, m = (g + p) / 2, y = t ? Math.abs(h - v) / 2 : 0, _ = Math.cos, S = Math.sin, b = f + h * _(g), w = c + h * S(g), x = "left", C = "top";
    switch (s) {
      case "startArc":
        b = f + (v - l) * _(m), w = c + (v - l) * S(m), x = "center", C = "top";
        break;
      case "insideStartArc":
        b = f + (v + l) * _(m), w = c + (v + l) * S(m), x = "center", C = "bottom";
        break;
      case "startAngle":
        b = f + d * _(g) + Ml(g, l + y, !1), w = c + d * S(g) + Dl(g, l + y, !1), x = "right", C = "middle";
        break;
      case "insideStartAngle":
        b = f + d * _(g) + Ml(g, -l + y, !1), w = c + d * S(g) + Dl(g, -l + y, !1), x = "left", C = "middle";
        break;
      case "middle":
        b = f + d * _(m), w = c + d * S(m), x = "center", C = "middle";
        break;
      case "endArc":
        b = f + (h + l) * _(m), w = c + (h + l) * S(m), x = "center", C = "bottom";
        break;
      case "insideEndArc":
        b = f + (h - l) * _(m), w = c + (h - l) * S(m), x = "center", C = "top";
        break;
      case "endAngle":
        b = f + d * _(p) + Ml(p, l + y, !0), w = c + d * S(p) + Dl(p, l + y, !0), x = "left", C = "middle";
        break;
      case "insideEndAngle":
        b = f + d * _(p) + Ml(p, -l + y, !0), w = c + d * S(p) + Dl(p, -l + y, !0), x = "right", C = "middle";
        break;
      default:
        return vu(n, i, a);
    }
    return n = n || {}, n.x = b, n.y = w, n.align = x, n.verticalAlign = C, n;
  };
}
function vL(r, e, t, n) {
  if (ve(n)) {
    r.setTextConfig({
      rotation: n
    });
    return;
  } else if (dist_F(e)) {
    r.setTextConfig({
      rotation: 0
    });
    return;
  }
  var i = r.shape, a = i.clockwise ? i.startAngle : i.endAngle, o = i.clockwise ? i.endAngle : i.startAngle, s = (a + o) / 2, l, u = t(e);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = a;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = o;
      break;
    default:
      r.setTextConfig({
        rotation: 0
      });
      return;
  }
  var f = Math.PI * 1.5 - l;
  u === "middle" && f > Math.PI / 2 && f < Math.PI * 1.5 && (f -= Math.PI), r.setTextConfig({
    rotation: f
  });
}
function Ml(r, e, t) {
  return e * Math.sin(r) * (t ? -1 : 1);
}
function Dl(r, e, t) {
  return e * Math.cos(r) * (t ? 1 : -1);
}
function Ro(r, e, t) {
  var n = r.get("borderRadius");
  if (n == null)
    return t ? {
      cornerRadius: 0
    } : null;
  dist_F(n) || (n = [n, n, n, n]);
  var i = Math.abs(e.r || 0 - e.r0 || 0);
  return {
    cornerRadius: dist_$(n, function(a) {
      return Lr(a, i);
    })
  };
}
var sh = Math.max, lh = Math.min;
function dL(r, e) {
  var t = r.getArea && r.getArea();
  if (x0(r, "cartesian2d")) {
    var n = r.getBaseAxis();
    if (n.type !== "category" || !n.onBand) {
      var i = e.getLayout("bandWidth");
      n.isHorizontal() ? (t.x -= i, t.width += i * 2) : (t.y -= i, t.height += i * 2);
    }
  }
  return t;
}
var pL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.type = e.type, t._isFirstFrame = !0, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this._model = t, this._removeOnRenderedListener(i), this._updateDrawMode(t);
      var o = t.get("coordinateSystem");
      o === "cartesian2d" || o === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, n, i) : this._renderNormal(t, n, i, a)) :  false && 0;
    }, e.prototype.incrementalPrepareRender = function(t) {
      this._clear(), this._updateDrawMode(t), this._updateLargeClip(t);
    }, e.prototype.incrementalRender = function(t, n) {
      this._progressiveEls = [], this._incrementalRenderLarge(t, n);
    }, e.prototype.eachRendered = function(t) {
      Is(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var n = t.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, e.prototype._renderNormal = function(t, n, i, a) {
      var o = this.group, s = t.getData(), l = this._data, u = t.coordinateSystem, f = u.getBaseAxis(), c;
      u.type === "cartesian2d" ? c = f.isHorizontal() : u.type === "polar" && (c = f.dim === "angle");
      var h = t.isAnimationEnabled() ? t : null, v = gL(t, u);
      v && this._enableRealtimeSort(v, s, i);
      var d = t.get("clip", !0) || v, g = dL(u, s);
      o.removeClipPath();
      var p = t.get("roundCap", !0), m = t.get("showBackground", !0), y = t.getModel("backgroundStyle"), _ = y.get("borderRadius") || 0, S = [], b = this._backgroundEls, w = a && a.isInitSort, x = a && a.type === "changeAxisOrder";
      function C(D) {
        var I = El[u.type](s, D), L = xL(u, c, I);
        return L.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? L.setShape("r", _) : L.setShape("cornerRadius", _), S[D] = L, L;
      }
      s.diff(l).add(function(D) {
        var I = s.getItemModel(D), L = El[u.type](s, D, I);
        if (m && C(D), !(!s.hasValue(D) || !M2[u.type](L))) {
          var N = !1;
          d && (N = b2[u.type](g, L));
          var P = x2[u.type](t, s, D, L, c, h, f.model, !1, p);
          v && (P.forceLabelAnimation = !0), D2(P, s, D, I, L, t, c, u.type === "polar"), w ? P.attr({
            shape: L
          }) : v ? C2(v, h, P, L, D, c, !1, !1) : Ze(P, {
            shape: L
          }, t, D), s.setItemGraphicEl(D, P), o.add(P), P.ignore = N;
        }
      }).update(function(D, I) {
        var L = s.getItemModel(D), N = El[u.type](s, D, L);
        if (m) {
          var P = void 0;
          b.length === 0 ? P = C(I) : (P = b[I], P.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? P.setShape("r", _) : P.setShape("cornerRadius", _), S[D] = P);
          var R = El[u.type](s, D), z = g5(c, R, u);
          Pe(P, {
            shape: z
          }, h, D);
        }
        var O = l.getItemGraphicEl(I);
        if (!s.hasValue(D) || !M2[u.type](N)) {
          o.remove(O);
          return;
        }
        var B = !1;
        if (d && (B = b2[u.type](g, N), B && o.remove(O)), O ? Wd(O) : O = x2[u.type](t, s, D, N, c, h, f.model, !!O, p), v && (O.forceLabelAnimation = !0), x) {
          var H = O.getTextContent();
          if (H) {
            var q = Ya(H);
            q.prevValue != null && (q.prevValue = q.value);
          }
        } else
          D2(O, s, D, L, N, t, c, u.type === "polar");
        w ? O.attr({
          shape: N
        }) : v ? C2(v, h, O, N, D, c, !0, x) : Pe(O, {
          shape: N
        }, t, D, null), s.setItemGraphicEl(D, O), O.ignore = B, o.add(O);
      }).remove(function(D) {
        var I = l.getItemGraphicEl(D);
        I && wu(I, t, D);
      }).execute();
      var T = this._backgroundGroup || (this._backgroundGroup = new dist_oe());
      T.removeAll();
      for (var E = 0; E < S.length; ++E)
        T.add(S[E]);
      o.add(T), this._backgroundEls = S, this._data = s;
    }, e.prototype._renderLarge = function(t, n, i) {
      this._clear(), A2(t, this.group), this._updateLargeClip(t);
    }, e.prototype._incrementalRenderLarge = function(t, n) {
      this._removeBackground(), A2(n, this.group, this._progressiveEls, !0);
    }, e.prototype._updateLargeClip = function(t) {
      var n = t.get("clip", !0) && h5(t.coordinateSystem, !1, t), i = this.group;
      n ? i.setClipPath(n) : i.removeClipPath();
    }, e.prototype._enableRealtimeSort = function(t, n, i) {
      var a = this;
      if (n.count()) {
        var o = t.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(n, t, i), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = n.getItemGraphicEl(l), f = u && u.shape;
            return f && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(o.isHorizontal() ? f.height : f.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(n, s, o, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, e.prototype._dataSort = function(t, n, i) {
      var a = [];
      return t.each(t.mapDimension(n.dim), function(o, s) {
        var l = i(s);
        l = l ?? NaN, a.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: o
        });
      }), a.sort(function(o, s) {
        return s.mappedValue - o.mappedValue;
      }), {
        ordinalNumbers: dist_$(a, function(o) {
          return o.ordinalNumber;
        })
      };
    }, e.prototype._isOrderChangedWithinSameData = function(t, n, i) {
      for (var a = i.scale, o = t.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var f = t.rawIndexOf(o, a.getRawOrdinalNumber(l)), c = f < 0 ? Number.MIN_VALUE : n(t.indexOfRawIndex(f));
        if (c > s)
          return !0;
        s = c;
      }
      return !1;
    }, e.prototype._isOrderDifferentInView = function(t, n) {
      for (var i = n.scale, a = i.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); o <= s; ++o)
        if (t.ordinalNumbers[o] !== i.getRawOrdinalNumber(o))
          return !0;
    }, e.prototype._updateSortWithinSameData = function(t, n, i, a) {
      if (this._isOrderChangedWithinSameData(t, n, i)) {
        var o = this._dataSort(t, i, n);
        this._isOrderDifferentInView(o, i) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: o
        }));
      }
    }, e.prototype._dispatchInitSort = function(t, n, i) {
      var a = n.baseAxis, o = this._dataSort(t, a, function(s) {
        return t.get(t.mapDimension(n.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: !0,
        axisId: a.index,
        sortInfo: o
      });
    }, e.prototype.remove = function(t, n) {
      this._clear(this._model), this._removeOnRenderedListener(n);
    }, e.prototype.dispose = function(t, n) {
      this._removeOnRenderedListener(n);
    }, e.prototype._removeOnRenderedListener = function(t) {
      this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, e.prototype._clear = function(t) {
      var n = this.group, i = this._data;
      t && t.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(a) {
        wu(a, t, dist_ie(a).dataIndex);
      })) : n.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, e.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, e.type = "bar", e;
  }(bt)
), b2 = {
  cartesian2d: function(r, e) {
    var t = e.width < 0 ? -1 : 1, n = e.height < 0 ? -1 : 1;
    t < 0 && (e.x += e.width, e.width = -e.width), n < 0 && (e.y += e.height, e.height = -e.height);
    var i = r.x + r.width, a = r.y + r.height, o = sh(e.x, r.x), s = lh(e.x + e.width, i), l = sh(e.y, r.y), u = lh(e.y + e.height, a), f = s < o, c = u < l;
    return e.x = f && o > i ? s : o, e.y = c && l > a ? u : l, e.width = f ? 0 : s - o, e.height = c ? 0 : u - l, t < 0 && (e.x += e.width, e.width = -e.width), n < 0 && (e.y += e.height, e.height = -e.height), f || c;
  },
  polar: function(r, e) {
    var t = e.r0 <= e.r ? 1 : -1;
    if (t < 0) {
      var n = e.r;
      e.r = e.r0, e.r0 = n;
    }
    var i = lh(e.r, r.r), a = sh(e.r0, r.r0);
    e.r = i, e.r0 = a;
    var o = i - a < 0;
    if (t < 0) {
      var n = e.r;
      e.r = e.r0, e.r0 = n;
    }
    return o;
  }
}, x2 = {
  cartesian2d: function(r, e, t, n, i, a, o, s, l) {
    var u = new xe({
      shape: dist_V({}, n),
      z2: 1
    });
    if (u.__dataIndex = t, u.name = "item", a) {
      var f = u.shape, c = i ? "height" : "width";
      f[c] = 0;
    }
    return u;
  },
  polar: function(r, e, t, n, i, a, o, s, l) {
    var u = !i && l ? w2 : nn, f = new u({
      shape: n,
      z2: 1
    });
    f.name = "item";
    var c = p5(i);
    if (f.calculateTextPosition = hL(c, {
      isRoundCap: u === w2
    }), a) {
      var h = f.shape, v = i ? "r" : "endAngle", d = {};
      h[v] = i ? n.r0 : n.startAngle, d[v] = n[v], (s ? Pe : Ze)(f, {
        shape: d
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, a);
    }
    return f;
  }
};
function gL(r, e) {
  var t = r.get("realtimeSort", !0), n = e.getBaseAxis();
  if ( false && (0), t && n.type === "category" && e.type === "cartesian2d")
    return {
      baseAxis: n,
      otherAxis: e.getOtherAxis(n)
    };
}
function C2(r, e, t, n, i, a, o, s) {
  var l, u;
  a ? (u = {
    x: n.x,
    width: n.width
  }, l = {
    y: n.y,
    height: n.height
  }) : (u = {
    y: n.y,
    height: n.height
  }, l = {
    x: n.x,
    width: n.width
  }), s || (o ? Pe : Ze)(t, {
    shape: l
  }, e, i, null);
  var f = e ? r.baseAxis.model : null;
  (o ? Pe : Ze)(t, {
    shape: u
  }, f, i);
}
function T2(r, e) {
  for (var t = 0; t < e.length; t++)
    if (!isFinite(r[e[t]]))
      return !0;
  return !1;
}
var mL = ["x", "y", "width", "height"], yL = ["cx", "cy", "r", "startAngle", "endAngle"], M2 = {
  cartesian2d: function(r) {
    return !T2(r, mL);
  },
  polar: function(r) {
    return !T2(r, yL);
  }
}, El = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(r, e, t) {
    var n = r.getItemLayout(e), i = t ? SL(t, n) : 0, a = n.width > 0 ? 1 : -1, o = n.height > 0 ? 1 : -1;
    return {
      x: n.x + a * i / 2,
      y: n.y + o * i / 2,
      width: n.width - a * i,
      height: n.height - o * i
    };
  },
  polar: function(r, e, t) {
    var n = r.getItemLayout(e);
    return {
      cx: n.cx,
      cy: n.cy,
      r0: n.r0,
      r: n.r,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    };
  }
};
function _L(r) {
  return r.startAngle != null && r.endAngle != null && r.startAngle === r.endAngle;
}
function p5(r) {
  return /* @__PURE__ */ function(e) {
    var t = e ? "Arc" : "Angle";
    return function(n) {
      switch (n) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return n + t;
        default:
          return n;
      }
    };
  }(r);
}
function D2(r, e, t, n, i, a, o, s) {
  var l = e.getItemVisual(t, "style");
  if (s) {
    if (!a.get("roundCap")) {
      var f = r.shape, c = Ro(n.getModel("itemStyle"), f, !0);
      dist_V(f, c), r.setShape(f);
    }
  } else {
    var u = n.get(["itemStyle", "borderRadius"]) || 0;
    r.setShape("r", u);
  }
  r.useStyle(l);
  var h = n.getShallow("cursor");
  h && r.attr("cursor", h);
  var v = s ? o ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : o ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", d = hn(n);
  Yn(r, d, {
    labelFetcher: a,
    labelDataIndex: t,
    defaultText: w0(a.getData(), t),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: v
  });
  var g = r.getTextContent();
  if (s && g) {
    var p = n.get(["label", "position"]);
    r.textConfig.inside = p === "middle" ? !0 : null, vL(r, p === "outside" ? v : p, p5(o), n.get(["label", "rotate"]));
  }
  W8(g, d, a.getRawValue(t), function(y) {
    return o5(e, y);
  });
  var m = n.getModel(["emphasis"]);
  rn(r, m.get("focus"), m.get("blurScope"), m.get("disabled")), yu(r, n), _L(i) && (r.style.fill = "none", r.style.stroke = "none", dist_M(r.states, function(y) {
    y.style && (y.style.fill = y.style.stroke = "none");
  }));
}
function SL(r, e) {
  var t = r.get(["itemStyle", "borderColor"]);
  if (!t || t === "none")
    return 0;
  var n = r.get(["itemStyle", "borderWidth"]) || 0, i = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), a = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
  return Math.min(n, i, a);
}
var wL = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), E2 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "largeBar", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new wL();
    }, e.prototype.buildPath = function(t, n) {
      for (var i = n.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, f = 0; f < i.length; f += 3)
        l[a] = u, l[o] = i[f + 2], s[a] = i[f + a], s[o] = i[f + o], t.rect(s[0], s[1], l[0], l[1]);
    }, e;
  }(fe)
);
function A2(r, e, t, n) {
  var i = r.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, o = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = r.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
  if (u) {
    var f = new E2({
      shape: {
        points: u
      },
      incremental: !!n,
      silent: !0,
      z2: 0
    });
    f.baseDimIdx = a, f.largeDataIndices = o, f.barWidth = s, f.useStyle(l.getItemStyle()), e.add(f), t && t.push(f);
  }
  var c = new E2({
    shape: {
      points: i.getLayout("largePoints")
    },
    incremental: !!n,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, e.add(c), c.useStyle(i.getVisual("style")), dist_ie(c).seriesIndex = r.seriesIndex, r.get("silent") || (c.on("mousedown", I2), c.on("mousemove", I2)), t && t.push(c);
}
var I2 = u0(function(r) {
  var e = this, t = bL(e, r.offsetX, r.offsetY);
  dist_ie(e).dataIndex = t >= 0 ? t : null;
}, 30, !1);
function bL(r, e, t) {
  for (var n = r.baseDimIdx, i = 1 - n, a = r.shape.points, o = r.largeDataIndices, s = [], l = [], u = r.barWidth, f = 0, c = a.length / 3; f < c; f++) {
    var h = f * 3;
    if (l[n] = u, l[i] = a[h + 2], s[n] = a[h + n], s[i] = a[h + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), e >= s[0] && e <= s[0] + l[0] && t >= s[1] && t <= s[1] + l[1])
      return o[f];
  }
  return -1;
}
function g5(r, e, t) {
  if (x0(t, "cartesian2d")) {
    var n = e, i = t.getArea();
    return {
      x: r ? n.x : i.x,
      y: r ? i.y : n.y,
      width: r ? n.width : i.width,
      height: r ? i.height : n.height
    };
  } else {
    var i = t.getArea(), a = e;
    return {
      cx: i.cx,
      cy: i.cy,
      r0: r ? i.r0 : a.r0,
      r: r ? i.r : a.r,
      startAngle: r ? a.startAngle : 0,
      endAngle: r ? a.endAngle : Math.PI * 2
    };
  }
}
function xL(r, e, t) {
  var n = r.type === "polar" ? nn : xe;
  return new n({
    shape: g5(e, t, r),
    silent: !0,
    z2: 0
  });
}
const CL = pL;
function TL(r) {
  r.registerChartView(CL), r.registerSeriesModel(fL), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Te(VA, "bar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, BA("bar")), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, d5("bar")), r.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(e, t) {
    var n = e.componentType || "series";
    t.eachComponent({
      mainType: n,
      query: e
    }, function(i) {
      e.sortInfo && i.axis.setCategorySortInfo(e.sortInfo);
    });
  });
}
var L2 = Math.PI * 2, Al = Math.PI / 180;
function m5(r, e) {
  return cr(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function y5(r, e) {
  var t = m5(r, e), n = r.get("center"), i = r.get("radius");
  dist_F(i) || (i = [0, i]);
  var a = me(t.width, e.getWidth()), o = me(t.height, e.getHeight()), s = Math.min(a, o), l = me(i[0], s / 2), u = me(i[1], s / 2), f, c, h = r.coordinateSystem;
  if (h) {
    var v = h.dataToPoint(n);
    f = v[0] || 0, c = v[1] || 0;
  } else
    dist_F(n) || (n = [n, n]), f = me(n[0], a) + t.x, c = me(n[1], o) + t.y;
  return {
    cx: f,
    cy: c,
    r0: l,
    r: u
  };
}
function ML(r, e, t) {
  e.eachSeriesByType(r, function(n) {
    var i = n.getData(), a = i.mapDimension("value"), o = m5(n, t), s = y5(n, t), l = s.cx, u = s.cy, f = s.r, c = s.r0, h = -n.get("startAngle") * Al, v = n.get("endAngle"), d = n.get("padAngle") * Al;
    v = v === "auto" ? h - L2 : -v * Al;
    var g = n.get("minAngle") * Al, p = g + d, m = 0;
    i.each(a, function(R) {
      !isNaN(R) && m++;
    });
    var y = i.getSum(a), _ = Math.PI / (y || m) * 2, S = n.get("clockwise"), b = n.get("roseType"), w = n.get("stillShowZeroSum"), x = i.getDataExtent(a);
    x[0] = 0;
    var C = S ? 1 : -1, T = [h, v], E = C * d / 2;
    l_(T, !S), h = T[0], v = T[1];
    var D = Math.abs(v - h), I = D, L = 0, N = h;
    if (i.setLayout({
      viewRect: o,
      r: f
    }), i.each(a, function(R, z) {
      var O;
      if (isNaN(R)) {
        i.setItemLayout(z, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: S,
          cx: l,
          cy: u,
          r0: c,
          r: b ? NaN : f
        });
        return;
      }
      b !== "area" ? O = y === 0 && w ? _ : R * _ : O = D / m, O < p ? (O = p, I -= p) : L += R;
      var B = N + C * O, H = 0, q = 0;
      d > O ? (H = N + C * O / 2, q = H) : (H = N + E, q = B - E), i.setItemLayout(z, {
        angle: O,
        startAngle: H,
        endAngle: q,
        clockwise: S,
        cx: l,
        cy: u,
        r0: c,
        r: b ? De(R, x, [c, f]) : f
      }), N = B;
    }), I < L2 && m)
      if (I <= 1e-3) {
        var P = D / m;
        i.each(a, function(R, z) {
          if (!isNaN(R)) {
            var O = i.getItemLayout(z);
            O.angle = P;
            var B = 0, H = 0;
            P < d ? (B = h + C * (z + 1 / 2) * P, H = B) : (B = h + C * z * P + E, H = h + C * (z + 1) * P - E), O.startAngle = B, O.endAngle = H;
          }
        });
      } else
        _ = I / L, N = h, i.each(a, function(R, z) {
          if (!isNaN(R)) {
            var O = i.getItemLayout(z), B = O.angle === p ? p : R * _, H = 0, q = 0;
            B < d ? (H = N + C * B / 2, q = H) : (H = N + E, q = N + C * B - E), O.startAngle = H, O.endAngle = q, N += C * B;
          }
        });
  });
}
function DL(r) {
  return {
    seriesType: r,
    reset: function(e, t) {
      var n = t.findComponents({
        mainType: "legend"
      });
      if (!(!n || !n.length)) {
        var i = e.getData();
        i.filterSelf(function(a) {
          for (var o = i.getName(a), s = 0; s < n.length; s++)
            if (!n[s].isSelected(o))
              return !1;
          return !0;
        });
      }
    }
  };
}
var EL = Math.PI / 180;
function N2(r, e, t, n, i, a, o, s, l, u) {
  if (r.length < 2)
    return;
  function f(g) {
    for (var p = g.rB, m = p * p, y = 0; y < g.list.length; y++) {
      var _ = g.list[y], S = Math.abs(_.label.y - t), b = n + _.len, w = b * b, x = Math.sqrt((1 - Math.abs(S * S / m)) * w), C = e + (x + _.len2) * i, T = C - _.label.x, E = _.targetTextWidth - T * i;
      _5(_, E, !0), _.label.x = C;
    }
  }
  function c(g) {
    for (var p = {
      list: [],
      maxY: 0
    }, m = {
      list: [],
      maxY: 0
    }, y = 0; y < g.length; y++)
      if (g[y].labelAlignTo === "none") {
        var _ = g[y], S = _.label.y > t ? m : p, b = Math.abs(_.label.y - t);
        if (b >= S.maxY) {
          var w = _.label.x - e - _.len2 * i, x = n + _.len, C = Math.abs(w) < x ? Math.sqrt(b * b / (1 - w * w / x / x)) : x;
          S.rB = C, S.maxY = b;
        }
        S.list.push(_);
      }
    f(p), f(m);
  }
  for (var h = r.length, v = 0; v < h; v++)
    if (r[v].position === "outer" && r[v].labelAlignTo === "labelLine") {
      var d = r[v].label.x - u;
      r[v].linePoints[1][0] += d, r[v].label.x = u;
    }
  i5(r, l, l + o) && c(r);
}
function AL(r, e, t, n, i, a, o, s) {
  for (var l = [], u = [], f = Number.MAX_VALUE, c = -Number.MAX_VALUE, h = 0; h < r.length; h++) {
    var v = r[h].label;
    uh(r[h]) || (v.x < e ? (f = Math.min(f, v.x), l.push(r[h])) : (c = Math.max(c, v.x), u.push(r[h])));
  }
  for (var h = 0; h < r.length; h++) {
    var d = r[h];
    if (!uh(d) && d.linePoints) {
      if (d.labelStyleWidth != null)
        continue;
      var v = d.label, g = d.linePoints, p = void 0;
      d.labelAlignTo === "edge" ? v.x < e ? p = g[2][0] - d.labelDistance - o - d.edgeDistance : p = o + i - d.edgeDistance - g[2][0] - d.labelDistance : d.labelAlignTo === "labelLine" ? v.x < e ? p = f - o - d.bleedMargin : p = o + i - c - d.bleedMargin : v.x < e ? p = v.x - o - d.bleedMargin : p = o + i - v.x - d.bleedMargin, d.targetTextWidth = p, _5(d, p);
    }
  }
  N2(u, e, t, n, 1, i, a, o, s, c), N2(l, e, t, n, -1, i, a, o, s, f);
  for (var h = 0; h < r.length; h++) {
    var d = r[h];
    if (!uh(d) && d.linePoints) {
      var v = d.label, g = d.linePoints, m = d.labelAlignTo === "edge", y = v.style.padding, _ = y ? y[1] + y[3] : 0, S = v.style.backgroundColor ? 0 : _, b = d.rect.width + S, w = g[1][0] - g[2][0];
      m ? v.x < e ? g[2][0] = o + d.edgeDistance + b + d.labelDistance : g[2][0] = o + i - d.edgeDistance - b - d.labelDistance : (v.x < e ? g[2][0] = v.x + d.labelDistance : g[2][0] = v.x - d.labelDistance, g[1][0] = g[2][0] + w), g[1][1] = g[2][1] = v.y;
    }
  }
}
function _5(r, e, t) {
  if (t === void 0 && (t = !1), r.labelStyleWidth == null) {
    var n = r.label, i = n.style, a = r.rect, o = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, f = a.width + (o ? 0 : l);
    if (e < f || t) {
      var c = a.height;
      if (u && u.match("break")) {
        n.setStyle("backgroundColor", null), n.setStyle("width", e - l);
        var h = n.getBoundingRect();
        n.setStyle("width", Math.ceil(h.width)), n.setStyle("backgroundColor", o);
      } else {
        var v = e - l, d = e < f ? v : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          t ? v > r.unconstrainedWidth ? null : v : null
        );
        n.setStyle("width", d);
      }
      var g = n.getBoundingRect();
      a.width = g.width;
      var p = (n.style.margin || 0) + 2.1;
      a.height = g.height + p, a.y -= (a.height - c) / 2;
    }
  }
}
function uh(r) {
  return r.position === "center";
}
function IL(r) {
  var e = r.getData(), t = [], n, i, a = !1, o = (r.get("minShowLabelAngle") || 0) * EL, s = e.getLayout("viewRect"), l = e.getLayout("r"), u = s.width, f = s.x, c = s.y, h = s.height;
  function v(w) {
    w.ignore = !0;
  }
  function d(w) {
    if (!w.ignore)
      return !0;
    for (var x in w.states)
      if (w.states[x].ignore === !1)
        return !0;
    return !1;
  }
  e.each(function(w) {
    var x = e.getItemGraphicEl(w), C = x.shape, T = x.getTextContent(), E = x.getTextGuideLine(), D = e.getItemModel(w), I = D.getModel("label"), L = I.get("position") || D.get(["emphasis", "label", "position"]), N = I.get("distanceToLabelLine"), P = I.get("alignTo"), R = me(I.get("edgeDistance"), u), z = I.get("bleedMargin"), O = D.getModel("labelLine"), B = O.get("length");
    B = me(B, u);
    var H = O.get("length2");
    if (H = me(H, u), Math.abs(C.endAngle - C.startAngle) < o) {
      dist_M(T.states, v), T.ignore = !0, E && (dist_M(E.states, v), E.ignore = !0);
      return;
    }
    if (d(T)) {
      var q = (C.startAngle + C.endAngle) / 2, Q = Math.cos(q), le = Math.sin(q), ge, Re, Ce, je;
      n = C.cx, i = C.cy;
      var Je = L === "inside" || L === "inner";
      if (L === "center")
        ge = C.cx, Re = C.cy, je = "center";
      else {
        var Fe = (Je ? (C.r + C.r0) / 2 * Q : C.r * Q) + n, Ee = (Je ? (C.r + C.r0) / 2 * le : C.r * le) + i;
        if (ge = Fe + Q * 3, Re = Ee + le * 3, !Je) {
          var J = Fe + Q * (B + l - C.r), ce = Ee + le * (B + l - C.r), pr = J + (Q < 0 ? -1 : 1) * H, $e = ce;
          P === "edge" ? ge = Q < 0 ? f + R : f + u - R : ge = pr + (Q < 0 ? -N : N), Re = $e, Ce = [[Fe, Ee], [J, ce], [pr, $e]];
        }
        je = Je ? "center" : P === "edge" ? Q > 0 ? "right" : "left" : Q > 0 ? "left" : "right";
      }
      var vn = Math.PI, Rr = 0, Ja = I.get("rotate");
      if (ve(Ja))
        Rr = Ja * (vn / 180);
      else if (L === "center")
        Rr = 0;
      else if (Ja === "radial" || Ja === !0) {
        var KS = Q < 0 ? -q + vn : -q;
        Rr = KS;
      } else if (Ja === "tangential" && L !== "outside" && L !== "outer") {
        var $i = Math.atan2(Q, le);
        $i < 0 && ($i = vn * 2 + $i);
        var jS = le > 0;
        jS && ($i = vn + $i), Rr = $i - vn;
      }
      if (a = !!Rr, T.x = ge, T.y = Re, T.rotation = Rr, T.setStyle({
        verticalAlign: "middle"
      }), Je) {
        T.setStyle({
          align: je
        });
        var Ff = T.states.select;
        Ff && (Ff.x += T.x, Ff.y += T.y);
      } else {
        var Qa = T.getBoundingRect().clone();
        Qa.applyTransform(T.getComputedTransform());
        var U0 = (T.style.margin || 0) + 2.1;
        Qa.y -= U0 / 2, Qa.height += U0, t.push({
          label: T,
          labelLine: E,
          position: L,
          len: B,
          len2: H,
          minTurnAngle: O.get("minTurnAngle"),
          maxSurfaceAngle: O.get("maxSurfaceAngle"),
          surfaceNormal: new dist_K(Q, le),
          linePoints: Ce,
          textAlign: je,
          labelDistance: N,
          labelAlignTo: P,
          edgeDistance: R,
          bleedMargin: z,
          rect: Qa,
          unconstrainedWidth: Qa.width,
          labelStyleWidth: T.style.width
        });
      }
      x.setTextConfig({
        inside: Je
      });
    }
  }), !a && r.get("avoidLabelOverlap") && AL(t, n, i, l, u, h, f, c);
  for (var g = 0; g < t.length; g++) {
    var p = t[g], m = p.label, y = p.labelLine, _ = isNaN(m.x) || isNaN(m.y);
    if (m) {
      m.setStyle({
        align: p.textAlign
      }), _ && (dist_M(m.states, v), m.ignore = !0);
      var S = m.states.select;
      S && (S.x += m.x, S.y += m.y);
    }
    if (y) {
      var b = p.linePoints;
      _ || !b ? (dist_M(y.states, v), y.ignore = !0) : (Q6(b, p.minTurnAngle), NI(b, p.surfaceNormal, p.maxSurfaceAngle), y.setShape({
        points: b
      }), m.__hostTarget.textGuideLineConfig = {
        anchor: new dist_K(b[0][0], b[0][1])
      });
    }
  }
}
var LL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      a.z2 = 2;
      var o = new Ne();
      return a.setTextContent(o), a.updateData(t, n, i, !0), a;
    }
    return e.prototype.updateData = function(t, n, i, a) {
      var o = this, s = t.hostModel, l = t.getItemModel(n), u = l.getModel("emphasis"), f = t.getItemLayout(n), c = dist_V(Ro(l.getModel("itemStyle"), f, !0), f);
      if (isNaN(c.startAngle)) {
        o.setShape(c);
        return;
      }
      if (a) {
        o.setShape(c);
        var h = s.getShallow("animationType");
        s.ecModel.ssr ? (Ze(o, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: n,
          isFrom: !0
        }), o.originX = c.cx, o.originY = c.cy) : h === "scale" ? (o.shape.r = f.r0, Ze(o, {
          shape: {
            r: f.r
          }
        }, s, n)) : i != null ? (o.setShape({
          startAngle: i,
          endAngle: i
        }), Ze(o, {
          shape: {
            startAngle: f.startAngle,
            endAngle: f.endAngle
          }
        }, s, n)) : (o.shape.endAngle = f.startAngle, Pe(o, {
          shape: {
            endAngle: f.endAngle
          }
        }, s, n));
      } else
        Wd(o), Pe(o, {
          shape: c
        }, s, n);
      o.useStyle(t.getItemVisual(n, "style")), yu(o, l);
      var v = (f.startAngle + f.endAngle) / 2, d = s.get("selectedOffset"), g = Math.cos(v) * d, p = Math.sin(v) * d, m = l.getShallow("cursor");
      m && o.attr("cursor", m), this._updateLabel(s, t, n), o.ensureState("emphasis").shape = dist_V({
        r: f.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, Ro(u.getModel("itemStyle"), f)), dist_V(o.ensureState("select"), {
        x: g,
        y: p,
        shape: Ro(l.getModel(["select", "itemStyle"]), f)
      }), dist_V(o.ensureState("blur"), {
        shape: Ro(l.getModel(["blur", "itemStyle"]), f)
      });
      var y = o.getTextGuideLine(), _ = o.getTextContent();
      y && dist_V(y.ensureState("select"), {
        x: g,
        y: p
      }), dist_V(_.ensureState("select"), {
        x: g,
        y: p
      }), rn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, n, i) {
      var a = this, o = n.getItemModel(i), s = o.getModel("labelLine"), l = n.getItemVisual(i, "style"), u = l && l.fill, f = l && l.opacity;
      Yn(a, hn(o), {
        labelFetcher: n.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: f,
        defaultText: t.getFormattedLabel(i, "normal") || n.getName(i)
      });
      var c = a.getTextContent();
      a.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), c.attr({
        z2: 10
      });
      var h = t.get(["label", "position"]);
      if (h !== "outside" && h !== "outer")
        a.removeTextGuideLine();
      else {
        var v = this.getTextGuideLine();
        v || (v = new cn(), this.setTextGuideLine(v)), e5(this, t5(o), {
          stroke: u,
          opacity: Dr(s.get(["lineStyle", "opacity"]), f, 1)
        });
      }
    }, e;
  }(nn)
), NL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      var o = t.getData(), s = this._data, l = this.group, u;
      if (!s && o.count() > 0) {
        for (var f = o.getItemLayout(0), c = 1; isNaN(f && f.startAngle) && c < o.count(); ++c)
          f = o.getItemLayout(c);
        f && (u = f.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && t.get("showEmptyCircle")) {
        var h = new nn({
          shape: y5(t, i)
        });
        h.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = h, l.add(h);
      }
      o.diff(s).add(function(v) {
        var d = new LL(o, v, u);
        o.setItemGraphicEl(v, d), l.add(d);
      }).update(function(v, d) {
        var g = s.getItemGraphicEl(d);
        g.updateData(o, v, u), g.off("click"), l.add(g), o.setItemGraphicEl(v, g);
      }).remove(function(v) {
        var d = s.getItemGraphicEl(v);
        wu(d, t, v);
      }).execute(), IL(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = o);
    }, e.prototype.dispose = function() {
    }, e.prototype.containPoint = function(t, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "pie", e;
  }(bt)
);
const PL = NL;
function S5(r, e, t) {
  e = dist_F(e) && {
    coordDimensions: e
  } || dist_V({
    encodeDefine: r.getEncode()
  }, e);
  var n = r.getSource(), i = p0(n, e).dimensions, a = new Ba(i, r);
  return a.initData(n, t), a;
}
var RL = (
  /** @class */
  function() {
    function r(e, t) {
      this._getDataWithEncodedVisual = e, this._getRawData = t;
    }
    return r.prototype.getAllNames = function() {
      var e = this._getRawData();
      return e.mapArray(e.getName);
    }, r.prototype.containName = function(e) {
      var t = this._getRawData();
      return t.indexOfName(e) >= 0;
    }, r.prototype.indexOfName = function(e) {
      var t = this._getDataWithEncodedVisual();
      return t.indexOfName(e);
    }, r.prototype.getItemVisual = function(e, t) {
      var n = this._getDataWithEncodedVisual();
      return n.getItemVisual(e, t);
    }, r;
  }()
);
const w5 = RL;
var OL = Me(), kL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new w5(dist_Z(this.getData, this), dist_Z(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.mergeOption = function() {
      r.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.getInitialData = function() {
      return S5(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Te(m4, this)
      });
    }, e.prototype.getDataParams = function(t) {
      var n = this.getData(), i = OL(n), a = i.seats;
      if (!a) {
        var o = [];
        n.each(n.mapDimension("value"), function(l) {
          o.push(l);
        }), a = i.seats = vC(o, n.hostModel.get("percentPrecision"));
      }
      var s = r.prototype.getDataParams.call(this, t);
      return s.percent = a[t] || 0, s.$vars.push("percent"), s;
    }, e.prototype._defaultLabelLine = function(t) {
      us(t, "labelLine", ["show"]);
      var n = t.labelLine, i = t.emphasis.labelLine;
      n.show = n.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.type = "series.pie", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      // 最小角度改为0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 选中时扇区偏移量
      selectedOffset: 10,
      // 选择模式，默认关闭，可选single，multiple
      // selectedMode: false,
      // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter: 标签文本格式器，同 tooltip.formatter，不支持异步回调
        // 默认使用全局文本样式，详见 textStyle
        // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 引导线两段中的第一段长度
        length: 15,
        // 引导线两段中的第二段长度
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: 各异,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, e;
  }(jt)
);
const VL = kL;
function BL(r) {
  return {
    seriesType: r,
    reset: function(e, t) {
      var n = e.getData();
      n.filterSelf(function(i) {
        var a = n.mapDimension("value"), o = n.get(a, i);
        return !(ve(o) && !isNaN(o) && o < 0);
      });
    }
  };
}
function FL(r) {
  r.registerChartView(PL), r.registerSeriesModel(VL), Q4("pie", r.registerAction), r.registerLayout(Te(ML, "pie")), r.registerProcessor(DL("pie")), r.registerProcessor(BL("pie"));
}
var zL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.type = "grid", e.dependencies = ["xAxis", "yAxis"], e.layoutMode = "box", e.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, e;
  }(Se)
);
const GL = zL;
var Wv = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", ft).models[0];
    }, e.type = "cartesian2dAxis", e;
  }(Se)
);
Ot(Wv, lI);
var b5 = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, HL = he({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, b5), T0 = he({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, b5), $L = he({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, T0), WL = dist_se({
  logBase: 10
}, T0);
const UL = {
  category: HL,
  value: T0,
  time: $L,
  log: WL
};
var YL = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function P2(r, e, t, n) {
  dist_M(YL, function(i, a) {
    var o = he(he({}, UL[a], !0), n, !0), s = (
      /** @class */
      function(l) {
        dist_k(u, l);
        function u() {
          var f = l !== null && l.apply(this, arguments) || this;
          return f.type = e + "Axis." + a, f;
        }
        return u.prototype.mergeDefaultAndTheme = function(f, c) {
          var h = vs(this), v = h ? Ps(f) : {}, d = c.getTheme();
          he(f, d.get(a + "Axis")), he(f, this.getDefaultOption()), f.type = R2(f), h && ka(f, v, h);
        }, u.prototype.optionUpdated = function() {
          var f = this.option;
          f.type === "category" && (this.__ordinalMeta = zv.createByAxisModel(this));
        }, u.prototype.getCategories = function(f) {
          var c = this.option;
          if (c.type === "category")
            return f ? c.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = e + "Axis." + a, u.defaultOption = o, u;
      }(t)
    );
    r.registerComponentModel(s);
  }), r.registerSubTypeDefaulter(e + "Axis", R2);
}
function R2(r) {
  return r.type || (r.data ? "category" : "value");
}
var XL = (
  /** @class */
  function() {
    function r(e) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "";
    }
    return r.prototype.getAxis = function(e) {
      return this._axes[e];
    }, r.prototype.getAxes = function() {
      return dist_$(this._dimList, function(e) {
        return this._axes[e];
      }, this);
    }, r.prototype.getAxesByScale = function(e) {
      return e = e.toLowerCase(), ke(this.getAxes(), function(t) {
        return t.scale.type === e;
      });
    }, r.prototype.addAxis = function(e) {
      var t = e.dim;
      this._axes[t] = e, this._dimList.push(t);
    }, r;
  }()
);
const ZL = XL;
var Uv = ["x", "y"];
function O2(r) {
  return r.type === "interval" || r.type === "time";
}
var qL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "cartesian2d", t.dimensions = Uv, t;
    }
    return e.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var t = this.getAxis("x").scale, n = this.getAxis("y").scale;
      if (!(!O2(t) || !O2(n))) {
        var i = t.getExtent(), a = n.getExtent(), o = this.dataToPoint([i[0], a[0]]), s = this.dataToPoint([i[1], a[1]]), l = i[1] - i[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var f = (s[0] - o[0]) / l, c = (s[1] - o[1]) / u, h = o[0] - i[0] * f, v = o[1] - a[0] * c, d = this._transform = [f, 0, 0, c, h, v];
          this._invTransform = Ua([], d);
        }
      }
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, e.prototype.containPoint = function(t) {
      var n = this.getAxis("x"), i = this.getAxis("y");
      return n.contain(n.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
    }, e.prototype.containData = function(t) {
      return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
    }, e.prototype.containZone = function(t, n) {
      var i = this.dataToPoint(t), a = this.dataToPoint(n), o = this.getArea(), s = new dist_ae(i[0], i[1], a[0] - i[0], a[1] - i[1]);
      return o.intersect(s);
    }, e.prototype.dataToPoint = function(t, n, i) {
      i = i || [];
      var a = t[0], o = t[1];
      if (this._transform && a != null && isFinite(a) && o != null && isFinite(o))
        return Xe(i, t, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(a, n)), i[1] = l.toGlobalCoord(l.dataToCoord(o, n)), i;
    }, e.prototype.clampData = function(t, n) {
      var i = this.getAxis("x").scale, a = this.getAxis("y").scale, o = i.getExtent(), s = a.getExtent(), l = i.parse(t[0]), u = a.parse(t[1]);
      return n = n || [], n[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), n[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), n;
    }, e.prototype.pointToData = function(t, n) {
      var i = [];
      if (this._invTransform)
        return Xe(i, t, this._invTransform);
      var a = this.getAxis("x"), o = this.getAxis("y");
      return i[0] = a.coordToData(a.toLocalCoord(t[0]), n), i[1] = o.coordToData(o.toLocalCoord(t[1]), n), i;
    }, e.prototype.getOtherAxis = function(t) {
      return this.getAxis(t.dim === "x" ? "y" : "x");
    }, e.prototype.getArea = function(t) {
      t = t || 0;
      var n = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(n[0], n[1]) - t, o = Math.min(i[0], i[1]) - t, s = Math.max(n[0], n[1]) - a + t, l = Math.max(i[0], i[1]) - o + t;
      return new dist_ae(a, o, s, l);
    }, e;
  }(ZL)
), KL = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i, a, o) {
      var s = r.call(this, t, n, i) || this;
      return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.getGlobalExtent = function(t) {
      var n = this.getExtent();
      return n[0] = this.toGlobalCoord(n[0]), n[1] = this.toGlobalCoord(n[1]), t && n[0] > n[1] && n.reverse(), n;
    }, e.prototype.pointToData = function(t, n) {
      return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), n);
    }, e.prototype.setCategorySortInfo = function(t) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = t, this.scale.setSortInfo(t);
    }, e;
  }(MI)
);
const jL = KL;
function Yv(r, e, t) {
  t = t || {};
  var n = r.coordinateSystem, i = e.axis, a = {}, o = i.getAxesOnZeroOf()[0], s = i.position, l = o ? "onZero" : s, u = i.dim, f = n.getRect(), c = [f.x, f.x + f.width, f.y, f.y + f.height], h = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, v = e.get("offset") || 0, d = u === "x" ? [c[2] - v, c[3] + v] : [c[0] - v, c[1] + v];
  if (o) {
    var g = o.toGlobalCoord(o.dataToCoord(0));
    d[h.onZero] = Math.max(Math.min(g, d[1]), d[0]);
  }
  a.position = [u === "y" ? d[h[l]] : c[0], u === "x" ? d[h[l]] : c[3]], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
  var p = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  a.labelDirection = a.tickDirection = a.nameDirection = p[s], a.labelOffset = o ? d[h[s]] - d[h.onZero] : 0, e.get(["axisTick", "inside"]) && (a.tickDirection = -a.tickDirection), Kt(t.labelInside, e.get(["axisLabel", "inside"])) && (a.labelDirection = -a.labelDirection);
  var m = e.get(["axisLabel", "rotate"]);
  return a.labelRotate = l === "top" ? -m : m, a.z2 = 1, a;
}
function k2(r) {
  return r.get("coordinateSystem") === "cartesian2d";
}
function V2(r) {
  var e = {
    xAxisModel: null,
    yAxisModel: null
  };
  return dist_M(e, function(t, n) {
    var i = n.replace(/Model$/, ""), a = r.getReferringComponents(i, ft).models[0];
    if (false)
      {}
    e[n] = a;
  }), e;
}
var fh = Math.log;
function JL(r, e, t) {
  var n = Vs.prototype, i = n.getTicks.call(t), a = n.getTicks.call(t, !0), o = i.length - 1, s = n.getInterval.call(t), l = z6(r, e), u = l.extent, f = l.fixMin, c = l.fixMax;
  if (r.type === "log") {
    var h = fh(r.base);
    u = [fh(u[0]) / h, fh(u[1]) / h];
  }
  r.setExtent(u[0], u[1]), r.calcNiceExtent({
    splitNumber: o,
    fixMin: f,
    fixMax: c
  });
  var v = n.getExtent.call(r);
  f && (u[0] = v[0]), c && (u[1] = v[1]);
  var d = n.getInterval.call(r), g = u[0], p = u[1];
  if (f && c)
    d = (p - g) / o;
  else if (f)
    for (p = u[0] + d * o; p < u[1] && isFinite(p) && isFinite(u[1]); )
      d = Qc(d), p = u[0] + d * o;
  else if (c)
    for (g = u[1] - d * o; g > u[0] && isFinite(g) && isFinite(u[0]); )
      d = Qc(d), g = u[1] - d * o;
  else {
    var m = r.getTicks().length - 1;
    m > o && (d = Qc(d));
    var y = d * o;
    p = Math.ceil(u[1] / d) * d, g = Be(p - y), g < 0 && u[0] >= 0 ? (g = 0, p = Be(y)) : p > 0 && u[1] <= 0 && (p = 0, g = -Be(y));
  }
  var _ = (i[0].value - a[0].value) / s, S = (i[o].value - a[o].value) / s;
  if (n.setExtent.call(r, g + d * _, p + d * S), n.setInterval.call(r, d), (_ || S) && n.setNiceExtent.call(r, g + d, p - d), "production" !== "production") {
    var b = n.getTicks.call(r);
    b[1] && (!AA(d) || pv(b[1].value) > pv(d)) && Ve(
      // eslint-disable-next-line
      "The ticks may be not readable when set min: " + e.get("min") + ", max: " + e.get("max") + " and alignTicks: true"
    );
  }
}
var QL = (
  /** @class */
  function() {
    function r(e, t, n) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = Uv, this._initCartesian(e, t, n), this.model = e;
    }
    return r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.update = function(e, t) {
      var n = this._axesMap;
      this._updateScale(e, this.model);
      function i(o) {
        var s, l = we(o), u = l.length;
        if (u) {
          for (var f = [], c = u - 1; c >= 0; c--) {
            var h = +l[c], v = o[h], d = v.model, g = v.scale;
            // Only value and log axis without interval support alignTicks.
            Gv(g) && d.get("alignTicks") && d.get("interval") == null ? f.push(v) : (n2(g, d), Gv(g) && (s = v));
          }
          f.length && (s || (s = f.pop(), n2(s.scale, s.model)), dist_M(f, function(p) {
            JL(p.scale, p.model, s.scale);
          }));
        }
      }
      i(n.x), i(n.y);
      var a = {};
      dist_M(n.x, function(o) {
        B2(n, "y", o, a);
      }), dist_M(n.y, function(o) {
        B2(n, "x", o, a);
      }), this.resize(this.model, t);
    }, r.prototype.resize = function(e, t, n) {
      var i = e.getBoxLayoutParams(), a = !n && e.get("containLabel"), o = cr(i, {
        width: t.getWidth(),
        height: t.getHeight()
      });
      this._rect = o;
      var s = this._axesList;
      l(), a && (dist_M(s, function(u) {
        if (!u.model.get(["axisLabel", "inside"])) {
          var f = aI(u);
          if (f) {
            var c = u.isHorizontal() ? "height" : "width", h = u.model.get(["axisLabel", "margin"]);
            o[c] -= f[c] + h, u.position === "top" ? o.y += f.height + h : u.position === "left" && (o.x += f.width + h);
          }
        }
      }), l()), dist_M(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        dist_M(s, function(u) {
          var f = u.isHorizontal(), c = f ? [0, o.width] : [0, o.height], h = u.inverse ? 1 : 0;
          u.setExtent(c[h], c[1 - h]), eN(u, f ? o.x : o.y);
        });
      }
    }, r.prototype.getAxis = function(e, t) {
      var n = this._axesMap[e];
      if (n != null)
        return n[t || 0];
    }, r.prototype.getAxes = function() {
      return this._axesList.slice();
    }, r.prototype.getCartesian = function(e, t) {
      if (e != null && t != null) {
        var n = "x" + e + "y" + t;
        return this._coordsMap[n];
      }
      dist_X(e) && (t = e.yAxisIndex, e = e.xAxisIndex);
      for (var i = 0, a = this._coordsList; i < a.length; i++)
        if (a[i].getAxis("x").index === e || a[i].getAxis("y").index === t)
          return a[i];
    }, r.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, r.prototype.convertToPixel = function(e, t, n) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null;
    }, r.prototype.convertFromPixel = function(e, t, n) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null;
    }, r.prototype._findConvertTarget = function(e) {
      var t = e.seriesModel, n = e.xAxisModel || t && t.getReferringComponents("xAxis", ft).models[0], i = e.yAxisModel || t && t.getReferringComponents("yAxis", ft).models[0], a = e.gridModel, o = this._coordsList, s, l;
      if (t)
        s = t.coordinateSystem, ye(o, s) < 0 && (s = null);
      else if (n && i)
        s = this.getCartesian(n.componentIndex, i.componentIndex);
      else if (n)
        l = this.getAxis("x", n.componentIndex);
      else if (i)
        l = this.getAxis("y", i.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, r.prototype.containPoint = function(e) {
      var t = this._coordsList[0];
      if (t)
        return t.containPoint(e);
    }, r.prototype._initCartesian = function(e, t, n) {
      var i = this, a = this, o = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (t.eachComponent("xAxis", u("x"), this), t.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, dist_M(s.x, function(f, c) {
        dist_M(s.y, function(h, v) {
          var d = "x" + c + "y" + v, g = new qL(d);
          g.master = i, g.model = e, i._coordsMap[d] = g, i._coordsList.push(g), g.addAxis(f), g.addAxis(h);
        });
      });
      function u(f) {
        return function(c, h) {
          if (ch(c, e)) {
            var v = c.get("position");
            f === "x" ? v !== "top" && v !== "bottom" && (v = o.bottom ? "top" : "bottom") : v !== "left" && v !== "right" && (v = o.left ? "right" : "left"), o[v] = !0;
            var d = new jL(f, nI(c), [0, 0], c.get("type"), v), g = d.type === "category";
            d.onBand = g && c.get("boundaryGap"), d.inverse = c.get("inverse"), c.axis = d, d.model = c, d.grid = a, d.index = h, a._axesList.push(d), s[f][h] = d, l[f]++;
          }
        };
      }
    }, r.prototype._updateScale = function(e, t) {
      dist_M(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var a = i.model.get("categorySortInfo");
          i.scale.setSortInfo(a);
        }
      }), e.eachSeries(function(i) {
        if (k2(i)) {
          var a = V2(i), o = a.xAxisModel, s = a.yAxisModel;
          if (!ch(o, t) || !ch(s, t))
            return;
          var l = this.getCartesian(o.componentIndex, s.componentIndex), u = i.getData(), f = l.getAxis("x"), c = l.getAxis("y");
          n(u, f), n(u, c);
        }
      }, this);
      function n(i, a) {
        dist_M(H6(i, a.dim), function(o) {
          a.scale.unionExtentFromData(i, o);
        });
      }
    }, r.prototype.getTooltipAxes = function(e) {
      var t = [], n = [];
      return dist_M(this.getCartesians(), function(i) {
        var a = e != null && e !== "auto" ? i.getAxis(e) : i.getBaseAxis(), o = i.getOtherAxis(a);
        ye(t, a) < 0 && t.push(a), ye(n, o) < 0 && n.push(o);
      }), {
        baseAxes: t,
        otherAxes: n
      };
    }, r.create = function(e, t) {
      var n = [];
      return e.eachComponent("grid", function(i, a) {
        var o = new r(i, e, t);
        o.name = "grid_" + a, o.resize(i, t, !0), i.coordinateSystem = o, n.push(o);
      }), e.eachSeries(function(i) {
        if (k2(i)) {
          var a = V2(i), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel();
          if (false) {}
          var u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex);
        }
      }), n;
    }, r.dimensions = Uv, r;
  }()
);
function ch(r, e) {
  return r.getCoordSysModel() === e;
}
function B2(r, e, t, n) {
  t.getAxesOnZeroOf = function() {
    return a ? [a] : [];
  };
  var i = r[e], a, o = t.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    F2(i[l]) && (a = i[l]);
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && F2(i[u]) && !n[f(i[u])]) {
        a = i[u];
        break;
      }
  a && (n[f(a)] = !0);
  function f(c) {
    return c.dim + "_" + c.index;
  }
}
function F2(r) {
  return r && r.type !== "category" && r.type !== "time" && iI(r);
}
function eN(r, e) {
  var t = r.getExtent(), n = t[0] + t[1];
  r.toGlobalCoord = r.dim === "x" ? function(i) {
    return i + e;
  } : function(i) {
    return n - i + e;
  }, r.toLocalCoord = r.dim === "x" ? function(i) {
    return i - e;
  } : function(i) {
    return n - i + e;
  };
}
const tN = QL;
var On = Math.PI, Ri = (
  /** @class */
  function() {
    function r(e, t) {
      this.group = new dist_oe(), this.opt = t, this.axisModel = e, dist_se(t, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var n = new dist_oe({
        x: t.position[0],
        y: t.position[1],
        rotation: t.rotation
      });
      n.updateTransform(), this._transformGroup = n;
    }
    return r.prototype.hasBuilder = function(e) {
      return !!z2[e];
    }, r.prototype.add = function(e) {
      z2[e](this.opt, this.axisModel, this.group, this._transformGroup);
    }, r.prototype.getGroup = function() {
      return this.group;
    }, r.innerTextLayout = function(e, t, n) {
      var i = X3(t - e), a, o;
      return du(i) ? (o = n > 0 ? "top" : "bottom", a = "center") : du(i - On) ? (o = n > 0 ? "bottom" : "top", a = "center") : (o = "middle", i > 0 && i < On ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: a,
        textVerticalAlign: o
      };
    }, r.makeAxisEventDataBase = function(e) {
      var t = {
        componentType: e.mainType,
        componentIndex: e.componentIndex
      };
      return t[e.mainType + "Index"] = e.componentIndex, t;
    }, r.isLabelSilent = function(e) {
      var t = e.get("tooltip");
      return e.get("silent") || !(e.get("triggerEvent") || t && t.show);
    }, r;
  }()
), z2 = {
  axisLine: function(r, e, t, n) {
    var i = e.get(["axisLine", "show"]);
    if (i === "auto" && r.handleAutoShown && (i = r.handleAutoShown("axisLine")), !!i) {
      var a = e.axis.getExtent(), o = n.transform, s = [a[0], 0], l = [a[1], 0], u = s[0] > l[0];
      o && (Xe(s, s, o), Xe(l, l, o));
      var f = dist_V({
        lineCap: "round"
      }, e.getModel(["axisLine", "lineStyle"]).getLineStyle()), c = new an({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: l[0],
          y2: l[1]
        },
        style: f,
        strokeContainThreshold: r.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      cs(c.shape, c.style.lineWidth), c.anid = "line", t.add(c);
      var h = e.get(["axisLine", "symbol"]);
      if (h != null) {
        var v = e.get(["axisLine", "symbolSize"]);
        dist_U(h) && (h = [h, h]), (dist_U(v) || ve(v)) && (v = [v, v]);
        var d = Os(e.get(["axisLine", "symbolOffset"]) || 0, v), g = v[0], p = v[1];
        dist_M([{
          rotate: r.rotation + Math.PI / 2,
          offset: d[0],
          r: 0
        }, {
          rotate: r.rotation - Math.PI / 2,
          offset: d[1],
          r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
        }], function(m, y) {
          if (h[y] !== "none" && h[y] != null) {
            var _ = dt(h[y], -g / 2, -p / 2, g, p, f.stroke, !0), S = m.r + m.offset, b = u ? l : s;
            _.attr({
              rotation: m.rotate,
              x: b[0] + S * Math.cos(r.rotation),
              y: b[1] - S * Math.sin(r.rotation),
              silent: !0,
              z2: 11
            }), t.add(_);
          }
        });
      }
    }
  },
  axisTickLabel: function(r, e, t, n) {
    var i = iN(t, n, e, r), a = oN(t, n, e, r);
    if (nN(e, a, i), aN(t, n, e, r.tickDirection), e.get(["axisLabel", "hideOverlap"])) {
      var o = r5(dist_$(a, function(s) {
        return {
          label: s,
          priority: s.z2,
          defaultAttr: {
            ignore: s.ignore
          }
        };
      }));
      a5(o);
    }
  },
  axisName: function(r, e, t, n) {
    var i = Kt(r.axisName, e.get("name"));
    if (i) {
      var a = e.get("nameLocation"), o = r.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = e.axis.getExtent(), f = u[0] > u[1] ? -1 : 1, c = [
        a === "start" ? u[0] - f * l : a === "end" ? u[1] + f * l : (u[0] + u[1]) / 2,
        // Reuse labelOffset.
        H2(a) ? r.labelOffset + o * l : 0
      ], h, v = e.get("nameRotate");
      v != null && (v = v * On / 180);
      var d;
      H2(a) ? h = Ri.innerTextLayout(
        r.rotation,
        v ?? r.rotation,
        // Adapt to axis.
        o
      ) : (h = rN(r.rotation, a, v || 0, u), d = r.axisNameAvailableWidth, d != null && (d = Math.abs(d / Math.sin(h.rotation)), !isFinite(d) && (d = null)));
      var g = s.getFont(), p = e.get("nameTruncate", !0) || {}, m = p.ellipsis, y = Kt(r.nameTruncateMaxWidth, p.maxWidth, d), _ = new Ne({
        x: c[0],
        y: c[1],
        rotation: h.rotation,
        silent: Ri.isLabelSilent(e),
        style: Lt(s, {
          text: i,
          font: g,
          overflow: "truncate",
          width: y,
          ellipsis: m,
          fill: s.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          align: s.get("align") || h.textAlign,
          verticalAlign: s.get("verticalAlign") || h.textVerticalAlign
        }),
        z2: 1
      });
      if (pf({
        el: _,
        componentModel: e,
        itemName: i
      }), _.__fullText = i, _.anid = "name", e.get("triggerEvent")) {
        var S = Ri.makeAxisEventDataBase(e);
        S.targetType = "axisName", S.name = i, dist_ie(_).eventData = S;
      }
      n.add(_), _.updateTransform(), t.add(_), _.decomposeTransform();
    }
  }
};
function rN(r, e, t, n) {
  var i = X3(t - r), a, o, s = n[0] > n[1], l = e === "start" && !s || e !== "start" && s;
  return du(i - On / 2) ? (o = l ? "bottom" : "top", a = "center") : du(i - On * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", i < On * 1.5 && i > On / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: i,
    textAlign: a,
    textVerticalAlign: o
  };
}
function nN(r, e, t) {
  if (!G6(r.axis)) {
    var n = r.get(["axisLabel", "showMinLabel"]), i = r.get(["axisLabel", "showMaxLabel"]);
    e = e || [], t = t || [];
    var a = e[0], o = e[1], s = e[e.length - 1], l = e[e.length - 2], u = t[0], f = t[1], c = t[t.length - 1], h = t[t.length - 2];
    n === !1 ? (Bt(a), Bt(u)) : G2(a, o) && (n ? (Bt(o), Bt(f)) : (Bt(a), Bt(u))), i === !1 ? (Bt(s), Bt(c)) : G2(l, s) && (i ? (Bt(l), Bt(h)) : (Bt(s), Bt(c)));
  }
}
function Bt(r) {
  r && (r.ignore = !0);
}
function G2(r, e) {
  var t = r && r.getBoundingRect().clone(), n = e && e.getBoundingRect().clone();
  if (!(!t || !n)) {
    var i = rf([]);
    return nf(i, i, -r.rotation), t.applyTransform(Xr([], i, r.getLocalTransform())), n.applyTransform(Xr([], i, e.getLocalTransform())), t.intersect(n);
  }
}
function H2(r) {
  return r === "middle" || r === "center";
}
function x5(r, e, t, n, i) {
  for (var a = [], o = [], s = [], l = 0; l < r.length; l++) {
    var u = r[l].coord;
    o[0] = u, o[1] = 0, s[0] = u, s[1] = t, e && (Xe(o, o, e), Xe(s, s, e));
    var f = new an({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    cs(f.shape, f.style.lineWidth), f.anid = i + "_" + r[l].tickValue, a.push(f);
  }
  return a;
}
function iN(r, e, t, n) {
  var i = t.axis, a = t.getModel("axisTick"), o = a.get("show");
  if (o === "auto" && n.handleAutoShown && (o = n.handleAutoShown("axisTick")), !(!o || i.scale.isBlank())) {
    for (var s = a.getModel("lineStyle"), l = n.tickDirection * a.get("length"), u = i.getTicksCoords(), f = x5(u, e.transform, l, dist_se(s.getLineStyle(), {
      stroke: t.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), c = 0; c < f.length; c++)
      r.add(f[c]);
    return f;
  }
}
function aN(r, e, t, n) {
  var i = t.axis, a = t.getModel("minorTick");
  if (!(!a.get("show") || i.scale.isBlank())) {
    var o = i.getMinorTicksCoords();
    if (o.length)
      for (var s = a.getModel("lineStyle"), l = n * a.get("length"), u = dist_se(s.getLineStyle(), dist_se(t.getModel("axisTick").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })), f = 0; f < o.length; f++)
        for (var c = x5(o[f], e.transform, l, u, "minorticks_" + f), h = 0; h < c.length; h++)
          r.add(c[h]);
  }
}
function oN(r, e, t, n) {
  var i = t.axis, a = Kt(n.axisLabelShow, t.get(["axisLabel", "show"]));
  if (!(!a || i.scale.isBlank())) {
    var o = t.getModel("axisLabel"), s = o.get("margin"), l = i.getViewLabels(), u = (Kt(n.labelRotate, o.get("rotate")) || 0) * On / 180, f = Ri.innerTextLayout(n.rotation, u, n.labelDirection), c = t.getCategories && t.getCategories(!0), h = [], v = Ri.isLabelSilent(t), d = t.get("triggerEvent");
    return dist_M(l, function(g, p) {
      var m = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(g.tickValue) : g.tickValue, y = g.formattedLabel, _ = g.rawLabel, S = o;
      if (c && c[m]) {
        var b = c[m];
        dist_X(b) && b.textStyle && (S = new He(b.textStyle, o, t.ecModel));
      }
      var w = S.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), x = i.dataToCoord(m), C = S.getShallow("align", !0) || f.textAlign, T = dist_ne(S.getShallow("alignMinLabel", !0), C), E = dist_ne(S.getShallow("alignMaxLabel", !0), C), D = S.getShallow("verticalAlign", !0) || S.getShallow("baseline", !0) || f.textVerticalAlign, I = dist_ne(S.getShallow("verticalAlignMinLabel", !0), D), L = dist_ne(S.getShallow("verticalAlignMaxLabel", !0), D), N = new Ne({
        x,
        y: n.labelOffset + n.labelDirection * s,
        rotation: f.rotation,
        silent: v,
        z2: 10 + (g.level || 0),
        style: Lt(S, {
          text: y,
          align: p === 0 ? T : p === l.length - 1 ? E : C,
          verticalAlign: p === 0 ? I : p === l.length - 1 ? L : D,
          fill: dist_j(w) ? w(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            i.type === "category" ? _ : i.type === "value" ? m + "" : m,
            p
          ) : w
        })
      });
      if (N.anid = "label_" + m, d) {
        var P = Ri.makeAxisEventDataBase(t);
        P.targetType = "axisLabel", P.value = _, P.tickIndex = p, i.type === "category" && (P.dataIndex = m), dist_ie(N).eventData = P;
      }
      e.add(N), N.updateTransform(), h.push(N), r.add(N), N.decomposeTransform();
    }), h;
  }
}
const C5 = Ri;
function sN(r, e) {
  var t = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return lN(t, r, e), t.seriesInvolved && fN(t, r), t;
}
function lN(r, e, t) {
  var n = e.getComponent("tooltip"), i = e.getComponent("axisPointer"), a = i.get("link", !0) || [], o = [];
  dist_M(t.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = ys(s.model), u = r.coordSysAxesInfo[l] = {};
    r.coordSysMap[l] = s;
    var f = s.model, c = f.getModel("tooltip", n);
    if (dist_M(s.getAxes(), Te(g, !1, null)), s.getTooltipAxes && n && c.get("show")) {
      var h = c.get("trigger") === "axis", v = c.get(["axisPointer", "type"]) === "cross", d = s.getTooltipAxes(c.get(["axisPointer", "axis"]));
      (h || v) && dist_M(d.baseAxes, Te(g, v ? "cross" : !0, h)), v && dist_M(d.otherAxes, Te(g, "cross", !1));
    }
    function g(p, m, y) {
      var _ = y.model.getModel("axisPointer", i), S = _.get("show");
      if (!(!S || S === "auto" && !p && !Xv(_))) {
        m == null && (m = _.get("triggerTooltip")), _ = p ? uN(y, c, i, e, p, m) : _;
        var b = _.get("snap"), w = _.get("triggerEmphasis"), x = ys(y.model), C = m || b || y.type === "category", T = r.axesInfo[x] = {
          key: x,
          axis: y,
          coordSys: s,
          axisPointerModel: _,
          triggerTooltip: m,
          triggerEmphasis: w,
          involveSeries: C,
          snap: b,
          useHandle: Xv(_),
          seriesModels: [],
          linkGroup: null
        };
        u[x] = T, r.seriesInvolved = r.seriesInvolved || C;
        var E = cN(a, y);
        if (E != null) {
          var D = o[E] || (o[E] = {
            axesInfo: {}
          });
          D.axesInfo[x] = T, D.mapper = a[E].mapper, T.linkGroup = D;
        }
      }
    }
  });
}
function uN(r, e, t, n, i, a) {
  var o = e.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  dist_M(s, function(h) {
    l[h] = dist_te(o.get(h));
  }), l.snap = r.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), i === "cross") {
    var f = o.get(["label", "show"]);
    if (u.show = f ?? !0, !a) {
      var c = l.lineStyle = o.get("crossStyle");
      c && dist_se(u, c.textStyle);
    }
  }
  return r.model.getModel("axisPointer", new He(l, t, n));
}
function fN(r, e) {
  e.eachSeries(function(t) {
    var n = t.coordinateSystem, i = t.get(["tooltip", "trigger"], !0), a = t.get(["tooltip", "show"], !0);
    !n || i === "none" || i === !1 || i === "item" || a === !1 || t.get(["axisPointer", "show"], !0) === !1 || dist_M(r.coordSysAxesInfo[ys(n.model)], function(o) {
      var s = o.axis;
      n.getAxis(s.dim) === s && (o.seriesModels.push(t), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += t.getData().count());
    });
  });
}
function cN(r, e) {
  for (var t = e.model, n = e.dim, i = 0; i < r.length; i++) {
    var a = r[i] || {};
    if (hh(a[n + "AxisId"], t.id) || hh(a[n + "AxisIndex"], t.componentIndex) || hh(a[n + "AxisName"], t.name))
      return i;
  }
}
function hh(r, e) {
  return r === "all" || dist_F(r) && ye(r, e) >= 0 || r === e;
}
function hN(r) {
  var e = M0(r);
  if (e) {
    var t = e.axisPointerModel, n = e.axis.scale, i = t.option, a = t.get("status"), o = t.get("value");
    o != null && (o = n.parse(o));
    var s = Xv(t);
    a == null && (i.status = s ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), i.value = o, s && (i.status = e.axis.scale.isBlank() ? "hide" : "show");
  }
}
function M0(r) {
  var e = (r.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return e && e.axesInfo[ys(r)];
}
function vN(r) {
  var e = M0(r);
  return e && e.axisPointerModel;
}
function Xv(r) {
  return !!r.get(["handle", "show"]);
}
function ys(r) {
  return r.type + "||" + r.id;
}
var vh = {}, T5 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this.axisPointerClass && hN(t), r.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, i, !0);
    }, e.prototype.updateAxisPointer = function(t, n, i, a) {
      this._doUpdateAxisPointerClass(t, i, !1);
    }, e.prototype.remove = function(t, n) {
      var i = this._axisPointer;
      i && i.remove(n);
    }, e.prototype.dispose = function(t, n) {
      this._disposeAxisPointer(n), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._doUpdateAxisPointerClass = function(t, n, i) {
      var a = e.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = vN(t);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(t, o, n, i) : this._disposeAxisPointer(n);
      }
    }, e.prototype._disposeAxisPointer = function(t) {
      this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null;
    }, e.registerAxisPointerClass = function(t, n) {
      if (false)
        {}
      vh[t] = n;
    }, e.getAxisPointerClass = function(t) {
      return t && vh[t];
    }, e.type = "axis", e;
  }(Pt)
), Zv = Me();
function dN(r, e, t, n) {
  var i = t.axis;
  if (!i.scale.isBlank()) {
    var a = t.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = n.coordinateSystem.getRect(), u = i.getTicksCoords({
      tickModel: a,
      clamp: !0
    });
    if (u.length) {
      var f = s.length, c = Zv(r).splitAreaColors, h = dist_W(), v = 0;
      if (c)
        for (var d = 0; d < u.length; d++) {
          var g = c.get(u[d].tickValue);
          if (g != null) {
            v = (g + (f - 1) * d) % f;
            break;
          }
        }
      var p = i.toGlobalCoord(u[0].coord), m = o.getAreaStyle();
      s = dist_F(s) ? s : [s];
      for (var d = 1; d < u.length; d++) {
        var y = i.toGlobalCoord(u[d].coord), _ = void 0, S = void 0, b = void 0, w = void 0;
        i.isHorizontal() ? (_ = p, S = l.y, b = y - _, w = l.height, p = _ + b) : (_ = l.x, S = p, b = l.width, w = y - S, p = S + w);
        var x = u[d - 1].tickValue;
        x != null && h.set(x, v), e.add(new xe({
          anid: x != null ? "area_" + x : null,
          shape: {
            x: _,
            y: S,
            width: b,
            height: w
          },
          style: dist_se({
            fill: s[v]
          }, m),
          autoBatch: !0,
          silent: !0
        })), v = (v + 1) % f;
      }
      Zv(r).splitAreaColors = h;
    }
  }
}
function pN(r) {
  Zv(r).splitAreaColors = null;
}
var gN = ["axisLine", "axisTickLabel", "axisName"], mN = ["splitArea", "splitLine", "minorSplitLine"], M5 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this.group.removeAll();
      var o = this._axisGroup;
      if (this._axisGroup = new dist_oe(), this.group.add(this._axisGroup), !!t.get("show")) {
        var s = t.getCoordSysModel(), l = Yv(s, t), u = new C5(t, dist_V({
          handleAutoShown: function(c) {
            for (var h = s.coordinateSystem.getCartesians(), v = 0; v < h.length; v++)
              if (Gv(h[v].getOtherAxis(t.axis).scale))
                return !0;
            return !1;
          }
        }, l));
        dist_M(gN, u.add, u), this._axisGroup.add(u.getGroup()), dist_M(mN, function(c) {
          t.get([c, "show"]) && yN[c](this, this._axisGroup, t, s);
        }, this);
        var f = a && a.type === "changeAxisOrder" && a.isInitSort;
        f || K_(o, this._axisGroup, t), r.prototype.render.call(this, t, n, i, a);
      }
    }, e.prototype.remove = function() {
      pN(this);
    }, e.type = "cartesianAxis", e;
  }(T5)
), yN = {
  splitLine: function(r, e, t, n) {
    var i = t.axis;
    if (!i.scale.isBlank()) {
      var a = t.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
      s = dist_F(s) ? s : [s];
      for (var l = n.coordinateSystem.getRect(), u = i.isHorizontal(), f = 0, c = i.getTicksCoords({
        tickModel: a
      }), h = [], v = [], d = o.getLineStyle(), g = 0; g < c.length; g++) {
        var p = i.toGlobalCoord(c[g].coord);
        u ? (h[0] = p, h[1] = l.y, v[0] = p, v[1] = l.y + l.height) : (h[0] = l.x, h[1] = p, v[0] = l.x + l.width, v[1] = p);
        var m = f++ % s.length, y = c[g].tickValue, _ = new an({
          anid: y != null ? "line_" + c[g].tickValue : null,
          autoBatch: !0,
          shape: {
            x1: h[0],
            y1: h[1],
            x2: v[0],
            y2: v[1]
          },
          style: dist_se({
            stroke: s[m]
          }, d),
          silent: !0
        });
        cs(_.shape, d.lineWidth), e.add(_);
      }
    }
  },
  minorSplitLine: function(r, e, t, n) {
    var i = t.axis, a = t.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = n.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
    if (u.length)
      for (var f = [], c = [], h = o.getLineStyle(), v = 0; v < u.length; v++)
        for (var d = 0; d < u[v].length; d++) {
          var g = i.toGlobalCoord(u[v][d].coord);
          l ? (f[0] = g, f[1] = s.y, c[0] = g, c[1] = s.y + s.height) : (f[0] = s.x, f[1] = g, c[0] = s.x + s.width, c[1] = g);
          var p = new an({
            anid: "minor_line_" + u[v][d].tickValue,
            autoBatch: !0,
            shape: {
              x1: f[0],
              y1: f[1],
              x2: c[0],
              y2: c[1]
            },
            style: h,
            silent: !0
          });
          cs(p.shape, h.lineWidth), e.add(p);
        }
  },
  splitArea: function(r, e, t, n) {
    dN(r, e, t, n);
  }
}, D5 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "xAxis", e;
  }(M5)
), _N = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = D5.type, t;
    }
    return e.type = "yAxis", e;
  }(M5)
), SN = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "grid", t;
    }
    return e.prototype.render = function(t, n) {
      this.group.removeAll(), t.get("show") && this.group.add(new xe({
        shape: t.coordinateSystem.getRect(),
        style: dist_se({
          fill: t.get("backgroundColor")
        }, t.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, e.type = "grid", e;
  }(Pt)
), $2 = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function wN(r) {
  r.registerComponentView(SN), r.registerComponentModel(GL), r.registerCoordinateSystem("cartesian2d", tN), P2(r, "x", Wv, $2), P2(r, "y", Wv, $2), r.registerComponentView(D5), r.registerComponentView(_N), r.registerPreprocessor(function(e) {
    e.xAxis && e.yAxis && !e.grid && (e.grid = {});
  });
}
var W2 = "\0_ec_interaction_mutex";
function U2(r, e) {
  return !!bN(r)[e];
}
function bN(r) {
  return r[W2] || (r[W2] = {});
}
Gi({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, Ue);
var xN = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this) || this;
      n._zr = t;
      var i = dist_Z(n._mousedownHandler, n), a = dist_Z(n._mousemoveHandler, n), o = dist_Z(n._mouseupHandler, n), s = dist_Z(n._mousewheelHandler, n), l = dist_Z(n._pinchHandler, n);
      return n.enable = function(u, f) {
        this.disable(), this._opt = dist_se(dist_te(f) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), u == null && (u = !0), (u === !0 || u === "move" || u === "pan") && (t.on("mousedown", i), t.on("mousemove", a), t.on("mouseup", o)), (u === !0 || u === "scale" || u === "zoom") && (t.on("mousewheel", s), t.on("pinch", l));
      }, n.disable = function() {
        t.off("mousedown", i), t.off("mousemove", a), t.off("mouseup", o), t.off("mousewheel", s), t.off("pinch", l);
      }, n;
    }
    return e.prototype.isDragging = function() {
      return this._dragging;
    }, e.prototype.isPinching = function() {
      return this._pinching;
    }, e.prototype.setPointerChecker = function(t) {
      this.pointerChecker = t;
    }, e.prototype.dispose = function() {
      this.disable();
    }, e.prototype._mousedownHandler = function(t) {
      if (!Dp(t)) {
        for (var n = t.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var i = t.offsetX, a = t.offsetY;
        this.pointerChecker && this.pointerChecker(t, i, a) && (this._x = i, this._y = a, this._dragging = !0);
      }
    }, e.prototype._mousemoveHandler = function(t) {
      if (!(!this._dragging || !eu("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || U2(this._zr, "globalPan"))) {
        var n = t.offsetX, i = t.offsetY, a = this._x, o = this._y, s = n - a, l = i - o;
        this._x = n, this._y = i, this._opt.preventDefaultMouseMove && Qr(t.event), E5(this, "pan", "moveOnMouseMove", t, {
          dx: s,
          dy: l,
          oldX: a,
          oldY: o,
          newX: n,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, e.prototype._mouseupHandler = function(t) {
      Dp(t) || (this._dragging = !1);
    }, e.prototype._mousewheelHandler = function(t) {
      var n = eu("zoomOnMouseWheel", t, this._opt), i = eu("moveOnMouseWheel", t, this._opt), a = t.wheelDelta, o = Math.abs(a), s = t.offsetX, l = t.offsetY;
      if (!(a === 0 || !n && !i)) {
        if (n) {
          var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, f = a > 0 ? u : 1 / u;
          dh(this, "zoom", "zoomOnMouseWheel", t, {
            scale: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var c = Math.abs(a), h = (a > 0 ? 1 : -1) * (c > 3 ? 0.4 : c > 1 ? 0.15 : 0.05);
          dh(this, "scrollMove", "moveOnMouseWheel", t, {
            scrollDelta: h,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, e.prototype._pinchHandler = function(t) {
      if (!U2(this._zr, "globalPan")) {
        var n = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
        dh(this, "zoom", null, t, {
          scale: n,
          originX: t.pinchX,
          originY: t.pinchY,
          isAvailableBehavior: null
        });
      }
    }, e;
  }(vr)
);
function dh(r, e, t, n, i) {
  r.pointerChecker && r.pointerChecker(n, i.originX, i.originY) && (Qr(n.event), E5(r, e, t, n, i));
}
function E5(r, e, t, n, i) {
  i.isAvailableBehavior = dist_Z(eu, null, t, n), r.trigger(e, i);
}
function eu(r, e, t) {
  var n = t[r];
  return !r || n && (!dist_U(n) || e.event[n + "Key"]);
}
const D0 = xN;
function A5(r, e, t) {
  var n = r.target;
  n.x += e, n.y += t, n.dirty();
}
function I5(r, e, t, n) {
  var i = r.target, a = r.zoomLimit, o = r.zoom = r.zoom || 1;
  if (o *= e, a) {
    var s = a.min || 0, l = a.max || 1 / 0;
    o = Math.max(Math.min(l, o), s);
  }
  var u = o / r.zoom;
  r.zoom = o, i.x -= (t - i.x) * (u - 1), i.y -= (n - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
}
var CN = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function L5(r, e, t) {
  var n = e.getComponentByElement(r.topTarget), i = n && n.coordinateSystem;
  return n && n !== t && !CN.hasOwnProperty(n.mainType) && i && i.model !== t;
}
function N5(r) {
  if (dist_U(r)) {
    var e = new DOMParser();
    r = e.parseFromString(r, "text/xml");
  }
  var t = r;
  for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1; )
    t = t.nextSibling;
  return t;
}
var ph, Bu = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, Y2 = we(Bu), Fu = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, X2 = we(Fu), TN = function() {
  function r() {
    this._defs = {}, this._root = null;
  }
  return r.prototype.parse = function(e, t) {
    t = t || {};
    var n = N5(e);
    if (false)
      {}
    this._defsUsePending = [];
    var i = new dist_oe();
    this._root = i;
    var a = [], o = n.getAttribute("viewBox") || "", s = parseFloat(n.getAttribute("width") || t.width), l = parseFloat(n.getAttribute("height") || t.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), Mt(n, i, null, !0, !1);
    for (var u = n.firstChild; u; )
      this._parseNode(u, i, a, null, !1, !1), u = u.nextSibling;
    EN(this._defs, this._defsUsePending), this._defsUsePending = [];
    var f, c;
    if (o) {
      var h = Pf(o);
      h.length >= 4 && (f = {
        x: parseFloat(h[0] || 0),
        y: parseFloat(h[1] || 0),
        width: parseFloat(h[2]),
        height: parseFloat(h[3])
      });
    }
    if (f && s != null && l != null && (c = R5(f, { x: 0, y: 0, width: s, height: l }), !t.ignoreViewBox)) {
      var v = i;
      i = new dist_oe(), i.add(v), v.scaleX = v.scaleY = c.scale, v.x = c.x, v.y = c.y;
    }
    return !t.ignoreRootClip && s != null && l != null && i.setClipPath(new xe({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: i,
      width: s,
      height: l,
      viewBoxRect: f,
      viewBoxTransform: c,
      named: a
    };
  }, r.prototype._parseNode = function(e, t, n, i, a, o) {
    var s = e.nodeName.toLowerCase(), l, u = i;
    if (s === "defs" && (a = !0), s === "text" && (o = !0), s === "defs" || s === "switch")
      l = t;
    else {
      if (!a) {
        var f = ph[s];
        if (f && xt(ph, s)) {
          l = f.call(this, e, t);
          var c = e.getAttribute("name");
          if (c) {
            var h = {
              name: c,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            n.push(h), s === "g" && (u = h);
          } else
            i && n.push({
              name: i.name,
              namedFrom: i,
              svgNodeTagLower: s,
              el: l
            });
          t.add(l);
        }
      }
      var v = Z2[s];
      if (v && xt(Z2, s)) {
        var d = v.call(this, e), g = e.getAttribute("id");
        g && (this._defs[g] = d);
      }
    }
    if (l && l.isGroup)
      for (var p = e.firstChild; p; )
        p.nodeType === 1 ? this._parseNode(p, l, n, u, a, o) : p.nodeType === 3 && o && this._parseText(p, l), p = p.nextSibling;
  }, r.prototype._parseText = function(e, t) {
    var n = new pu({
      style: {
        text: e.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    Ft(t, n), Mt(e, n, this._defsUsePending, !1, !1), MN(n, t);
    var i = n.style, a = i.fontSize;
    a && a < 9 && (i.fontSize = 9, n.scaleX *= a / 9, n.scaleY *= a / 9);
    var o = (i.fontSize || i.fontFamily) && [
      i.fontStyle,
      i.fontWeight,
      (i.fontSize || 12) + "px",
      i.fontFamily || "sans-serif"
    ].join(" ");
    i.font = o;
    var s = n.getBoundingRect();
    return this._textX += s.width, t.add(n), n;
  }, r.internalField = function() {
    ph = {
      g: function(e, t) {
        var n = new dist_oe();
        return Ft(t, n), Mt(e, n, this._defsUsePending, !1, !1), n;
      },
      rect: function(e, t) {
        var n = new xe();
        return Ft(t, n), Mt(e, n, this._defsUsePending, !1, !1), n.setShape({
          x: parseFloat(e.getAttribute("x") || "0"),
          y: parseFloat(e.getAttribute("y") || "0"),
          width: parseFloat(e.getAttribute("width") || "0"),
          height: parseFloat(e.getAttribute("height") || "0")
        }), n.silent = !0, n;
      },
      circle: function(e, t) {
        var n = new As();
        return Ft(t, n), Mt(e, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          r: parseFloat(e.getAttribute("r") || "0")
        }), n.silent = !0, n;
      },
      line: function(e, t) {
        var n = new an();
        return Ft(t, n), Mt(e, n, this._defsUsePending, !1, !1), n.setShape({
          x1: parseFloat(e.getAttribute("x1") || "0"),
          y1: parseFloat(e.getAttribute("y1") || "0"),
          x2: parseFloat(e.getAttribute("x2") || "0"),
          y2: parseFloat(e.getAttribute("y2") || "0")
        }), n.silent = !0, n;
      },
      ellipse: function(e, t) {
        var n = new zd();
        return Ft(t, n), Mt(e, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          rx: parseFloat(e.getAttribute("rx") || "0"),
          ry: parseFloat(e.getAttribute("ry") || "0")
        }), n.silent = !0, n;
      },
      polygon: function(e, t) {
        var n = e.getAttribute("points"), i;
        n && (i = j2(n));
        var a = new Un({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Ft(t, a), Mt(e, a, this._defsUsePending, !1, !1), a;
      },
      polyline: function(e, t) {
        var n = e.getAttribute("points"), i;
        n && (i = j2(n));
        var a = new cn({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Ft(t, a), Mt(e, a, this._defsUsePending, !1, !1), a;
      },
      image: function(e, t) {
        var n = new un();
        return Ft(t, n), Mt(e, n, this._defsUsePending, !1, !1), n.setStyle({
          image: e.getAttribute("xlink:href") || e.getAttribute("href"),
          x: +e.getAttribute("x"),
          y: +e.getAttribute("y"),
          width: +e.getAttribute("width"),
          height: +e.getAttribute("height")
        }), n.silent = !0, n;
      },
      text: function(e, t) {
        var n = e.getAttribute("x") || "0", i = e.getAttribute("y") || "0", a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0";
        this._textX = parseFloat(n) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(o);
        var s = new dist_oe();
        return Ft(t, s), Mt(e, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(e, t) {
        var n = e.getAttribute("x"), i = e.getAttribute("y");
        n != null && (this._textX = parseFloat(n)), i != null && (this._textY = parseFloat(i));
        var a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0", s = new dist_oe();
        return Ft(t, s), Mt(e, s, this._defsUsePending, !1, !0), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
      },
      path: function(e, t) {
        var n = e.getAttribute("d") || "", i = N_(n);
        return Ft(t, i), Mt(e, i, this._defsUsePending, !1, !1), i.silent = !0, i;
      }
    };
  }(), r;
}(), Z2 = {
  lineargradient: function(r) {
    var e = parseInt(r.getAttribute("x1") || "0", 10), t = parseInt(r.getAttribute("y1") || "0", 10), n = parseInt(r.getAttribute("x2") || "10", 10), i = parseInt(r.getAttribute("y2") || "0", 10), a = new vf(e, t, n, i);
    return q2(r, a), K2(r, a), a;
  },
  radialgradient: function(r) {
    var e = parseInt(r.getAttribute("cx") || "0", 10), t = parseInt(r.getAttribute("cy") || "0", 10), n = parseInt(r.getAttribute("r") || "0", 10), i = new U_(e, t, n);
    return q2(r, i), K2(r, i), i;
  }
};
function q2(r, e) {
  var t = r.getAttribute("gradientUnits");
  t === "userSpaceOnUse" && (e.global = !0);
}
function K2(r, e) {
  for (var t = r.firstChild; t; ) {
    if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") {
      var n = t.getAttribute("offset"), i = void 0;
      n && n.indexOf("%") > 0 ? i = parseInt(n, 10) / 100 : n ? i = parseFloat(n) : i = 0;
      var a = {};
      P5(t, a, a);
      var o = a.stopColor || t.getAttribute("stop-color") || "#000000";
      e.colorStops.push({
        offset: i,
        color: o
      });
    }
    t = t.nextSibling;
  }
}
function Ft(r, e) {
  r && r.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), dist_se(e.__inheritedStyle, r.__inheritedStyle));
}
function j2(r) {
  for (var e = Pf(r), t = [], n = 0; n < e.length; n += 2) {
    var i = parseFloat(e[n]), a = parseFloat(e[n + 1]);
    t.push([i, a]);
  }
  return t;
}
function Mt(r, e, t, n, i) {
  var a = e, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
  r.nodeType === 1 && (LN(r, e), P5(r, o, s), n || NN(r, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = J2(a, "fill", o.fill, t)), o.stroke != null && (a.style.stroke = J2(a, "stroke", o.stroke, t)), dist_M([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    o[l] != null && (a.style[l] = parseFloat(o[l]));
  }), dist_M([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    o[l] != null && (a.style[l] = o[l]);
  }), i && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = dist_$(Pf(o.lineDash), function(l) {
    return parseFloat(l);
  })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = !0), o.display === "none" && (a.ignore = !0);
}
function MN(r, e) {
  var t = e.__selfStyle;
  if (t) {
    var n = t.textBaseline, i = n;
    !n || n === "auto" || n === "baseline" ? i = "alphabetic" : n === "before-edge" || n === "text-before-edge" ? i = "top" : n === "after-edge" || n === "text-after-edge" ? i = "bottom" : (n === "central" || n === "mathematical") && (i = "middle"), r.style.textBaseline = i;
  }
  var a = e.__inheritedStyle;
  if (a) {
    var o = a.textAlign, s = o;
    o && (o === "middle" && (s = "center"), r.style.textAlign = s);
  }
}
var DN = /^url\(\s*#(.*?)\)/;
function J2(r, e, t, n) {
  var i = t && t.match(DN);
  if (i) {
    var a = or(i[1]);
    n.push([r, e, a]);
    return;
  }
  return t === "none" && (t = null), t;
}
function EN(r, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n[0].style[n[1]] = r[n[2]];
  }
}
var AN = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function Pf(r) {
  return r.match(AN) || [];
}
var IN = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, gh = Math.PI / 180;
function LN(r, e) {
  var t = r.getAttribute("transform");
  if (t) {
    t = t.replace(/,/g, " ");
    var n = [], i = null;
    t.replace(IN, function(c, h, v) {
      return n.push(h, v), "";
    });
    for (var a = n.length - 1; a > 0; a -= 2) {
      var o = n[a], s = n[a - 1], l = Pf(o);
      switch (i = i || Yr(), s) {
        case "translate":
          lu(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          C3(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          nf(i, i, -parseFloat(l[0]) * gh, [
            parseFloat(l[1] || "0"),
            parseFloat(l[2] || "0")
          ]);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * gh);
          Xr(i, [1, 0, u, 1, 0, 0], i);
          break;
        case "skewY":
          var f = Math.tan(parseFloat(l[0]) * gh);
          Xr(i, [1, f, 0, 1, 0, 0], i);
          break;
        case "matrix":
          i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
          break;
      }
    }
    e.setLocalTransform(i);
  }
}
var Q2 = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function P5(r, e, t) {
  var n = r.getAttribute("style");
  if (n) {
    Q2.lastIndex = 0;
    for (var i; (i = Q2.exec(n)) != null; ) {
      var a = i[1], o = xt(Bu, a) ? Bu[a] : null;
      o && (e[o] = i[2]);
      var s = xt(Fu, a) ? Fu[a] : null;
      s && (t[s] = i[2]);
    }
  }
}
function NN(r, e, t) {
  for (var n = 0; n < Y2.length; n++) {
    var i = Y2[n], a = r.getAttribute(i);
    a != null && (e[Bu[i]] = a);
  }
  for (var n = 0; n < X2.length; n++) {
    var i = X2[n], a = r.getAttribute(i);
    a != null && (t[Fu[i]] = a);
  }
}
function R5(r, e) {
  var t = e.width / r.width, n = e.height / r.height, i = Math.min(t, n);
  return {
    scale: i,
    x: -(r.x + r.width / 2) * i + (e.x + e.width / 2),
    y: -(r.y + r.height / 2) * i + (e.y + e.height / 2)
  };
}
function PN(r, e) {
  var t = new TN();
  return t.parse(r, e);
}
var RN = dist_W([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), ON = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = "geoSVG", this._usedGraphicMap = dist_W(), this._freedGraphics = [], this._mapName = e, this._parsedXML = N5(t);
    }
    return r.prototype.load = function() {
      var e = this._firstGraphic;
      if (!e) {
        e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var t = VN(e.named), n = t.regions, i = t.regionsMap;
        this._regions = n, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, r.prototype._buildGraphic = function(e) {
      var t, n;
      try {
        t = e && PN(e, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, n = t.root, dist_re(n != null);
      } catch (p) {
        throw new Error(`Invalid svg format
` + p.message);
      }
      var i = new dist_oe();
      i.add(n), i.isGeoSVGGraphicRoot = !0;
      var a = t.width, o = t.height, s = t.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, f = void 0, c = void 0, h = void 0;
        if (a != null ? (u = 0, c = a) : s && (u = s.x, c = s.width), o != null ? (f = 0, h = o) : s && (f = s.y, h = s.height), u == null || f == null) {
          var v = n.getBoundingRect();
          u == null && (u = v.x, c = v.width), f == null && (f = v.y, h = v.height);
        }
        l = this._boundingRect = new dist_ae(u, f, c, h);
      }
      if (s) {
        var d = R5(s, l);
        n.scaleX = n.scaleY = d.scale, n.x = d.x, n.y = d.y;
      }
      i.setClipPath(new xe({
        shape: l.plain()
      }));
      var g = [];
      return dist_M(t.named, function(p) {
        RN.get(p.svgNodeTagLower) != null && (g.push(p), kN(p.el));
      }), {
        root: i,
        boundingRect: l,
        named: g
      };
    }, r.prototype.useGraphic = function(e) {
      var t = this._usedGraphicMap, n = t.get(e);
      return n || (n = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, n), n);
    }, r.prototype.freeGraphic = function(e) {
      var t = this._usedGraphicMap, n = t.get(e);
      n && (t.removeKey(e), this._freedGraphics.push(n));
    }, r;
  }()
);
function kN(r) {
  r.silent = !1, r.isGroup && r.traverse(function(e) {
    e.silent = !1;
  });
}
function VN(r) {
  var e = [], t = dist_W();
  return dist_M(r, function(n) {
    if (n.namedFrom == null) {
      var i = new vI(n.name, n.el);
      e.push(i), t.set(n.name, i);
    }
  }), {
    regions: e,
    regionsMap: t
  };
}
var qv = [126, 25], em = "南海诸岛", mi = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var pi = 0; pi < mi.length; pi++)
  for (var sa = 0; sa < mi[pi].length; sa++)
    mi[pi][sa][0] /= 10.5, mi[pi][sa][1] /= -10.5 / 0.75, mi[pi][sa][0] += qv[0], mi[pi][sa][1] += qv[1];
function BN(r, e) {
  if (r === "china") {
    for (var t = 0; t < e.length; t++)
      if (e[t].name === em)
        return;
    e.push(new W6(em, dist_$(mi, function(n) {
      return {
        type: "polygon",
        exterior: n
      };
    }), qv));
  }
}
var FN = {
  南海诸岛: [32, 80],
  // 全国
  广东: [0, -10],
  香港: [10, 5],
  澳门: [-10, 10],
  // '北京': [-10, 0],
  天津: [5, 5]
};
function zN(r, e) {
  if (r === "china") {
    var t = FN[e.name];
    if (t) {
      var n = e.getCenter();
      n[0] += t[0] / 10.5, n[1] += -t[1] / (10.5 / 0.75), e.setCenter(n);
    }
  }
}
var GN = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function HN(r, e) {
  r === "china" && e.name === "台湾" && e.geometries.push({
    type: "polygon",
    exterior: GN[0]
  });
}
var $N = "name", WN = (
  /** @class */
  function() {
    function r(e, t, n) {
      this.type = "geoJSON", this._parsedMap = dist_W(), this._mapName = e, this._specialAreas = n, this._geoJSON = YN(t);
    }
    return r.prototype.load = function(e, t) {
      t = t || $N;
      var n = this._parsedMap.get(t);
      if (!n) {
        var i = this._parseToRegions(t);
        n = this._parsedMap.set(t, {
          regions: i,
          boundingRect: UN(i)
        });
      }
      var a = dist_W(), o = [];
      return dist_M(n.regions, function(s) {
        var l = s.name;
        e && xt(e, l) && (s = s.cloneShallow(l = e[l])), o.push(s), a.set(l, s);
      }), {
        regions: o,
        boundingRect: n.boundingRect || new dist_ae(0, 0, 0, 0),
        regionsMap: a
      };
    }, r.prototype._parseToRegions = function(e) {
      var t = this._mapName, n = this._geoJSON, i;
      try {
        i = n ? pI(n, e) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return BN(t, i), dist_M(i, function(a) {
        var o = a.name;
        zN(t, a), HN(t, a);
        var s = this._specialAreas && this._specialAreas[o];
        s && a.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, r.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, r;
  }()
);
function UN(r) {
  for (var e, t = 0; t < r.length; t++) {
    var n = r[t].getBoundingRect();
    e = e || n.clone(), e.union(n);
  }
  return e;
}
function YN(r) {
  return dist_U(r) ? typeof JSON < "u" && JSON.parse ? JSON.parse(r) : new Function("return (" + r + ");")() : r;
}
var So = dist_W();
const sn = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(r, e, t) {
    if (e.svg) {
      var n = new ON(r, e.svg);
      So.set(r, n);
    } else {
      var i = e.geoJson || e.geoJSON;
      i && !e.features ? t = e.specialAreas : i = e;
      var n = new WN(r, i, t);
      So.set(r, n);
    }
  },
  getGeoResource: function(r) {
    return So.get(r);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(r) {
    var e = So.get(r);
    return e && e.type === "geoJSON" && e.getMapForUser();
  },
  load: function(r, e, t) {
    var n = So.get(r);
    if (!n) {
      "production";
      return;
    }
    return n.load(e, t);
  }
};
var E0 = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], XN = dist_W(E0), ZN = dist_W(E0.concat(["g"])), qN = dist_W(E0.concat(["g"])), O5 = Me();
function Il(r) {
  var e = r.getItemStyle(), t = r.get("areaColor");
  return t != null && (e.fill = t), e;
}
function tm(r) {
  var e = r.style;
  e && (e.stroke = e.stroke || e.fill, e.fill = null);
}
var KN = (
  /** @class */
  function() {
    function r(e) {
      var t = new dist_oe();
      this.uid = Ls("ec_map_draw"), this._controller = new D0(e.getZr()), this._controllerHost = {
        target: t
      }, this.group = t, t.add(this._regionsGroup = new dist_oe()), t.add(this._svgGroup = new dist_oe());
    }
    return r.prototype.draw = function(e, t, n, i, a) {
      var o = e.mainType === "geo", s = e.getData && e.getData();
      o && t.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(m) {
        !s && m.getHostGeoModel() === e && (s = m.getData());
      });
      var l = e.coordinateSystem, u = this._regionsGroup, f = this.group, c = l.getTransformInfo(), h = c.raw, v = c.roam, d = !u.childAt(0) || a;
      d ? (f.x = v.x, f.y = v.y, f.scaleX = v.scaleX, f.scaleY = v.scaleY, f.dirty()) : Pe(f, v, e);
      var g = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, p = {
        api: n,
        geo: l,
        mapOrGeoModel: e,
        data: s,
        isVisualEncodedByVisualMap: g,
        isGeo: o,
        transformInfoRaw: h
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(p) : l.resourceType === "geoSVG" && this._buildSVG(p), this._updateController(e, t, n), this._updateMapSelectHandler(e, u, n, i);
    }, r.prototype._buildGeoJSON = function(e) {
      var t = this._regionsGroupByName = dist_W(), n = dist_W(), i = this._regionsGroup, a = e.transformInfoRaw, o = e.mapOrGeoModel, s = e.data, l = e.geo.projection, u = l && l.stream;
      function f(v, d) {
        return d && (v = d(v)), v && [v[0] * a.scaleX + a.x, v[1] * a.scaleY + a.y];
      }
      function c(v) {
        for (var d = [], g = !u && l && l.project, p = 0; p < v.length; ++p) {
          var m = f(v[p], g);
          m && d.push(m);
        }
        return d;
      }
      function h(v) {
        return {
          shape: {
            points: c(v)
          }
        };
      }
      i.removeAll(), dist_M(e.geo.regions, function(v) {
        var d = v.name, g = t.get(d), p = n.get(d) || {}, m = p.dataIdx, y = p.regionModel;
        g || (g = t.set(d, new dist_oe()), i.add(g), m = s ? s.indexOfName(d) : null, y = e.isGeo ? o.getRegionModel(d) : s ? s.getItemModel(m) : null, n.set(d, {
          dataIdx: m,
          regionModel: y
        }));
        var _ = [], S = [];
        dist_M(v.geometries, function(x) {
          if (x.type === "polygon") {
            var C = [x.exterior].concat(x.interiors || []);
            u && (C = sm(C, u)), dist_M(C, function(E) {
              _.push(new Un(h(E)));
            });
          } else {
            var T = x.points;
            u && (T = sm(T, u, !0)), dist_M(T, function(E) {
              S.push(new cn(h(E)));
            });
          }
        });
        var b = f(v.getCenter(), l && l.project);
        function w(x, C) {
          if (x.length) {
            var T = new $_({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: x
              }
            });
            g.add(T), rm(e, T, m, y), nm(e, T, d, y, o, m, b), C && (tm(T), dist_M(T.states, tm));
          }
        }
        w(_), w(S, !0);
      }), t.each(function(v, d) {
        var g = n.get(d), p = g.dataIdx, m = g.regionModel;
        im(e, v, d, m, o, p), am(e, v, d, m, o), om(e, v, d, m, o);
      }, this);
    }, r.prototype._buildSVG = function(e) {
      var t = e.geo.map, n = e.transformInfoRaw;
      this._svgGroup.x = n.x, this._svgGroup.y = n.y, this._svgGroup.scaleX = n.scaleX, this._svgGroup.scaleY = n.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t));
      var i = this._svgDispatcherMap = dist_W(), a = !1;
      dist_M(this._svgGraphicRecord.named, function(o) {
        var s = o.name, l = e.mapOrGeoModel, u = e.data, f = o.svgNodeTagLower, c = o.el, h = u ? u.indexOfName(s) : null, v = l.getRegionModel(s);
        if (XN.get(f) != null && c instanceof Wn && rm(e, c, h, v), c instanceof Wn && (c.culling = !0), c.z2EmphasisLift = 0, !o.namedFrom && (qN.get(f) != null && nm(e, c, s, v, l, h, null), im(e, c, s, v, l, h), am(e, c, s, v, l), ZN.get(f) != null)) {
          var d = om(e, c, s, v, l);
          d === "self" && (a = !0);
          var g = i.get(s) || i.set(s, []);
          g.push(c);
        }
      }, this), this._enableBlurEntireSVG(a, e);
    }, r.prototype._enableBlurEntireSVG = function(e, t) {
      if (e && t.isGeo) {
        var n = t.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), i = n.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            kd(a);
            var o = a.ensureState("blur").style || {};
            o.opacity == null && i != null && (o.opacity = i), a.ensureState("emphasis");
          }
        });
      }
    }, r.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, r.prototype.findHighDownDispatchers = function(e, t) {
      if (e == null)
        return [];
      var n = t.coordinateSystem;
      if (n.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var a = i.get(e);
          return a ? [a] : [];
        }
      } else if (n.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [];
    }, r.prototype._svgResourceChanged = function(e) {
      return this._svgMapName !== e;
    }, r.prototype._useSVG = function(e) {
      var t = sn.getGeoResource(e);
      if (t && t.type === "geoSVG") {
        var n = t.useGraphic(this.uid);
        this._svgGroup.add(n.root), this._svgGraphicRecord = n, this._svgMapName = e;
      }
    }, r.prototype._freeSVG = function() {
      var e = this._svgMapName;
      if (e != null) {
        var t = sn.getGeoResource(e);
        t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, r.prototype._updateController = function(e, t, n) {
      var i = e.coordinateSystem, a = this._controller, o = this._controllerHost;
      o.zoomLimit = e.get("scaleLimit"), o.zoom = i.getZoom(), a.enable(e.get("roam") || !1);
      var s = e.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = e.id, u;
      }
      a.off("pan").on("pan", function(u) {
        this._mouseDownFlag = !1, A5(o, u.dx, u.dy), n.dispatchAction(dist_V(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), a.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = !1, I5(o, u.scale, u.originX, u.originY), n.dispatchAction(dist_V(l(), {
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), a.setPointerChecker(function(u, f, c) {
        return i.containPoint([f, c]) && !L5(u, n, e);
      });
    }, r.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(e) {
        var t = e.getTextContent();
        t && (t.ignore = O5(t).ignore);
      });
    }, r.prototype._updateMapSelectHandler = function(e, t, n, i) {
      var a = this;
      t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function() {
        a._mouseDownFlag = !0;
      }), t.on("click", function(o) {
        a._mouseDownFlag && (a._mouseDownFlag = !1);
      }));
    }, r;
  }()
);
function rm(r, e, t, n) {
  var i = n.getModel("itemStyle"), a = n.getModel(["emphasis", "itemStyle"]), o = n.getModel(["blur", "itemStyle"]), s = n.getModel(["select", "itemStyle"]), l = Il(i), u = Il(a), f = Il(s), c = Il(o), h = r.data;
  if (h) {
    var v = h.getItemVisual(t, "style"), d = h.getItemVisual(t, "decal");
    r.isVisualEncodedByVisualMap && v.fill && (l.fill = v.fill), d && (l.decal = Nu(d, r.api));
  }
  e.setStyle(l), e.style.strokeNoScale = !0, e.ensureState("emphasis").style = u, e.ensureState("select").style = f, e.ensureState("blur").style = c, kd(e);
}
function nm(r, e, t, n, i, a, o) {
  var s = r.data, l = r.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), f = s && s.getItemLayout(a);
  if (l || u || f && f.showLabel) {
    var c = l ? t : a, h = void 0;
    (!s || a >= 0) && (h = i);
    var v = o ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    Yn(e, hn(n), {
      labelFetcher: h,
      labelDataIndex: c,
      defaultText: t
    }, v);
    var d = e.getTextContent();
    if (d && (O5(d).ignore = d.ignore, e.textConfig && o)) {
      var g = e.getBoundingRect().clone();
      e.textConfig.layoutRect = g, e.textConfig.position = [(o[0] - g.x) / g.width * 100 + "%", (o[1] - g.y) / g.height * 100 + "%"];
    }
    e.disableLabelAnimation = !0;
  } else
    e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null;
}
function im(r, e, t, n, i, a) {
  r.data ? r.data.setItemGraphicEl(a, e) : dist_ie(e).eventData = {
    componentType: "geo",
    componentIndex: i.componentIndex,
    geoIndex: i.componentIndex,
    name: t,
    region: n && n.option || {}
  };
}
function am(r, e, t, n, i) {
  r.data || pf({
    el: e,
    componentModel: i,
    itemName: t,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: n.get("tooltip")
  });
}
function om(r, e, t, n, i) {
  e.highDownSilentOnTouch = !!i.get("selectedMode");
  var a = n.getModel("emphasis"), o = a.get("focus");
  return rn(e, o, a.get("blurScope"), a.get("disabled")), r.isGeo && KT(e, i, t), o;
}
function sm(r, e, t) {
  var n = [], i;
  function a() {
    i = [];
  }
  function o() {
    i.length && (n.push(i), i = []);
  }
  var s = e({
    polygonStart: a,
    polygonEnd: o,
    lineStart: a,
    lineEnd: o,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !t && s.polygonStart(), dist_M(r, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !t && s.polygonEnd(), n;
}
const k5 = KN;
var jN = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var o = this.group;
        if (o.removeAll(), !t.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === t.id) {
            var s = this._mapDraw;
            s && o.add(s.group);
          } else if (t.needsDrawMap) {
            var s = this._mapDraw || new k5(i);
            o.add(s.group), s.draw(t, n, i, this, a), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          t.get("showLegendSymbol") && n.getComponent("legend") && this._renderSymbols(t, n, i);
        }
      }
    }, e.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, e.prototype._renderSymbols = function(t, n, i) {
      var a = t.originalData, o = this.group;
      a.each(a.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var f = u.point, c = u.offset, h = new As({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: t.getData().getVisual("style").fill
              },
              shape: {
                cx: f[0] + c * 9,
                cy: f[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (c ? 0 : __ + 1)
            });
            if (!c) {
              var v = t.mainSeries.getData(), d = a.getName(l), g = v.indexOfName(d), p = a.getItemModel(l), m = p.getModel("label"), y = v.getItemGraphicEl(g);
              Yn(h, hn(p), {
                labelFetcher: {
                  getFormattedLabel: function(_, S) {
                    return t.getFormattedLabel(g, S);
                  }
                },
                defaultText: d
              }), h.disableLabelAnimation = !0, m.get("position") || h.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(_) {
                _v(h, _);
              };
            }
            o.add(h);
          }
        }
      });
    }, e.type = "map", e;
  }(bt)
);
const JN = jN;
var QN = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.needsDrawMap = !1, t.seriesGroup = [], t.getTooltipPosition = function(n) {
        if (n != null) {
          var i = this.getData().getName(n), a = this.coordinateSystem, o = a.getRegion(i);
          return o && a.dataToPoint(o.getCenter());
        }
      }, t;
    }
    return e.prototype.getInitialData = function(t) {
      for (var n = S5(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Te(m4, this)
      }), i = dist_W(), a = [], o = 0, s = n.count(); o < s; o++) {
        var l = n.getName(o);
        i.set(l, !0);
      }
      var u = sn.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return dist_M(u.regions, function(f) {
        var c = f.name;
        i.get(c) || a.push(c);
      }), n.appendValues([], a), n;
    }, e.prototype.getHostGeoModel = function() {
      var t = this.option.geoIndex;
      return t != null ? this.ecModel.getComponent("geo", t) : null;
    }, e.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, e.prototype.getRawValue = function(t) {
      var n = this.getData();
      return n.get(n.mapDimension("value"), t);
    }, e.prototype.getRegionModel = function(t) {
      var n = this.getData();
      return n.getItemModel(n.indexOfName(t));
    }, e.prototype.formatTooltip = function(t, n, i) {
      for (var a = this.getData(), o = this.getRawValue(t), s = a.getName(t), l = this.seriesGroup, u = [], f = 0; f < l.length; f++) {
        var c = l[f].originalData.indexOfName(s), h = a.mapDimension("value");
        isNaN(l[f].originalData.get(h, c)) || u.push(l[f].name);
      }
      return on("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [on("nameValue", {
          name: s,
          value: o
        })]
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.getLegendIcon = function(t) {
      var n = t.icon || "roundRect", i = dt(n, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
      return i.setStyle(t.itemStyle), i.style.stroke = "none", n.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, e.type = "series.map", e.dependencies = ["geo"], e.layoutMode = "box", e.defaultOption = {
      // 一级层叠
      // zlevel: 0,
      // 二级层叠
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, e;
  }(jt)
);
const eP = QN;
function tP(r, e) {
  var t = {};
  return dist_M(r, function(n) {
    n.each(n.mapDimension("value"), function(i, a) {
      var o = "ec-" + n.getName(a);
      t[o] = t[o] || [], isNaN(i) || t[o].push(i);
    });
  }), r[0].map(r[0].mapDimension("value"), function(n, i) {
    for (var a = "ec-" + r[0].getName(i), o = 0, s = 1 / 0, l = -1 / 0, u = t[a].length, f = 0; f < u; f++)
      s = Math.min(s, t[a][f]), l = Math.max(l, t[a][f]), o += t[a][f];
    var c;
    return e === "min" ? c = s : e === "max" ? c = l : e === "average" ? c = o / u : c = o, u === 0 ? NaN : c;
  });
}
function rP(r) {
  var e = {};
  r.eachSeriesByType("map", function(t) {
    var n = t.getHostGeoModel(), i = n ? "o" + n.id : "i" + t.getMapType();
    (e[i] = e[i] || []).push(t);
  }), dist_M(e, function(t, n) {
    for (var i = tP(dist_$(t, function(o) {
      return o.getData();
    }), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++)
      t[a].originalData = t[a].getData();
    for (var a = 0; a < t.length; a++)
      t[a].seriesGroup = t, t[a].needsDrawMap = a === 0 && !t[a].getHostGeoModel(), t[a].setData(i.cloneShallow()), t[a].mainSeries = t[0];
  });
}
function nP(r) {
  var e = {};
  r.eachSeriesByType("map", function(t) {
    var n = t.getMapType();
    if (!(t.getHostGeoModel() || e[n])) {
      var i = {};
      dist_M(t.seriesGroup, function(o) {
        var s = o.coordinateSystem, l = o.originalData;
        o.get("showLegendSymbol") && r.getComponent("legend") && l.each(l.mapDimension("value"), function(u, f) {
          var c = l.getName(f), h = s.getRegion(c);
          if (!(!h || isNaN(u))) {
            var v = i[c] || 0, d = s.dataToPoint(h.getCenter());
            i[c] = v + 1, l.setItemLayout(f, {
              point: d,
              offset: v
            });
          }
        });
      });
      var a = t.getData();
      a.each(function(o) {
        var s = a.getName(o), l = a.getItemLayout(o) || {};
        l.showLabel = !i[s], a.setItemLayout(o, l);
      }), e[n] = !0;
    }
  });
}
var lm = Xe, Rf = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this) || this;
      return n.type = "view", n.dimensions = ["x", "y"], n._roamTransformable = new Fr(), n._rawTransformable = new Fr(), n.name = t, n;
    }
    return e.prototype.setBoundingRect = function(t, n, i, a) {
      return this._rect = new dist_ae(t, n, i, a), this._rect;
    }, e.prototype.getBoundingRect = function() {
      return this._rect;
    }, e.prototype.setViewRect = function(t, n, i, a) {
      this._transformTo(t, n, i, a), this._viewRect = new dist_ae(t, n, i, a);
    }, e.prototype._transformTo = function(t, n, i, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new dist_ae(t, n, i, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, e.prototype.setCenter = function(t, n) {
      t && (this._center = [me(t[0], n.getWidth()), me(t[1], n.getHeight())], this._updateCenterAndZoom());
    }, e.prototype.setZoom = function(t) {
      t = t || 1;
      var n = this.zoomLimit;
      n && (n.max != null && (t = Math.min(n.max, t)), n.min != null && (t = Math.max(n.min, t))), this._zoom = t, this._updateCenterAndZoom();
    }, e.prototype.getDefaultCenter = function() {
      var t = this.getBoundingRect(), n = t.x + t.width / 2, i = t.y + t.height / 2;
      return [n, i];
    }, e.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, e.prototype.getZoom = function() {
      return this._zoom || 1;
    }, e.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, e.prototype._updateCenterAndZoom = function() {
      var t = this._rawTransformable.getLocalTransform(), n = this._roamTransformable, i = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
      a = Xe([], a, t), i = Xe([], i, t), n.originX = a[0], n.originY = a[1], n.x = i[0] - a[0], n.y = i[1] - a[1], n.scaleX = n.scaleY = o, this._updateTransform();
    }, e.prototype._updateTransform = function() {
      var t = this._roamTransformable, n = this._rawTransformable;
      n.parent = t, t.updateTransform(), n.updateTransform(), Cd(this.transform || (this.transform = []), n.transform || Yr()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], Ua(this.invTransform, this.transform), this.decomposeTransform();
    }, e.prototype.getTransformInfo = function() {
      var t = this._rawTransformable, n = this._roamTransformable, i = new Fr();
      return i.transform = n.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: t.x,
          y: t.y,
          scaleX: t.scaleX,
          scaleY: t.scaleY
        }
      };
    }, e.prototype.getViewRect = function() {
      return this._viewRect;
    }, e.prototype.getViewRectAfterRoam = function() {
      var t = this.getBoundingRect().clone();
      return t.applyTransform(this.transform), t;
    }, e.prototype.dataToPoint = function(t, n, i) {
      var a = n ? this._rawTransform : this.transform;
      return i = i || [], a ? lm(i, t, a) : st(i, t);
    }, e.prototype.pointToData = function(t) {
      var n = this.invTransform;
      return n ? lm([], t, n) : [t[0], t[1]];
    }, e.prototype.convertToPixel = function(t, n, i) {
      var a = um(n);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, n, i) {
      var a = um(n);
      return a === this ? a.pointToData(i) : null;
    }, e.prototype.containPoint = function(t) {
      return this.getViewRectAfterRoam().contain(t[0], t[1]);
    }, e.dimensions = ["x", "y"], e;
  }(Fr)
);
function um(r) {
  var e = r.seriesModel;
  return e ? e.coordinateSystem : null;
}
var iP = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, V5 = ["lng", "lat"], B5 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i) {
      var a = r.call(this, t) || this;
      a.dimensions = V5, a.type = "geo", a._nameCoordMap = dist_W(), a.map = n;
      var o = i.projection, s = sn.load(n, i.nameMap, i.nameProperty), l = sn.getGeoResource(n), u = a.resourceType = l ? l.type : null, f = a.regions = s.regions, c = iP[l.type];
      a._regionsMap = s.regionsMap, a.regions = s.regions,  false && (0), a.projection = o;
      var h;
      if (o)
        for (var v = 0; v < f.length; v++) {
          var d = f[v].getBoundingRect(o);
          h = h || d.clone(), h.union(d);
        }
      else
        h = s.boundingRect;
      return a.setBoundingRect(h.x, h.y, h.width, h.height), a.aspectScale = o ? 1 : dist_ne(i.aspectScale, c.aspectScale), a._invertLongitute = o ? !1 : c.invertLongitute, a;
    }
    return e.prototype._transformTo = function(t, n, i, a) {
      var o = this.getBoundingRect(), s = this._invertLongitute;
      o = o.clone(), s && (o.y = -o.y - o.height);
      var l = this._rawTransformable;
      l.transform = o.calculateTransform(new dist_ae(t, n, i, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, e.prototype.getRegion = function(t) {
      return this._regionsMap.get(t);
    }, e.prototype.getRegionByCoord = function(t) {
      for (var n = this.regions, i = 0; i < n.length; i++) {
        var a = n[i];
        if (a.type === "geoJSON" && a.contain(t))
          return n[i];
      }
    }, e.prototype.addGeoCoord = function(t, n) {
      this._nameCoordMap.set(t, n);
    }, e.prototype.getGeoCoord = function(t) {
      var n = this._regionsMap.get(t);
      return this._nameCoordMap.get(t) || n && n.getCenter();
    }, e.prototype.dataToPoint = function(t, n, i) {
      if (dist_U(t) && (t = this.getGeoCoord(t)), t) {
        var a = this.projection;
        return a && (t = a.project(t)), t && this.projectedToPoint(t, n, i);
      }
    }, e.prototype.pointToData = function(t) {
      var n = this.projection;
      return n && (t = n.unproject(t)), t && this.pointToProjected(t);
    }, e.prototype.pointToProjected = function(t) {
      return r.prototype.pointToData.call(this, t);
    }, e.prototype.projectedToPoint = function(t, n, i) {
      return r.prototype.dataToPoint.call(this, t, n, i);
    }, e.prototype.convertToPixel = function(t, n, i) {
      var a = fm(n);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, n, i) {
      var a = fm(n);
      return a === this ? a.pointToData(i) : null;
    }, e;
  }(Rf)
);
Ot(B5, Rf);
function fm(r) {
  var e = r.geoModel, t = r.seriesModel;
  return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", ft).models[0] || {}).coordinateSystem : null;
}
const cm = B5;
function hm(r, e) {
  var t = r.get("boundingCoords");
  if (t != null) {
    var n = t[0], i = t[1];
    if (!(isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])))
      "production";
    else {
      var a = this.projection;
      if (a) {
        var o = n[0], s = n[1], l = i[0], u = i[1];
        n = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0];
        var f = function(w, x, C, T) {
          for (var E = C - w, D = T - x, I = 0; I <= 100; I++) {
            var L = I / 100, N = a.project([w + E * L, x + D * L]);
            Ln(n, n, N), Nn(i, i, N);
          }
        };
        f(o, s, l, s), f(l, s, l, u), f(l, u, o, u), f(o, u, l, s);
      }
      this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1]);
    }
  }
  var c = this.getBoundingRect(), h = r.get("layoutCenter"), v = r.get("layoutSize"), d = e.getWidth(), g = e.getHeight(), p = c.width / c.height * this.aspectScale, m = !1, y, _;
  h && v && (y = [me(h[0], d), me(h[1], g)], _ = me(v, Math.min(d, g)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(_) ? m = !0 : "production");
  var S;
  if (m)
    S = {}, p > 1 ? (S.width = _, S.height = _ / p) : (S.height = _, S.width = _ * p), S.y = y[1] - S.height / 2, S.x = y[0] - S.width / 2;
  else {
    var b = r.getBoxLayoutParams();
    b.aspect = p, S = cr(b, {
      width: d,
      height: g
    });
  }
  this.setViewRect(S.x, S.y, S.width, S.height), this.setCenter(r.get("center"), e), this.setZoom(r.get("zoom"));
}
function aP(r, e) {
  dist_M(e.get("geoCoord"), function(t, n) {
    r.addGeoCoord(n, t);
  });
}
var oP = (
  /** @class */
  function() {
    function r() {
      this.dimensions = V5;
    }
    return r.prototype.create = function(e, t) {
      var n = [];
      function i(o) {
        return {
          nameProperty: o.get("nameProperty"),
          aspectScale: o.get("aspectScale"),
          projection: o.get("projection")
        };
      }
      e.eachComponent("geo", function(o, s) {
        var l = o.get("map"), u = new cm(l + s, l, dist_V({
          nameMap: o.get("nameMap")
        }, i(o)));
        u.zoomLimit = o.get("scaleLimit"), n.push(u), o.coordinateSystem = u, u.model = o, u.resize = hm, u.resize(o, t);
      }), e.eachSeries(function(o) {
        var s = o.get("coordinateSystem");
        if (s === "geo") {
          var l = o.get("geoIndex") || 0;
          o.coordinateSystem = n[l];
        }
      });
      var a = {};
      return e.eachSeriesByType("map", function(o) {
        if (!o.getHostGeoModel()) {
          var s = o.getMapType();
          a[s] = a[s] || [], a[s].push(o);
        }
      }), dist_M(a, function(o, s) {
        var l = dist_$(o, function(f) {
          return f.get("nameMap");
        }), u = new cm(s, s, dist_V({
          nameMap: m3(l)
        }, i(o[0])));
        u.zoomLimit = Kt.apply(null, dist_$(o, function(f) {
          return f.get("scaleLimit");
        })), n.push(u), u.resize = hm, u.resize(o[0], t), dist_M(o, function(f) {
          f.coordinateSystem = u, aP(u, f);
        });
      }), n;
    }, r.prototype.getFilledRegions = function(e, t, n, i) {
      for (var a = (e || []).slice(), o = dist_W(), s = 0; s < a.length; s++)
        o.set(a[s].name, a[s]);
      var l = sn.load(t, n, i);
      return dist_M(l.regions, function(u) {
        var f = u.name;
        !o.get(f) && a.push({
          name: f
        });
      }), a;
    }, r;
  }()
), sP = new oP();
const F5 = sP;
var lP = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n, i) {
      var a = sn.getGeoResource(t.map);
      if (a && a.type === "geoJSON") {
        var o = t.itemStyle = t.itemStyle || {};
        "color" in o || (o.color = "#eee");
      }
      this.mergeDefaultAndTheme(t, i), us(t, "label", ["show"]);
    }, e.prototype.optionUpdated = function() {
      var t = this, n = this.option;
      n.regions = F5.getFilledRegions(n.regions, n.map, n.nameMap, n.nameProperty);
      var i = {};
      this._optionModelMap = Jr(n.regions || [], function(a, o) {
        var s = o.name;
        return s && (a.set(s, new He(o, t, t.ecModel)), o.selected && (i[s] = !0)), a;
      }, dist_W()), n.selectedMap || (n.selectedMap = i);
    }, e.prototype.getRegionModel = function(t) {
      return this._optionModelMap.get(t) || new He(null, this, this.ecModel);
    }, e.prototype.getFormattedLabel = function(t, n) {
      var i = this.getRegionModel(t), a = n === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]), o = {
        name: t
      };
      if (dist_j(a))
        return o.status = n, a(o);
      if (dist_U(a))
        return a.replace("{a}", t ?? "");
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.select = function(t) {
      var n = this.option, i = n.selectedMode;
      if (i) {
        i !== "multiple" && (n.selectedMap = null);
        var a = n.selectedMap || (n.selectedMap = {});
        a[t] = !0;
      }
    }, e.prototype.unSelect = function(t) {
      var n = this.option.selectedMap;
      n && (n[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      this[this.isSelected(t) ? "unSelect" : "select"](t);
    }, e.prototype.isSelected = function(t) {
      var n = this.option.selectedMap;
      return !!(n && n[t]);
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, e;
  }(Se)
);
const uP = lP;
function vm(r, e) {
  return r.pointToProjected ? r.pointToProjected(e) : r.pointToData(e);
}
function z5(r, e, t, n) {
  var i = r.getZoom(), a = r.getCenter(), o = e.zoom, s = r.projectedToPoint ? r.projectedToPoint(a) : r.dataToPoint(a);
  if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, r.setCenter(vm(r, s), n)), o != null) {
    if (t) {
      var l = t.min || 0, u = t.max || 1 / 0;
      o = Math.max(Math.min(i * o, u), l) / i;
    }
    r.scaleX *= o, r.scaleY *= o;
    var f = (e.originX - r.x) * (o - 1), c = (e.originY - r.y) * (o - 1);
    r.x -= f, r.y -= c, r.updateTransform(), r.setCenter(vm(r, s), n), r.setZoom(o * i);
  }
  return {
    center: r.getCenter(),
    zoom: r.getZoom()
  };
}
var fP = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.focusBlurEnabled = !0, t;
    }
    return e.prototype.init = function(t, n) {
      this._api = n;
    }, e.prototype.render = function(t, n, i, a) {
      if (this._model = t, !t.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new k5(i));
      var o = this._mapDraw;
      o.draw(t, n, i, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = t.get("silent"), this.group.add(o.group), this.updateSelectStatus(t, n, i);
    }, e.prototype._handleRegionClick = function(t) {
      var n;
      Ti(t.target, function(i) {
        return (n = dist_ie(i).eventData) != null;
      }, !0), n && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: n.name
      });
    }, e.prototype.updateSelectStatus = function(t, n, i) {
      var a = this;
      this._mapDraw.group.traverse(function(o) {
        var s = dist_ie(o).eventData;
        if (s)
          return a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o), !0;
      });
    }, e.prototype.findHighDownDispatchers = function(t) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model);
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, e.type = "geo", e;
  }(Pt)
);
const cP = fP;
function hP(r, e, t) {
  sn.registerMap(r, e, t);
}
function vP(r) {
  r.registerCoordinateSystem("geo", F5), r.registerComponentModel(uP), r.registerComponentView(cP), r.registerImpl("registerMap", hP), r.registerImpl("getMap", function(t) {
    return sn.getMapForUser(t);
  });
  function e(t, n) {
    n.update = "geo:updateSelectStatus", r.registerAction(n, function(i, a) {
      var o = {}, s = [];
      return a.eachComponent({
        mainType: "geo",
        query: i
      }, function(l) {
        l[t](i.name);
        var u = l.coordinateSystem;
        dist_M(u.regions, function(c) {
          o[c.name] = l.isSelected(c.name) || !1;
        });
        var f = [];
        dist_M(o, function(c, h) {
          o[h] && f.push(h);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: f
        });
      }), {
        selected: o,
        allSelected: s,
        name: i.name
      };
    });
  }
  e("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), e("select", {
    type: "geoSelect",
    event: "geoselected"
  }), e("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), r.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(t, n, i) {
    var a = t.componentType || "series";
    n.eachComponent({
      mainType: a,
      query: t
    }, function(o) {
      var s = o.coordinateSystem;
      if (s.type === "geo") {
        var l = z5(s, t, o.get("scaleLimit"), i);
        o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && dist_M(o.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function dP(r) {
  Rt(vP), r.registerChartView(JN), r.registerSeriesModel(eP), r.registerLayout(nP), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, rP), Q4("map", r.registerAction);
}
var qt = Me();
function pP(r) {
  var e = r.mainData, t = r.datas;
  t || (t = {
    main: e
  }, r.datasAttr = {
    main: "data"
  }), r.datas = r.mainData = null, G5(e, t, r), dist_M(t, function(n) {
    dist_M(e.TRANSFERABLE_METHODS, function(i) {
      n.wrapMethod(i, Te(gP, r));
    });
  }), e.wrapMethod("cloneShallow", Te(yP, r)), dist_M(e.CHANGABLE_METHODS, function(n) {
    e.wrapMethod(n, Te(mP, r));
  }), dist_re(t[e.dataType] === e);
}
function gP(r, e) {
  if (wP(this)) {
    var t = dist_V({}, qt(this).datas);
    t[this.dataType] = e, G5(e, t, r);
  } else
    A0(e, this.dataType, qt(this).mainData, r);
  return e;
}
function mP(r, e) {
  return r.struct && r.struct.update(), e;
}
function yP(r, e) {
  return dist_M(qt(e).datas, function(t, n) {
    t !== e && A0(t.cloneShallow(), n, e, r);
  }), e;
}
function _P(r) {
  var e = qt(this).mainData;
  return r == null || e == null ? e : qt(e).datas[r];
}
function SP() {
  var r = qt(this).mainData;
  return r == null ? [{
    data: r
  }] : dist_$(we(qt(r).datas), function(e) {
    return {
      type: e,
      data: qt(r).datas[e]
    };
  });
}
function wP(r) {
  return qt(r).mainData === r;
}
function G5(r, e, t) {
  qt(r).datas = {}, dist_M(e, function(n, i) {
    A0(n, i, r, t);
  });
}
function A0(r, e, t, n) {
  qt(t).datas[e] = r, qt(r).mainData = t, r.dataType = e, n.struct && (r[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = r), r.getLinkedData = _P, r.getLinkedDataAll = SP;
}
var _s = dist_M, bP = dist_X, zu = -1, nt = (
  /** @class */
  function() {
    function r(e) {
      var t = e.mappingMethod, n = e.type, i = this.option = dist_te(e);
      this.type = n, this.mappingMethod = t, this._normalizeData = TP[t];
      var a = r.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[t], t === "piecewise" ? (mh(i), xP(i)) : t === "category" ? i.categories ? CP(i) : mh(i, !0) : (dist_re(t !== "linear" || i.dataExtent), mh(i));
    }
    return r.prototype.mapValueToVisual = function(e) {
      var t = this._normalizeData(e);
      return this._normalizedToVisual(t, e);
    }, r.prototype.getNormalizer = function() {
      return dist_Z(this._normalizeData, this);
    }, r.listVisualTypes = function() {
      return we(r.visualHandlers);
    }, r.isValidType = function(e) {
      return r.visualHandlers.hasOwnProperty(e);
    }, r.eachVisual = function(e, t, n) {
      dist_X(e) ? dist_M(e, t, n) : t.call(n, e);
    }, r.mapVisual = function(e, t, n) {
      var i, a = dist_F(e) ? [] : dist_X(e) ? {} : (i = !0, null);
      return r.eachVisual(e, function(o, s) {
        var l = t.call(n, o, s);
        i ? a = l : a[s] = l;
      }), a;
    }, r.retrieveVisuals = function(e) {
      var t = {}, n;
      return e && _s(r.visualHandlers, function(i, a) {
        e.hasOwnProperty(a) && (t[a] = e[a], n = !0);
      }), n ? t : null;
    }, r.prepareVisualTypes = function(e) {
      if (dist_F(e))
        e = e.slice();
      else if (bP(e)) {
        var t = [];
        _s(e, function(n, i) {
          t.push(i);
        }), e = t;
      } else
        return [];
      return e.sort(function(n, i) {
        return i === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), e;
    }, r.dependsOn = function(e, t) {
      return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t;
    }, r.findPieceIndex = function(e, t, n) {
      for (var i, a = 1 / 0, o = 0, s = t.length; o < s; o++) {
        var l = t[o].value;
        if (l != null) {
          if (l === e || dist_U(l) && l === e + "")
            return o;
          n && h(l, o);
        }
      }
      for (var o = 0, s = t.length; o < s; o++) {
        var u = t[o], f = u.interval, c = u.close;
        if (f) {
          if (f[0] === -1 / 0) {
            if (Nl(c[1], e, f[1]))
              return o;
          } else if (f[1] === 1 / 0) {
            if (Nl(c[0], f[0], e))
              return o;
          } else if (Nl(c[0], f[0], e) && Nl(c[1], e, f[1]))
            return o;
          n && h(f[0], o), n && h(f[1], o);
        }
      }
      if (n)
        return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : i;
      function h(v, d) {
        var g = Math.abs(v - e);
        g < a && (a = g, i = d);
      }
    }, r.visualHandlers = {
      color: {
        applyVisual: wo("color"),
        getColorMapper: function() {
          var e = this.option;
          return dist_Z(e.mappingMethod === "category" ? function(t, n) {
            return !n && (t = this._normalizeData(t)), Oo.call(this, t);
          } : function(t, n, i) {
            var a = !!i;
            return !n && (t = this._normalizeData(t)), i = tc(t, e.parsedVisual, i), a ? i : Zr(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(e) {
            return Zr(tc(e, this.option.parsedVisual), "rgba");
          },
          category: Oo,
          piecewise: function(e, t) {
            var n = jv.call(this, t);
            return n == null && (n = Zr(tc(e, this.option.parsedVisual), "rgba")), n;
          },
          fixed: yi
        }
      },
      colorHue: Ll(function(e, t) {
        return rc(e, t);
      }),
      colorSaturation: Ll(function(e, t) {
        return rc(e, null, t);
      }),
      colorLightness: Ll(function(e, t) {
        return rc(e, null, null, t);
      }),
      colorAlpha: Ll(function(e, t) {
        return V7(e, t);
      }),
      decal: {
        applyVisual: wo("decal"),
        _normalizedToVisual: {
          linear: null,
          category: Oo,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: wo("opacity"),
        _normalizedToVisual: Kv([0, 1])
      },
      liftZ: {
        applyVisual: wo("liftZ"),
        _normalizedToVisual: {
          linear: yi,
          category: yi,
          piecewise: yi,
          fixed: yi
        }
      },
      symbol: {
        applyVisual: function(e, t, n) {
          var i = this.mapValueToVisual(e);
          n("symbol", i);
        },
        _normalizedToVisual: {
          linear: dm,
          category: Oo,
          piecewise: function(e, t) {
            var n = jv.call(this, t);
            return n == null && (n = dm.call(this, e)), n;
          },
          fixed: yi
        }
      },
      symbolSize: {
        applyVisual: wo("symbolSize"),
        _normalizedToVisual: Kv([0, 1])
      }
    }, r;
  }()
);
function xP(r) {
  var e = r.pieceList;
  r.hasSpecialVisual = !1, dist_M(e, function(t, n) {
    t.originIndex = n, t.visual != null && (r.hasSpecialVisual = !0);
  });
}
function CP(r) {
  var e = r.categories, t = r.categoryMap = {}, n = r.visual;
  if (_s(e, function(o, s) {
    t[o] = s;
  }), !dist_F(n)) {
    var i = [];
    dist_X(n) ? _s(n, function(o, s) {
      var l = t[s];
      i[l ?? zu] = o;
    }) : i[zu] = n, n = H5(r, i);
  }
  for (var a = e.length - 1; a >= 0; a--)
    n[a] == null && (delete t[e[a]], e.pop());
}
function mh(r, e) {
  var t = r.visual, n = [];
  dist_X(t) ? _s(t, function(a) {
    n.push(a);
  }) : t != null && n.push(t);
  var i = {
    color: 1,
    symbol: 1
  };
  !e && n.length === 1 && !i.hasOwnProperty(r.type) && (n[1] = n[0]), H5(r, n);
}
function Ll(r) {
  return {
    applyVisual: function(e, t, n) {
      var i = this.mapValueToVisual(e);
      n("color", r(t("color"), i));
    },
    _normalizedToVisual: Kv([0, 1])
  };
}
function dm(r) {
  var e = this.option.visual;
  return e[Math.round(De(r, [0, 1], [0, e.length - 1], !0))] || {};
}
function wo(r) {
  return function(e, t, n) {
    n(r, this.mapValueToVisual(e));
  };
}
function Oo(r) {
  var e = this.option.visual;
  return e[this.option.loop && r !== zu ? r % e.length : r];
}
function yi() {
  return this.option.visual[0];
}
function Kv(r) {
  return {
    linear: function(e) {
      return De(e, r, this.option.visual, !0);
    },
    category: Oo,
    piecewise: function(e, t) {
      var n = jv.call(this, t);
      return n == null && (n = De(e, r, this.option.visual, !0)), n;
    },
    fixed: yi
  };
}
function jv(r) {
  var e = this.option, t = e.pieceList;
  if (e.hasSpecialVisual) {
    var n = nt.findPieceIndex(r, t), i = t[n];
    if (i && i.visual)
      return i.visual[this.type];
  }
}
function H5(r, e) {
  return r.visual = e, r.type === "color" && (r.parsedVisual = dist_$(e, function(t) {
    var n = Xt(t);
    return !n && "production" !== "production" && 0, n || [0, 0, 0, 1];
  })), e;
}
var TP = {
  linear: function(r) {
    return De(r, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(r) {
    var e = this.option.pieceList, t = nt.findPieceIndex(r, e, !0);
    if (t != null)
      return De(t, [0, e.length - 1], [0, 1], !0);
  },
  category: function(r) {
    var e = this.option.categories ? this.option.categoryMap[r] : r;
    return e ?? zu;
  },
  fixed: Ue
};
function Nl(r, e, t) {
  return r ? e <= t : e < t;
}
function MP(r) {
  var e = r.findComponents({
    mainType: "legend"
  });
  !e || !e.length || r.eachSeriesByType("graph", function(t) {
    var n = t.getCategoriesData(), i = t.getGraph(), a = i.data, o = n.mapArray(n.getName);
    a.filterSelf(function(s) {
      var l = a.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        ve(u) && (u = o[u]);
        for (var f = 0; f < e.length; f++)
          if (!e[f].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function DP(r) {
  var e = {};
  r.eachSeriesByType("graph", function(t) {
    var n = t.getCategoriesData(), i = t.getData(), a = {};
    n.each(function(o) {
      var s = n.getName(o);
      a["ec-" + s] = o;
      var l = n.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = t.getColorFromPalette(s, e)), n.setItemVisual(o, "style", u);
      for (var f = ["symbol", "symbolSize", "symbolKeepAspect"], c = 0; c < f.length; c++) {
        var h = l.getShallow(f[c], !0);
        h != null && n.setItemVisual(o, f[c], h);
      }
    }), n.count() && i.each(function(o) {
      var s = i.getItemModel(o), l = s.getShallow("category");
      if (l != null) {
        dist_U(l) && (l = a["ec-" + l]);
        var u = n.getItemVisual(l, "style"), f = i.ensureUniqueItemVisual(o, "style");
        dist_V(f, u);
        for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], h = 0; h < c.length; h++)
          i.setItemVisual(o, c[h], n.getItemVisual(l, c[h]));
      }
    });
  });
}
function Pl(r) {
  return r instanceof Array || (r = [r, r]), r;
}
function EP(r) {
  r.eachSeriesByType("graph", function(e) {
    var t = e.getGraph(), n = e.getEdgeData(), i = Pl(e.get("edgeSymbol")), a = Pl(e.get("edgeSymbolSize"));
    n.setVisual("fromSymbol", i && i[0]), n.setVisual("toSymbol", i && i[1]), n.setVisual("fromSymbolSize", a && a[0]), n.setVisual("toSymbolSize", a && a[1]), n.setVisual("style", e.getModel("lineStyle").getLineStyle()), n.each(function(o) {
      var s = n.getItemModel(o), l = t.getEdgeByIndex(o), u = Pl(s.getShallow("symbol", !0)), f = Pl(s.getShallow("symbolSize", !0)), c = s.getModel("lineStyle").getLineStyle(), h = n.ensureUniqueItemVisual(o, "style");
      switch (dist_V(h, c), h.stroke) {
        case "source": {
          var v = l.node1.getVisual("style");
          h.stroke = v && v.fill;
          break;
        }
        case "target": {
          var v = l.node2.getVisual("style");
          h.stroke = v && v.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), f[0] && l.setVisual("fromSymbolSize", f[0]), f[1] && l.setVisual("toSymbolSize", f[1]);
    });
  });
}
var Jv = "-->", Of = function(r) {
  return r.get("autoCurveness") || null;
}, $5 = function(r, e) {
  var t = Of(r), n = 20, i = [];
  if (ve(t))
    n = t;
  else if (dist_F(t)) {
    r.__curvenessList = t;
    return;
  }
  e > n && (n = e);
  var a = n % 2 ? n + 2 : n + 3;
  i = [];
  for (var o = 0; o < a; o++)
    i.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
  r.__curvenessList = i;
}, Ss = function(r, e, t) {
  var n = [r.id, r.dataIndex].join("."), i = [e.id, e.dataIndex].join(".");
  return [t.uid, n, i].join(Jv);
}, W5 = function(r) {
  var e = r.split(Jv);
  return [e[0], e[2], e[1]].join(Jv);
}, AP = function(r, e) {
  var t = Ss(r.node1, r.node2, e);
  return e.__edgeMap[t];
}, IP = function(r, e) {
  var t = Qv(Ss(r.node1, r.node2, e), e), n = Qv(Ss(r.node2, r.node1, e), e);
  return t + n;
}, Qv = function(r, e) {
  var t = e.__edgeMap;
  return t[r] ? t[r].length : 0;
};
function LP(r) {
  Of(r) && (r.__curvenessList = [], r.__edgeMap = {}, $5(r));
}
function NP(r, e, t, n) {
  if (Of(t)) {
    var i = Ss(r, e, t), a = t.__edgeMap, o = a[W5(i)];
    a[i] && !o ? a[i].isForward = !0 : o && a[i] && (o.isForward = !0, a[i].isForward = !1), a[i] = a[i] || [], a[i].push(n);
  }
}
function I0(r, e, t, n) {
  var i = Of(e), a = dist_F(i);
  if (!i)
    return null;
  var o = AP(r, e);
  if (!o)
    return null;
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === t) {
      s = l;
      break;
    }
  var u = IP(r, e);
  $5(e, u), r.lineStyle = r.lineStyle || {};
  var f = Ss(r.node1, r.node2, e), c = e.__curvenessList, h = a || u % 2 ? 0 : 1;
  if (o.isForward)
    return c[h + s];
  var v = W5(f), d = Qv(v, e), g = c[s + d + h];
  return n ? a ? i && i[0] === 0 ? (d + h) % 2 ? g : -g : ((d % 2 ? 0 : 1) + h) % 2 ? g : -g : (d + h) % 2 ? g : -g : c[s + d + h];
}
function U5(r) {
  var e = r.coordinateSystem;
  if (!(e && e.type !== "view")) {
    var t = r.getGraph();
    t.eachNode(function(n) {
      var i = n.getModel();
      n.setLayout([+i.get("x"), +i.get("y")]);
    }), L0(t, r);
  }
}
function L0(r, e) {
  r.eachEdge(function(t, n) {
    var i = Dr(t.getModel().get(["lineStyle", "curveness"]), -I0(t, e, n, !0), 0), a = Ur(t.node1.getLayout()), o = Ur(t.node2.getLayout()), s = [a, o];
    +i && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * i, (a[1] + o[1]) / 2 - (o[0] - a[0]) * i]), t.setLayout(s);
  });
}
function PP(r, e) {
  r.eachSeriesByType("graph", function(t) {
    var n = t.get("layout"), i = t.coordinateSystem;
    if (i && i.type !== "view") {
      var a = t.getData(), o = [];
      dist_M(i.dimensions, function(h) {
        o = o.concat(a.mapDimensionsAll(h));
      });
      for (var s = 0; s < a.count(); s++) {
        for (var l = [], u = !1, f = 0; f < o.length; f++) {
          var c = a.get(o[f], s);
          isNaN(c) || (u = !0), l.push(c);
        }
        u ? a.setItemLayout(s, i.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]);
      }
      L0(a.graph, t);
    } else
      (!n || n === "none") && U5(t);
  });
}
function ko(r) {
  var e = r.coordinateSystem;
  if (e.type !== "view")
    return 1;
  var t = r.option.nodeScaleRatio, n = e.scaleX, i = e.getZoom(), a = (i - 1) * t + 1;
  return a / n;
}
function Vo(r) {
  var e = r.getVisual("symbolSize");
  return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
}
var pm = Math.PI, yh = [];
function N0(r, e, t, n) {
  var i = r.coordinateSystem;
  if (!(i && i.type !== "view")) {
    var a = i.getBoundingRect(), o = r.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, f = Math.min(a.width, a.height) / 2, c = o.count();
    if (o.setLayout({
      cx: l,
      cy: u
    }), !!c) {
      if (t) {
        var h = i.pointToData(n), v = h[0], d = h[1], g = [v - l, d - u];
        Wa(g, g), zl(g, g, f), t.setLayout([l + g[0], u + g[1]], !0);
        var p = r.get(["circular", "rotateLabel"]);
        Y5(t, p, l, u);
      }
      RP[e](r, s, o, f, l, u, c), s.eachEdge(function(m, y) {
        var _ = Dr(m.getModel().get(["lineStyle", "curveness"]), I0(m, r, y), 0), S = Ur(m.node1.getLayout()), b = Ur(m.node2.getLayout()), w, x = (S[0] + b[0]) / 2, C = (S[1] + b[1]) / 2;
        +_ && (_ *= 3, w = [l * _ + x * (1 - _), u * _ + C * (1 - _)]), m.setLayout([S, b, w]);
      });
    }
  }
}
var RP = {
  value: function(r, e, t, n, i, a, o) {
    var s = 0, l = t.getSum("value"), u = Math.PI * 2 / (l || o);
    e.eachNode(function(f) {
      var c = f.getValue("value"), h = u * (l ? c : 1) / 2;
      s += h, f.setLayout([n * Math.cos(s) + i, n * Math.sin(s) + a]), s += h;
    });
  },
  symbolSize: function(r, e, t, n, i, a, o) {
    var s = 0;
    yh.length = o;
    var l = ko(r);
    e.eachNode(function(c) {
      var h = Vo(c);
      isNaN(h) && (h = 2), h < 0 && (h = 0), h *= l;
      var v = Math.asin(h / 2 / n);
      isNaN(v) && (v = pm / 2), yh[c.dataIndex] = v, s += v * 2;
    });
    var u = (2 * pm - s) / o / 2, f = 0;
    e.eachNode(function(c) {
      var h = u + yh[c.dataIndex];
      f += h, (!c.getLayout() || !c.getLayout().fixed) && c.setLayout([n * Math.cos(f) + i, n * Math.sin(f) + a]), f += h;
    });
  }
};
function Y5(r, e, t, n) {
  var i = r.getGraphicEl();
  if (i) {
    var a = r.getModel(), o = a.get(["label", "rotate"]) || 0, s = i.getSymbolPath();
    if (e) {
      var l = r.getLayout(), u = Math.atan2(l[1] - n, l[0] - t);
      u < 0 && (u = Math.PI * 2 + u);
      var f = l[0] < t;
      f && (u = u - Math.PI);
      var c = f ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: c,
        origin: "center"
      });
      var h = s.ensureState("emphasis");
      dist_V(h.textConfig || (h.textConfig = {}), {
        position: c
      });
    } else
      s.setTextConfig({
        rotation: o *= Math.PI / 180
      });
  }
}
function OP(r) {
  r.eachSeriesByType("graph", function(e) {
    e.get("layout") === "circular" && N0(e, "symbolSize");
  });
}
var la = jh;
function kP(r, e, t) {
  for (var n = r, i = e, a = t.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], u = t.gravity == null ? 0.1 : t.gravity, f = 0; f < n.length; f++) {
    var c = n[f];
    c.p || (c.p = Fi(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), c.pp = Ur(c.p), c.edges = null;
  }
  var h = t.friction == null ? 0.6 : t.friction, v = h, d, g;
  return {
    warmUp: function() {
      v = h * 0.8;
    },
    setFixed: function(p) {
      n[p].fixed = !0;
    },
    setUnfixed: function(p) {
      n[p].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(p) {
      d = p;
    },
    /**
     * After step hook
     */
    afterStep: function(p) {
      g = p;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(p) {
      d && d(n, i);
      for (var m = [], y = n.length, _ = 0; _ < i.length; _++) {
        var S = i[_];
        if (!S.ignoreForceLayout) {
          var b = S.n1, w = S.n2;
          bi(m, w.p, b.p);
          var x = Jh(m) - S.d, C = w.w / (b.w + w.w);
          isNaN(C) && (C = 0), Wa(m, m), !b.fixed && la(b.p, b.p, m, C * x * v), !w.fixed && la(w.p, w.p, m, -(1 - C) * x * v);
        }
      }
      for (var _ = 0; _ < y; _++) {
        var T = n[_];
        T.fixed || (bi(m, l, T.p), la(T.p, T.p, m, u * v));
      }
      for (var _ = 0; _ < y; _++)
        for (var b = n[_], E = _ + 1; E < y; E++) {
          var w = n[E];
          bi(m, w.p, b.p);
          var x = Jh(m);
          x === 0 && (Jx(m, Math.random() - 0.5, Math.random() - 0.5), x = 1);
          var D = (b.rep + w.rep) / x / x;
          !b.fixed && la(b.pp, b.pp, m, D), !w.fixed && la(w.pp, w.pp, m, -D);
        }
      for (var I = [], _ = 0; _ < y; _++) {
        var T = n[_];
        T.fixed || (bi(I, T.p, T.pp), la(T.p, T.p, I, v), st(T.pp, T.p));
      }
      v = v * 0.992;
      var L = v < 0.01;
      g && g(n, i, L), p && p(L);
    }
  };
}
function VP(r) {
  r.eachSeriesByType("graph", function(e) {
    var t = e.coordinateSystem;
    if (!(t && t.type !== "view"))
      if (e.get("layout") === "force") {
        var n = e.preservedPoints || {}, i = e.getGraph(), a = i.data, o = i.edgeData, s = e.getModel("force"), l = s.get("initLayout");
        e.preservedPoints ? a.each(function(_) {
          var S = a.getId(_);
          a.setItemLayout(_, n[S] || [NaN, NaN]);
        }) : !l || l === "none" ? U5(e) : l === "circular" && N0(e, "value");
        var u = a.getDataExtent("value"), f = o.getDataExtent("value"), c = s.get("repulsion"), h = s.get("edgeLength"), v = dist_F(c) ? c : [c, c], d = dist_F(h) ? h : [h, h];
        d = [d[1], d[0]];
        var g = a.mapArray("value", function(_, S) {
          var b = a.getItemLayout(S), w = De(_, u, v);
          return isNaN(w) && (w = (v[0] + v[1]) / 2), {
            w,
            rep: w,
            fixed: a.getItemModel(S).get("fixed"),
            p: !b || isNaN(b[0]) || isNaN(b[1]) ? null : b
          };
        }), p = o.mapArray("value", function(_, S) {
          var b = i.getEdgeByIndex(S), w = De(_, f, d);
          isNaN(w) && (w = (d[0] + d[1]) / 2);
          var x = b.getModel(), C = Dr(b.getModel().get(["lineStyle", "curveness"]), -I0(b, e, S, !0), 0);
          return {
            n1: g[b.node1.dataIndex],
            n2: g[b.node2.dataIndex],
            d: w,
            curveness: C,
            ignoreForceLayout: x.get("ignoreForceLayout")
          };
        }), m = t.getBoundingRect(), y = kP(g, p, {
          rect: m,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(_, S) {
          for (var b = 0, w = _.length; b < w; b++)
            _[b].fixed && st(_[b].p, i.getNodeByIndex(b).getLayout());
        }), y.afterStep(function(_, S, b) {
          for (var w = 0, x = _.length; w < x; w++)
            _[w].fixed || i.getNodeByIndex(w).setLayout(_[w].p), n[a.getId(w)] = _[w].p;
          for (var w = 0, x = S.length; w < x; w++) {
            var C = S[w], T = i.getEdgeByIndex(w), E = C.n1.p, D = C.n2.p, I = T.getLayout();
            I = I ? I.slice() : [], I[0] = I[0] || [], I[1] = I[1] || [], st(I[0], E), st(I[1], D), +C.curveness && (I[2] = [(E[0] + D[0]) / 2 - (E[1] - D[1]) * C.curveness, (E[1] + D[1]) / 2 - (D[0] - E[0]) * C.curveness]), T.setLayout(I);
          }
        }), e.forceLayout = y, e.preservedPoints = n, y.step();
      } else
        e.forceLayout = null;
  });
}
function BP(r, e, t) {
  var n = dist_V(r.getBoxLayoutParams(), {
    aspect: t
  });
  return cr(n, {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function FP(r, e) {
  var t = [];
  return r.eachSeriesByType("graph", function(n) {
    var i = n.get("coordinateSystem");
    if (!i || i === "view") {
      var a = n.getData(), o = a.mapArray(function(p) {
        var m = a.getItemModel(p);
        return [+m.get("x"), +m.get("y")];
      }), s = [], l = [];
      Nd(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), f = BP(n, e, u);
      isNaN(u) && (s = [f.x, f.y], l = [f.x + f.width, f.y + f.height]);
      var c = l[0] - s[0], h = l[1] - s[1], v = f.width, d = f.height, g = n.coordinateSystem = new Rf();
      g.zoomLimit = n.get("scaleLimit"), g.setBoundingRect(s[0], s[1], c, h), g.setViewRect(f.x, f.y, v, d), g.setCenter(n.get("center"), e), g.setZoom(n.get("zoom")), t.push(g);
    }
  }), t;
}
var gm = an.prototype, _h = Gd.prototype, X5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return r;
  }()
);
(function(r) {
  dist_k(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e;
})(X5);
function Sh(r) {
  return isNaN(+r.cpx1) || isNaN(+r.cpy1);
}
var zP = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "ec-line", n;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new X5();
    }, e.prototype.buildPath = function(t, n) {
      Sh(n) ? gm.buildPath.call(this, t, n) : _h.buildPath.call(this, t, n);
    }, e.prototype.pointAt = function(t) {
      return Sh(this.shape) ? gm.pointAt.call(this, t) : _h.pointAt.call(this, t);
    }, e.prototype.tangentAt = function(t) {
      var n = this.shape, i = Sh(n) ? [n.x2 - n.x1, n.y2 - n.y1] : _h.tangentAt.call(this, t);
      return Wa(i, i);
    }, e;
  }(fe)
), wh = ["fromSymbol", "toSymbol"];
function mm(r) {
  return "_" + r + "Type";
}
function ym(r, e, t) {
  var n = e.getItemVisual(t, r);
  if (!n || n === "none")
    return n;
  var i = e.getItemVisual(t, r + "Size"), a = e.getItemVisual(t, r + "Rotate"), o = e.getItemVisual(t, r + "Offset"), s = e.getItemVisual(t, r + "KeepAspect"), l = Df(i), u = Os(o || 0, l);
  return n + l + u + (a || "") + (s || "");
}
function _m(r, e, t) {
  var n = e.getItemVisual(t, r);
  if (!(!n || n === "none")) {
    var i = e.getItemVisual(t, r + "Size"), a = e.getItemVisual(t, r + "Rotate"), o = e.getItemVisual(t, r + "Offset"), s = e.getItemVisual(t, r + "KeepAspect"), l = Df(i), u = Os(o || 0, l), f = dt(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return f.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, f.name = r, f;
  }
}
function GP(r) {
  var e = new zP({
    name: "line",
    subPixelOptimize: !0
  });
  return ed(e.shape, r), e;
}
function ed(r, e) {
  r.x1 = e[0][0], r.y1 = e[0][1], r.x2 = e[1][0], r.y2 = e[1][1], r.percent = 1;
  var t = e[2];
  t ? (r.cpx1 = t[0], r.cpy1 = t[1]) : (r.cpx1 = NaN, r.cpy1 = NaN);
}
var HP = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      return a._createLine(t, n, i), a;
    }
    return e.prototype._createLine = function(t, n, i) {
      var a = t.hostModel, o = t.getItemLayout(n), s = GP(o);
      s.shape.percent = 0, Ze(s, {
        shape: {
          percent: 1
        }
      }, a, n), this.add(s), dist_M(wh, function(l) {
        var u = _m(l, t, n);
        this.add(u), this[mm(l)] = ym(l, t, n);
      }, this), this._updateCommonStl(t, n, i);
    }, e.prototype.updateData = function(t, n, i) {
      var a = t.hostModel, o = this.childOfName("line"), s = t.getItemLayout(n), l = {
        shape: {}
      };
      ed(l.shape, s), Pe(o, l, a, n), dist_M(wh, function(u) {
        var f = ym(u, t, n), c = mm(u);
        if (this[c] !== f) {
          this.remove(this.childOfName(u));
          var h = _m(u, t, n);
          this.add(h);
        }
        this[c] = f;
      }, this), this._updateCommonStl(t, n, i);
    }, e.prototype.getLinePath = function() {
      return this.childAt(0);
    }, e.prototype._updateCommonStl = function(t, n, i) {
      var a = t.hostModel, o = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, f = i && i.labelStatesModels, c = i && i.emphasisDisabled, h = i && i.focus, v = i && i.blurScope;
      if (!i || t.hasItemOption) {
        var d = t.getItemModel(n), g = d.getModel("emphasis");
        s = g.getModel("lineStyle").getLineStyle(), l = d.getModel(["blur", "lineStyle"]).getLineStyle(), u = d.getModel(["select", "lineStyle"]).getLineStyle(), c = g.get("disabled"), h = g.get("focus"), v = g.get("blurScope"), f = hn(d);
      }
      var p = t.getItemVisual(n, "style"), m = p.stroke;
      o.useStyle(p), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, dist_M(wh, function(w) {
        var x = this.childOfName(w);
        if (x) {
          x.setColor(m), x.style.opacity = p.opacity;
          for (var C = 0; C < Ct.length; C++) {
            var T = Ct[C], E = o.getState(T);
            if (E) {
              var D = E.style || {}, I = x.ensureState(T), L = I.style || (I.style = {});
              D.stroke != null && (L[x.__isEmptyBrush ? "stroke" : "fill"] = D.stroke), D.opacity != null && (L.opacity = D.opacity);
            }
          }
          x.markRedraw();
        }
      }, this);
      var y = a.getRawValue(n);
      Yn(this, f, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function(w, x) {
            return a.getFormattedLabel(w, x, t.dataType);
          }
        },
        inheritColor: m || "#000",
        defaultOpacity: p.opacity,
        defaultText: (y == null ? t.getName(n) : isFinite(y) ? Be(y) : y) + ""
      });
      var _ = this.getTextContent();
      if (_) {
        var S = f.normal;
        _.__align = _.style.align, _.__verticalAlign = _.style.verticalAlign, _.__position = S.get("position") || "middle";
        var b = S.get("distance");
        dist_F(b) || (b = [b, b]), _.__labelDistance = b;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), rn(this, h, v, c);
    }, e.prototype.highlight = function() {
      Pa(this);
    }, e.prototype.downplay = function() {
      Ra(this);
    }, e.prototype.updateLayout = function(t, n) {
      this.setLinePoints(t.getItemLayout(n));
    }, e.prototype.setLinePoints = function(t) {
      var n = this.childOfName("line");
      ed(n.shape, t), n.dirty();
    }, e.prototype.beforeUpdate = function() {
      var t = this, n = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), a = t.getTextContent();
      if (!n && !i && (!a || a.ignore))
        return;
      for (var o = 1, s = this.parent; s; )
        s.scaleX && (o /= s.scaleX), s = s.parent;
      var l = t.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, f = l.pointAt(0), c = l.pointAt(u), h = bi([], c, f);
      Wa(h, h);
      function v(E, D) {
        var I = E.__specifiedRotation;
        if (I == null) {
          var L = l.tangentAt(D);
          E.attr("rotation", (D === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(L[1], L[0]));
        } else
          E.attr("rotation", I);
      }
      if (n && (n.setPosition(f), v(n, 0), n.scaleX = n.scaleY = o * u, n.markRedraw()), i && (i.setPosition(c), v(i, 1), i.scaleX = i.scaleY = o * u, i.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var d = void 0, g = void 0, p = a.__labelDistance, m = p[0] * o, y = p[1] * o, _ = u / 2, S = l.tangentAt(_), b = [S[1], -S[0]], w = l.pointAt(_);
        b[1] > 0 && (b[0] = -b[0], b[1] = -b[1]);
        var x = S[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var C = -Math.atan2(S[1], S[0]);
          c[0] < f[0] && (C = Math.PI + C), a.rotation = C;
        }
        var T = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            T = -y, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            T = y, g = "top";
            break;
          default:
            T = 0, g = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = h[0] * m + c[0], a.y = h[1] * y + c[1], d = h[0] > 0.8 ? "left" : h[0] < -0.8 ? "right" : "center", g = h[1] > 0.8 ? "top" : h[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -h[0] * m + f[0], a.y = -h[1] * y + f[1], d = h[0] > 0.8 ? "right" : h[0] < -0.8 ? "left" : "center", g = h[1] > 0.8 ? "bottom" : h[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = m * x + f[0], a.y = f[1] + T, d = S[0] < 0 ? "right" : "left", a.originX = -m * x, a.originY = -T;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = w[0], a.y = w[1] + T, d = "center", a.originY = -T;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -m * x + c[0], a.y = c[1] + T, d = S[0] >= 0 ? "right" : "left", a.originX = m * x, a.originY = -T;
            break;
        }
        a.scaleX = a.scaleY = o, a.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: a.__verticalAlign || g,
          align: a.__align || d
        });
      }
    }, e;
  }(dist_oe)
);
const P0 = HP;
var Z5 = (
  /** @class */
  function() {
    function r(e) {
      this.group = new dist_oe(), this._LineCtor = e || P0;
    }
    return r.prototype.updateData = function(e) {
      var t = this;
      this._progressiveEls = null;
      var n = this, i = n.group, a = n._lineData;
      n._lineData = e, a || i.removeAll();
      var o = Sm(e);
      e.diff(a).add(function(s) {
        t._doAdd(e, s, o);
      }).update(function(s, l) {
        t._doUpdate(a, e, l, s, o);
      }).remove(function(s) {
        i.remove(a.getItemGraphicEl(s));
      }).execute();
    }, r.prototype.updateLayout = function() {
      var e = this._lineData;
      e && e.eachItemGraphicEl(function(t, n) {
        t.updateLayout(e, n);
      }, this);
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = Sm(e), this._lineData = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(e, t) {
      this._progressiveEls = [];
      function n(s) {
        !s.isGroup && !$P(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var i = e.start; i < e.end; i++) {
        var a = t.getItemLayout(i);
        if (bh(a)) {
          var o = new this._LineCtor(t, i, this._seriesScope);
          o.traverse(n), this.group.add(o), t.setItemGraphicEl(i, o), this._progressiveEls.push(o);
        }
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r.prototype.eachRendered = function(e) {
      Is(this._progressiveEls || this.group, e);
    }, r.prototype._doAdd = function(e, t, n) {
      var i = e.getItemLayout(t);
      if (bh(i)) {
        var a = new this._LineCtor(e, t, n);
        e.setItemGraphicEl(t, a), this.group.add(a);
      }
    }, r.prototype._doUpdate = function(e, t, n, i, a) {
      var o = e.getItemGraphicEl(n);
      if (!bh(t.getItemLayout(i))) {
        this.group.remove(o);
        return;
      }
      o ? o.updateData(t, i, a) : o = new this._LineCtor(t, i, a), t.setItemGraphicEl(i, o), this.group.add(o);
    }, r;
  }()
);
function $P(r) {
  return r.animators && r.animators.length > 0;
}
function Sm(r) {
  var e = r.hostModel, t = e.getModel("emphasis");
  return {
    lineStyle: e.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: t.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: e.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: e.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: t.get("disabled"),
    blurScope: t.get("blurScope"),
    focus: t.get("focus"),
    labelStatesModels: hn(e)
  };
}
function wm(r) {
  return isNaN(r[0]) || isNaN(r[1]);
}
function bh(r) {
  return r && !wm(r[0]) && !wm(r[1]);
}
var xh = [], Ch = [], Th = [], ua = We, Mh = Ai, bm = Math.abs;
function xm(r, e, t) {
  for (var n = r[0], i = r[1], a = r[2], o = 1 / 0, s, l = t * t, u = 0.1, f = 0.1; f <= 0.9; f += 0.1) {
    xh[0] = ua(n[0], i[0], a[0], f), xh[1] = ua(n[1], i[1], a[1], f);
    var c = bm(Mh(xh, e) - l);
    c < o && (o = c, s = f);
  }
  for (var h = 0; h < 32; h++) {
    var v = s + u;
    Ch[0] = ua(n[0], i[0], a[0], s), Ch[1] = ua(n[1], i[1], a[1], s), Th[0] = ua(n[0], i[0], a[0], v), Th[1] = ua(n[1], i[1], a[1], v);
    var c = Mh(Ch, e) - l;
    if (bm(c) < 0.01)
      break;
    var d = Mh(Th, e) - l;
    u /= 2, c < 0 ? d >= 0 ? s = s + u : s = s - u : d >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function Dh(r, e) {
  var t = [], n = os, i = [[], [], []], a = [[], []], o = [];
  e /= 2, r.eachEdge(function(s, l) {
    var u = s.getLayout(), f = s.getVisual("fromSymbol"), c = s.getVisual("toSymbol");
    u.__original || (u.__original = [Ur(u[0]), Ur(u[1])], u[2] && u.__original.push(Ur(u[2])));
    var h = u.__original;
    if (u[2] != null) {
      if (st(i[0], h[0]), st(i[1], h[2]), st(i[2], h[1]), f && f !== "none") {
        var v = Vo(s.node1), d = xm(i, h[0], v * e);
        n(i[0][0], i[1][0], i[2][0], d, t), i[0][0] = t[3], i[1][0] = t[4], n(i[0][1], i[1][1], i[2][1], d, t), i[0][1] = t[3], i[1][1] = t[4];
      }
      if (c && c !== "none") {
        var v = Vo(s.node2), d = xm(i, h[1], v * e);
        n(i[0][0], i[1][0], i[2][0], d, t), i[1][0] = t[1], i[2][0] = t[2], n(i[0][1], i[1][1], i[2][1], d, t), i[1][1] = t[1], i[2][1] = t[2];
      }
      st(u[0], i[0]), st(u[1], i[2]), st(u[2], i[1]);
    } else {
      if (st(a[0], h[0]), st(a[1], h[1]), bi(o, a[1], a[0]), Wa(o, o), f && f !== "none") {
        var v = Vo(s.node1);
        jh(a[0], a[0], o, v * e);
      }
      if (c && c !== "none") {
        var v = Vo(s.node2);
        jh(a[1], a[1], o, -v * e);
      }
      st(u[0], a[0]), st(u[1], a[1]);
    }
  });
}
function Cm(r) {
  return r.type === "view";
}
var WP = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n) {
      var i = new b0(), a = new Z5(), o = this.group;
      this._controller = new D0(n.getZr()), this._controllerHost = {
        target: o
      }, o.add(i.group), o.add(a.group), this._symbolDraw = i, this._lineDraw = a, this._firstRender = !0;
    }, e.prototype.render = function(t, n, i) {
      var a = this, o = t.coordinateSystem;
      this._model = t;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (Cm(o)) {
        var f = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY
        };
        this._firstRender ? u.attr(f) : Pe(u, f, t);
      }
      Dh(t.getGraph(), ko(t));
      var c = t.getData();
      s.updateData(c);
      var h = t.getEdgeData();
      l.updateData(h), this._updateNodeAndLinkScale(), this._updateController(t, n, i), clearTimeout(this._layoutTimeout);
      var v = t.forceLayout, d = t.get(["force", "layoutAnimation"]);
      v && this._startForceLayoutIteration(v, d);
      var g = t.get("layout");
      c.graph.eachNode(function(_) {
        var S = _.dataIndex, b = _.getGraphicEl(), w = _.getModel();
        if (b) {
          b.off("drag").off("dragend");
          var x = w.get("draggable");
          x && b.on("drag", function(T) {
            switch (g) {
              case "force":
                v.warmUp(), !a._layouting && a._startForceLayoutIteration(v, d), v.setFixed(S), c.setItemLayout(S, [b.x, b.y]);
                break;
              case "circular":
                c.setItemLayout(S, [b.x, b.y]), _.setLayout({
                  fixed: !0
                }, !0), N0(t, "symbolSize", _, [T.offsetX, T.offsetY]), a.updateLayout(t);
                break;
              case "none":
              default:
                c.setItemLayout(S, [b.x, b.y]), L0(t.getGraph(), t), a.updateLayout(t);
                break;
            }
          }).on("dragend", function() {
            v && v.setUnfixed(S);
          }), b.setDraggable(x, !!w.get("cursor"));
          var C = w.get(["emphasis", "focus"]);
          C === "adjacency" && (dist_ie(b).focus = _.getAdjacentDataIndices());
        }
      }), c.graph.eachEdge(function(_) {
        var S = _.getGraphicEl(), b = _.getModel().get(["emphasis", "focus"]);
        S && b === "adjacency" && (dist_ie(S).focus = {
          edge: [_.dataIndex],
          node: [_.node1.dataIndex, _.node2.dataIndex]
        });
      });
      var p = t.get("layout") === "circular" && t.get(["circular", "rotateLabel"]), m = c.getLayout("cx"), y = c.getLayout("cy");
      c.graph.eachNode(function(_) {
        Y5(_, p, m, y);
      }), this._firstRender = !1;
    }, e.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype._startForceLayoutIteration = function(t, n) {
      var i = this;
      (function a() {
        t.step(function(o) {
          i.updateLayout(i._model), (i._layouting = !o) && (n ? i._layoutTimeout = setTimeout(a, 16) : a());
        });
      })();
    }, e.prototype._updateController = function(t, n, i) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      if (o.setPointerChecker(function(u, f, c) {
        var h = l.getBoundingRect();
        return h.applyTransform(l.transform), h.contain(f, c) && !L5(u, i, t);
      }), !Cm(t.coordinateSystem)) {
        o.disable();
        return;
      }
      o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        A5(s, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        I5(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(), Dh(t.getGraph(), ko(t)), a._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function() {
      var t = this._model, n = t.getData(), i = ko(t);
      n.eachItemGraphicEl(function(a, o) {
        a && a.setSymbolScale(i);
      });
    }, e.prototype.updateLayout = function(t) {
      Dh(t.getGraph(), ko(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, e.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, e.type = "graph", e;
  }(bt)
);
const UP = WP;
function fa(r) {
  return "_EC_" + r;
}
var YP = (
  /** @class */
  function() {
    function r(e) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || !1;
    }
    return r.prototype.isDirected = function() {
      return this._directed;
    }, r.prototype.addNode = function(e, t) {
      e = e == null ? "" + t : "" + e;
      var n = this._nodesMap;
      if (n[fa(e)]) {
        "production";
        return;
      }
      var i = new _i(e, t);
      return i.hostGraph = this, this.nodes.push(i), n[fa(e)] = i, i;
    }, r.prototype.getNodeByIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this.nodes[t];
    }, r.prototype.getNodeById = function(e) {
      return this._nodesMap[fa(e)];
    }, r.prototype.addEdge = function(e, t, n) {
      var i = this._nodesMap, a = this._edgesMap;
      if (ve(e) && (e = this.nodes[e]), ve(t) && (t = this.nodes[t]), e instanceof _i || (e = i[fa(e)]), t instanceof _i || (t = i[fa(t)]), !(!e || !t)) {
        var o = e.id + "-" + t.id, s = new q5(e, t, n);
        return s.hostGraph = this, this._directed && (e.outEdges.push(s), t.inEdges.push(s)), e.edges.push(s), e !== t && t.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, r.prototype.getEdgeByIndex = function(e) {
      var t = this.edgeData.getRawIndex(e);
      return this.edges[t];
    }, r.prototype.getEdge = function(e, t) {
      e instanceof _i && (e = e.id), t instanceof _i && (t = t.id);
      var n = this._edgesMap;
      return this._directed ? n[e + "-" + t] : n[e + "-" + t] || n[t + "-" + e];
    }, r.prototype.eachNode = function(e, t) {
      for (var n = this.nodes, i = n.length, a = 0; a < i; a++)
        n[a].dataIndex >= 0 && e.call(t, n[a], a);
    }, r.prototype.eachEdge = function(e, t) {
      for (var n = this.edges, i = n.length, a = 0; a < i; a++)
        n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && e.call(t, n[a], a);
    }, r.prototype.breadthFirstTraverse = function(e, t, n, i) {
      if (t instanceof _i || (t = this._nodesMap[fa(t)]), !!t) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
          this.nodes[o].__visited = !1;
        if (!e.call(i, t, null))
          for (var s = [t]; s.length; )
            for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var f = u[o], c = f.node1 === l ? f.node2 : f.node1;
              if (!c.__visited) {
                if (e.call(i, c, l))
                  return;
                s.push(c), c.__visited = !0;
              }
            }
      }
    }, r.prototype.update = function() {
      for (var e = this.data, t = this.edgeData, n = this.nodes, i = this.edges, a = 0, o = n.length; a < o; a++)
        n[a].dataIndex = -1;
      for (var a = 0, o = e.count(); a < o; a++)
        n[e.getRawIndex(a)].dataIndex = a;
      t.filterSelf(function(s) {
        var l = i[t.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = i.length; a < o; a++)
        i[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++)
        i[t.getRawIndex(a)].dataIndex = a;
    }, r.prototype.clone = function() {
      for (var e = new r(this._directed), t = this.nodes, n = this.edges, i = 0; i < t.length; i++)
        e.addNode(t[i].id, t[i].dataIndex);
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        e.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return e;
    }, r;
  }()
), _i = (
  /** @class */
  function() {
    function r(e, t) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = t ?? -1;
    }
    return r.prototype.degree = function() {
      return this.edges.length;
    }, r.prototype.inDegree = function() {
      return this.inEdges.length;
    }, r.prototype.outDegree = function() {
      return this.outEdges.length;
    }, r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, n = t.data.getItemModel(this.dataIndex);
        return n.getModel(e);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      for (var e = {
        edge: [],
        node: []
      }, t = 0; t < this.edges.length; t++) {
        var n = this.edges[t];
        n.dataIndex < 0 || (e.edge.push(n.dataIndex), e.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return e;
    }, r.prototype.getTrajectoryDataIndices = function() {
      for (var e = dist_W(), t = dist_W(), n = 0; n < this.edges.length; n++) {
        var i = this.edges[n];
        if (!(i.dataIndex < 0)) {
          e.set(i.dataIndex, !0);
          for (var a = [i.node1], o = [i.node2], s = 0; s < a.length; ) {
            var l = a[s];
            s++, t.set(l.dataIndex, !0);
            for (var u = 0; u < l.inEdges.length; u++)
              e.set(l.inEdges[u].dataIndex, !0), a.push(l.inEdges[u].node1);
          }
          for (s = 0; s < o.length; ) {
            var f = o[s];
            s++, t.set(f.dataIndex, !0);
            for (var u = 0; u < f.outEdges.length; u++)
              e.set(f.outEdges[u].dataIndex, !0), o.push(f.outEdges[u].node2);
          }
        }
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, r;
  }()
), q5 = (
  /** @class */
  function() {
    function r(e, t, n) {
      this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = n ?? -1;
    }
    return r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, n = t.edgeData.getItemModel(this.dataIndex);
        return n.getModel(e);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, r.prototype.getTrajectoryDataIndices = function() {
      var e = dist_W(), t = dist_W();
      e.set(this.dataIndex, !0);
      for (var n = [this.node1], i = [this.node2], a = 0; a < n.length; ) {
        var o = n[a];
        a++, t.set(o.dataIndex, !0);
        for (var s = 0; s < o.inEdges.length; s++)
          e.set(o.inEdges[s].dataIndex, !0), n.push(o.inEdges[s].node1);
      }
      for (a = 0; a < i.length; ) {
        var l = i[a];
        a++, t.set(l.dataIndex, !0);
        for (var s = 0; s < l.outEdges.length; s++)
          e.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2);
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, r;
  }()
);
function K5(r, e) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(t) {
      var n = this[r][e];
      return n.getStore().get(n.getDimensionIndex(t || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(t, n) {
      this.dataIndex >= 0 && this[r][e].setItemVisual(this.dataIndex, t, n);
    },
    getVisual: function(t) {
      return this[r][e].getItemVisual(this.dataIndex, t);
    },
    setLayout: function(t, n) {
      this.dataIndex >= 0 && this[r][e].setItemLayout(this.dataIndex, t, n);
    },
    getLayout: function() {
      return this[r][e].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[r][e].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[r][e].getRawIndex(this.dataIndex);
    }
  };
}
Ot(_i, K5("hostGraph", "data"));
Ot(q5, K5("hostGraph", "edgeData"));
function XP(r, e, t, n, i) {
  for (var a = new YP(n), o = 0; o < r.length; o++)
    a.addNode(Kt(
      // Id, name, dataIndex
      r[o].id,
      r[o].name,
      o
    ), o);
  for (var s = [], l = [], u = 0, o = 0; o < e.length; o++) {
    var f = e[o], c = f.source, h = f.target;
    a.addEdge(c, h, u) && (l.push(f), s.push(Kt(Zt(f.id, null), c + " > " + h)), u++);
  }
  var v = t.get("coordinateSystem"), d;
  if (v === "cartesian2d" || v === "polar")
    d = ks(r, t);
  else {
    var g = Rs.get(v), p = g ? g.dimensions || [] : [];
    ye(p, "value") < 0 && p.concat(["value"]);
    var m = p0(r, {
      coordDimensions: p,
      encodeDefine: t.getEncode()
    }).dimensions;
    d = new Ba(m, t), d.initData(r);
  }
  var y = new Ba(["value"], t);
  return y.initData(l, s), i && i(d, y), pP({
    mainData: d,
    struct: a,
    structAttr: "graph",
    datas: {
      node: d,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var ZP = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments);
      var n = this;
      function i() {
        return n._categoriesData;
      }
      this.legendVisualProvider = new w5(i, i), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeDefaultAndTheme = function(t) {
      r.prototype.mergeDefaultAndTheme.apply(this, arguments), us(t, "edgeLabel", ["show"]);
    }, e.prototype.getInitialData = function(t, n) {
      var i = t.edges || t.links || [], a = t.data || t.nodes || [], o = this;
      if (a && i) {
        LP(this);
        var s = XP(a, i, this, !0, l);
        return dist_M(s.edges, function(u) {
          NP(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, f) {
        u.wrapMethod("getItemModel", function(d) {
          var g = o._categoriesModels, p = d.getShallow("category"), m = g[p];
          return m && (m.parentModel = d.parentModel, d.parentModel = m), d;
        });
        var c = He.prototype.getModel;
        function h(d, g) {
          var p = c.call(this, d, g);
          return p.resolveParentPath = v, p;
        }
        f.wrapMethod("getItemModel", function(d) {
          return d.resolveParentPath = v, d.getModel = h, d;
        });
        function v(d) {
          if (d && (d[0] === "label" || d[1] === "label")) {
            var g = d.slice();
            return d[0] === "label" ? g[0] = "edgeLabel" : d[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return d;
        }
      }
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, e.prototype.formatTooltip = function(t, n, i) {
      if (i === "edge") {
        var a = this.getData(), o = this.getDataParams(t, i), s = a.graph.getEdgeByIndex(t), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), f = [];
        return l != null && f.push(l), u != null && f.push(u), on("nameValue", {
          name: f.join(" > "),
          value: o.value,
          noValue: o.value == null
        });
      }
      var c = H4({
        series: this,
        dataIndex: t,
        multipleSeries: n
      });
      return c;
    }, e.prototype._updateCategoriesData = function() {
      var t = dist_$(this.option.categories || [], function(i) {
        return i.value != null ? i : dist_V({
          value: 0
        }, i);
      }), n = new Ba(["value"], this);
      n.initData(t), this._categoriesData = n, this._categoriesModels = n.mapArray(function(i) {
        return n.getItemModel(i);
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.isAnimationEnabled = function() {
      return r.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, e.type = "series.graph", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(jt)
);
const qP = ZP;
var KP = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function jP(r) {
  r.registerChartView(UP), r.registerSeriesModel(qP), r.registerProcessor(MP), r.registerVisual(DP), r.registerVisual(EP), r.registerLayout(PP), r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, OP), r.registerLayout(VP), r.registerCoordinateSystem("graphView", {
    dimensions: Rf.dimensions,
    create: FP
  }), r.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, Ue), r.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, Ue), r.registerAction(KP, function(e, t, n) {
    t.eachComponent({
      mainType: "series",
      query: e
    }, function(i) {
      var a = i.coordinateSystem, o = z5(a, e, void 0, n);
      i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom);
    });
  });
}
function Fs(r, e, t, n, i, a) {
  r = r || 0;
  var o = t[1] - t[0];
  if (i != null && (i = ca(i, [0, o])), a != null && (a = Math.max(a, i ?? 0)), n === "all") {
    var s = Math.abs(e[1] - e[0]);
    s = ca(s, [0, o]), i = a = ca(s, [i, a]), n = 0;
  }
  e[0] = ca(e[0], t), e[1] = ca(e[1], t);
  var l = Eh(e, n);
  e[n] += r;
  var u = i || 0, f = t.slice();
  l.sign < 0 ? f[0] += u : f[1] -= u, e[n] = ca(e[n], f);
  var c;
  return c = Eh(e, n), i != null && (c.sign !== l.sign || c.span < i) && (e[1 - n] = e[n] + l.sign * i), c = Eh(e, n), a != null && c.span > a && (e[1 - n] = e[n] + c.sign * a), e;
}
function Eh(r, e) {
  var t = r[e] - r[1 - e];
  return {
    span: Math.abs(t),
    sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1
  };
}
function ca(r, e) {
  return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, r));
}
function Tm(r, e) {
  var t = e.rippleEffectColor || e.color;
  r.eachChild(function(n) {
    n.attr({
      z: e.z,
      zlevel: e.zlevel,
      style: {
        stroke: e.brushType === "stroke" ? t : null,
        fill: e.brushType === "fill" ? t : null
      }
    });
  });
}
var JP = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n) {
      var i = r.call(this) || this, a = new Nf(t, n), o = new dist_oe();
      return i.add(a), i.add(o), i.updateData(t, n), i;
    }
    return e.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, e.prototype.startEffectAnimation = function(t) {
      for (var n = t.symbolType, i = t.color, a = t.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
        var l = dt(n, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / a * t.period + t.effectOffset;
        l.animate("", !0).when(t.period, {
          scaleX: t.rippleScale / 2,
          scaleY: t.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(t.period, {
          opacity: 0
        }).delay(u).start(), o.add(l);
      }
      Tm(o, t);
    }, e.prototype.updateEffectAnimation = function(t) {
      for (var n = this._effectCfg, i = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) {
        var s = a[o];
        if (n[s] !== t[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(t);
          return;
        }
      }
      Tm(i, t);
    }, e.prototype.highlight = function() {
      Pa(this);
    }, e.prototype.downplay = function() {
      Ra(this);
    }, e.prototype.getSymbolType = function() {
      var t = this.childAt(0);
      return t && t.getSymbolType();
    }, e.prototype.updateData = function(t, n) {
      var i = this, a = t.hostModel;
      this.childAt(0).updateData(t, n);
      var o = this.childAt(1), s = t.getItemModel(n), l = t.getItemVisual(n, "symbol"), u = Df(t.getItemVisual(n, "symbolSize")), f = t.getItemVisual(n, "style"), c = f && f.fill, h = s.getModel("emphasis");
      o.setScale(u), o.traverse(function(p) {
        p.setStyle("fill", c);
      });
      var v = Os(t.getItemVisual(n, "symbolOffset"), u);
      v && (o.x = v[0], o.y = v[1]);
      var d = t.getItemVisual(n, "symbolRotate");
      o.rotation = (d || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = a.get("showEffectOn"), g.rippleScale = s.get(["rippleEffect", "scale"]), g.brushType = s.get(["rippleEffect", "brushType"]), g.period = s.get(["rippleEffect", "period"]) * 1e3, g.effectOffset = n / t.count(), g.z = a.getShallow("z") || 0, g.zlevel = a.getShallow("zlevel") || 0, g.symbolType = l, g.color = c, g.rippleEffectColor = s.get(["rippleEffect", "color"]), g.rippleNumber = s.get(["rippleEffect", "number"]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(p) {
        p === "emphasis" ? g.showEffectOn !== "render" && i.startEffectAnimation(g) : p === "normal" && g.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = g, rn(this, h.get("focus"), h.get("blurScope"), h.get("disabled"));
    }, e.prototype.fadeOut = function(t) {
      t && t();
    }, e;
  }(dist_oe)
);
const QP = JP;
var eR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._symbolDraw = new b0(QP);
    }, e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = this._symbolDraw;
      o.updateData(a, {
        clipShape: this._getClipShape(t)
      }), this.group.add(o.group);
    }, e.prototype._getClipShape = function(t) {
      var n = t.coordinateSystem, i = n && n.getArea && n.getArea();
      return t.get("clip", !0) ? i : null;
    }, e.prototype.updateTransform = function(t, n, i) {
      var a = t.getData();
      this.group.dirty();
      var o = C0("").reset(t, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, e.prototype._updateGroupTransform = function(t) {
      var n = t.coordinateSystem;
      n && n.getRoamTransform && (this.group.transform = p7(n.getRoamTransform()), this.group.decomposeTransform());
    }, e.prototype.remove = function(t, n) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, e.type = "effectScatter", e;
  }(bt)
);
const tR = eR;
var rR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      return ks(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.brushSelector = function(t, n, i) {
      return i.point(n.getItemLayout(t));
    }, e.type = "series.effectScatter", e.dependencies = ["grid", "polar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 图形类型
      symbolSize: 10
      // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
      // symbolRotate: null,  // 图形旋转控制
      // itemStyle: {
      //     opacity: 1
      // }
    }, e;
  }(jt)
);
const nR = rR;
function iR(r) {
  r.registerChartView(tR), r.registerSeriesModel(nR), r.registerLayout(C0("effectScatter"));
}
var aR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      return a.add(a.createLine(t, n, i)), a._updateEffectSymbol(t, n), a;
    }
    return e.prototype.createLine = function(t, n, i) {
      return new P0(t, n, i);
    }, e.prototype._updateEffectSymbol = function(t, n) {
      var i = t.getItemModel(n), a = i.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
      dist_F(o) || (o = [o, o]);
      var l = t.getItemVisual(n, "style"), u = a.get("color") || l && l.stroke, f = this.childAt(1);
      this._symbolType !== s && (this.remove(f), f = dt(s, -0.5, -0.5, 1, 1, u), f.z2 = 100, f.culling = !0, this.add(f)), f && (f.setStyle("shadowColor", u), f.setStyle(a.getItemStyle(["color"])), f.scaleX = o[0], f.scaleY = o[1], f.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(t, a, n));
    }, e.prototype._updateEffectAnimation = function(t, n, i) {
      var a = this.childAt(1);
      if (a) {
        var o = t.getItemLayout(i), s = n.get("period") * 1e3, l = n.get("loop"), u = n.get("roundTrip"), f = n.get("constantSpeed"), c = Kt(n.get("delay"), function(v) {
          return v / t.count() * s / 3;
        });
        if (a.ignore = !0, this._updateAnimationPoints(a, o), f > 0 && (s = this._getLineLength(a) / f * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var h = void 0;
          dist_j(c) ? h = c(i) : h = c, a.__t > 0 && (h = -s * a.__t), this._animateSymbol(a, s, h, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, e.prototype._animateSymbol = function(t, n, i, a, o) {
      if (n > 0) {
        t.__t = 0;
        var s = this, l = t.animate("", a).when(o ? n * 2 : n, {
          __t: o ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(t);
        });
        a || l.done(function() {
          s.remove(t);
        }), l.start();
      }
    }, e.prototype._getLineLength = function(t) {
      return In(t.__p1, t.__cp1) + In(t.__cp1, t.__p2);
    }, e.prototype._updateAnimationPoints = function(t, n) {
      t.__p1 = n[0], t.__p2 = n[1], t.__cp1 = n[2] || [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2];
    }, e.prototype.updateData = function(t, n, i) {
      this.childAt(0).updateData(t, n, i), this._updateEffectSymbol(t, n);
    }, e.prototype._updateSymbolPosition = function(t) {
      var n = t.__p1, i = t.__p2, a = t.__cp1, o = t.__t < 1 ? t.__t : 2 - t.__t, s = [t.x, t.y], l = s.slice(), u = We, f = iv;
      s[0] = u(n[0], a[0], i[0], o), s[1] = u(n[1], a[1], i[1], o);
      var c = t.__t < 1 ? f(n[0], a[0], i[0], o) : f(i[0], a[0], n[0], 1 - o), h = t.__t < 1 ? f(n[1], a[1], i[1], o) : f(i[1], a[1], n[1], 1 - o);
      t.rotation = -Math.atan2(h, c) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = In(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * In(n, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = !1, t.x = s[0], t.y = s[1];
    }, e.prototype.updateLayout = function(t, n) {
      this.childAt(0).updateLayout(t, n);
      var i = t.getItemModel(n).getModel("effect");
      this._updateEffectAnimation(t, i, n);
    }, e;
  }(dist_oe)
);
const j5 = aR;
var oR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      return a._createPolyline(t, n, i), a;
    }
    return e.prototype._createPolyline = function(t, n, i) {
      var a = t.getItemLayout(n), o = new cn({
        shape: {
          points: a
        }
      });
      this.add(o), this._updateCommonStl(t, n, i);
    }, e.prototype.updateData = function(t, n, i) {
      var a = t.hostModel, o = this.childAt(0), s = {
        shape: {
          points: t.getItemLayout(n)
        }
      };
      Pe(o, s, a, n), this._updateCommonStl(t, n, i);
    }, e.prototype._updateCommonStl = function(t, n, i) {
      var a = this.childAt(0), o = t.getItemModel(n), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, f = i && i.emphasisDisabled;
      if (!i || t.hasItemOption) {
        var c = o.getModel("emphasis");
        s = c.getModel("lineStyle").getLineStyle(), f = c.get("disabled"), l = c.get("focus"), u = c.get("blurScope");
      }
      a.useStyle(t.getItemVisual(n, "style")), a.style.fill = null, a.style.strokeNoScale = !0;
      var h = a.ensureState("emphasis");
      h.style = s, rn(this, l, u, f);
    }, e.prototype.updateLayout = function(t, n) {
      var i = this.childAt(0);
      i.setShape("points", t.getItemLayout(n));
    }, e;
  }(dist_oe)
);
const J5 = oR;
var sR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t._lastFrame = 0, t._lastFramePercent = 0, t;
    }
    return e.prototype.createLine = function(t, n, i) {
      return new J5(t, n, i);
    }, e.prototype._updateAnimationPoints = function(t, n) {
      this._points = n;
      for (var i = [0], a = 0, o = 1; o < n.length; o++) {
        var s = n[o - 1], l = n[o];
        a += In(s, l), i.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var o = 0; o < i.length; o++)
        i[o] /= a;
      this._offsets = i, this._length = a;
    }, e.prototype._getLineLength = function() {
      return this._length;
    }, e.prototype._updateSymbolPosition = function(t) {
      var n = t.__t < 1 ? t.__t : 2 - t.__t, i = this._points, a = this._offsets, o = i.length;
      if (a) {
        var s = this._lastFrame, l;
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1);
          for (l = u; l >= 0 && !(a[l] <= n); l--)
            ;
          l = Math.min(l, o - 2);
        } else {
          for (l = s; l < o && !(a[l] > n); l++)
            ;
          l = Math.min(l - 1, o - 2);
        }
        var f = (n - a[l]) / (a[l + 1] - a[l]), c = i[l], h = i[l + 1];
        t.x = c[0] * (1 - f) + f * h[0], t.y = c[1] * (1 - f) + f * h[1];
        var v = t.__t < 1 ? h[0] - c[0] : c[0] - h[0], d = t.__t < 1 ? h[1] - c[1] : c[1] - h[1];
        t.rotation = -Math.atan2(d, v) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = n, t.ignore = !1;
      }
    }, e;
  }(j5)
);
const lR = sR;
var uR = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return r;
  }()
), fR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new uR();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.segs, a = n.curveness, o;
      if (n.polyline)
        for (o = this._off; o < i.length; ) {
          var s = i[o++];
          if (s > 0) {
            t.moveTo(i[o++], i[o++]);
            for (var l = 1; l < s; l++)
              t.lineTo(i[o++], i[o++]);
          }
        }
      else
        for (o = this._off; o < i.length; ) {
          var u = i[o++], f = i[o++], c = i[o++], h = i[o++];
          if (t.moveTo(u, f), a > 0) {
            var v = (u + c) / 2 - (f - h) * a, d = (f + h) / 2 - (c - u) * a;
            t.quadraticCurveTo(v, d, c, h);
          } else
            t.lineTo(c, h);
        }
      this.incremental && (this._off = o, this.notClear = !0);
    }, e.prototype.findDataIndex = function(t, n) {
      var i = this.shape, a = i.segs, o = i.curveness, s = this.style.lineWidth;
      if (i.polyline)
        for (var l = 0, u = 0; u < a.length; ) {
          var f = a[u++];
          if (f > 0)
            for (var c = a[u++], h = a[u++], v = 1; v < f; v++) {
              var d = a[u++], g = a[u++];
              if (Mn(c, h, d, g, s, t, n))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < a.length; ) {
          var c = a[u++], h = a[u++], d = a[u++], g = a[u++];
          if (o > 0) {
            var p = (c + d) / 2 - (h - g) * o, m = (h + g) / 2 - (d - c) * o;
            if (u_(c, h, p, m, d, g, s, t, n))
              return l;
          } else if (Mn(c, h, d, g, s, t, n))
            return l;
          l++;
        }
      return -1;
    }, e.prototype.contain = function(t, n) {
      var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
      if (t = i[0], n = i[1], a.contain(t, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var n = this.shape, i = n.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var f = i[u++], c = i[u++];
          a = Math.min(f, a), s = Math.max(f, s), o = Math.min(c, o), l = Math.max(c, l);
        }
        t = this._rect = new dist_ae(a, o, s, l);
      }
      return t;
    }, e;
  }(fe)
), cR = (
  /** @class */
  function() {
    function r() {
      this.group = new dist_oe();
    }
    return r.prototype.updateData = function(e) {
      this._clear();
      var t = this._create();
      t.setShape({
        segs: e.getLayout("linesPoints")
      }), this._setCommon(t, e);
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this.group.removeAll(), this._clear();
    }, r.prototype.incrementalUpdate = function(e, t) {
      var n = this._newAdded[0], i = t.getLayout("linesPoints"), a = n && n.shape.segs;
      if (a && a.length < 2e4) {
        var o = a.length, s = new Float32Array(o + i.length);
        s.set(a), s.set(i, o), n.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: i
        }), this._setCommon(l, t), l.__startIndex = e.start;
      }
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, r.prototype._create = function() {
      var e = new fR({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(e), this.group.add(e), e;
    }, r.prototype._setCommon = function(e, t, n) {
      var i = t.hostModel;
      e.setShape({
        polyline: i.get("polyline"),
        curveness: i.get(["lineStyle", "curveness"])
      }), e.useStyle(i.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = !0;
      var a = t.getVisual("style");
      a && a.stroke && e.setStyle("stroke", a.stroke), e.setStyle("fill", null);
      var o = dist_ie(e);
      o.seriesIndex = i.seriesIndex, e.on("mousemove", function(s) {
        o.dataIndex = null;
        var l = e.hoverDataIdx;
        l > 0 && (o.dataIndex = l + e.__startIndex);
      });
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
), hR = {
  seriesType: "lines",
  plan: Tf(),
  reset: function(r) {
    var e = r.coordinateSystem;
    if (!e) {
       false && 0;
      return;
    }
    var t = r.get("polyline"), n = r.pipelineContext.large;
    return {
      progress: function(i, a) {
        var o = [];
        if (n) {
          var s = void 0, l = i.end - i.start;
          if (t) {
            for (var u = 0, f = i.start; f < i.end; f++)
              u += r.getLineCoordsCount(f);
            s = new Float32Array(l + u * 2);
          } else
            s = new Float32Array(l * 4);
          for (var c = 0, h = [], f = i.start; f < i.end; f++) {
            var v = r.getLineCoords(f, o);
            t && (s[c++] = v);
            for (var d = 0; d < v; d++)
              h = e.dataToPoint(o[d], !1, h), s[c++] = h[0], s[c++] = h[1];
          }
          a.setLayout("linesPoints", s);
        } else
          for (var f = i.start; f < i.end; f++) {
            var g = a.getItemModel(f), v = r.getLineCoords(f, o), p = [];
            if (t)
              for (var m = 0; m < v; m++)
                p.push(e.dataToPoint(o[m]));
            else {
              p[0] = e.dataToPoint(o[0]), p[1] = e.dataToPoint(o[1]);
              var y = g.get(["lineStyle", "curveness"]);
              +y && (p[2] = [(p[0][0] + p[1][0]) / 2 - (p[0][1] - p[1][1]) * y, (p[0][1] + p[1][1]) / 2 - (p[1][0] - p[0][0]) * y]);
            }
            a.setItemLayout(f, p);
          }
      }
    };
  }
};
const Q5 = hR;
var vR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = this._updateLineDraw(a, t), s = t.get("zlevel"), l = t.get(["effect", "trailLength"]), u = i.getZr(), f = u.painter.getType() === "svg";
      f || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !f && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(t) && l > 0 && (f ? "production" : u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), o.updateData(a);
      var c = t.get("clip", !0) && h5(t.coordinateSystem, !1, t);
      c ? this.group.setClipPath(c) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, n, i) {
      var a = t.getData(), o = this._updateLineDraw(a, t);
      o.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, n, i) {
      this._lineDraw.incrementalUpdate(t, n.getData()), this._finished = t.end === n.getData().count();
    }, e.prototype.eachRendered = function(t) {
      this._lineDraw && this._lineDraw.eachRendered(t);
    }, e.prototype.updateTransform = function(t, n, i) {
      var a = t.getData(), o = t.pipelineContext;
      if (!this._finished || o.large || o.progressiveRender)
        return {
          update: !0
        };
      var s = Q5.reset(t, n, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, e.prototype._updateLineDraw = function(t, n) {
      var i = this._lineDraw, a = this._showEffect(n), o = !!n.get("polyline"), s = n.pipelineContext, l = s.large;
      return "production", (!i || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new cR() : new Z5(o ? a ? lR : J5 : a ? j5 : P0), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(i.group), i;
    }, e.prototype._showEffect = function(t) {
      return !!t.get(["effect", "show"]);
    }, e.prototype._clearLayer = function(t) {
      var n = t.getZr(), i = n.painter.getType() === "svg";
      !i && this._lastZlevel != null && n.painter.getLayer(this._lastZlevel).clear(!0);
    }, e.prototype.remove = function(t, n) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(n);
    }, e.prototype.dispose = function(t, n) {
      this.remove(t, n);
    }, e.type = "lines", e;
  }(bt)
);
const dR = vR;
var pR = typeof Uint32Array > "u" ? Array : Uint32Array, gR = typeof Float64Array > "u" ? Array : Float64Array;
function Mm(r) {
  var e = r.data;
  e && e[0] && e[0][0] && e[0][0].coord && ("production", r.data = dist_$(e, function(t) {
    var n = [t[0].coord, t[1].coord], i = {
      coords: n
    };
    return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), m3([i, t[0], t[1]]);
  }));
}
var mR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.init = function(t) {
      t.data = t.data || [], Mm(t);
      var n = this._processFlatCoordsArray(t.data);
      this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (t.data = new Float32Array(n.count)), r.prototype.init.apply(this, arguments);
    }, e.prototype.mergeOption = function(t) {
      if (Mm(t), t.data) {
        var n = this._processFlatCoordsArray(t.data);
        this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (t.data = new Float32Array(n.count));
      }
      r.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.appendData = function(t) {
      var n = this._processFlatCoordsArray(t.data);
      n.flatCoords && (this._flatCoords ? (this._flatCoords = Kh(this._flatCoords, n.flatCoords), this._flatCoordsOffset = Kh(this._flatCoordsOffset, n.flatCoordsOffset)) : (this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset), t.data = new Float32Array(n.count)), this.getRawData().appendData(t.data);
    }, e.prototype._getCoordsFromItemModel = function(t) {
      var n = this.getData().getItemModel(t), i = n.option instanceof Array ? n.option : n.getShallow("coords");
      if (false)
        {}
      return i;
    }, e.prototype.getLineCoordsCount = function(t) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length;
    }, e.prototype.getLineCoords = function(t, n) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[t * 2], a = this._flatCoordsOffset[t * 2 + 1], o = 0; o < a; o++)
          n[o] = n[o] || [], n[o][0] = this._flatCoords[i + o * 2], n[o][1] = this._flatCoords[i + o * 2 + 1];
        return a;
      } else {
        for (var s = this._getCoordsFromItemModel(t), o = 0; o < s.length; o++)
          n[o] = n[o] || [], n[o][0] = s[o][0], n[o][1] = s[o][1];
        return s.length;
      }
    }, e.prototype._processFlatCoordsArray = function(t) {
      var n = 0;
      if (this._flatCoords && (n = this._flatCoords.length), ve(t[0])) {
        for (var i = t.length, a = new pR(i), o = new gR(i), s = 0, l = 0, u = 0, f = 0; f < i; ) {
          u++;
          var c = t[f++];
          a[l++] = s + n, a[l++] = c;
          for (var h = 0; h < c; h++) {
            var v = t[f++], d = t[f++];
            if (o[s++] = v, o[s++] = d, f > i && "production" !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: t.length
      };
    }, e.prototype.getInitialData = function(t, n) {
      if (false) { var i; }
      var a = new Ba(["value"], this);
      return a.hasItemOption = !1, a.initData(t.data, [], function(o, s, l, u) {
        if (o instanceof Array)
          return NaN;
        a.hasItemOption = !0;
        var f = o.value;
        if (f != null)
          return f instanceof Array ? f[u] : f;
      }), a;
    }, e.prototype.formatTooltip = function(t, n, i) {
      var a = this.getData(), o = a.getItemModel(t), s = o.get("name");
      if (s)
        return s;
      var l = o.get("fromName"), u = o.get("toName"), f = [];
      return l != null && f.push(l), u != null && f.push(u), on("nameValue", {
        name: f.join(" > ")
      });
    }, e.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, e.prototype.getZLevelKey = function() {
      var t = this.getModel("effect"), n = t.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && n > 0 ? n + "" : "";
    }, e.type = "series.lines", e.dependencies = ["grid", "polar", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      lineStyle: {
        opacity: 0.5
      }
    }, e;
  }(jt)
);
const yR = mR;
function Rl(r) {
  return r instanceof Array || (r = [r, r]), r;
}
var _R = {
  seriesType: "lines",
  reset: function(r) {
    var e = Rl(r.get("symbol")), t = Rl(r.get("symbolSize")), n = r.getData();
    n.setVisual("fromSymbol", e && e[0]), n.setVisual("toSymbol", e && e[1]), n.setVisual("fromSymbolSize", t && t[0]), n.setVisual("toSymbolSize", t && t[1]);
    function i(a, o) {
      var s = a.getItemModel(o), l = Rl(s.getShallow("symbol", !0)), u = Rl(s.getShallow("symbolSize", !0));
      l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
    }
    return {
      dataEach: n.hasItemOption ? i : null
    };
  }
};
const SR = _R;
function wR(r) {
  r.registerChartView(dR), r.registerSeriesModel(yR), r.registerLayout(Q5), r.registerVisual(SR);
}
var wi = Me(), Dm = dist_te, Ah = dist_Z, bR = (
  /** @class */
  function() {
    function r() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return r.prototype.render = function(e, t, n, i) {
      var a = t.get("value"), o = t.get("status");
      if (this._axisModel = e, this._axisPointerModel = t, this._api = n, !(!i && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, e, t, n);
        var f = u.graphicKey;
        f !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = f;
        var c = this._moveAnimation = this.determineAnimation(e, t);
        if (!s)
          s = this._group = new dist_oe(), this.createPointerEl(s, u, e, t), this.createLabelEl(s, u, e, t), n.getZr().add(s);
        else {
          var h = Te(Em, t, c);
          this.updatePointerEl(s, u, h), this.updateLabelEl(s, u, h, t);
        }
        Im(s, t, !0), this._renderHandle(a);
      }
    }, r.prototype.remove = function(e) {
      this.clear(e);
    }, r.prototype.dispose = function(e) {
      this.clear(e);
    }, r.prototype.determineAnimation = function(e, t) {
      var n = t.get("animation"), i = e.axis, a = i.type === "category", o = t.get("snap");
      if (!o && !a)
        return !1;
      if (n === "auto" || n == null) {
        var s = this.animationThreshold;
        if (a && i.getBandWidth() > s)
          return !0;
        if (o) {
          var l = M0(e).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return n === !0;
    }, r.prototype.makeElOption = function(e, t, n, i, a) {
    }, r.prototype.createPointerEl = function(e, t, n, i) {
      var a = t.pointer;
      if (a) {
        var o = wi(e).pointerEl = new z8[a.type](Dm(t.pointer));
        e.add(o);
      }
    }, r.prototype.createLabelEl = function(e, t, n, i) {
      if (t.label) {
        var a = wi(e).labelEl = new Ne(Dm(t.label));
        e.add(a), Am(a, i);
      }
    }, r.prototype.updatePointerEl = function(e, t, n) {
      var i = wi(e).pointerEl;
      i && t.pointer && (i.setStyle(t.pointer.style), n(i, {
        shape: t.pointer.shape
      }));
    }, r.prototype.updateLabelEl = function(e, t, n, i) {
      var a = wi(e).labelEl;
      a && (a.setStyle(t.label.style), n(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: t.label.x,
        y: t.label.y
      }), Am(a, i));
    }, r.prototype._renderHandle = function(e) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var t = this._axisPointerModel, n = this._api.getZr(), i = this._handle, a = t.getModel("handle"), o = t.get("status");
        if (!a.get("show") || !o || o === "hide") {
          i && n.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, i = this._handle = Xd(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Qr(u.event);
          },
          onmousedown: Ah(this._onHandleDragMove, this, 0, 0),
          drift: Ah(this._onHandleDragMove, this),
          ondragend: Ah(this._onHandleDragEnd, this)
        }), n.add(i)), Im(i, t, !1), i.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        dist_F(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, Mf(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s);
      }
    }, r.prototype._moveHandleToValue = function(e, t) {
      Em(this._axisPointerModel, !t && this._moveAnimation, this._handle, Ih(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)));
    }, r.prototype._onHandleDragMove = function(e, t) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var i = this.updateHandleTransform(Ih(n), [e, t], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, n.stopAnimation(), n.attr(Ih(i)), wi(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, r.prototype._doDispatchAxisPointer = function() {
      var e = this._handle;
      if (e) {
        var t = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: t.cursorPoint[0],
          y: t.cursorPoint[1],
          tooltipOption: t.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, r.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var e = this._handle;
      if (e) {
        var t = this._axisPointerModel.get("value");
        this._moveHandleToValue(t), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, r.prototype.clear = function(e) {
      this._lastValue = null, this._lastStatus = null;
      var t = e.getZr(), n = this._group, i = this._handle;
      t && n && (this._lastGraphicKey = null, n && t.remove(n), i && t.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), Du(this, "_doDispatchAxisPointer");
    }, r.prototype.doClear = function() {
    }, r.prototype.buildLabel = function(e, t, n) {
      return n = n || 0, {
        x: e[n],
        y: e[1 - n],
        width: t[n],
        height: t[1 - n]
      };
    }, r;
  }()
);
function Em(r, e, t, n) {
  eS(wi(t).lastProp, n) || (wi(t).lastProp = n, e ? Pe(t, n, r) : (t.stopAnimation(), t.attr(n)));
}
function eS(r, e) {
  if (dist_X(r) && dist_X(e)) {
    var t = !0;
    return dist_M(e, function(n, i) {
      t = t && eS(r[i], n);
    }), !!t;
  } else
    return r === e;
}
function Am(r, e) {
  r[e.get(["label", "show"]) ? "show" : "hide"]();
}
function Ih(r) {
  return {
    x: r.x || 0,
    y: r.y || 0,
    rotation: r.rotation || 0
  };
}
function Im(r, e, t) {
  var n = e.get("z"), i = e.get("zlevel");
  r && r.traverse(function(a) {
    a.type !== "group" && (n != null && (a.z = n), i != null && (a.zlevel = i), a.silent = t);
  });
}
const xR = bR;
function CR(r) {
  var e = r.get("type"), t = r.getModel(e + "Style"), n;
  return e === "line" ? (n = t.getLineStyle(), n.fill = null) : e === "shadow" && (n = t.getAreaStyle(), n.stroke = null), n;
}
function TR(r, e, t, n, i) {
  var a = t.get("value"), o = tS(a, e.axis, e.ecModel, t.get("seriesDataIndices"), {
    precision: t.get(["label", "precision"]),
    formatter: t.get(["label", "formatter"])
  }), s = t.getModel("label"), l = Ns(s.get("padding") || 0), u = s.getFont(), f = Md(o, u), c = i.position, h = f.width + l[1] + l[3], v = f.height + l[0] + l[2], d = i.align;
  d === "right" && (c[0] -= h), d === "center" && (c[0] -= h / 2);
  var g = i.verticalAlign;
  g === "bottom" && (c[1] -= v), g === "middle" && (c[1] -= v / 2), MR(c, h, v, n);
  var p = s.get("backgroundColor");
  (!p || p === "auto") && (p = e.get(["axisLine", "lineStyle", "color"])), r.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: c[0],
    y: c[1],
    style: Lt(s, {
      text: o,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: p
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function MR(r, e, t, n) {
  var i = n.getWidth(), a = n.getHeight();
  r[0] = Math.min(r[0] + e, i) - e, r[1] = Math.min(r[1] + t, a) - t, r[0] = Math.max(r[0], 0), r[1] = Math.max(r[1], 0);
}
function tS(r, e, t, n, i) {
  r = e.scale.parse(r);
  var a = e.scale.getLabel({
    value: r
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: i.precision
  }), o = i.formatter;
  if (o) {
    var s = {
      value: _0(e, {
        value: r
      }),
      axisDimension: e.dim,
      axisIndex: e.index,
      seriesData: []
    };
    dist_M(n, function(l) {
      var u = t.getSeriesByIndex(l.seriesIndex), f = l.dataIndexInside, c = u && u.getDataParams(f);
      c && s.seriesData.push(c);
    }), dist_U(o) ? a = o.replace("{value}", a) : dist_j(o) && (a = o(s));
  }
  return a;
}
function rS(r, e, t) {
  var n = Yr();
  return nf(n, n, t.rotation), lu(n, n, t.position), Bn([r.dataToCoord(e), (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)], n);
}
function DR(r, e, t, n, i, a) {
  var o = C5.innerTextLayout(t.rotation, 0, t.labelDirection);
  t.labelMargin = i.get(["label", "margin"]), TR(e, n, i, a, {
    position: rS(n.axis, r, t),
    align: o.textAlign,
    verticalAlign: o.textVerticalAlign
  });
}
function ER(r, e, t) {
  return t = t || 0, {
    x1: r[t],
    y1: r[1 - t],
    x2: e[t],
    y2: e[1 - t]
  };
}
function AR(r, e, t) {
  return t = t || 0, {
    x: r[t],
    y: r[1 - t],
    width: e[t],
    height: e[1 - t]
  };
}
var IR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, n, i, a, o) {
      var s = i.axis, l = s.grid, u = a.get("type"), f = Lm(l, s).getOtherAxis(s).getGlobalExtent(), c = s.toGlobalCoord(s.dataToCoord(n, !0));
      if (u && u !== "none") {
        var h = CR(a), v = LR[u](s, c, f);
        v.style = h, t.graphicKey = v.type, t.pointer = v;
      }
      var d = Yv(l.model, i);
      DR(
        // @ts-ignore
        n,
        t,
        d,
        i,
        a,
        o
      );
    }, e.prototype.getHandleTransform = function(t, n, i) {
      var a = Yv(n.axis.grid.model, n, {
        labelInside: !1
      });
      a.labelMargin = i.get(["handle", "margin"]);
      var o = rS(n.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, n, i, a) {
      var o = i.axis, s = o.grid, l = o.getGlobalExtent(!0), u = Lm(s, o).getOtherAxis(o).getGlobalExtent(), f = o.dim === "x" ? 0 : 1, c = [t.x, t.y];
      c[f] += n[f], c[f] = Math.min(l[1], c[f]), c[f] = Math.max(l[0], c[f]);
      var h = (u[1] + u[0]) / 2, v = [h, h];
      v[f] = c[f];
      var d = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: c[0],
        y: c[1],
        rotation: t.rotation,
        cursorPoint: v,
        tooltipOption: d[f]
      };
    }, e;
  }(xR)
);
function Lm(r, e) {
  var t = {};
  return t[e.dim + "AxisIndex"] = e.index, r.getCartesian(t);
}
var LR = {
  line: function(r, e, t) {
    var n = ER([e, t[0]], [e, t[1]], Nm(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(r, e, t) {
    var n = Math.max(1, r.getBandWidth()), i = t[1] - t[0];
    return {
      type: "Rect",
      shape: AR([e - n / 2, t[0]], [n, i], Nm(r))
    };
  }
};
function Nm(r) {
  return r.dim === "x" ? 0 : 1;
}
const NR = IR;
var PR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "axisPointer", e.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, e;
  }(Se)
);
const RR = PR;
var $r = Me(), OR = dist_M;
function nS(r, e, t) {
  if (!dist_ee.node) {
    var n = e.getZr();
    $r(n).records || ($r(n).records = {}), kR(n, e);
    var i = $r(n).records[r] || ($r(n).records[r] = {});
    i.handler = t;
  }
}
function kR(r, e) {
  if ($r(r).initialized)
    return;
  $r(r).initialized = !0, t("click", Te(Pm, "click")), t("mousemove", Te(Pm, "mousemove")), t("globalout", BR);
  function t(n, i) {
    r.on(n, function(a) {
      var o = FR(e);
      OR($r(r).records, function(s) {
        s && i(s, a, o.dispatchAction);
      }), VR(o.pendings, e);
    });
  }
}
function VR(r, e) {
  var t = r.showTip.length, n = r.hideTip.length, i;
  t ? i = r.showTip[t - 1] : n && (i = r.hideTip[n - 1]), i && (i.dispatchAction = null, e.dispatchAction(i));
}
function BR(r, e, t) {
  r.handler("leave", null, t);
}
function Pm(r, e, t, n) {
  e.handler(r, t, n);
}
function FR(r) {
  var e = {
    showTip: [],
    hideTip: []
  }, t = function(n) {
    var i = e[n.type];
    i ? i.push(n) : (n.dispatchAction = t, r.dispatchAction(n));
  };
  return {
    dispatchAction: t,
    pendings: e
  };
}
function td(r, e) {
  if (!dist_ee.node) {
    var t = e.getZr(), n = ($r(t).records || {})[r];
    n && ($r(t).records[r] = null);
  }
}
var zR = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = n.getComponent("tooltip"), o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      nS("axisPointer", i, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, e.prototype.remove = function(t, n) {
      td("axisPointer", n);
    }, e.prototype.dispose = function(t, n) {
      td("axisPointer", n);
    }, e.type = "axisPointer", e;
  }(Pt)
);
const GR = zR;
function iS(r, e) {
  var t = [], n = r.seriesIndex, i;
  if (n == null || !(i = e.getSeriesByIndex(n)))
    return {
      point: []
    };
  var a = i.getData(), o = Vi(a, r);
  if (o == null || o < 0 || dist_F(o))
    return {
      point: []
    };
  var s = a.getItemGraphicEl(o), l = i.coordinateSystem;
  if (i.getTooltipPosition)
    t = i.getTooltipPosition(o) || [];
  else if (l && l.dataToPoint)
    if (r.isStacked) {
      var u = l.getBaseAxis(), f = l.getOtherAxis(u), c = f.dim, h = u.dim, v = c === "x" || c === "radius" ? 1 : 0, d = a.mapDimension(h), g = [];
      g[v] = a.get(d, o), g[1 - v] = a.get(a.getCalculationInfo("stackResultDimension"), o), t = l.dataToPoint(g) || [];
    } else
      t = l.dataToPoint(a.getValues(dist_$(l.dimensions, function(m) {
        return a.mapDimension(m);
      }), o)) || [];
  else if (s) {
    var p = s.getBoundingRect().clone();
    p.applyTransform(s.transform), t = [p.x + p.width / 2, p.y + p.height / 2];
  }
  return {
    point: t,
    el: s
  };
}
var Rm = Me();
function HR(r, e, t) {
  var n = r.currTrigger, i = [r.x, r.y], a = r, o = r.dispatchAction || dist_Z(t.dispatchAction, t), s = e.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    tu(i) && (i = iS({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, e).point);
    var l = tu(i), u = a.axesInfo, f = s.axesInfo, c = n === "leave" || tu(i), h = {}, v = {}, d = {
      list: [],
      map: {}
    }, g = {
      showPointer: Te(WR, v),
      showTooltip: Te(UR, d)
    };
    dist_M(s.coordSysMap, function(m, y) {
      var _ = l || m.containPoint(i);
      dist_M(s.coordSysAxesInfo[y], function(S, b) {
        var w = S.axis, x = qR(u, S);
        if (!c && _ && (!u || x)) {
          var C = x && x.value;
          C == null && !l && (C = w.pointToData(i)), C != null && Om(S, C, g, !1, h);
        }
      });
    });
    var p = {};
    return dist_M(f, function(m, y) {
      var _ = m.linkGroup;
      _ && !v[y] && dist_M(_.axesInfo, function(S, b) {
        var w = v[b];
        if (S !== m && w) {
          var x = w.value;
          _.mapper && (x = m.axis.scale.parse(_.mapper(x, km(S), km(m)))), p[m.key] = x;
        }
      });
    }), dist_M(p, function(m, y) {
      Om(f[y], m, g, !0, h);
    }), YR(v, f, h), XR(d, i, r, o), ZR(f, o, t), h;
  }
}
function Om(r, e, t, n, i) {
  var a = r.axis;
  if (!(a.scale.isBlank() || !a.containData(e))) {
    if (!r.involveSeries) {
      t.showPointer(r, e);
      return;
    }
    var o = $R(e, r), s = o.payloadBatch, l = o.snapToValue;
    s[0] && i.seriesIndex == null && dist_V(i, s[0]), !n && r.snap && a.containData(l) && l != null && (e = l), t.showPointer(r, e, s), t.showTooltip(r, o, l);
  }
}
function $R(r, e) {
  var t = e.axis, n = t.dim, i = r, a = [], o = Number.MAX_VALUE, s = -1;
  return dist_M(e.seriesModels, function(l, u) {
    var f = l.getData().mapDimensionsAll(n), c, h;
    if (l.getAxisTooltipData) {
      var v = l.getAxisTooltipData(f, r, t);
      h = v.dataIndices, c = v.nestestValue;
    } else {
      if (h = l.getData().indicesOfNearest(
        f[0],
        r,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        t.type === "category" ? 0.5 : null
      ), !h.length)
        return;
      c = l.getData().get(f[0], h[0]);
    }
    if (!(c == null || !isFinite(c))) {
      var d = r - c, g = Math.abs(d);
      g <= o && ((g < o || d >= 0 && s < 0) && (o = g, s = d, i = c, a.length = 0), dist_M(h, function(p) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: p,
          dataIndex: l.getData().getRawIndex(p)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: i
  };
}
function WR(r, e, t, n) {
  r[e.key] = {
    value: t,
    payloadBatch: n
  };
}
function UR(r, e, t, n) {
  var i = t.payloadBatch, a = e.axis, o = a.model, s = e.axisPointerModel;
  if (!(!e.triggerTooltip || !i.length)) {
    var l = e.coordSys.model, u = ys(l), f = r.map[u];
    f || (f = r.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, r.list.push(f)), f.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: o.componentIndex,
      axisType: o.type,
      axisId: o.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: i.slice()
    });
  }
}
function YR(r, e, t) {
  var n = t.axesInfo = [];
  dist_M(e, function(i, a) {
    var o = i.axisPointerModel.option, s = r[a];
    s ? (!i.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (o.status = "hide"), o.status === "show" && n.push({
      axisDim: i.axis.dim,
      axisIndex: i.axis.model.componentIndex,
      value: o.value
    });
  });
}
function XR(r, e, t, n) {
  if (tu(e) || !r.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var i = ((r.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: e[0],
    y: e[1],
    tooltipOption: t.tooltipOption,
    position: t.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: r.list
  });
}
function ZR(r, e, t) {
  var n = t.getZr(), i = "axisPointerLastHighlights", a = Rm(n)[i] || {}, o = Rm(n)[i] = {};
  dist_M(r, function(u, f) {
    var c = u.axisPointerModel.option;
    c.status === "show" && u.triggerEmphasis && dist_M(c.seriesDataIndices, function(h) {
      var v = h.seriesIndex + " | " + h.dataIndex;
      o[v] = h;
    });
  });
  var s = [], l = [];
  dist_M(a, function(u, f) {
    !o[f] && l.push(u);
  }), dist_M(o, function(u, f) {
    !a[f] && s.push(u);
  }), l.length && t.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && t.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function qR(r, e) {
  for (var t = 0; t < (r || []).length; t++) {
    var n = r[t];
    if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function km(r) {
  var e = r.axis.model, t = {}, n = t.axisDim = r.axis.dim;
  return t.axisIndex = t[n + "AxisIndex"] = e.componentIndex, t.axisName = t[n + "AxisName"] = e.name, t.axisId = t[n + "AxisId"] = e.id, t;
}
function tu(r) {
  return !r || r[0] == null || isNaN(r[0]) || r[1] == null || isNaN(r[1]);
}
function aS(r) {
  T5.registerAxisPointerClass("CartesianAxisPointer", NR), r.registerComponentModel(RR), r.registerComponentView(GR), r.registerPreprocessor(function(e) {
    if (e) {
      (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
      var t = e.axisPointer.link;
      t && !dist_F(t) && (e.axisPointer.link = [t]);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, function(e, t) {
    e.getComponent("axisPointer").coordSysAxesInfo = sN(e, t);
  }), r.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, HR);
}
function KR(r) {
  Rt(wN), Rt(aS);
}
var Vm = ["x", "y", "radius", "angle", "single"], jR = ["cartesian2d", "polar", "singleAxis"];
function JR(r) {
  var e = r.get("coordinateSystem");
  return ye(jR, e) >= 0;
}
function kn(r) {
  return  false && 0, r + "Axis";
}
function QR(r, e) {
  var t = dist_W(), n = [], i = dist_W();
  r.eachComponent({
    mainType: "dataZoom",
    query: e
  }, function(f) {
    i.get(f.uid) || s(f);
  });
  var a;
  do
    a = !1, r.eachComponent("dataZoom", o);
  while (a);
  function o(f) {
    !i.get(f.uid) && l(f) && (s(f), a = !0);
  }
  function s(f) {
    i.set(f.uid, !0), n.push(f), u(f);
  }
  function l(f) {
    var c = !1;
    return f.eachTargetAxis(function(h, v) {
      var d = t.get(h);
      d && d[v] && (c = !0);
    }), c;
  }
  function u(f) {
    f.eachTargetAxis(function(c, h) {
      (t.get(c) || t.set(c, []))[h] = !0;
    });
  }
  return n;
}
function oS(r) {
  var e = r.ecModel, t = {
    infoList: [],
    infoMap: dist_W()
  };
  return r.eachTargetAxis(function(n, i) {
    var a = e.getComponent(kn(n), i);
    if (a) {
      var o = a.getCoordSysModel();
      if (o) {
        var s = o.uid, l = t.infoMap.get(s);
        l || (l = {
          model: o,
          axisModels: []
        }, t.infoList.push(l), t.infoMap.set(s, l)), l.axisModels.push(a);
      }
    }
  }), t;
}
var Lh = (
  /** @class */
  function() {
    function r() {
      this.indexList = [], this.indexMap = [];
    }
    return r.prototype.add = function(e) {
      this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = !0);
    }, r;
  }()
), Gu = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._autoThrottle = !0, t._noTarget = !0, t._rangePropMode = ["percent", "percent"], t;
    }
    return e.prototype.init = function(t, n, i) {
      var a = Bm(t);
      this.settledOption = a, this.mergeDefaultAndTheme(t, i), this._doInit(a);
    }, e.prototype.mergeOption = function(t) {
      var n = Bm(t);
      he(this.option, t, !0), he(this.settledOption, n, !0), this._doInit(n);
    }, e.prototype._doInit = function(t) {
      var n = this.option;
      this._setDefaultThrottle(t), this._updateRangeUse(t);
      var i = this.settledOption;
      dist_M([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        this._rangePropMode[o] === "value" && (n[a[0]] = i[a[0]] = null);
      }, this), this._resetTarget();
    }, e.prototype._resetTarget = function() {
      var t = this.get("orient", !0), n = this._targetAxisInfoMap = dist_W(), i = this._fillSpecifiedTargetAxis(n);
      i ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(n, this._orient)), this._noTarget = !0, n.each(function(a) {
        a.indexList.length && (this._noTarget = !1);
      }, this);
    }, e.prototype._fillSpecifiedTargetAxis = function(t) {
      var n = !1;
      return dist_M(Vm, function(i) {
        var a = this.getReferringComponents(kn(i), NC);
        if (a.specified) {
          n = !0;
          var o = new Lh();
          dist_M(a.models, function(s) {
            o.add(s.componentIndex);
          }), t.set(i, o);
        }
      }, this), n;
    }, e.prototype._fillAutoTargetAxisByOrient = function(t, n) {
      var i = this.ecModel, a = !0;
      if (a) {
        var o = n === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: o + "Axis"
        });
        l(s, o);
      }
      if (a) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(f) {
            return f.get("orient", !0) === n;
          }
        });
        l(s, "single");
      }
      function l(u, f) {
        var c = u[0];
        if (c) {
          var h = new Lh();
          if (h.add(c.componentIndex), t.set(f, h), a = !1, f === "x" || f === "y") {
            var v = c.getReferringComponents("grid", ft).models[0];
            v && dist_M(u, function(d) {
              c.componentIndex !== d.componentIndex && v === d.getReferringComponents("grid", ft).models[0] && h.add(d.componentIndex);
            });
          }
        }
      }
      a && dist_M(Vm, function(u) {
        if (a) {
          var f = i.findComponents({
            mainType: kn(u),
            filter: function(h) {
              return h.get("type", !0) === "category";
            }
          });
          if (f[0]) {
            var c = new Lh();
            c.add(f[0].componentIndex), t.set(u, c), a = !1;
          }
        }
      }, this);
    }, e.prototype._makeAutoOrientByTargetAxis = function() {
      var t;
      return this.eachTargetAxis(function(n) {
        !t && (t = n);
      }, this), t === "y" ? "vertical" : "horizontal";
    }, e.prototype._setDefaultThrottle = function(t) {
      if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var n = this.ecModel.option;
        this.option.throttle = n.animation && n.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, e.prototype._updateRangeUse = function(t) {
      var n = this._rangePropMode, i = this.get("rangeMode");
      dist_M([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        var s = t[a[0]] != null, l = t[a[1]] != null;
        s && !l ? n[o] = "percent" : !s && l ? n[o] = "value" : i ? n[o] = i[o] : s && (n[o] = "percent");
      });
    }, e.prototype.noTarget = function() {
      return this._noTarget;
    }, e.prototype.getFirstTargetAxisModel = function() {
      var t;
      return this.eachTargetAxis(function(n, i) {
        t == null && (t = this.ecModel.getComponent(kn(n), i));
      }, this), t;
    }, e.prototype.eachTargetAxis = function(t, n) {
      this._targetAxisInfoMap.each(function(i, a) {
        dist_M(i.indexList, function(o) {
          t.call(n, a, o);
        });
      });
    }, e.prototype.getAxisProxy = function(t, n) {
      var i = this.getAxisModel(t, n);
      if (i)
        return i.__dzAxisProxy;
    }, e.prototype.getAxisModel = function(t, n) {
       false && 0;
      var i = this._targetAxisInfoMap.get(t);
      if (i && i.indexMap[n])
        return this.ecModel.getComponent(kn(t), n);
    }, e.prototype.setRawRange = function(t) {
      var n = this.option, i = this.settledOption;
      dist_M([["start", "startValue"], ["end", "endValue"]], function(a) {
        (t[a[0]] != null || t[a[1]] != null) && (n[a[0]] = i[a[0]] = t[a[0]], n[a[1]] = i[a[1]] = t[a[1]]);
      }, this), this._updateRangeUse(t);
    }, e.prototype.setCalculatedRange = function(t) {
      var n = this.option;
      dist_M(["start", "startValue", "end", "endValue"], function(i) {
        n[i] = t[i];
      });
    }, e.prototype.getPercentRange = function() {
      var t = this.findRepresentativeAxisProxy();
      if (t)
        return t.getDataPercentWindow();
    }, e.prototype.getValueRange = function(t, n) {
      if (t == null && n == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i)
          return i.getDataValueWindow();
      } else
        return this.getAxisProxy(t, n).getDataValueWindow();
    }, e.prototype.findRepresentativeAxisProxy = function(t) {
      if (t)
        return t.__dzAxisProxy;
      for (var n, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++)
        for (var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(o, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          n || (n = u);
        }
      return n;
    }, e.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, e.prototype.getOrient = function() {
      return  false && 0, this._orient;
    }, e.type = "dataZoom", e.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, e;
  }(Se)
);
function Bm(r) {
  var e = {};
  return dist_M(["start", "end", "startValue", "endValue", "throttle"], function(t) {
    r.hasOwnProperty(t) && (e[t] = r[t]);
  }), e;
}
var eO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this.dataZoomModel = t, this.ecModel = n, this.api = i;
    }, e.type = "dataZoom", e;
  }(Pt)
);
const sS = eO;
var _a = dist_M, Fm = xi, tO = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      this._dimName = e, this._axisIndex = t, this.ecModel = i, this._dataZoomModel = n;
    }
    return r.prototype.hostedBy = function(e) {
      return this._dataZoomModel === e;
    }, r.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, r.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, r.prototype.getTargetSeriesModels = function() {
      var e = [];
      return this.ecModel.eachSeries(function(t) {
        if (JR(t)) {
          var n = kn(this._dimName), i = t.getReferringComponents(n, ft).models[0];
          i && this._axisIndex === i.componentIndex && e.push(t);
        }
      }, this), e;
    }, r.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, r.prototype.getMinMaxSpan = function() {
      return dist_te(this._minMaxSpan);
    }, r.prototype.calculateDataWindow = function(e) {
      var t = this._dataExtent, n = this.getAxisModel(), i = n.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], u;
      _a(["start", "end"], function(h, v) {
        var d = e[h], g = e[h + "Value"];
        a[v] === "percent" ? (d == null && (d = o[v]), g = i.parse(De(d, o, t))) : (u = !0, g = g == null ? t[v] : i.parse(g), d = De(g, t, o)), l[v] = g == null || isNaN(g) ? t[v] : g, s[v] = d == null || isNaN(d) ? o[v] : d;
      }), Fm(l), Fm(s);
      var f = this._minMaxSpan;
      u ? c(l, s, t, o, !1) : c(s, l, o, t, !0);
      function c(h, v, d, g, p) {
        var m = p ? "Span" : "ValueSpan";
        Fs(0, h, d, "all", f["min" + m], f["max" + m]);
        for (var y = 0; y < 2; y++)
          v[y] = De(h[y], d, g, !0), p && (v[y] = i.parse(v[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, r.prototype.reset = function(e) {
      if (e === this._dataZoomModel) {
        var t = this.getTargetSeriesModels();
        this._dataExtent = rO(this, this._dimName, t), this._updateMinMaxSpan();
        var n = this.calculateDataWindow(e.settledOption);
        this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, this._setAxisModel();
      }
    }, r.prototype.filterData = function(e, t) {
      if (e !== this._dataZoomModel)
        return;
      var n = this._dimName, i = this.getTargetSeriesModels(), a = e.get("filterMode"), o = this._valueWindow;
      if (a === "none")
        return;
      _a(i, function(l) {
        var u = l.getData(), f = u.mapDimensionsAll(n);
        if (f.length) {
          if (a === "weakFilter") {
            var c = u.getStore(), h = dist_$(f, function(v) {
              return u.getDimensionIndex(v);
            }, u);
            u.filterSelf(function(v) {
              for (var d, g, p, m = 0; m < f.length; m++) {
                var y = c.get(h[m], v), _ = !isNaN(y), S = y < o[0], b = y > o[1];
                if (_ && !S && !b)
                  return !0;
                _ && (p = !0), S && (d = !0), b && (g = !0);
              }
              return p && d && g;
            });
          } else
            _a(f, function(v) {
              if (a === "empty")
                l.setData(u = u.map(v, function(g) {
                  return s(g) ? g : NaN;
                }));
              else {
                var d = {};
                d[v] = o, u.selectRange(d);
              }
            });
          _a(f, function(v) {
            u.setApproximateExtent(o, v);
          });
        }
      });
      function s(l) {
        return l >= o[0] && l <= o[1];
      }
    }, r.prototype._updateMinMaxSpan = function() {
      var e = this._minMaxSpan = {}, t = this._dataZoomModel, n = this._dataExtent;
      _a(["min", "max"], function(i) {
        var a = t.get(i + "Span"), o = t.get(i + "ValueSpan");
        o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = De(n[0] + o, n, [0, 100], !0) : a != null && (o = De(a, [0, 100], n, !0) - n[0]), e[i + "Span"] = a, e[i + "ValueSpan"] = o;
      }, this);
    }, r.prototype._setAxisModel = function() {
      var e = this.getAxisModel(), t = this._percentWindow, n = this._valueWindow;
      if (t) {
        var i = Y3(n, [0, 500]);
        i = Math.min(i, 20);
        var a = e.axis.scale.rawExtentInfo;
        t[0] !== 0 && a.setDeterminedMinMax("min", +n[0].toFixed(i)), t[1] !== 100 && a.setDeterminedMinMax("max", +n[1].toFixed(i)), a.freeze();
      }
    }, r;
  }()
);
function rO(r, e, t) {
  var n = [1 / 0, -1 / 0];
  _a(t, function(o) {
    sI(n, o.getData(), e);
  });
  var i = r.getAxisModel(), a = F6(i.axis.scale, i, n).calculate();
  return [a.min, a.max];
}
var nO = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(r) {
    function e(i) {
      r.eachComponent("dataZoom", function(a) {
        a.eachTargetAxis(function(o, s) {
          var l = r.getComponent(kn(o), s);
          i(o, s, l, a);
        });
      });
    }
    e(function(i, a, o, s) {
      o.__dzAxisProxy = null;
    });
    var t = [];
    e(function(i, a, o, s) {
      o.__dzAxisProxy || (o.__dzAxisProxy = new tO(i, a, s, r), t.push(o.__dzAxisProxy));
    });
    var n = dist_W();
    return dist_M(t, function(i) {
      dist_M(i.getTargetSeriesModels(), function(a) {
        n.set(a.uid, a);
      });
    }), n;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(r, e) {
    r.eachComponent("dataZoom", function(t) {
      t.eachTargetAxis(function(n, i) {
        t.getAxisProxy(n, i).reset(t);
      }), t.eachTargetAxis(function(n, i) {
        t.getAxisProxy(n, i).filterData(t, e);
      });
    }), r.eachComponent("dataZoom", function(t) {
      var n = t.findRepresentativeAxisProxy();
      if (n) {
        var i = n.getDataPercentWindow(), a = n.getDataValueWindow();
        t.setCalculatedRange({
          start: i[0],
          end: i[1],
          startValue: a[0],
          endValue: a[1]
        });
      }
    });
  }
};
const iO = nO;
function aO(r) {
  r.registerAction("dataZoom", function(e, t) {
    var n = QR(t, e);
    dist_M(n, function(i) {
      i.setRawRange({
        start: e.start,
        end: e.end,
        startValue: e.startValue,
        endValue: e.endValue
      });
    });
  });
}
var zm = !1;
function lS(r) {
  zm || (zm = !0, r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, iO), aO(r), r.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function oO(r, e) {
  var t = Ns(e.get("padding")), n = e.getItemStyle(["color", "opacity"]);
  return n.fill = e.get("backgroundColor"), r = new xe({
    shape: {
      x: r.x - t[3],
      y: r.y - t[0],
      width: r.width + t[1] + t[3],
      height: r.height + t[0] + t[2],
      r: e.get("borderRadius")
    },
    style: n,
    silent: !0,
    z2: -1
  }), r;
}
var sO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "tooltip", e.dependencies = ["axisPointer"], e.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, e;
  }(Se)
);
const lO = sO;
function uS(r) {
  var e = r.get("confine");
  return e != null ? !!e : r.get("renderMode") === "richText";
}
function fS(r) {
  if (dist_ee.domSupported) {
    for (var e = document.documentElement.style, t = 0, n = r.length; t < n; t++)
      if (r[t] in e)
        return r[t];
  }
}
var cS = fS(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), uO = fS(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function hS(r, e) {
  if (!r)
    return e;
  e = h4(e, !0);
  var t = r.indexOf(e);
  return r = t === -1 ? e : "-" + r.slice(0, t) + "-" + e, r.toLowerCase();
}
function fO(r, e) {
  var t = r.currentStyle || document.defaultView && document.defaultView.getComputedStyle(r);
  return t ? e ? t[e] : t : null;
}
var cO = hS(uO, "transition"), R0 = hS(cS, "transform"), hO = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (dist_ee.transform3dSupported ? "will-change:transform;" : "");
function vO(r) {
  return r = r === "left" ? "right" : r === "right" ? "left" : r === "top" ? "bottom" : "top", r;
}
function dO(r, e, t) {
  if (!dist_U(t) || t === "inside")
    return "";
  var n = r.get("backgroundColor"), i = r.get("borderWidth");
  e = Bi(e);
  var a = vO(t), o = Math.max(Math.round(i) * 1.5, 6), s = "", l = R0 + ":", u;
  ye(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var f = u * Math.PI / 180, c = o + i, h = c * Math.abs(Math.cos(f)) + c * Math.abs(Math.sin(f)), v = Math.round(((h - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (h - c) / 2) * 100) / 100;
  s += ";" + a + ":-" + v + "px";
  var d = e + " solid " + i + "px;", g = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + d, "border-right:" + d, "background-color:" + n + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function pO(r, e) {
  var t = "cubic-bezier(0.23,1,0.32,1)", n = " " + r / 2 + "s " + t, i = "opacity" + n + ",visibility" + n;
  return e || (n = " " + r + "s " + t, i += dist_ee.transformSupported ? "," + R0 + n : ",left" + n + ",top" + n), cO + ":" + i;
}
function Gm(r, e, t) {
  var n = r.toFixed(0) + "px", i = e.toFixed(0) + "px";
  if (!dist_ee.transformSupported)
    return t ? "top:" + i + ";left:" + n + ";" : [["top", i], ["left", n]];
  var a = dist_ee.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + n + "," + i + (a ? ",0" : "") + ")";
  return t ? "top:0;left:0;" + R0 + ":" + o + ";" : [["top", 0], ["left", 0], [cS, o]];
}
function gO(r) {
  var e = [], t = r.get("fontSize"), n = r.getTextColor();
  n && e.push("color:" + n), e.push("font:" + r.getFont()), t && e.push("line-height:" + Math.round(t * 3 / 2) + "px");
  var i = r.get("textShadowColor"), a = r.get("textShadowBlur") || 0, o = r.get("textShadowOffsetX") || 0, s = r.get("textShadowOffsetY") || 0;
  return i && a && e.push("text-shadow:" + o + "px " + s + "px " + a + "px " + i), dist_M(["decoration", "align"], function(l) {
    var u = r.get(l);
    u && e.push("text-" + l + ":" + u);
  }), e.join(";");
}
function mO(r, e, t) {
  var n = [], i = r.get("transitionDuration"), a = r.get("backgroundColor"), o = r.get("shadowBlur"), s = r.get("shadowColor"), l = r.get("shadowOffsetX"), u = r.get("shadowOffsetY"), f = r.getModel("textStyle"), c = G4(r, "html"), h = l + "px " + u + "px " + o + "px " + s;
  return n.push("box-shadow:" + h), e && i && n.push(pO(i, t)), a && n.push("background-color:" + a), dist_M(["width", "color", "radius"], function(v) {
    var d = "border-" + v, g = h4(d), p = r.get(g);
    p != null && n.push(d + ":" + p + (v === "color" ? "" : "px"));
  }), n.push(gO(f)), c != null && n.push("padding:" + Ns(c).join("px ") + "px"), n.join(";") + ";";
}
function Hm(r, e, t, n, i) {
  var a = e && e.painter;
  if (t) {
    var o = a && a.getViewportRoot();
    o && n7(r, o, t, n, i);
  } else {
    r[0] = n, r[1] = i;
    var s = a && a.getViewportRootOffset();
    s && (r[0] += s.offsetLeft, r[1] += s.offsetTop);
  }
  r[2] = r[0] / e.getWidth(), r[3] = r[1] / e.getHeight();
}
var yO = (
  /** @class */
  function() {
    function r(e, t) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, dist_ee.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var i = this._zr = e.getZr(), a = t.appendTo, o = a && (dist_U(a) ? document.querySelector(a) : La(a) ? a : dist_j(a) && a(e.getDom()));
      Hm(this._styleCoord, i, o, e.getWidth() / 2, e.getHeight() / 2), (o || e.getDom()).appendChild(n), this._api = e, this._container = o;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, f = i.painter.getViewportRoot();
          Gt(f, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return r.prototype.update = function(e) {
      if (!this._container) {
        var t = this._api.getDom(), n = fO(t, "position"), i = t.style;
        i.position !== "absolute" && n !== "absolute" && (i.position = "relative");
      }
      var a = e.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = e.get("className") || "";
    }, r.prototype.show = function(e, t) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, i = n.style, a = this._styleCoord;
      n.innerHTML ? i.cssText = hO + mO(e, !this._firstShow, this._longHide) + Gm(a[0], a[1], !0) + ("border-color:" + Bi(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, r.prototype.setContent = function(e, t, n, i, a) {
      var o = this.el;
      if (e == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (dist_U(a) && n.get("trigger") === "item" && !uS(n) && (s = dO(n, i, a)), dist_U(e))
        o.innerHTML = e + s;
      else if (e) {
        o.innerHTML = "", dist_F(e) || (e = [e]);
        for (var l = 0; l < e.length; l++)
          La(e[l]) && e[l].parentNode !== o && o.appendChild(e[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, r.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, r.prototype.getSize = function() {
      var e = this.el;
      return [e.offsetWidth, e.offsetHeight];
    }, r.prototype.moveTo = function(e, t) {
      var n = this._styleCoord;
      if (Hm(n, this._zr, this._container, e, t), n[0] != null && n[1] != null) {
        var i = this.el.style, a = Gm(n[0], n[1]);
        dist_M(a, function(o) {
          i[o[0]] = o[1];
        });
      }
    }, r.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, r.prototype.hide = function() {
      var e = this, t = this.el.style;
      t.visibility = "hidden", t.opacity = "0", dist_ee.transform3dSupported && (t.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return e._longHide = !0;
      }, 500);
    }, r.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(dist_Z(this.hide, this), e)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var e = this.el.parentNode;
      e && e.removeChild(this.el), this.el = this._container = null;
    }, r;
  }()
);
const _O = yO;
var SO = (
  /** @class */
  function() {
    function r(e) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = e.getZr(), Wm(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2);
    }
    return r.prototype.update = function(e) {
      var t = e.get("alwaysShowContent");
      t && this._moveIfResized(), this._alwaysShowContent = t;
    }, r.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, r.prototype.setContent = function(e, t, n, i, a) {
      var o = this;
      dist_X(e) && de( false ? 0 : ""), this.el && this._zr.remove(this.el);
      var s = n.getModel("textStyle");
      this.el = new Ne({
        style: {
          rich: t.richTextStyles,
          text: e,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: G4(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), dist_M(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        o.el.style[u] = n.get(u);
      }), dist_M(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, r.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, r.prototype.getSize = function() {
      var e = this.el, t = this.el.getBoundingRect(), n = $m(e.style);
      return [t.width + n.left + n.right, t.height + n.top + n.bottom];
    }, r.prototype.moveTo = function(e, t) {
      var n = this.el;
      if (n) {
        var i = this._styleCoord;
        Wm(i, this._zr, e, t), e = i[0], t = i[1];
        var a = n.style, o = Tn(a.borderWidth || 0), s = $m(a);
        n.x = e + o + s.left, n.y = t + o + s.top, n.markRedraw();
      }
    }, r.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, r.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, r.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(dist_Z(this.hide, this), e)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, r;
  }()
);
function Tn(r) {
  return Math.max(0, r);
}
function $m(r) {
  var e = Tn(r.shadowBlur || 0), t = Tn(r.shadowOffsetX || 0), n = Tn(r.shadowOffsetY || 0);
  return {
    left: Tn(e - t),
    right: Tn(e + t),
    top: Tn(e - n),
    bottom: Tn(e + n)
  };
}
function Wm(r, e, t, n) {
  r[0] = t, r[1] = n, r[2] = r[0] / e.getWidth(), r[3] = r[1] / e.getHeight();
}
var wO = new xe({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), bO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n) {
      if (!(dist_ee.node || !n.getDom())) {
        var i = t.getComponent("tooltip"), a = this._renderMode = RC(i.get("renderMode"));
        this._tooltipContent = a === "richText" ? new SO(n) : new _O(n, {
          appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0)
        });
      }
    }, e.prototype.render = function(t, n, i) {
      if (!(dist_ee.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = t, this._ecModel = n, this._api = i;
        var a = this._tooltipContent;
        a.update(t), a.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? Mf(this, "_updatePosition", 50, "fixRate") : Du(this, "_updatePosition");
      }
    }, e.prototype._initGlobalListener = function() {
      var t = this._tooltipModel, n = t.get("triggerOn");
      nS("itemTooltip", this._api, dist_Z(function(i, a, o) {
        n !== "none" && (n.indexOf(i) >= 0 ? this._tryShow(a, o) : i === "leave" && this._hide(o));
      }, this));
    }, e.prototype._keepShow = function() {
      var t = this._tooltipModel, n = this._ecModel, i = this._api, a = t.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && o.manuallyShowTip(t, n, i, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, e.prototype.manuallyShowTip = function(t, n, i, a) {
      if (!(a.from === this.uid || dist_ee.node || !i.getDom())) {
        var o = Um(a, i);
        this._ticket = "";
        var s = a.dataByCoordSys, l = MO(a, n, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var f = wO;
          f.x = a.x, f.y = a.y, f.update(), dist_ie(f).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: f
          }, o);
        } else if (s)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: s,
            tooltipOption: a.tooltipOption
          }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(t, n, i, a))
            return;
          var c = iS(a, n), h = c.point[0], v = c.point[1];
          h != null && v != null && this._tryShow({
            offsetX: h,
            offsetY: v,
            target: c.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else
          a.x != null && a.y != null && (i.dispatchAction({
            type: "updateAxisPointer",
            x: a.x,
            y: a.y
          }), this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            target: i.getZr().findHover(a.x, a.y).target
          }, o));
      }
    }, e.prototype.manuallyHideTip = function(t, n, i, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(Um(a, i));
    }, e.prototype._manuallyAxisShowTip = function(t, n, i, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = n.getSeriesByIndex(o);
        if (u) {
          var f = u.getData(), c = bo([f.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (c.get("trigger") === "axis")
            return i.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: o,
              dataIndex: s,
              position: a.position
            }), !0;
        }
      }
    }, e.prototype._tryShow = function(t, n) {
      var i = t.target, a = this._tooltipModel;
      if (a) {
        this._lastX = t.offsetX, this._lastY = t.offsetY;
        var o = t.dataByCoordSys;
        if (o && o.length)
          this._showAxisTooltip(o, t);
        else if (i) {
          var s = dist_ie(i);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          Ti(i, function(f) {
            if (dist_ie(f).dataIndex != null)
              return l = f, !0;
            if (dist_ie(f).tooltipConfig != null)
              return u = f, !0;
          }, !0), l ? this._showSeriesItemTooltip(t, l, n) : u ? this._showComponentItemTooltip(t, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, e.prototype._showOrMove = function(t, n) {
      var i = t.get("showDelay");
      n = dist_Z(n, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(n, i) : n();
    }, e.prototype._showAxisTooltip = function(t, n) {
      var i = this._ecModel, a = this._tooltipModel, o = [n.offsetX, n.offsetY], s = bo([n.tooltipOption], a), l = this._renderMode, u = [], f = on("section", {
        blocks: [],
        noHeader: !0
      }), c = [], h = new Gc();
      dist_M(t, function(y) {
        dist_M(y.dataByAxis, function(_) {
          var S = i.getComponent(_.axisDim + "Axis", _.axisIndex), b = _.value;
          if (!(!S || b == null)) {
            var w = tS(b, S.axis, i, _.seriesDataIndices, _.valueLabelOpt), x = on("section", {
              header: w,
              noHeader: !or(w),
              sortBlocks: !0,
              blocks: []
            });
            f.blocks.push(x), dist_M(_.seriesDataIndices, function(C) {
              var T = i.getSeriesByIndex(C.seriesIndex), E = C.dataIndexInside, D = T.getDataParams(E);
              if (!(D.dataIndex < 0)) {
                D.axisDim = _.axisDim, D.axisIndex = _.axisIndex, D.axisType = _.axisType, D.axisId = _.axisId, D.axisValue = _0(S.axis, {
                  value: b
                }), D.axisValueLabel = w, D.marker = h.makeTooltipMarker("item", Bi(D.color), l);
                var I = c1(T.formatTooltip(E, !0, null)), L = I.frag;
                if (L) {
                  var N = bo([T], a).get("valueFormatter");
                  x.blocks.push(N ? dist_V({
                    valueFormatter: N
                  }, L) : L);
                }
                I.text && c.push(I.text), u.push(D);
              }
            });
          }
        });
      }), f.blocks.reverse(), c.reverse();
      var v = n.position, d = s.get("order"), g = m1(f, h, l, d, i.get("useUTC"), s.get("textStyle"));
      g && c.unshift(g);
      var p = l === "richText" ? `

` : "<br/>", m = c.join(p);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(t, u) ? this._updatePosition(s, v, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, m, u, Math.random() + "", o[0], o[1], v, null, h);
      });
    }, e.prototype._showSeriesItemTooltip = function(t, n, i) {
      var a = this._ecModel, o = dist_ie(n), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, f = o.dataIndex, c = o.dataType, h = u.getData(c), v = this._renderMode, d = t.positionDefault, g = bo([h.getItemModel(f), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, d ? {
        position: d
      } : null), p = g.get("trigger");
      if (!(p != null && p !== "item")) {
        var m = u.getDataParams(f, c), y = new Gc();
        m.marker = y.makeTooltipMarker("item", Bi(m.color), v);
        var _ = c1(u.formatTooltip(f, !1, c)), S = g.get("order"), b = g.get("valueFormatter"), w = _.frag, x = w ? m1(b ? dist_V({
          valueFormatter: b
        }, w) : w, y, v, S, a.get("useUTC"), g.get("textStyle")) : _.text, C = "item_" + u.name + "_" + f;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, x, m, C, t.offsetX, t.offsetY, t.position, t.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: f,
          dataIndex: h.getRawIndex(f),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, e.prototype._showComponentItemTooltip = function(t, n, i) {
      var a = dist_ie(n), o = a.tooltipConfig, s = o.option || {};
      if (dist_U(s)) {
        var l = s;
        s = {
          content: l,
          // Fixed formatter
          formatter: l
        };
      }
      var u = [s], f = this._ecModel.getComponent(a.componentMainType, a.componentIndex);
      f && u.push(f), u.push({
        formatter: s.content
      });
      var c = t.positionDefault, h = bo(u, this._tooltipModel, c ? {
        position: c
      } : null), v = h.get("content"), d = Math.random() + "", g = new Gc();
      this._showOrMove(h, function() {
        var p = dist_te(h.get("formatterParams") || {});
        this._showTooltipContent(h, v, p, d, t.offsetX, t.offsetY, t.position, n, g);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, e.prototype._showTooltipContent = function(t, n, i, a, o, s, l, u, f) {
      if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
        var c = this._tooltipContent;
        c.setEnterable(t.get("enterable"));
        var h = t.get("formatter");
        l = l || t.get("position");
        var v = n, d = this._getNearestPoint([o, s], i, t.get("trigger"), t.get("borderColor")), g = d.color;
        if (h)
          if (dist_U(h)) {
            var p = t.ecModel.get("useUTC"), m = dist_F(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
            v = h, y && (v = mf(m.axisValue, v, p)), v = v4(v, i, !0);
          } else if (dist_j(h)) {
            var _ = dist_Z(function(S, b) {
              S === this._ticket && (c.setContent(b, f, t, g, l), this._updatePosition(t, l, o, s, c, i, u));
            }, this);
            this._ticket = a, v = h(i, a, _);
          } else
            v = h;
        c.setContent(v, f, t, g, l), c.show(t, g), this._updatePosition(t, l, o, s, c, i, u);
      }
    }, e.prototype._getNearestPoint = function(t, n, i, a) {
      if (i === "axis" || dist_F(n))
        return {
          color: a || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!dist_F(n))
        return {
          color: a || n.color || n.borderColor
        };
    }, e.prototype._updatePosition = function(t, n, i, a, o, s, l) {
      var u = this._api.getWidth(), f = this._api.getHeight();
      n = n || t.get("position");
      var c = o.getSize(), h = t.get("align"), v = t.get("verticalAlign"), d = l && l.getBoundingRect().clone();
      if (l && d.applyTransform(l.transform), dist_j(n) && (n = n([i, a], s, o.el, d, {
        viewSize: [u, f],
        contentSize: c.slice()
      })), dist_F(n))
        i = me(n[0], u), a = me(n[1], f);
      else if (dist_X(n)) {
        var g = n;
        g.width = c[0], g.height = c[1];
        var p = cr(g, {
          width: u,
          height: f
        });
        i = p.x, a = p.y, h = null, v = null;
      } else if (dist_U(n) && l) {
        var m = TO(n, d, c, t.get("borderWidth"));
        i = m[0], a = m[1];
      } else {
        var m = xO(i, a, o, u, f, h ? null : 20, v ? null : 20);
        i = m[0], a = m[1];
      }
      if (h && (i -= Ym(h) ? c[0] / 2 : h === "right" ? c[0] : 0), v && (a -= Ym(v) ? c[1] / 2 : v === "bottom" ? c[1] : 0), uS(t)) {
        var m = CO(i, a, o, u, f);
        i = m[0], a = m[1];
      }
      o.moveTo(i, a);
    }, e.prototype._updateContentNotChangedOnAxis = function(t, n) {
      var i = this._lastDataByCoordSys, a = this._cbParamsList, o = !!i && i.length === t.length;
      return o && dist_M(i, function(s, l) {
        var u = s.dataByAxis || [], f = t[l] || {}, c = f.dataByAxis || [];
        o = o && u.length === c.length, o && dist_M(u, function(h, v) {
          var d = c[v] || {}, g = h.seriesDataIndices || [], p = d.seriesDataIndices || [];
          o = o && h.value === d.value && h.axisType === d.axisType && h.axisId === d.axisId && g.length === p.length, o && dist_M(g, function(m, y) {
            var _ = p[y];
            o = o && m.seriesIndex === _.seriesIndex && m.dataIndex === _.dataIndex;
          }), a && dist_M(h.seriesDataIndices, function(m) {
            var y = m.seriesIndex, _ = n[y], S = a[y];
            _ && S && S.data !== _.data && (o = !1);
          });
        });
      }), this._lastDataByCoordSys = t, this._cbParamsList = n, !!o;
    }, e.prototype._hide = function(t) {
      this._lastDataByCoordSys = null, t({
        type: "hideTip",
        from: this.uid
      });
    }, e.prototype.dispose = function(t, n) {
      dist_ee.node || !n.getDom() || (Du(this, "_updatePosition"), this._tooltipContent.dispose(), td("itemTooltip", n));
    }, e.type = "tooltip", e;
  }(Pt)
);
function bo(r, e, t) {
  var n = e.ecModel, i;
  t ? (i = new He(t, n, n), i = new He(e.option, i, n)) : i = e;
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a];
    o && (o instanceof He && (o = o.get("tooltip", !0)), dist_U(o) && (o = {
      formatter: o
    }), o && (i = new He(o, i, n)));
  }
  return i;
}
function Um(r, e) {
  return r.dispatchAction || dist_Z(e.dispatchAction, e);
}
function xO(r, e, t, n, i, a, o) {
  var s = t.getSize(), l = s[0], u = s[1];
  return a != null && (r + l + a + 2 > n ? r -= l + a : r += a), o != null && (e + u + o > i ? e -= u + o : e += o), [r, e];
}
function CO(r, e, t, n, i) {
  var a = t.getSize(), o = a[0], s = a[1];
  return r = Math.min(r + o, n) - o, e = Math.min(e + s, i) - s, r = Math.max(r, 0), e = Math.max(e, 0), [r, e];
}
function TO(r, e, t, n) {
  var i = t[0], a = t[1], o = Math.ceil(Math.SQRT2 * n) + 8, s = 0, l = 0, u = e.width, f = e.height;
  switch (r) {
    case "inside":
      s = e.x + u / 2 - i / 2, l = e.y + f / 2 - a / 2;
      break;
    case "top":
      s = e.x + u / 2 - i / 2, l = e.y - a - o;
      break;
    case "bottom":
      s = e.x + u / 2 - i / 2, l = e.y + f + o;
      break;
    case "left":
      s = e.x - i - o, l = e.y + f / 2 - a / 2;
      break;
    case "right":
      s = e.x + u + o, l = e.y + f / 2 - a / 2;
  }
  return [s, l];
}
function Ym(r) {
  return r === "center" || r === "middle";
}
function MO(r, e, t) {
  var n = Id(r).queryOptionMap, i = n.keys()[0];
  if (!(!i || i === "series")) {
    var a = Es(e, i, n.get(i), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), o = a.models[0];
    if (o) {
      var s = t.getViewOfComponentModel(o), l;
      if (s.group.traverse(function(u) {
        var f = dist_ie(u).tooltipConfig;
        if (f && f.name === r.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: i,
          componentIndex: o.componentIndex,
          el: l
        };
    }
  }
}
const DO = bO;
function EO(r) {
  Rt(aS), r.registerComponentModel(lO), r.registerComponentView(DO), r.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, Ue), r.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, Ue);
}
var Xm = dist_M;
function Zm(r) {
  if (r) {
    for (var e in r)
      if (r.hasOwnProperty(e))
        return !0;
  }
}
function qm(r, e, t) {
  var n = {};
  return Xm(e, function(a) {
    var o = n[a] = i();
    Xm(r[a], function(s, l) {
      if (nt.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        t && t(u, a), o[l] = new nt(u), l === "opacity" && (u = dist_te(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new nt(u));
      }
    });
  }), n;
  function i() {
    var a = function() {
    };
    a.prototype.__hidden = a.prototype;
    var o = new a();
    return o;
  }
}
function AO(r, e, t) {
  var n;
  dist_M(t, function(i) {
    e.hasOwnProperty(i) && Zm(e[i]) && (n = !0);
  }), n && dist_M(t, function(i) {
    e.hasOwnProperty(i) && Zm(e[i]) ? r[i] = dist_te(e[i]) : delete r[i];
  });
}
function IO(r, e, t, n) {
  var i = {};
  return dist_M(r, function(a) {
    var o = nt.prepareVisualTypes(e[a]);
    i[a] = o;
  }), {
    progress: function(o, s) {
      var l;
      n != null && (l = s.getDimensionIndex(n));
      function u(b) {
        return j4(s, c, b);
      }
      function f(b, w) {
        iE(s, c, b, w);
      }
      for (var c, h = s.getStore(); (c = o.next()) != null; ) {
        var v = s.getRawDataItem(c);
        if (!(v && v.visualMap === !1))
          for (var d = n != null ? h.get(l, c) : c, g = t(d), p = e[g], m = i[g], y = 0, _ = m.length; y < _; y++) {
            var S = m[y];
            p[S] && p[S].applyVisual(d, u, f);
          }
      }
    }
  };
}
var LO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t;
    }
    return e.type = "title", e.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, e;
  }(Se)
), NO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var a = this.group, o = t.getModel("textStyle"), s = t.getModel("subtextStyle"), l = t.get("textAlign"), u = dist_ne(t.get("textBaseline"), t.get("textVerticalAlign")), f = new Ne({
          style: Lt(o, {
            text: t.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), c = f.getBoundingRect(), h = t.get("subtext"), v = new Ne({
          style: Lt(s, {
            text: h,
            fill: s.getTextColor(),
            y: c.height + t.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), d = t.get("link"), g = t.get("sublink"), p = t.get("triggerEvent", !0);
        f.silent = !d && !p, v.silent = !g && !p, d && f.on("click", function() {
          Xg(d, "_" + t.get("target"));
        }), g && v.on("click", function() {
          Xg(g, "_" + t.get("subtarget"));
        }), dist_ie(f).eventData = dist_ie(v).eventData = p ? {
          componentType: "title",
          componentIndex: t.componentIndex
        } : null, a.add(f), h && a.add(v);
        var m = a.getBoundingRect(), y = t.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var _ = cr(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, t.get("padding"));
        l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? _.x += _.width : l === "center" && (_.x += _.width / 2)), u || (u = t.get("top") || t.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? _.y += _.height : u === "middle" && (_.y += _.height / 2), u = u || "top"), a.x = _.x, a.y = _.y, a.markRedraw();
        var S = {
          align: l,
          verticalAlign: u
        };
        f.setStyle(S), v.setStyle(S), m = a.getBoundingRect();
        var b = _.margin, w = t.getItemStyle(["color", "opacity"]);
        w.fill = t.get("backgroundColor");
        var x = new xe({
          shape: {
            x: m.x - b[3],
            y: m.y - b[0],
            width: m.width + b[1] + b[3],
            height: m.height + b[0] + b[2],
            r: t.get("borderRadius")
          },
          style: w,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(x);
      }
    }, e.type = "title", e;
  }(Pt)
);
function PO(r) {
  r.registerComponentModel(LO), r.registerComponentView(NO);
}
var RO = function(r, e) {
  if (e === "all")
    return {
      type: "all",
      title: r.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (e === "inverse")
    return {
      type: "inverse",
      title: r.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, OO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, t;
    }
    return e.prototype.init = function(t, n, i) {
      this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t);
    }, e.prototype.mergeOption = function(t, n) {
      r.prototype.mergeOption.call(this, t, n), this._updateSelector(t);
    }, e.prototype._updateSelector = function(t) {
      var n = t.selector, i = this.ecModel;
      n === !0 && (n = t.selector = ["all", "inverse"]), dist_F(n) && dist_M(n, function(a, o) {
        dist_U(a) && (a = {
          type: a
        }), n[o] = he(a, RO(i, a.type));
      });
    }, e.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var t = this._data;
      if (t[0] && this.get("selectedMode") === "single") {
        for (var n = !1, i = 0; i < t.length; i++) {
          var a = t[i].get("name");
          if (this.isSelected(a)) {
            this.select(a), n = !0;
            break;
          }
        }
        !n && this.select(t[0].get("name"));
      }
    }, e.prototype._updateData = function(t) {
      var n = [], i = [];
      t.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var f;
        if (l.legendVisualProvider) {
          var c = l.legendVisualProvider, h = c.getAllNames();
          t.isSeriesFiltered(l) || (i = i.concat(h)), h.length ? n = n.concat(h) : f = !0;
        } else
          f = !0;
        f && Ad(l) && n.push(l.name);
      }), this._availableNames = i;
      var a = this.get("data") || n, o = dist_W(), s = dist_$(a, function(l) {
        return (dist_U(l) || ve(l)) && (l = {
          name: l
        }), o.get(l.name) ? null : (o.set(l.name, !0), new He(l, this, this.ecModel));
      }, this);
      this._data = ke(s, function(l) {
        return !!l;
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.select = function(t) {
      var n = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var a = this._data;
        dist_M(a, function(o) {
          n[o.get("name")] = !1;
        });
      }
      n[t] = !0;
    }, e.prototype.unSelect = function(t) {
      this.get("selectedMode") !== "single" && (this.option.selected[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      var n = this.option.selected;
      n.hasOwnProperty(t) || (n[t] = !0), this[n[t] ? "unSelect" : "select"](t);
    }, e.prototype.allSelect = function() {
      var t = this._data, n = this.option.selected;
      dist_M(t, function(i) {
        n[i.get("name", !0)] = !0;
      });
    }, e.prototype.inverseSelect = function() {
      var t = this._data, n = this.option.selected;
      dist_M(t, function(i) {
        var a = i.get("name", !0);
        n.hasOwnProperty(a) || (n[a] = !0), n[a] = !n[a];
      });
    }, e.prototype.isSelected = function(t) {
      var n = this.option.selected;
      return !(n.hasOwnProperty(t) && !n[t]) && ye(this._availableNames, t) >= 0;
    }, e.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, e.type = "legend.plain", e.dependencies = ["series"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, e;
  }(Se)
);
const rd = OO;
var ha = Te, nd = dist_M, Ol = dist_oe, kO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._contentGroup = new Ol()), this.group.add(this._selectorGroup = new Ol()), this._isFirstRender = !0;
    }, e.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, e.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, e.prototype.render = function(t, n, i) {
      var a = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!t.get("show", !0)) {
        var o = t.get("align"), s = t.get("orient");
        (!o || o === "auto") && (o = t.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = t.get("selector", !0), u = t.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, t, n, i, l, s, u);
        var f = t.getBoxLayoutParams(), c = {
          width: i.getWidth(),
          height: i.getHeight()
        }, h = t.get("padding"), v = cr(f, c, h), d = this.layoutInner(t, o, v, a, l, u), g = cr(dist_se({
          width: d.width,
          height: d.height
        }, f), c, h);
        this.group.x = g.x - d.x, this.group.y = g.y - d.y, this.group.markRedraw(), this.group.add(this._backgroundEl = oO(d, t));
      }
    }, e.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, e.prototype.renderInner = function(t, n, i, a, o, s, l) {
      var u = this.getContentGroup(), f = dist_W(), c = n.get("selectedMode"), h = [];
      i.eachRawSeries(function(v) {
        !v.get("legendHoverLink") && h.push(v.id);
      }), nd(n.getData(), function(v, d) {
        var g = v.get("name");
        if (!this.newlineDisabled && (g === "" || g === `
`)) {
          var p = new Ol();
          p.newline = !0, u.add(p);
          return;
        }
        var m = i.getSeriesByName(g)[0];
        if (!f.get(g)) {
          if (m) {
            var y = m.getData(), _ = y.getVisual("legendLineStyle") || {}, S = y.getVisual("legendIcon"), b = y.getVisual("style"), w = this._createItem(m, g, d, v, n, t, _, b, S, c, a);
            w.on("click", ha(Km, g, null, a, h)).on("mouseover", ha(id, m.name, null, a, h)).on("mouseout", ha(ad, m.name, null, a, h)), i.ssr && w.eachChild(function(x) {
              var C = dist_ie(x);
              C.seriesIndex = m.seriesIndex, C.dataIndex = d, C.ssrType = "legend";
            }), f.set(g, !0);
          } else
            i.eachRawSeries(function(x) {
              if (!f.get(g) && x.legendVisualProvider) {
                var C = x.legendVisualProvider;
                if (!C.containName(g))
                  return;
                var T = C.indexOfName(g), E = C.getItemVisual(T, "style"), D = C.getItemVisual(T, "legendIcon"), I = Xt(E.fill);
                I && I[3] === 0 && (I[3] = 0.2, E = dist_V(dist_V({}, E), {
                  fill: Zr(I, "rgba")
                }));
                var L = this._createItem(x, g, d, v, n, t, {}, E, D, c, a);
                L.on("click", ha(Km, null, g, a, h)).on("mouseover", ha(id, null, g, a, h)).on("mouseout", ha(ad, null, g, a, h)), i.ssr && L.eachChild(function(N) {
                  var P = dist_ie(N);
                  P.seriesIndex = x.seriesIndex, P.dataIndex = d, P.ssrType = "legend";
                }), f.set(g, !0);
              }
            }, this);
           false && 0;
        }
      }, this), o && this._createSelector(o, n, a, s, l);
    }, e.prototype._createSelector = function(t, n, i, a, o) {
      var s = this.getSelectorGroup();
      nd(t, function(u) {
        var f = u.type, c = new Ne({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: f === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        s.add(c);
        var h = n.getModel("selectorLabel"), v = n.getModel(["emphasis", "selectorLabel"]);
        Yn(c, {
          normal: h,
          emphasis: v
        }, {
          defaultText: u.title
        }), mu(c);
      });
    }, e.prototype._createItem = function(t, n, i, a, o, s, l, u, f, c, h) {
      var v = t.visualDrawType, d = o.get("itemWidth"), g = o.get("itemHeight"), p = o.isSelected(n), m = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), _ = a.get("icon");
      f = _ || f || "roundRect";
      var S = VO(f, a, l, u, v, p, h), b = new Ol(), w = a.getModel("textStyle");
      if (dist_j(t.getLegendIcon) && (!_ || _ === "inherit"))
        b.add(t.getLegendIcon({
          itemWidth: d,
          itemHeight: g,
          icon: f,
          iconRotate: m,
          itemStyle: S.itemStyle,
          lineStyle: S.lineStyle,
          symbolKeepAspect: y
        }));
      else {
        var x = _ === "inherit" && t.getData().getVisual("symbol") ? m === "inherit" ? t.getData().getVisual("symbolRotate") : m : 0;
        b.add(BO({
          itemWidth: d,
          itemHeight: g,
          icon: f,
          iconRotate: x,
          itemStyle: S.itemStyle,
          lineStyle: S.lineStyle,
          symbolKeepAspect: y
        }));
      }
      var C = s === "left" ? d + 5 : -5, T = s, E = o.get("formatter"), D = n;
      dist_U(E) && E ? D = E.replace("{name}", n ?? "") : dist_j(E) && (D = E(n));
      var I = p ? w.getTextColor() : a.get("inactiveColor");
      b.add(new Ne({
        style: Lt(w, {
          text: D,
          x: C,
          y: g / 2,
          fill: I,
          align: T,
          verticalAlign: "middle"
        }, {
          inheritColor: I
        })
      }));
      var L = new xe({
        shape: b.getBoundingRect(),
        style: {
          // Cannot use 'invisible' because SVG SSR will miss the node
          fill: "transparent"
        }
      }), N = a.getModel("tooltip");
      return N.get("show") && pf({
        el: L,
        componentModel: o,
        itemName: n,
        itemTooltipOption: N.option
      }), b.add(L), b.eachChild(function(P) {
        P.silent = !0;
      }), L.silent = !c, this.getContentGroup().add(b), mu(b), b.__legendDataIndex = i, b;
    }, e.prototype.layoutInner = function(t, n, i, a, o, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      Aa(t.get("orient"), l, t.get("itemGap"), i.width, i.height);
      var f = l.getBoundingRect(), c = [-f.x, -f.y];
      if (u.markRedraw(), l.markRedraw(), o) {
        Aa(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          t.get("selectorItemGap", !0)
        );
        var h = u.getBoundingRect(), v = [-h.x, -h.y], d = t.get("selectorButtonGap", !0), g = t.getOrient().index, p = g === 0 ? "width" : "height", m = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
        s === "end" ? v[g] += f[p] + d : c[g] += h[p] + d, v[1 - g] += f[m] / 2 - h[m] / 2, u.x = v[0], u.y = v[1], l.x = c[0], l.y = c[1];
        var _ = {
          x: 0,
          y: 0
        };
        return _[p] = f[p] + d + h[p], _[m] = Math.max(f[m], h[m]), _[y] = Math.min(0, h[y] + v[1 - g]), _;
      } else
        return l.x = c[0], l.y = c[1], this.group.getBoundingRect();
    }, e.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, e.type = "legend.plain", e;
  }(Pt)
);
function VO(r, e, t, n, i, a, o) {
  function s(p, m) {
    p.lineWidth === "auto" && (p.lineWidth = m.lineWidth > 0 ? 2 : 0), nd(p, function(y, _) {
      p[_] === "inherit" && (p[_] = m[_]);
    });
  }
  var l = e.getModel("itemStyle"), u = l.getItemStyle(), f = r.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", c = l.getShallow("decal");
  u.decal = !c || c === "inherit" ? n.decal : Nu(c, o), u.fill === "inherit" && (u.fill = n[i]), u.stroke === "inherit" && (u.stroke = n[f]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? n : t).opacity), s(u, n);
  var h = e.getModel("lineStyle"), v = h.getLineStyle();
  if (s(v, t), u.fill === "auto" && (u.fill = n.fill), u.stroke === "auto" && (u.stroke = n.fill), v.stroke === "auto" && (v.stroke = n.fill), !a) {
    var d = e.get("inactiveBorderWidth"), g = u[f];
    u.lineWidth = d === "auto" ? n.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), v.stroke = h.get("inactiveColor"), v.lineWidth = h.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: v
  };
}
function BO(r) {
  var e = r.icon || "roundRect", t = dt(e, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill, r.symbolKeepAspect);
  return t.setStyle(r.itemStyle), t.rotation = (r.iconRotate || 0) * Math.PI / 180, t.setOrigin([r.itemWidth / 2, r.itemHeight / 2]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t;
}
function Km(r, e, t, n) {
  ad(r, e, t, n), t.dispatchAction({
    type: "legendToggleSelect",
    name: r ?? e
  }), id(r, e, t, n);
}
function vS(r) {
  for (var e = r.getZr().storage.getDisplayList(), t, n = 0, i = e.length; n < i && !(t = e[n].states.emphasis); )
    n++;
  return t && t.hoverLayer;
}
function id(r, e, t, n) {
  vS(t) || t.dispatchAction({
    type: "highlight",
    seriesName: r,
    name: e,
    excludeSeriesId: n
  });
}
function ad(r, e, t, n) {
  vS(t) || t.dispatchAction({
    type: "downplay",
    seriesName: r,
    name: e,
    excludeSeriesId: n
  });
}
const dS = kO;
function FO(r) {
  var e = r.findComponents({
    mainType: "legend"
  });
  e && e.length && r.filterSeries(function(t) {
    for (var n = 0; n < e.length; n++)
      if (!e[n].isSelected(t.name))
        return !1;
    return !0;
  });
}
function xo(r, e, t) {
  var n = {}, i = r === "toggleSelected", a;
  return t.eachComponent("legend", function(o) {
    i && a != null ? o[a ? "select" : "unSelect"](e.name) : r === "allSelect" || r === "inverseSelect" ? o[r]() : (o[r](e.name), a = o.isSelected(e.name));
    var s = o.getData();
    dist_M(s, function(l) {
      var u = l.get("name");
      if (!(u === `
` || u === "")) {
        var f = o.isSelected(u);
        n.hasOwnProperty(u) ? n[u] = n[u] && f : n[u] = f;
      }
    });
  }), r === "allSelect" || r === "inverseSelect" ? {
    selected: n
  } : {
    name: e.name,
    selected: n
  };
}
function zO(r) {
  r.registerAction("legendToggleSelect", "legendselectchanged", Te(xo, "toggleSelected")), r.registerAction("legendAllSelect", "legendselectall", Te(xo, "allSelect")), r.registerAction("legendInverseSelect", "legendinverseselect", Te(xo, "inverseSelect")), r.registerAction("legendSelect", "legendselected", Te(xo, "select")), r.registerAction("legendUnSelect", "legendunselected", Te(xo, "unSelect"));
}
function pS(r) {
  r.registerComponentModel(rd), r.registerComponentView(dS), r.registerProcessor(r.PRIORITY.PROCESSOR.SERIES_FILTER, FO), r.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), zO(r);
}
var GO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.setScrollDataIndex = function(t) {
      this.option.scrollDataIndex = t;
    }, e.prototype.init = function(t, n, i) {
      var a = Ps(t);
      r.prototype.init.call(this, t, n, i), jm(this, t, a);
    }, e.prototype.mergeOption = function(t, n) {
      r.prototype.mergeOption.call(this, t, n), jm(this, this.option, t);
    }, e.type = "legend.scroll", e.defaultOption = Xa(rd.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), e;
  }(rd)
);
function jm(r, e, t) {
  var n = r.getOrient(), i = [1, 1];
  i[n.index] = 0, ka(e, t, {
    type: "box",
    ignoreSize: !!i
  });
}
const HO = GO;
var Jm = dist_oe, Nh = ["width", "height"], Ph = ["x", "y"], $O = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !0, t._currentIndex = 0, t;
    }
    return e.prototype.init = function() {
      r.prototype.init.call(this), this.group.add(this._containerGroup = new Jm()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new Jm());
    }, e.prototype.resetInner = function() {
      r.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, e.prototype.renderInner = function(t, n, i, a, o, s, l) {
      var u = this;
      r.prototype.renderInner.call(this, t, n, i, a, o, s, l);
      var f = this._controllerGroup, c = n.get("pageIconSize", !0), h = dist_F(c) ? c : [c, c];
      d("pagePrev", 0);
      var v = n.getModel("pageTextStyle");
      f.add(new Ne({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: v.getTextColor(),
          font: v.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), d("pageNext", 1);
      function d(g, p) {
        var m = g + "DataIndex", y = Xd(n.get("pageIcons", !0)[n.getOrient().name][p], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: dist_Z(u._pageGo, u, m, n, a)
        }, {
          x: -h[0] / 2,
          y: -h[1] / 2,
          width: h[0],
          height: h[1]
        });
        y.name = g, f.add(y);
      }
    }, e.prototype.layoutInner = function(t, n, i, a, o, s) {
      var l = this.getSelectorGroup(), u = t.getOrient().index, f = Nh[u], c = Ph[u], h = Nh[1 - u], v = Ph[1 - u];
      o && Aa(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        t.get("selectorItemGap", !0)
      );
      var d = t.get("selectorButtonGap", !0), g = l.getBoundingRect(), p = [-g.x, -g.y], m = dist_te(i);
      o && (m[f] = i[f] - g[f] - d);
      var y = this._layoutContentAndController(t, a, m, u, f, h, v, c);
      if (o) {
        if (s === "end")
          p[u] += y[f] + d;
        else {
          var _ = g[f] + d;
          p[u] -= _, y[c] -= _;
        }
        y[f] += g[f] + d, p[1 - u] += y[v] + y[h] / 2 - g[h] / 2, y[h] = Math.max(y[h], g[h]), y[v] = Math.min(y[v], g[v] + p[1 - u]), l.x = p[0], l.y = p[1], l.markRedraw();
      }
      return y;
    }, e.prototype._layoutContentAndController = function(t, n, i, a, o, s, l, u) {
      var f = this.getContentGroup(), c = this._containerGroup, h = this._controllerGroup;
      Aa(t.get("orient"), f, t.get("itemGap"), a ? i.width : null, a ? null : i.height), Aa(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        h,
        t.get("pageButtonItemGap", !0)
      );
      var v = f.getBoundingRect(), d = h.getBoundingRect(), g = this._showController = v[o] > i[o], p = [-v.x, -v.y];
      n || (p[a] = f[u]);
      var m = [0, 0], y = [-d.x, -d.y], _ = dist_ne(t.get("pageButtonGap", !0), t.get("itemGap", !0));
      if (g) {
        var S = t.get("pageButtonPosition", !0);
        S === "end" ? y[a] += i[o] - d[o] : m[a] += d[o] + _;
      }
      y[1 - a] += v[s] / 2 - d[s] / 2, f.setPosition(p), c.setPosition(m), h.setPosition(y);
      var b = {
        x: 0,
        y: 0
      };
      if (b[o] = g ? i[o] : v[o], b[s] = Math.max(v[s], d[s]), b[l] = Math.min(0, d[l] + y[1 - a]), c.__rectSize = i[o], g) {
        var w = {
          x: 0,
          y: 0
        };
        w[o] = Math.max(i[o] - d[o] - _, 0), w[s] = b[s], c.setClipPath(new xe({
          shape: w
        })), c.__rectSize = w[o];
      } else
        h.eachChild(function(C) {
          C.attr({
            invisible: !0,
            silent: !0
          });
        });
      var x = this._getPageInfo(t);
      return x.pageIndex != null && Pe(
        f,
        {
          x: x.contentPosition[0],
          y: x.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        g ? t : null
      ), this._updatePageInfoView(t, x), b;
    }, e.prototype._pageGo = function(t, n, i) {
      var a = this._getPageInfo(n)[t];
      a != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: n.id
      });
    }, e.prototype._updatePageInfoView = function(t, n) {
      var i = this._controllerGroup;
      dist_M(["pagePrev", "pageNext"], function(f) {
        var c = f + "DataIndex", h = n[c] != null, v = i.childOfName(f);
        v && (v.setStyle("fill", h ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), v.cursor = h ? "pointer" : "default");
      });
      var a = i.childOfName("pageText"), o = t.get("pageFormatter"), s = n.pageIndex, l = s != null ? s + 1 : 0, u = n.pageCount;
      a && o && a.setStyle("text", dist_U(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
        current: l,
        total: u
      }));
    }, e.prototype._getPageInfo = function(t) {
      var n = t.get("scrollDataIndex", !0), i = this.getContentGroup(), a = this._containerGroup.__rectSize, o = t.getOrient().index, s = Nh[o], l = Ph[o], u = this._findTargetItemIndex(n), f = i.children(), c = f[u], h = f.length, v = h ? 1 : 0, d = {
        contentPosition: [i.x, i.y],
        pageCount: v,
        pageIndex: v - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!c)
        return d;
      var g = S(c);
      d.contentPosition[o] = -g.s;
      for (var p = u + 1, m = g, y = g, _ = null; p <= h; ++p)
        _ = S(f[p]), // Half of the last item is out of the window.
        (!_ && y.e > m.s + a || _ && !b(_, m.s)) && (y.i > m.i ? m = y : m = _, m && (d.pageNextDataIndex == null && (d.pageNextDataIndex = m.i), ++d.pageCount)), y = _;
      for (var p = u - 1, m = g, y = g, _ = null; p >= -1; --p)
        _ = S(f[p]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!_ || !b(y, _.s)) && m.i < y.i && (y = m, d.pagePrevDataIndex == null && (d.pagePrevDataIndex = m.i), ++d.pageCount, ++d.pageIndex), m = _;
      return d;
      function S(w) {
        if (w) {
          var x = w.getBoundingRect(), C = x[l] + w[l];
          return {
            s: C,
            e: C + x[s],
            i: w.__legendDataIndex
          };
        }
      }
      function b(w, x) {
        return w.e >= x && w.s <= x + a;
      }
    }, e.prototype._findTargetItemIndex = function(t) {
      if (!this._showController)
        return 0;
      var n, i = this.getContentGroup(), a;
      return i.eachChild(function(o, s) {
        var l = o.__legendDataIndex;
        a == null && l != null && (a = s), l === t && (n = s);
      }), n ?? a;
    }, e.type = "legend.scroll", e;
  }(dS)
);
const WO = $O;
function UO(r) {
  r.registerAction("legendScroll", "legendscroll", function(e, t) {
    var n = e.scrollDataIndex;
    n != null && t.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: e
    }, function(i) {
      i.setScrollDataIndex(n);
    });
  });
}
function YO(r) {
  Rt(pS), r.registerComponentModel(HO), r.registerComponentView(WO), UO(r);
}
function XO(r) {
  Rt(pS), Rt(YO);
}
var ZO = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.inside", e.defaultOption = Xa(Gu.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), e;
  }(Gu)
);
const qO = ZO;
var O0 = Me();
function KO(r, e, t) {
  O0(r).coordSysRecordMap.each(function(n) {
    var i = n.dataZoomInfoMap.get(e.uid);
    i && (i.getRange = t);
  });
}
function jO(r, e) {
  for (var t = O0(r).coordSysRecordMap, n = t.keys(), i = 0; i < n.length; i++) {
    var a = n[i], o = t.get(a), s = o.dataZoomInfoMap;
    if (s) {
      var l = e.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || gS(t, o));
    }
  }
}
function gS(r, e) {
  if (e) {
    r.removeKey(e.model.uid);
    var t = e.controller;
    t && t.dispose();
  }
}
function JO(r, e) {
  var t = {
    model: e,
    containsPoint: Te(e9, e),
    dispatchAction: Te(QO, r),
    dataZoomInfoMap: null,
    controller: null
  }, n = t.controller = new D0(r.getZr());
  return dist_M(["pan", "zoom", "scrollMove"], function(i) {
    n.on(i, function(a) {
      var o = [];
      t.dataZoomInfoMap.each(function(s) {
        if (a.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, t.model.mainType, t.controller, a);
          !s.model.get("disabled", !0) && u && o.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), o.length && t.dispatchAction(o);
    });
  }), t;
}
function QO(r, e) {
  r.isDisposed() || r.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: e
  });
}
function e9(r, e, t, n) {
  return r.coordinateSystem.containPoint([t, n]);
}
function t9(r) {
  var e, t = "type_", n = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, i = !0;
  return r.each(function(a) {
    var o = a.model, s = o.get("disabled", !0) ? !1 : o.get("zoomLock", !0) ? "move" : !0;
    n[t + s] > n[t + e] && (e = s), i = i && o.get("preventDefaultMouseMove", !0);
  }), {
    controlType: e,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!i
    }
  };
}
function r9(r) {
  r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, function(e, t) {
    var n = O0(t), i = n.coordSysRecordMap || (n.coordSysRecordMap = dist_W());
    i.each(function(a) {
      a.dataZoomInfoMap = null;
    }), e.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(a) {
      var o = oS(a);
      dist_M(o.infoList, function(s) {
        var l = s.model.uid, u = i.get(l) || i.set(l, JO(t, s.model)), f = u.dataZoomInfoMap || (u.dataZoomInfoMap = dist_W());
        f.set(a.uid, {
          dzReferCoordSysInfo: s,
          model: a,
          getRange: null
        });
      });
    }), i.each(function(a) {
      var o = a.controller, s, l = a.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        gS(i, a);
        return;
      }
      var f = t9(l);
      o.enable(f.controlType, f.opt), o.setPointerChecker(a.containsPoint), Mf(a, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var n9 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataZoom.inside", t;
    }
    return e.prototype.render = function(t, n, i) {
      if (r.prototype.render.apply(this, arguments), t.noTarget()) {
        this._clear();
        return;
      }
      this.range = t.getPercentRange(), KO(i, t, {
        pan: dist_Z(Rh.pan, this),
        zoom: dist_Z(Rh.zoom, this),
        scrollMove: dist_Z(Rh.scrollMove, this)
      });
    }, e.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      jO(this.api, this.dataZoomModel), this.range = null;
    }, e.type = "dataZoom.inside", e;
  }(sS)
), Rh = {
  zoom: function(r, e, t, n) {
    var i = this.range, a = i.slice(), o = r.axisModels[0];
    if (o) {
      var s = Oh[e](null, [n.originX, n.originY], o, t, r), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / n.scale, 0);
      a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
      var f = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (Fs(0, a, [0, 100], 0, f.minSpan, f.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1])
        return a;
    }
  },
  pan: Qm(function(r, e, t, n, i, a) {
    var o = Oh[n]([a.oldX, a.oldY], [a.newX, a.newY], e, i, t);
    return o.signal * (r[1] - r[0]) * o.pixel / o.pixelLength;
  }),
  scrollMove: Qm(function(r, e, t, n, i, a) {
    var o = Oh[n]([0, 0], [a.scrollDelta, a.scrollDelta], e, i, t);
    return o.signal * (r[1] - r[0]) * a.scrollDelta;
  })
};
function Qm(r) {
  return function(e, t, n, i) {
    var a = this.range, o = a.slice(), s = e.axisModels[0];
    if (s) {
      var l = r(o, s, e, t, n, i);
      if (Fs(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1])
        return o;
    }
  };
}
var Oh = {
  grid: function(r, e, t, n, i) {
    var a = t.axis, o = {}, s = i.model.coordinateSystem.getRect();
    return r = r || [0, 0], a.dim === "x" ? (o.pixel = e[0] - r[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - r[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
  },
  polar: function(r, e, t, n, i) {
    var a = t.axis, o = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return r = r ? s.pointToCoord(r) : [0, 0], e = s.pointToCoord(e), t.mainType === "radiusAxis" ? (o.pixel = e[0] - r[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - r[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
  },
  singleAxis: function(r, e, t, n, i) {
    var a = t.axis, o = i.model.coordinateSystem.getRect(), s = {};
    return r = r || [0, 0], a.orient === "horizontal" ? (s.pixel = e[0] - r[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - r[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
  }
};
const i9 = n9;
function a9(r) {
  lS(r), r.registerComponentModel(qO), r.registerComponentView(i9), r9(r);
}
var o9 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = Xa(Gu.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), e;
  }(Gu)
);
const s9 = o9;
var Co = xe, ey = 7, l9 = 1, kh = 30, u9 = 7, To = "horizontal", ty = "vertical", f9 = 5, c9 = ["line", "bar", "candlestick", "scatter"], h9 = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, v9 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._displayables = {}, t;
    }
    return e.prototype.init = function(t, n) {
      this.api = n, this._onBrush = dist_Z(this._onBrush, this), this._onBrushEnd = dist_Z(this._onBrushEnd, this);
    }, e.prototype.render = function(t, n, i, a) {
      if (r.prototype.render.apply(this, arguments), Mf(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (t.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, e.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      Du(this, "_dispatchZoomAction");
      var t = this.api.getZr();
      t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd);
    }, e.prototype._buildView = function() {
      var t = this.group;
      t.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var n = this._displayables.sliderGroup = new dist_oe();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(n), this._positionGroup();
    }, e.prototype._resetLocation = function() {
      var t = this.dataZoomModel, n = this.api, i = t.get("brushSelect"), a = i ? u9 : 0, o = this._findCoordRect(), s = {
        width: n.getWidth(),
        height: n.getHeight()
      }, l = this._orient === To ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: s.width - o.x - o.width,
        top: s.height - kh - ey - a,
        width: o.width,
        height: kh
      } : {
        right: ey,
        top: o.y,
        width: kh,
        height: o.height
      }, u = Ps(t.option);
      dist_M(["right", "top", "width", "height"], function(c) {
        u[c] === "ph" && (u[c] = l[c]);
      });
      var f = cr(u, s);
      this._location = {
        x: f.x,
        y: f.y
      }, this._size = [f.width, f.height], this._orient === ty && this._size.reverse();
    }, e.prototype._positionGroup = function() {
      var t = this.group, n = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === To && !o ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === To && o ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === ty && !o ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = t.getBoundingRect([s]);
      t.x = n.x - u.x, t.y = n.y - u.y, t.markRedraw();
    }, e.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, e.prototype._renderBackground = function() {
      var t = this.dataZoomModel, n = this._size, i = this._displayables.sliderGroup, a = t.get("brushSelect");
      i.add(new Co({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: t.get("backgroundColor")
        },
        z2: -40
      }));
      var o = new Co({
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: dist_Z(this._onClickPanel, this)
      }), s = this.api.getZr();
      a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(o);
    }, e.prototype._renderDataShadow = function() {
      var t = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !t)
        return;
      var n = this._size, i = this._shadowSize || [], a = t.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : t.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, f = this._shadowPolylinePts;
      if (o !== this._shadowData || l !== this._shadowDim || n[0] !== i[0] || n[1] !== i[1]) {
        var c = o.getDataExtent(l), h = (c[1] - c[0]) * 0.3;
        c = [c[0] - h, c[1] + h];
        var v = [0, n[1]], d = [0, n[0]], g = [[n[0], 0], [0, 0]], p = [], m = d[1] / (o.count() - 1), y = 0, _ = Math.round(o.count() / n[0]), S;
        o.each([l], function(T, E) {
          if (_ > 0 && E % _) {
            y += m;
            return;
          }
          var D = T == null || isNaN(T) || T === "", I = D ? 0 : De(T, c, v, !0);
          D && !S && E ? (g.push([g[g.length - 1][0], 0]), p.push([p[p.length - 1][0], 0])) : !D && S && (g.push([y, 0]), p.push([y, 0])), g.push([y, I]), p.push([y, I]), y += m, S = D;
        }), u = this._shadowPolygonPts = g, f = this._shadowPolylinePts = p;
      }
      this._shadowData = o, this._shadowDim = l, this._shadowSize = [n[0], n[1]];
      var b = this.dataZoomModel;
      function w(T) {
        var E = b.getModel(T ? "selectedDataBackground" : "dataBackground"), D = new dist_oe(), I = new Un({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: E.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), L = new cn({
          shape: {
            points: f
          },
          segmentIgnoreThreshold: 1,
          style: E.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return D.add(I), D.add(L), D;
      }
      for (var x = 0; x < 3; x++) {
        var C = w(x === 1);
        this._displayables.sliderGroup.add(C), this._displayables.dataShadowSegs.push(C);
      }
    }, e.prototype._prepareDataShadowInfo = function() {
      var t = this.dataZoomModel, n = t.get("showDataShadow");
      if (n !== !1) {
        var i, a = this.ecModel;
        return t.eachTargetAxis(function(o, s) {
          var l = t.getAxisProxy(o, s).getTargetSeriesModels();
          dist_M(l, function(u) {
            if (!i && !(n !== !0 && ye(c9, u.get("type")) < 0)) {
              var f = a.getComponent(kn(o), s).axis, c = d9(o), h, v = u.coordinateSystem;
              c != null && v.getOtherAxis && (h = v.getOtherAxis(f).inverse), c = u.getData().mapDimension(c), i = {
                thisAxis: f,
                series: u,
                thisDim: o,
                otherDim: c,
                otherAxisInverse: h
              };
            }
          }, this);
        }, this), i;
      }
    }, e.prototype._renderHandle = function() {
      var t = this.group, n = this._displayables, i = n.handles = [null, null], a = n.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, f = l.get("borderRadius") || 0, c = l.get("brushSelect"), h = n.filler = new Co({
        silent: c,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      o.add(h), o.add(new Co({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: f
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: l9,
          fill: "rgba(0,0,0,0)"
        }
      })), dist_M([0, 1], function(_) {
        var S = l.get("handleIcon");
        !Au[S] && S.indexOf("path://") < 0 && S.indexOf("image://") < 0 && (S = "path://" + S,  false && 0);
        var b = dt(S, -1, 0, 2, 2, null, !0);
        b.attr({
          cursor: ry(this._orient),
          draggable: !0,
          drift: dist_Z(this._onDragMove, this, _),
          ondragend: dist_Z(this._onDragEnd, this),
          onmouseover: dist_Z(this._showDataInfo, this, !0),
          onmouseout: dist_Z(this._showDataInfo, this, !1),
          z2: 5
        });
        var w = b.getBoundingRect(), x = l.get("handleSize");
        this._handleHeight = me(x, this._size[1]), this._handleWidth = w.width / w.height * this._handleHeight, b.setStyle(l.getModel("handleStyle").getItemStyle()), b.style.strokeNoScale = !0, b.rectHover = !0, b.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), mu(b);
        var C = l.get("handleColor");
        C != null && (b.style.fill = C), o.add(i[_] = b);
        var T = l.getModel("textStyle");
        t.add(a[_] = new Ne({
          silent: !0,
          invisible: !0,
          style: Lt(T, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: T.getTextColor(),
            font: T.getFont()
          }),
          z2: 10
        }));
      }, this);
      var v = h;
      if (c) {
        var d = me(l.get("moveHandleSize"), s[1]), g = n.moveHandle = new xe({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: d
          }
        }), p = d * 0.8, m = n.moveHandleIcon = dt(l.get("moveHandleIcon"), -p / 2, -p / 2, p, p, "#fff", !0);
        m.silent = !0, m.y = s[1] + d / 2 - 0.5, g.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(d, 10));
        v = n.moveZone = new xe({
          invisible: !0,
          shape: {
            y: s[1] - y,
            height: d + y
          }
        }), v.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), o.add(g), o.add(m), o.add(v);
      }
      v.attr({
        draggable: !0,
        cursor: ry(this._orient),
        drift: dist_Z(this._onDragMove, this, "all"),
        ondragstart: dist_Z(this._showDataInfo, this, !0),
        ondragend: dist_Z(this._onDragEnd, this),
        onmouseover: dist_Z(this._showDataInfo, this, !0),
        onmouseout: dist_Z(this._showDataInfo, this, !1)
      });
    }, e.prototype._resetInterval = function() {
      var t = this._range = this.dataZoomModel.getPercentRange(), n = this._getViewExtent();
      this._handleEnds = [De(t[0], [0, 100], n, !0), De(t[1], [0, 100], n, !0)];
    }, e.prototype._updateInterval = function(t, n) {
      var i = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      Fs(n, a, o, i.get("zoomLock") ? "all" : t, s.minSpan != null ? De(s.minSpan, l, o, !0) : null, s.maxSpan != null ? De(s.maxSpan, l, o, !0) : null);
      var u = this._range, f = this._range = xi([De(a[0], o, l, !0), De(a[1], o, l, !0)]);
      return !u || u[0] !== f[0] || u[1] !== f[1];
    }, e.prototype._updateView = function(t) {
      var n = this._displayables, i = this._handleEnds, a = xi(i.slice()), o = this._size;
      dist_M([0, 1], function(v) {
        var d = n.handles[v], g = this._handleHeight;
        d.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: i[v] + (v ? -1 : 1),
          y: o[1] / 2 - g / 2
        });
      }, this), n.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: o[1]
      });
      var s = {
        x: a[0],
        width: a[1] - a[0]
      };
      n.moveHandle && (n.moveHandle.setShape(s), n.moveZone.setShape(s), n.moveZone.getBoundingRect(), n.moveHandleIcon && n.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = n.dataShadowSegs, u = [0, a[0], a[1], o[0]], f = 0; f < l.length; f++) {
        var c = l[f], h = c.getClipPath();
        h || (h = new xe(), c.setClipPath(h)), h.setShape({
          x: u[f],
          y: 0,
          width: u[f + 1] - u[f],
          height: o[1]
        });
      }
      this._updateDataInfo(t);
    }, e.prototype._updateDataInfo = function(t) {
      var n = this.dataZoomModel, i = this._displayables, a = i.handleLabels, o = this._orient, s = ["", ""];
      if (n.get("showDetail")) {
        var l = n.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, f = this._range, c = t ? l.calculateDataWindow({
            start: f[0],
            end: f[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(c[0], u), this._formatLabel(c[1], u)];
        }
      }
      var h = xi(this._handleEnds.slice());
      v.call(this, 0), v.call(this, 1);
      function v(d) {
        var g = Wo(i.handles[d].parent, this.group), p = Yd(d === 0 ? "right" : "left", g), m = this._handleWidth / 2 + f9, y = Bn([h[d] + (d === 0 ? -m : m), this._size[1] / 2], g);
        a[d].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: o === To ? "middle" : p,
          align: o === To ? p : "center",
          text: s[d]
        });
      }
    }, e.prototype._formatLabel = function(t, n) {
      var i = this.dataZoomModel, a = i.get("labelFormatter"), o = i.get("labelPrecision");
      (o == null || o === "auto") && (o = n.getPixelPrecision());
      var s = t == null || isNaN(t) ? "" : n.type === "category" || n.type === "time" ? n.scale.getLabel({
        value: Math.round(t)
      }) : t.toFixed(Math.min(o, 20));
      return dist_j(a) ? a(t, s) : dist_U(a) ? a.replace("{value}", s) : s;
    }, e.prototype._showDataInfo = function(t) {
      t = this._dragging || t;
      var n = this._displayables, i = n.handleLabels;
      i[0].attr("invisible", !t), i[1].attr("invisible", !t), n.moveHandle && this.api[t ? "enterEmphasis" : "leaveEmphasis"](n.moveHandle, 1);
    }, e.prototype._onDragMove = function(t, n, i, a) {
      this._dragging = !0, Qr(a.event);
      var o = this._displayables.sliderGroup.getLocalTransform(), s = Bn([n, i], o, !0), l = this._updateInterval(t, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, e.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var t = this.dataZoomModel.get("realtime");
      !t && this._dispatchZoomAction(!1);
    }, e.prototype._onClickPanel = function(t) {
      var n = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
      if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
        var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", i[0] - o);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, e.prototype._onBrushStart = function(t) {
      var n = t.offsetX, i = t.offsetY;
      this._brushStart = new dist_K(n, i), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, e.prototype._onBrushEnd = function(t) {
      if (this._brushing) {
        var n = this._displayables.brushRect;
        if (this._brushing = !1, !!n) {
          n.attr("ignore", !0);
          var i = n.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var o = this._getViewExtent(), s = [0, 100];
            this._range = xi([De(i.x, o, s, !0), De(i.x + i.width, o, s, !0)]), this._handleEnds = [i.x, i.x + i.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, e.prototype._onBrush = function(t) {
      this._brushing && (Qr(t.event), this._updateBrushRect(t.offsetX, t.offsetY));
    }, e.prototype._updateBrushRect = function(t, n) {
      var i = this._displayables, a = this.dataZoomModel, o = i.brushRect;
      o || (o = i.brushRect = new Co({
        silent: !0,
        style: a.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(o)), o.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(t, n), f = l.transformCoordToLocal(s.x, s.y), c = this._size;
      u[0] = Math.max(Math.min(c[0], u[0]), 0), o.setShape({
        x: f[0],
        y: 0,
        width: u[0] - f[0],
        height: c[1]
      });
    }, e.prototype._dispatchZoomAction = function(t) {
      var n = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: t ? h9 : null,
        start: n[0],
        end: n[1]
      });
    }, e.prototype._findCoordRect = function() {
      var t, n = oS(this.dataZoomModel).infoList;
      if (!t && n.length) {
        var i = n[0].model.coordinateSystem;
        t = i.getRect && i.getRect();
      }
      if (!t) {
        var a = this.api.getWidth(), o = this.api.getHeight();
        t = {
          x: a * 0.2,
          y: o * 0.2,
          width: a * 0.6,
          height: o * 0.6
        };
      }
      return t;
    }, e.type = "dataZoom.slider", e;
  }(sS)
);
function d9(r) {
  var e = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return e[r];
}
function ry(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
const p9 = v9;
function g9(r) {
  r.registerComponentModel(s9), r.registerComponentView(p9), lS(r);
}
function m9(r) {
  Rt(a9), Rt(g9);
}
var mS = {
  /**
   * @public
   */
  get: function(r, e, t) {
    var n = dist_te((y9[r] || {})[e]);
    return t && dist_F(n) ? n[n.length - 1] : n;
  }
}, y9 = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
}, ny = nt.mapVisual, _9 = nt.eachVisual, S9 = dist_F, iy = dist_M, w9 = xi, b9 = De, Hu = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.stateList = ["inRange", "outOfRange"], t.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t.dataBound = [-1 / 0, 1 / 0], t.targetVisuals = {}, t.controllerVisuals = {}, t;
    }
    return e.prototype.init = function(t, n, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.optionUpdated = function(t, n) {
      var i = this.option;
      !n && AO(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, e.prototype.resetVisual = function(t) {
      var n = this.stateList;
      t = dist_Z(t, this), this.controllerVisuals = qm(this.option.controller, n, t), this.targetVisuals = qm(this.option.target, n, t);
    }, e.prototype.getItemSymbol = function() {
      return null;
    }, e.prototype.getTargetSeriesIndices = function() {
      var t = this.option.seriesIndex, n = [];
      return t == null || t === "all" ? this.ecModel.eachSeries(function(i, a) {
        n.push(a);
      }) : n = Ae(t), n;
    }, e.prototype.eachTargetSeries = function(t, n) {
      dist_M(this.getTargetSeriesIndices(), function(i) {
        var a = this.ecModel.getSeriesByIndex(i);
        a && t.call(n, a);
      }, this);
    }, e.prototype.isTargetSeries = function(t) {
      var n = !1;
      return this.eachTargetSeries(function(i) {
        i === t && (n = !0);
      }), n;
    }, e.prototype.formatValueText = function(t, n, i) {
      var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
      i = i || ["<", ">"], dist_F(t) && (t = t.slice(), u = !0);
      var f = n ? t : u ? [c(t[0]), c(t[1])] : c(t);
      if (dist_U(l))
        return l.replace("{value}", u ? f[0] : f).replace("{value2}", u ? f[1] : f);
      if (dist_j(l))
        return u ? l(t[0], t[1]) : l(t);
      if (u)
        return t[0] === s[0] ? i[0] + " " + f[1] : t[1] === s[1] ? i[1] + " " + f[0] : f[0] + " - " + f[1];
      return f;
      function c(h) {
        return h === s[0] ? "min" : h === s[1] ? "max" : (+h).toFixed(Math.min(o, 20));
      }
    }, e.prototype.resetExtent = function() {
      var t = this.option, n = w9([t.min, t.max]);
      this._dataExtent = n;
    }, e.prototype.getDataDimensionIndex = function(t) {
      var n = this.option.dimension;
      if (n != null)
        return t.getDimensionIndex(n);
      for (var i = t.dimensions, a = i.length - 1; a >= 0; a--) {
        var o = i[a], s = t.getDimensionInfo(o);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, e.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, e.prototype.completeVisualOption = function() {
      var t = this.ecModel, n = this.option, i = {
        inRange: n.inRange,
        outOfRange: n.outOfRange
      }, a = n.target || (n.target = {}), o = n.controller || (n.controller = {});
      he(a, i), he(o, i);
      var s = this.isCategory();
      l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), f.call(this, o);
      function l(c) {
        S9(n.color) && !c.inRange && (c.inRange = {
          color: n.color.slice().reverse()
        }), c.inRange = c.inRange || {
          color: t.get("gradientColor")
        };
      }
      function u(c, h, v) {
        var d = c[h], g = c[v];
        d && !g && (g = c[v] = {}, iy(d, function(p, m) {
          if (nt.isValidType(m)) {
            var y = mS.get(m, "inactive", s);
            y != null && (g[m] = y, m === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [0, 0]));
          }
        }));
      }
      function f(c) {
        var h = (c.inRange || {}).symbol || (c.outOfRange || {}).symbol, v = (c.inRange || {}).symbolSize || (c.outOfRange || {}).symbolSize, d = this.get("inactiveColor"), g = this.getItemSymbol(), p = g || "roundRect";
        iy(this.stateList, function(m) {
          var y = this.itemSize, _ = c[m];
          _ || (_ = c[m] = {
            color: s ? d : [d]
          }), _.symbol == null && (_.symbol = h && dist_te(h) || (s ? p : [p])), _.symbolSize == null && (_.symbolSize = v && dist_te(v) || (s ? y[0] : [y[0], y[0]])), _.symbol = ny(_.symbol, function(w) {
            return w === "none" ? p : w;
          });
          var S = _.symbolSize;
          if (S != null) {
            var b = -1 / 0;
            _9(S, function(w) {
              w > b && (b = w);
            }), _.symbolSize = ny(S, function(w) {
              return b9(w, [0, b], [0, y[0]], !0);
            });
          }
        }, this);
      }
    }, e.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, e.prototype.isCategory = function() {
      return !!this.option.categories;
    }, e.prototype.setSelected = function(t) {
    }, e.prototype.getSelected = function() {
      return null;
    }, e.prototype.getValueState = function(t) {
      return null;
    }, e.prototype.getVisualMeta = function(t) {
      return null;
    }, e.type = "visualMap", e.dependencies = ["series"], e.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // 接受数组分别设定上右下左边距，同css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 值域文字颜色
      }
    }, e;
  }(Se)
), ay = [20, 140], x9 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function(t, n) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, e.prototype.resetItemSize = function() {
      r.prototype.resetItemSize.apply(this, arguments);
      var t = this.itemSize;
      (t[0] == null || isNaN(t[0])) && (t[0] = ay[0]), (t[1] == null || isNaN(t[1])) && (t[1] = ay[1]);
    }, e.prototype._resetRange = function() {
      var t = this.getExtent(), n = this.option.range;
      !n || n.auto ? (t.auto = 1, this.option.range = t) : dist_F(n) && (n[0] > n[1] && n.reverse(), n[0] = Math.max(n[0], t[0]), n[1] = Math.min(n[1], t[1]));
    }, e.prototype.completeVisualOption = function() {
      r.prototype.completeVisualOption.apply(this, arguments), dist_M(this.stateList, function(t) {
        var n = this.option.controller[t].symbolSize;
        n && n[0] !== n[1] && (n[0] = n[1] / 3);
      }, this);
    }, e.prototype.setSelected = function(t) {
      this.option.range = t.slice(), this._resetRange();
    }, e.prototype.getSelected = function() {
      var t = this.getExtent(), n = xi((this.get("range") || []).slice());
      return n[0] > t[1] && (n[0] = t[1]), n[1] > t[1] && (n[1] = t[1]), n[0] < t[0] && (n[0] = t[0]), n[1] < t[0] && (n[1] = t[0]), n;
    }, e.prototype.getValueState = function(t) {
      var n = this.option.range, i = this.getExtent();
      return (n[0] <= i[0] || n[0] <= t) && (n[1] >= i[1] || t <= n[1]) ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var n = [];
      return this.eachTargetSeries(function(i) {
        var a = [], o = i.getData();
        o.each(this.getDataDimensionIndex(o), function(s, l) {
          t[0] <= s && s <= t[1] && a.push(l);
        }, this), n.push({
          seriesId: i.id,
          dataIndex: a
        });
      }, this), n;
    }, e.prototype.getVisualMeta = function(t) {
      var n = oy(this, "outOfRange", this.getExtent()), i = oy(this, "inRange", this.option.range.slice()), a = [];
      function o(v, d) {
        a.push({
          value: v,
          color: t(v, d)
        });
      }
      for (var s = 0, l = 0, u = i.length, f = n.length; l < f && (!i.length || n[l] <= i[0]); l++)
        n[l] < i[s] && o(n[l], "outOfRange");
      for (var c = 1; s < u; s++, c = 0)
        c && a.length && o(i[s], "outOfRange"), o(i[s], "inRange");
      for (var c = 1; l < f; l++)
        (!i.length || i[i.length - 1] < n[l]) && (c && (a.length && o(a[a.length - 1].value, "outOfRange"), c = 0), o(n[l], "outOfRange"));
      var h = a.length;
      return {
        stops: a,
        outerColors: [h ? a[0].color : "transparent", h ? a[h - 1].color : "transparent"]
      };
    }, e.type = "visualMap.continuous", e.defaultOption = Xa(Hu.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), e;
  }(Hu)
);
function oy(r, e, t) {
  if (t[0] === t[1])
    return t.slice();
  for (var n = 200, i = (t[1] - t[0]) / n, a = t[0], o = [], s = 0; s <= n && a < t[1]; s++)
    o.push(a), a += i;
  return o.push(t[1]), o;
}
const C9 = x9;
var T9 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, t;
    }
    return e.prototype.init = function(t, n) {
      this.ecModel = t, this.api = n;
    }, e.prototype.render = function(t, n, i, a) {
      if (this.visualMapModel = t, t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(t, n, i, a);
    }, e.prototype.renderBackground = function(t) {
      var n = this.visualMapModel, i = Ns(n.get("padding") || 0), a = t.getBoundingRect();
      t.add(new xe({
        z2: -1,
        silent: !0,
        shape: {
          x: a.x - i[3],
          y: a.y - i[0],
          width: a.width + i[3] + i[1],
          height: a.height + i[0] + i[2]
        },
        style: {
          fill: n.get("backgroundColor"),
          stroke: n.get("borderColor"),
          lineWidth: n.get("borderWidth")
        }
      }));
    }, e.prototype.getControllerVisual = function(t, n, i) {
      i = i || {};
      var a = i.forceState, o = this.visualMapModel, s = {};
      if (n === "color") {
        var l = o.get("contentColor");
        s.color = l;
      }
      function u(v) {
        return s[v];
      }
      function f(v, d) {
        s[v] = d;
      }
      var c = o.controllerVisuals[a || o.getValueState(t)], h = nt.prepareVisualTypes(c);
      return dist_M(h, function(v) {
        var d = c[v];
        i.convertOpacityToAlpha && v === "opacity" && (v = "colorAlpha", d = c.__alphaForOpacity), nt.dependsOn(v, n) && d && d.applyVisual(t, u, f);
      }), s[n];
    }, e.prototype.positionGroup = function(t) {
      var n = this.visualMapModel, i = this.api;
      vM(t, n.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, e.prototype.doRender = function(t, n, i, a) {
    }, e.type = "visualMap", e;
  }(Pt)
);
const yS = T9;
var sy = [["left", "right", "width"], ["top", "bottom", "height"]];
function _S(r, e, t) {
  var n = r.option, i = n.align;
  if (i != null && i !== "auto")
    return i;
  for (var a = {
    width: e.getWidth(),
    height: e.getHeight()
  }, o = n.orient === "horizontal" ? 1 : 0, s = sy[o], l = [0, null, 10], u = {}, f = 0; f < 3; f++)
    u[sy[1 - o][f]] = l[f], u[s[f]] = f === 2 ? t[0] : n[s[f]];
  var c = [["x", "width", 3], ["y", "height", 0]][o], h = cr(u, a, n.padding);
  return s[(h.margin[c[2]] || 0) + h[c[0]] + h[c[1]] * 0.5 < a[c[1]] * 0.5 ? 0 : 1];
}
function ru(r, e) {
  return dist_M(r || [], function(t) {
    t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "");
  }), r;
}
var wr = De, M9 = dist_M, ly = Math.min, Vh = Math.max, D9 = 12, E9 = 6, A9 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t;
    }
    return e.prototype.init = function(t, n) {
      r.prototype.init.call(this, t, n), this._hoverLinkFromSeriesMouseOver = dist_Z(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = dist_Z(this._hideIndicator, this);
    }, e.prototype.doRender = function(t, n, i, a) {
      (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, e.prototype._buildView = function() {
      this.group.removeAll();
      var t = this.visualMapModel, n = this.group;
      this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(n);
      var i = t.get("text");
      this._renderEndsText(n, i, 0), this._renderEndsText(n, i, 1), this._updateView(!0), this.renderBackground(n), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(n);
    }, e.prototype._renderEndsText = function(t, n, i) {
      if (n) {
        var a = n[1 - i];
        a = a != null ? a + "" : "";
        var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, f = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u), c = this._applyTransform(i === 0 ? "bottom" : "top", u), h = this._orient, v = this.visualMapModel.textStyleModel;
        this.group.add(new Ne({
          style: Lt(v, {
            x: f[0],
            y: f[1],
            verticalAlign: h === "horizontal" ? "middle" : c,
            align: h === "horizontal" ? c : "center",
            text: a
          })
        }));
      }
    }, e.prototype._renderBar = function(t) {
      var n = this.visualMapModel, i = this._shapes, a = n.itemSize, o = this._orient, s = this._useHandle, l = _S(n, this.api, a), u = i.mainGroup = this._createBarGroup(l), f = new dist_oe();
      u.add(f), f.add(i.outOfRange = uy()), f.add(i.inRange = uy(null, s ? cy(this._orient) : null, dist_Z(this._dragHandle, this, "all", !1), dist_Z(this._dragHandle, this, "all", !0))), f.setClipPath(new xe({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var c = n.textStyleModel.getTextRect("国"), h = Vh(c.width, c.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(n, u, 0, a, h, o), this._createHandle(n, u, 1, a, h, o)), this._createIndicator(n, u, a, h, o), t.add(u);
    }, e.prototype._createHandle = function(t, n, i, a, o, s) {
      var l = dist_Z(this._dragHandle, this, i, !1), u = dist_Z(this._dragHandle, this, i, !0), f = Lr(t.get("handleSize"), a[0]), c = dt(t.get("handleIcon"), -f / 2, -f / 2, f, f, null, !0), h = cy(this._orient);
      c.attr({
        cursor: h,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          Qr(m.event);
        }
      }), c.x = a[0] / 2, c.useStyle(t.getModel("handleStyle").getItemStyle()), c.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), c.style.lineWidth *= 2, c.ensureState("emphasis").style = t.getModel(["emphasis", "handleStyle"]).getItemStyle(), Bd(c, !0), n.add(c);
      var v = this.visualMapModel.textStyleModel, d = new Ne({
        cursor: h,
        draggable: !0,
        drift: l,
        onmousemove: function(m) {
          Qr(m.event);
        },
        ondragend: u,
        style: Lt(v, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      d.ensureState("blur").style = {
        opacity: 0.1
      }, d.stateTransition = {
        duration: 200
      }, this.group.add(d);
      var g = [f, 0], p = this._shapes;
      p.handleThumbs[i] = c, p.handleLabelPoints[i] = g, p.handleLabels[i] = d;
    }, e.prototype._createIndicator = function(t, n, i, a, o) {
      var s = Lr(t.get("indicatorSize"), i[0]), l = dt(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: i[0] / 2
      });
      var u = t.getModel("indicatorStyle").getItemStyle();
      if (l instanceof un) {
        var f = l.style;
        l.useStyle(dist_V({
          // TODO other properties like x, y ?
          image: f.image,
          x: f.x,
          y: f.y,
          width: f.width,
          height: f.height
        }, u));
      } else
        l.useStyle(u);
      n.add(l);
      var c = this.visualMapModel.textStyleModel, h = new Ne({
        silent: !0,
        invisible: !0,
        style: Lt(c, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(h);
      var v = [(o === "horizontal" ? a / 2 : E9) + i[0] / 2, 0], d = this._shapes;
      d.indicator = l, d.indicatorLabel = h, d.indicatorLabelPoint = v, this._firstShowIndicator = !0;
    }, e.prototype._dragHandle = function(t, n, i, a) {
      if (this._useHandle) {
        if (this._dragging = !n, !n) {
          var o = this._applyTransform([i, a], this._shapes.mainGroup, !0);
          this._updateInterval(t, o[1]), this._hideIndicator(), this._updateView();
        }
        n === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), n ? !this._hovering && this._clearHoverLinkToSeries() : fy(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
      }
    }, e.prototype._resetInterval = function() {
      var t = this.visualMapModel, n = this._dataInterval = t.getSelected(), i = t.getExtent(), a = [0, t.itemSize[1]];
      this._handleEnds = [wr(n[0], i, a, !0), wr(n[1], i, a, !0)];
    }, e.prototype._updateInterval = function(t, n) {
      n = n || 0;
      var i = this.visualMapModel, a = this._handleEnds, o = [0, i.itemSize[1]];
      Fs(
        n,
        a,
        o,
        t,
        // cross is forbidden
        0
      );
      var s = i.getExtent();
      this._dataInterval = [wr(a[0], o, s, !0), wr(a[1], o, s, !0)];
    }, e.prototype._updateView = function(t) {
      var n = this.visualMapModel, i = n.getExtent(), a = this._shapes, o = [0, n.itemSize[1]], s = t ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, o, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, e.prototype._createBarVisual = function(t, n, i, a) {
      var o = {
        forceState: a,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(t, o), l = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)], u = this._createBarPoints(i, l);
      return {
        barColor: new vf(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, e.prototype._makeColorGradient = function(t, n) {
      var i = 100, a = [], o = (t[1] - t[0]) / i;
      a.push({
        color: this.getControllerVisual(t[0], "color", n),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = t[0] + o * s;
        if (l > t[1])
          break;
        a.push({
          color: this.getControllerVisual(l, "color", n),
          offset: s / i
        });
      }
      return a.push({
        color: this.getControllerVisual(t[1], "color", n),
        offset: 1
      }), a;
    }, e.prototype._createBarPoints = function(t, n) {
      var i = this.visualMapModel.itemSize;
      return [[i[0] - n[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - n[1], t[1]]];
    }, e.prototype._createBarGroup = function(t) {
      var n = this._orient, i = this.visualMapModel.get("inverse");
      return new dist_oe(n === "horizontal" && !i ? {
        scaleX: t === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : n === "horizontal" && i ? {
        scaleX: t === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : n === "vertical" && !i ? {
        scaleX: t === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: t === "left" ? 1 : -1
      });
    }, e.prototype._updateHandle = function(t, n) {
      if (this._useHandle) {
        var i = this._shapes, a = this.visualMapModel, o = i.handleThumbs, s = i.handleLabels, l = a.itemSize, u = a.getExtent();
        M9([0, 1], function(f) {
          var c = o[f];
          c.setStyle("fill", n.handlesColor[f]), c.y = t[f];
          var h = wr(t[f], [0, l[1]], u, !0), v = this.getControllerVisual(h, "symbolSize");
          c.scaleX = c.scaleY = v / l[0], c.x = l[0] - v / 2;
          var d = Bn(i.handleLabelPoints[f], Wo(c, this.group));
          s[f].setStyle({
            x: d[0],
            y: d[1],
            text: a.formatValueText(this._dataInterval[f]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, e.prototype._showIndicator = function(t, n, i, a) {
      var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [0, l[1]], f = this._shapes, c = f.indicator;
      if (c) {
        c.attr("invisible", !1);
        var h = {
          convertOpacityToAlpha: !0
        }, v = this.getControllerVisual(t, "color", h), d = this.getControllerVisual(t, "symbolSize"), g = wr(t, s, u, !0), p = l[0] - d / 2, m = {
          x: c.x,
          y: c.y
        };
        c.y = g, c.x = p;
        var y = Bn(f.indicatorLabelPoint, Wo(c, this.group)), _ = f.indicatorLabel;
        _.attr("invisible", !1);
        var S = this._applyTransform("left", f.mainGroup), b = this._orient, w = b === "horizontal";
        _.setStyle({
          text: (i || "") + o.formatValueText(n),
          verticalAlign: w ? S : "middle",
          align: w ? "center" : S
        });
        var x = {
          x: p,
          y: g,
          style: {
            fill: v
          }
        }, C = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var T = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          c.x = m.x, c.y = m.y, c.animateTo(x, T), _.animateTo(C, T);
        } else
          c.attr(x), _.attr(C);
        this._firstShowIndicator = !1;
        var E = this._shapes.handleLabels;
        if (E)
          for (var D = 0; D < E.length; D++)
            this.api.enterBlur(E[D]);
      }
    }, e.prototype._enableHoverLinkToSeries = function() {
      var t = this;
      this._shapes.mainGroup.on("mousemove", function(n) {
        if (t._hovering = !0, !t._dragging) {
          var i = t.visualMapModel.itemSize, a = t._applyTransform([n.offsetX, n.offsetY], t._shapes.mainGroup, !0, !0);
          a[1] = ly(Vh(0, a[1]), i[1]), t._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]);
        }
      }).on("mouseout", function() {
        t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries();
      });
    }, e.prototype._enableHoverLinkFromSeries = function() {
      var t = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, e.prototype._doHoverLinkToSeries = function(t, n) {
      var i = this.visualMapModel, a = i.itemSize;
      if (i.option.hoverLink) {
        var o = [0, a[1]], s = i.getExtent();
        t = ly(Vh(o[0], t), o[1]);
        var l = I9(i, s, o), u = [t - l, t + l], f = wr(t, o, s, !0), c = [wr(u[0], o, s, !0), wr(u[1], o, s, !0)];
        u[0] < o[0] && (c[0] = -1 / 0), u[1] > o[1] && (c[1] = 1 / 0), n && (c[0] === -1 / 0 ? this._showIndicator(f, c[1], "< ", l) : c[1] === 1 / 0 ? this._showIndicator(f, c[0], "> ", l) : this._showIndicator(f, f, "≈ ", l));
        var h = this._hoverLinkDataIndices, v = [];
        (n || fy(i)) && (v = this._hoverLinkDataIndices = i.findTargetDataIndices(c));
        var d = IC(h, v);
        this._dispatchHighDown("downplay", ru(d[0], i)), this._dispatchHighDown("highlight", ru(d[1], i));
      }
    }, e.prototype._hoverLinkFromSeriesMouseOver = function(t) {
      var n;
      if (Ti(t.target, function(l) {
        var u = dist_ie(l);
        if (u.dataIndex != null)
          return n = u, !0;
      }, !0), !!n) {
        var i = this.ecModel.getSeriesByIndex(n.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(i)) {
          var o = i.getData(n.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), n.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, e.prototype._hideIndicator = function() {
      var t = this._shapes;
      t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
      var n = this._shapes.handleLabels;
      if (n)
        for (var i = 0; i < n.length; i++)
          this.api.leaveBlur(n[i]);
    }, e.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var t = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", ru(t, this.visualMapModel)), t.length = 0;
    }, e.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var t = this.api.getZr();
      t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
    }, e.prototype._applyTransform = function(t, n, i, a) {
      var o = Wo(n, a ? null : this.group);
      return dist_F(t) ? Bn(t, o, i) : Yd(t, o, i);
    }, e.prototype._dispatchHighDown = function(t, n) {
      n && n.length && this.api.dispatchAction({
        type: t,
        batch: n
      });
    }, e.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.type = "visualMap.continuous", e;
  }(yS)
);
function uy(r, e, t, n) {
  return new Un({
    shape: {
      points: r
    },
    draggable: !!t,
    cursor: e,
    drift: t,
    onmousemove: function(i) {
      Qr(i.event);
    },
    ondragend: n
  });
}
function I9(r, e, t) {
  var n = D9 / 2, i = r.get("hoverLinkDataSize");
  return i && (n = wr(i, e, t, !0) / 2), n;
}
function fy(r) {
  var e = r.get("hoverLinkOnHandle");
  return !!(e ?? r.get("realtime"));
}
function cy(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
const L9 = A9;
var N9 = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, P9 = function(r, e) {
  e.eachComponent({
    mainType: "visualMap",
    query: r
  }, function(t) {
    t.setSelected(r.selected);
  });
}, R9 = [
  {
    createOnAllSeries: !0,
    reset: function(r, e) {
      var t = [];
      return e.eachComponent("visualMap", function(n) {
        var i = r.pipelineContext;
        !n.isTargetSeries(r) || i && i.large || t.push(IO(n.stateList, n.targetVisuals, dist_Z(n.getValueState, n), n.getDataDimensionIndex(r.getData())));
      }), t;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(r, e) {
      var t = r.getData(), n = [];
      e.eachComponent("visualMap", function(i) {
        if (i.isTargetSeries(r)) {
          var a = i.getVisualMeta(dist_Z(O9, null, r, i)) || {
            stops: [],
            outerColors: []
          }, o = i.getDataDimensionIndex(t);
          o >= 0 && (a.dimension = o, n.push(a));
        }
      }), r.getData().setVisual("visualMeta", n);
    }
  }
];
function O9(r, e, t, n) {
  for (var i = e.targetVisuals[n], a = nt.prepareVisualTypes(i), o = {
    color: J4(r.getData(), "color")
    // default color.
  }, s = 0, l = a.length; s < l; s++) {
    var u = a[s], f = i[u === "opacity" ? "__alphaForOpacity" : u];
    f && f.applyVisual(t, c, h);
  }
  return o.color;
  function c(v) {
    return o[v];
  }
  function h(v, d) {
    o[v] = d;
  }
}
var hy = dist_M;
function k9(r) {
  var e = r && r.visualMap;
  dist_F(e) || (e = e ? [e] : []), hy(e, function(t) {
    if (t) {
      va(t, "splitList") && !va(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
      var n = t.pieces;
      n && dist_F(n) && hy(n, function(i) {
        dist_X(i) && (va(i, "start") && !va(i, "min") && (i.min = i.start), va(i, "end") && !va(i, "max") && (i.max = i.end));
      });
    }
  });
}
function va(r, e) {
  return r && r.hasOwnProperty && r.hasOwnProperty(e);
}
var vy = !1;
function SS(r) {
  vy || (vy = !0, r.registerSubTypeDefaulter("visualMap", function(e) {
    return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise";
  }), r.registerAction(N9, P9), dist_M(R9, function(e) {
    r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, e);
  }), r.registerPreprocessor(k9));
}
function V9(r) {
  r.registerComponentModel(C9), r.registerComponentView(L9), SS(r);
}
var B9 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._pieceList = [], t;
    }
    return e.prototype.optionUpdated = function(t, n) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], F9[this._mode].call(this, this._pieceList), this._resetSelected(t, n);
      var a = this.option.categories;
      this.resetVisual(function(o, s) {
        i === "categories" ? (o.mappingMethod = "category", o.categories = dist_te(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = dist_$(this._pieceList, function(l) {
          return l = dist_te(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, e.prototype.completeVisualOption = function() {
      var t = this.option, n = {}, i = nt.listVisualTypes(), a = this.isCategory();
      dist_M(t.pieces, function(s) {
        dist_M(i, function(l) {
          s.hasOwnProperty(l) && (n[l] = 1);
        });
      }), dist_M(n, function(s, l) {
        var u = !1;
        dist_M(this.stateList, function(f) {
          u = u || o(t, f, l) || o(t.target, f, l);
        }, this), !u && dist_M(this.stateList, function(f) {
          (t[f] || (t[f] = {}))[l] = mS.get(l, f === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function o(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      r.prototype.completeVisualOption.apply(this, arguments);
    }, e.prototype._resetSelected = function(t, n) {
      var i = this.option, a = this._pieceList, o = (n ? i : t).selected || {};
      if (i.selected = o, dist_M(a, function(l, u) {
        var f = this.getSelectedMapKey(l);
        o.hasOwnProperty(f) || (o[f] = !0);
      }, this), i.selectedMode === "single") {
        var s = !1;
        dist_M(a, function(l, u) {
          var f = this.getSelectedMapKey(l);
          o[f] && (s ? o[f] = !1 : s = !0);
        }, this);
      }
    }, e.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, e.prototype.getSelectedMapKey = function(t) {
      return this._mode === "categories" ? t.value + "" : t.index + "";
    }, e.prototype.getPieceList = function() {
      return this._pieceList;
    }, e.prototype._determineMode = function() {
      var t = this.option;
      return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, e.prototype.setSelected = function(t) {
      this.option.selected = dist_te(t);
    }, e.prototype.getValueState = function(t) {
      var n = nt.findPieceIndex(t, this._pieceList);
      return n != null && this.option.selected[this.getSelectedMapKey(this._pieceList[n])] ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var n = [], i = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var o = [], s = a.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var f = nt.findPieceIndex(l, i);
          f === t && o.push(u);
        }, this), n.push({
          seriesId: a.id,
          dataIndex: o
        });
      }, this), n;
    }, e.prototype.getRepresentValue = function(t) {
      var n;
      if (this.isCategory())
        n = t.value;
      else if (t.value != null)
        n = t.value;
      else {
        var i = t.interval || [];
        n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return n;
    }, e.prototype.getVisualMeta = function(t) {
      if (this.isCategory())
        return;
      var n = [], i = ["", ""], a = this;
      function o(f, c) {
        var h = a.getRepresentValue({
          interval: f
        });
        c || (c = a.getValueState(h));
        var v = t(h, c);
        f[0] === -1 / 0 ? i[0] = v : f[1] === 1 / 0 ? i[1] = v : n.push({
          value: f[0],
          color: v
        }, {
          value: f[1],
          color: v
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return dist_M(s, function(f) {
        var c = f.interval;
        c && (c[0] > u && o([u, c[0]], "outOfRange"), o(c.slice()), u = c[1]);
      }, this), {
        stops: n,
        outerColors: i
      };
    }, e.type = "visualMap.piecewise", e.defaultOption = Xa(Hu.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), e;
  }(Hu)
), F9 = {
  splitNumber: function(r) {
    var e = this.option, t = Math.min(e.precision, 20), n = this.getExtent(), i = e.splitNumber;
    i = Math.max(parseInt(i, 10), 1), e.splitNumber = i;
    for (var a = (n[1] - n[0]) / i; +a.toFixed(t) !== a && t < 5; )
      t++;
    e.precision = t, a = +a.toFixed(t), e.minOpen && r.push({
      interval: [-1 / 0, n[0]],
      close: [0, 0]
    });
    for (var o = 0, s = n[0]; o < i; s += a, o++) {
      var l = o === i - 1 ? n[1] : s + a;
      r.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    e.maxOpen && r.push({
      interval: [n[1], 1 / 0],
      close: [0, 0]
    }), Jp(r), dist_M(r, function(u, f) {
      u.index = f, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(r) {
    var e = this.option;
    dist_M(e.categories, function(t) {
      r.push({
        text: this.formatValueText(t, !0),
        value: t
      });
    }, this), dy(e, r);
  },
  pieces: function(r) {
    var e = this.option;
    dist_M(e.pieces, function(t, n) {
      dist_X(t) || (t = {
        value: t
      });
      var i = {
        text: "",
        index: n
      };
      if (t.label != null && (i.text = t.label), t.hasOwnProperty("value")) {
        var a = i.value = t.value;
        i.interval = [a, a], i.close = [1, 1];
      } else {
        for (var o = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], f = [], c = 0; c < 2; c++) {
          for (var h = [["gte", "gt", "min"], ["lte", "lt", "max"]][c], v = 0; v < 3 && o[c] == null; v++)
            o[c] = t[h[v]], s[c] = l[v], f[c] = v === 2;
          o[c] == null && (o[c] = u[c]);
        }
        f[0] && o[1] === 1 / 0 && (s[0] = 0), f[1] && o[0] === -1 / 0 && (s[1] = 0),  false && 0, o[0] === o[1] && s[0] && s[1] && (i.value = o[0]);
      }
      i.visual = nt.retrieveVisuals(t), r.push(i);
    }, this), dy(e, r), Jp(r), dist_M(r, function(t) {
      var n = t.close, i = [["<", "≤"][n[1]], [">", "≥"][n[0]]];
      t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, !1, i);
    }, this);
  }
};
function dy(r, e) {
  var t = r.inverse;
  (r.orient === "vertical" ? !t : t) && e.reverse();
}
const z9 = B9;
var G9 = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.doRender = function() {
      var t = this.group;
      t.removeAll();
      var n = this.visualMapModel, i = n.get("textGap"), a = n.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), u = n.itemSize, f = this._getViewData(), c = f.endsText, h = Kt(n.get("showLabel", !0), !c);
      c && this._renderEndsText(t, c[0], u, h, l), dist_M(f.viewPieceList, function(v) {
        var d = v.piece, g = new dist_oe();
        g.onclick = dist_Z(this._onItemClick, this, d), this._enableHoverLink(g, v.indexInModelPieceList);
        var p = n.getRepresentValue(d);
        if (this._createItemSymbol(g, p, [0, 0, u[0], u[1]]), h) {
          var m = this.visualMapModel.getValueState(p);
          g.add(new Ne({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: d.text,
              verticalAlign: "middle",
              align: l,
              font: o,
              fill: s,
              opacity: m === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        t.add(g);
      }, this), c && this._renderEndsText(t, c[1], u, h, l), Aa(n.get("orient"), t, n.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
    }, e.prototype._enableHoverLink = function(t, n) {
      var i = this;
      t.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(o) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: o,
          batch: ru(s.findTargetDataIndices(n), s)
        });
      };
    }, e.prototype._getItemAlign = function() {
      var t = this.visualMapModel, n = t.option;
      if (n.orient === "vertical")
        return _S(t, this.api, t.itemSize);
      var i = n.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, e.prototype._renderEndsText = function(t, n, i, a, o) {
      if (n) {
        var s = new dist_oe(), l = this.visualMapModel.textStyleModel;
        s.add(new Ne({
          style: Lt(l, {
            x: a ? o === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: a ? o : "center",
            text: n
          })
        })), t.add(s);
      }
    }, e.prototype._getViewData = function() {
      var t = this.visualMapModel, n = dist_$(t.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = t.get("text"), a = t.get("orient"), o = t.get("inverse");
      return (a === "horizontal" ? o : !o) ? n.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: n,
        endsText: i
      };
    }, e.prototype._createItemSymbol = function(t, n, i) {
      t.add(dt(
        // symbol will be string
        this.getControllerVisual(n, "symbol"),
        i[0],
        i[1],
        i[2],
        i[3],
        // color will be string
        this.getControllerVisual(n, "color")
      ));
    }, e.prototype._onItemClick = function(t) {
      var n = this.visualMapModel, i = n.option, a = i.selectedMode;
      if (a) {
        var o = dist_te(i.selected), s = n.getSelectedMapKey(t);
        a === "single" || a === !0 ? (o[s] = !0, dist_M(o, function(l, u) {
          o[u] = u === s;
        })) : o[s] = !o[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: o
        });
      }
    }, e.type = "visualMap.piecewise", e;
  }(yS)
);
const H9 = G9;
function $9(r) {
  r.registerComponentModel(z9), r.registerComponentView(H9), SS(r);
}
function W9(r) {
  Rt(V9), Rt($9);
}
var py = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, U9 = (
  /** @class */
  function() {
    function r(e) {
      var t = this._condVal = dist_U(e) ? new RegExp(e) : y3(e) ? e : null;
      if (t == null) {
        var n = "";
         false && (0), de(n);
      }
    }
    return r.prototype.evaluate = function(e) {
      var t = typeof e;
      return dist_U(t) ? this._condVal.test(e) : ve(t) ? this._condVal.test(e + "") : !1;
    }, r;
  }()
), Y9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return this.value;
    }, r;
  }()
), X9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (!e[t].evaluate())
          return !1;
      return !0;
    }, r;
  }()
), Z9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (e[t].evaluate())
          return !0;
      return !1;
    }, r;
  }()
), q9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, r;
  }()
), K9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = !!this.valueParser, t = this.getValue, n = t(this.valueGetterParam), i = e ? this.valueParser(n) : null, a = 0; a < this.subCondList.length; a++)
        if (!this.subCondList[a].evaluate(e ? i : n))
          return !1;
      return !0;
    }, r;
  }()
);
function k0(r, e) {
  if (r === !0 || r === !1) {
    var t = new Y9();
    return t.value = r, t;
  }
  var n = "";
  return wS(r) || ( false && (0), de(n)), r.and ? gy("and", r, e) : r.or ? gy("or", r, e) : r.not ? j9(r, e) : J9(r, e);
}
function gy(r, e, t) {
  var n = e[r], i = "";
   false && (0), dist_F(n) || de(i), n.length || de(i);
  var a = r === "and" ? new X9() : new Z9();
  return a.children = dist_$(n, function(o) {
    return k0(o, t);
  }), a.children.length || de(i), a;
}
function j9(r, e) {
  var t = r.not, n = "";
   false && (0), wS(t) || de(n);
  var i = new q9();
  return i.child = k0(t, e), i.child || de(n), i;
}
function J9(r, e) {
  for (var t = "", n = e.prepareGetValue(r), i = [], a = we(r), o = r.parser, s = o ? A4(o) : null, l = 0; l < a.length; l++) {
    var u = a[l];
    if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
      var f = xt(py, u) ? py[u] : u, c = r[u], h = s ? s(c) : c, v = sD(f, h) || f === "reg" && new U9(h);
      v || ( false && (0), de(t)), i.push(v);
    }
  }
  i.length || ( false && (0), de(t));
  var d = new K9();
  return d.valueGetterParam = n, d.valueParser = s, d.getValue = e.getValue, d.subCondList = i, d;
}
function wS(r) {
  return dist_X(r) && !ct(r);
}
var Q9 = (
  /** @class */
  function() {
    function r(e, t) {
      this._cond = k0(e, t);
    }
    return r.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, r;
  }()
);
function ek(r, e) {
  return new Q9(r, e);
}
var tk = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(r) {
    for (var e = r.upstream, t, n = ek(r.config, {
      valueGetterAttrMap: dist_W({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        xt(s, "dimension") || ( false && (0), de(l));
        var f = e.getDimensionInfo(u);
        return f || ( false && (0), de(l)), {
          dimIdx: f.index
        };
      },
      getValue: function(s) {
        return e.retrieveValueFromItem(t, s.dimIdx);
      }
    }), i = [], a = 0, o = e.count(); a < o; a++)
      t = e.getRawDataItem(a), n.evaluate() && i.push(t);
    return {
      data: i
    };
  }
}, od = "";
 false && (0);
var rk = {
  type: "echarts:sort",
  transform: function(r) {
    var e = r.upstream, t = r.config, n = "", i = Ae(t);
    i.length || ( false && (0), de(n));
    var a = [];
    dist_M(i, function(f) {
      var c = f.dimension, h = f.order, v = f.parser, d = f.incomparable;
      if (c == null && ( false && (0), de(n)), h !== "asc" && h !== "desc" && ( false && (0), de(n)), d && d !== "min" && d !== "max") {
        var g = "";
         false && (0), de(g);
      }
      if (h !== "asc" && h !== "desc") {
        var p = "";
         false && (0), de(p);
      }
      var m = e.getDimensionInfo(c);
      m || ( false && (0), de(n));
      var y = v ? A4(v) : null;
      v && !y && ( false && (0), de(n)), a.push({
        dimIdx: m.index,
        parser: y,
        comparator: new L4(h, d)
      });
    });
    var o = e.sourceFormat;
    o !== vt && o !== Qt && ( false && (0), de(n));
    for (var s = [], l = 0, u = e.count(); l < u; l++)
      s.push(e.getRawDataItem(l));
    return s.sort(function(f, c) {
      for (var h = 0; h < a.length; h++) {
        var v = a[h], d = e.retrieveValueFromItem(f, v.dimIdx), g = e.retrieveValueFromItem(c, v.dimIdx);
        v.parser && (d = v.parser(d), g = v.parser(g));
        var p = v.comparator.evaluate(d, g);
        if (p !== 0)
          return p;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function nk(r) {
  r.registerTransform(tk), r.registerTransform(rk);
}
var ik = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.prototype.init = function(t, n, i) {
      r.prototype.init.call(this, t, n, i), this._sourceManager = new O4(this), p1(this);
    }, e.prototype.mergeOption = function(t, n) {
      r.prototype.mergeOption.call(this, t, n), p1(this);
    }, e.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, e.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, e.type = "dataset", e.defaultOption = {
      seriesLayoutBy: Er
    }, e;
  }(Se)
), ak = (
  /** @class */
  function(r) {
    dist_k(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.type = "dataset", e;
  }(Pt)
);
function ok(r) {
  r.registerComponentModel(ik), r.registerComponentView(ak);
}
var Sr = tn.CMD;
function ba(r, e) {
  return Math.abs(r - e) < 1e-5;
}
function sd(r) {
  var e = r.data, t = r.len(), n = [], i, a = 0, o = 0, s = 0, l = 0;
  function u(L, N) {
    i && i.length > 2 && n.push(i), i = [L, N];
  }
  function f(L, N, P, R) {
    ba(L, P) && ba(N, R) || i.push(L, N, P, R, P, R);
  }
  function c(L, N, P, R, z, O) {
    var B = Math.abs(N - L), H = Math.tan(B / 4) * 4 / 3, q = N < L ? -1 : 1, Q = Math.cos(L), le = Math.sin(L), ge = Math.cos(N), Re = Math.sin(N), Ce = Q * z + P, je = le * O + R, Je = ge * z + P, Fe = Re * O + R, Ee = z * H * q, J = O * H * q;
    i.push(Ce - Ee * le, je + J * Q, Je + Ee * Re, Fe - J * ge, Je, Fe);
  }
  for (var h, v, d, g, p = 0; p < t; ) {
    var m = e[p++], y = p === 1;
    switch (y && (a = e[p], o = e[p + 1], s = a, l = o, (m === Sr.L || m === Sr.C || m === Sr.Q) && (i = [s, l])), m) {
      case Sr.M:
        a = s = e[p++], o = l = e[p++], u(s, l);
        break;
      case Sr.L:
        h = e[p++], v = e[p++], f(a, o, h, v), a = h, o = v;
        break;
      case Sr.C:
        i.push(e[p++], e[p++], e[p++], e[p++], a = e[p++], o = e[p++]);
        break;
      case Sr.Q:
        h = e[p++], v = e[p++], d = e[p++], g = e[p++], i.push(a + 2 / 3 * (h - a), o + 2 / 3 * (v - o), d + 2 / 3 * (h - d), g + 2 / 3 * (v - g), d, g), a = d, o = g;
        break;
      case Sr.A:
        var _ = e[p++], S = e[p++], b = e[p++], w = e[p++], x = e[p++], C = e[p++] + x;
        p += 1;
        var T = !e[p++];
        h = Math.cos(x) * b + _, v = Math.sin(x) * w + S, y ? (s = h, l = v, u(s, l)) : f(a, o, h, v), a = Math.cos(C) * b + _, o = Math.sin(C) * w + S;
        for (var E = (T ? -1 : 1) * Math.PI / 2, D = x; T ? D > C : D < C; D += E) {
          var I = T ? Math.max(D + E, C) : Math.min(D + E, C);
          c(D, I, _, S, b, w);
        }
        break;
      case Sr.R:
        s = a = e[p++], l = o = e[p++], h = s + e[p++], v = l + e[p++], u(h, l), f(h, l, h, v), f(h, v, s, v), f(s, v, s, l), f(s, l, h, l);
        break;
      case Sr.Z:
        i && f(a, o, s, l), a = s, o = l;
        break;
    }
  }
  return i && i.length > 2 && n.push(i), n;
}
function ld(r, e, t, n, i, a, o, s, l, u) {
  if (ba(r, t) && ba(e, n) && ba(i, o) && ba(a, s)) {
    l.push(o, s);
    return;
  }
  var f = 2 / u, c = f * f, h = o - r, v = s - e, d = Math.sqrt(h * h + v * v);
  h /= d, v /= d;
  var g = t - r, p = n - e, m = i - o, y = a - s, _ = g * g + p * p, S = m * m + y * y;
  if (_ < c && S < c) {
    l.push(o, s);
    return;
  }
  var b = h * g + v * p, w = -h * m - v * y, x = _ - b * b, C = S - w * w;
  if (x < c && b >= 0 && C < c && w >= 0) {
    l.push(o, s);
    return;
  }
  var T = [], E = [];
  Hn(r, t, i, o, 0.5, T), Hn(e, n, a, s, 0.5, E), ld(T[0], E[0], T[1], E[1], T[2], E[2], T[3], E[3], l, u), ld(T[4], E[4], T[5], E[5], T[6], E[6], T[7], E[7], l, u);
}
function sk(r, e) {
  var t = sd(r), n = [];
  e = e || 1;
  for (var i = 0; i < t.length; i++) {
    var a = t[i], o = [], s = a[0], l = a[1];
    o.push(s, l);
    for (var u = 2; u < a.length; ) {
      var f = a[u++], c = a[u++], h = a[u++], v = a[u++], d = a[u++], g = a[u++];
      ld(s, l, f, c, h, v, d, g, o, e), s = d, l = g;
    }
    n.push(o);
  }
  return n;
}
function bS(r, e, t) {
  var n = r[e], i = r[1 - e], a = Math.abs(n / i), o = Math.ceil(Math.sqrt(a * t)), s = Math.floor(t / o);
  s === 0 && (s = 1, o = t);
  for (var l = [], u = 0; u < o; u++)
    l.push(s);
  var f = o * s, c = t - f;
  if (c > 0)
    for (var u = 0; u < c; u++)
      l[u % o] += 1;
  return l;
}
function my(r, e, t) {
  for (var n = r.r0, i = r.r, a = r.startAngle, o = r.endAngle, s = Math.abs(o - a), l = s * i, u = i - n, f = l > Math.abs(u), c = bS([l, u], f ? 0 : 1, e), h = (f ? s : u) / c.length, v = 0; v < c.length; v++)
    for (var d = (f ? u : s) / c[v], g = 0; g < c[v]; g++) {
      var p = {};
      f ? (p.startAngle = a + h * v, p.endAngle = a + h * (v + 1), p.r0 = n + d * g, p.r = n + d * (g + 1)) : (p.startAngle = a + d * g, p.endAngle = a + d * (g + 1), p.r0 = n + h * v, p.r = n + h * (v + 1)), p.clockwise = r.clockwise, p.cx = r.cx, p.cy = r.cy, t.push(p);
    }
}
function lk(r, e, t) {
  for (var n = r.width, i = r.height, a = n > i, o = bS([n, i], a ? 0 : 1, e), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", f = a ? "y" : "x", c = r[s] / o.length, h = 0; h < o.length; h++)
    for (var v = r[l] / o[h], d = 0; d < o[h]; d++) {
      var g = {};
      g[u] = h * c, g[f] = d * v, g[s] = c, g[l] = v, g.x += r.x, g.y += r.y, t.push(g);
    }
}
function yy(r, e, t, n) {
  return r * n - t * e;
}
function uk(r, e, t, n, i, a, o, s) {
  var l = t - r, u = n - e, f = o - i, c = s - a, h = yy(f, c, l, u);
  if (Math.abs(h) < 1e-6)
    return null;
  var v = r - i, d = e - a, g = yy(v, d, f, c) / h;
  return g < 0 || g > 1 ? null : new dist_K(g * l + r, g * u + e);
}
function fk(r, e, t) {
  var n = new dist_K();
  dist_K.sub(n, t, e), n.normalize();
  var i = new dist_K();
  dist_K.sub(i, r, e);
  var a = i.dot(n);
  return a;
}
function da(r, e) {
  var t = r[r.length - 1];
  t && t[0] === e[0] && t[1] === e[1] || r.push(e);
}
function ck(r, e, t) {
  for (var n = r.length, i = [], a = 0; a < n; a++) {
    var o = r[a], s = r[(a + 1) % n], l = uk(o[0], o[1], s[0], s[1], e.x, e.y, t.x, t.y);
    l && i.push({
      projPt: fk(l, e, t),
      pt: l,
      idx: a
    });
  }
  if (i.length < 2)
    return [{ points: r }, { points: r }];
  i.sort(function(p, m) {
    return p.projPt - m.projPt;
  });
  var u = i[0], f = i[i.length - 1];
  if (f.idx < u.idx) {
    var c = u;
    u = f, f = c;
  }
  for (var h = [u.pt.x, u.pt.y], v = [f.pt.x, f.pt.y], d = [h], g = [v], a = u.idx + 1; a <= f.idx; a++)
    da(d, r[a].slice());
  da(d, v), da(d, h);
  for (var a = f.idx + 1; a <= u.idx + n; a++)
    da(g, r[a % n].slice());
  return da(g, h), da(g, v), [{
    points: d
  }, {
    points: g
  }];
}
function _y(r) {
  var e = r.points, t = [], n = [];
  Nd(e, t, n);
  var i = new dist_ae(t[0], t[1], n[0] - t[0], n[1] - t[1]), a = i.width, o = i.height, s = i.x, l = i.y, u = new dist_K(), f = new dist_K();
  return a > o ? (u.x = f.x = s + a / 2, u.y = l, f.y = l + o) : (u.y = f.y = l + o / 2, u.x = s, f.x = s + a), ck(e, u, f);
}
function $u(r, e, t, n) {
  if (t === 1)
    n.push(e);
  else {
    var i = Math.floor(t / 2), a = r(e);
    $u(r, a[0], i, n), $u(r, a[1], t - i, n);
  }
  return n;
}
function hk(r, e) {
  for (var t = [], n = 0; n < e; n++)
    t.push(Fd(r));
  return t;
}
function vk(r, e) {
  e.setStyle(r.style), e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel;
}
function dk(r) {
  for (var e = [], t = 0; t < r.length; )
    e.push([r[t++], r[t++]]);
  return e;
}
function pk(r, e) {
  var t = [], n = r.shape, i;
  switch (r.type) {
    case "rect":
      lk(n, e, t), i = xe;
      break;
    case "sector":
      my(n, e, t), i = nn;
      break;
    case "circle":
      my({
        r0: 0,
        r: n.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: n.cx,
        cy: n.cy
      }, e, t), i = nn;
      break;
    default:
      var a = r.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = dist_$(sk(r.getUpdatedPathProxy(), o), function(m) {
        return dk(m);
      }), l = s.length;
      if (l === 0)
        $u(_y, {
          points: s[0]
        }, e, t);
      else if (l === e)
        for (var u = 0; u < l; u++)
          t.push({
            points: s[u]
          });
      else {
        var f = 0, c = dist_$(s, function(m) {
          var y = [], _ = [];
          Nd(m, y, _);
          var S = (_[1] - y[1]) * (_[0] - y[0]);
          return f += S, { poly: m, area: S };
        });
        c.sort(function(m, y) {
          return y.area - m.area;
        });
        for (var h = e, u = 0; u < l; u++) {
          var v = c[u];
          if (h <= 0)
            break;
          var d = u === l - 1 ? h : Math.ceil(v.area / f * e);
          d < 0 || ($u(_y, {
            points: v.poly
          }, d, t), h -= d);
        }
      }
      i = Un;
      break;
  }
  if (!i)
    return hk(r, e);
  for (var g = [], u = 0; u < t.length; u++) {
    var p = new i();
    p.setShape(t[u]), vk(r, p), g.push(p);
  }
  return g;
}
function gk(r, e) {
  var t = r.length, n = e.length;
  if (t === n)
    return [r, e];
  for (var i = [], a = [], o = t < n ? r : e, s = Math.min(t, n), l = Math.abs(n - t) / 6, u = (s - 2) / 6, f = Math.ceil(l / u) + 1, c = [o[0], o[1]], h = l, v = 2; v < s; ) {
    var d = o[v - 2], g = o[v - 1], p = o[v++], m = o[v++], y = o[v++], _ = o[v++], S = o[v++], b = o[v++];
    if (h <= 0) {
      c.push(p, m, y, _, S, b);
      continue;
    }
    for (var w = Math.min(h, f - 1) + 1, x = 1; x <= w; x++) {
      var C = x / w;
      Hn(d, p, y, S, C, i), Hn(g, m, _, b, C, a), d = i[3], g = a[3], c.push(i[1], a[1], i[2], a[2], d, g), p = i[5], m = a[5], y = i[6], _ = a[6];
    }
    h -= w - 1;
  }
  return o === r ? [c, e] : [r, c];
}
function Sy(r, e) {
  for (var t = r.length, n = r[t - 2], i = r[t - 1], a = [], o = 0; o < e.length; )
    a[o++] = n, a[o++] = i;
  return a;
}
function mk(r, e) {
  for (var t, n, i, a = [], o = [], s = 0; s < Math.max(r.length, e.length); s++) {
    var l = r[s], u = e[s], f = void 0, c = void 0;
    l ? u ? (t = gk(l, u), f = t[0], c = t[1], n = f, i = c) : (c = Sy(i || l, l), f = l) : (f = Sy(n || u, u), c = u), a.push(f), o.push(c);
  }
  return [a, o];
}
function wy(r) {
  for (var e = 0, t = 0, n = 0, i = r.length, a = 0, o = i - 2; a < i; o = a, a += 2) {
    var s = r[o], l = r[o + 1], u = r[a], f = r[a + 1], c = s * f - u * l;
    e += c, t += (s + u) * c, n += (l + f) * c;
  }
  return e === 0 ? [r[0] || 0, r[1] || 0] : [t / e / 3, n / e / 3, e];
}
function yk(r, e, t, n) {
  for (var i = (r.length - 2) / 6, a = 1 / 0, o = 0, s = r.length, l = s - 2, u = 0; u < i; u++) {
    for (var f = u * 6, c = 0, h = 0; h < s; h += 2) {
      var v = h === 0 ? f : (f + h - 2) % l + 2, d = r[v] - t[0], g = r[v + 1] - t[1], p = e[h] - n[0], m = e[h + 1] - n[1], y = p - d, _ = m - g;
      c += y * y + _ * _;
    }
    c < a && (a = c, o = u);
  }
  return o;
}
function _k(r) {
  for (var e = [], t = r.length, n = 0; n < t; n += 2)
    e[n] = r[t - n - 2], e[n + 1] = r[t - n - 1];
  return e;
}
function Sk(r, e, t, n) {
  for (var i = [], a, o = 0; o < r.length; o++) {
    var s = r[o], l = e[o], u = wy(s), f = wy(l);
    a == null && (a = u[2] < 0 != f[2] < 0);
    var c = [], h = [], v = 0, d = 1 / 0, g = [], p = s.length;
    a && (s = _k(s));
    for (var m = yk(s, l, u, f) * 6, y = p - 2, _ = 0; _ < y; _ += 2) {
      var S = (m + _) % y + 2;
      c[_ + 2] = s[S] - u[0], c[_ + 3] = s[S + 1] - u[1];
    }
    if (c[0] = s[m] - u[0], c[1] = s[m + 1] - u[1], t > 0)
      for (var b = n / t, w = -n / 2; w <= n / 2; w += b) {
        for (var x = Math.sin(w), C = Math.cos(w), T = 0, _ = 0; _ < s.length; _ += 2) {
          var E = c[_], D = c[_ + 1], I = l[_] - f[0], L = l[_ + 1] - f[1], N = I * C - L * x, P = I * x + L * C;
          g[_] = N, g[_ + 1] = P;
          var R = N - E, z = P - D;
          T += R * R + z * z;
        }
        if (T < d) {
          d = T, v = w;
          for (var O = 0; O < g.length; O++)
            h[O] = g[O];
        }
      }
    else
      for (var B = 0; B < p; B += 2)
        h[B] = l[B] - f[0], h[B + 1] = l[B + 1] - f[1];
    i.push({
      from: c,
      to: h,
      fromCp: u,
      toCp: f,
      rotation: -v
    });
  }
  return i;
}
function Wu(r) {
  return r.__isCombineMorphing;
}
var xS = "__mOriginal_";
function Uu(r, e, t) {
  var n = xS + e, i = r[n] || r[e];
  r[n] || (r[n] = r[e]);
  var a = t.replace, o = t.after, s = t.before;
  r[e] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), a ? u = a.apply(this, l) : u = i.apply(this, l), o && o.apply(this, l), u;
  };
}
function Ko(r, e) {
  var t = xS + e;
  r[t] && (r[e] = r[t], r[t] = null);
}
function by(r, e) {
  for (var t = 0; t < r.length; t++)
    for (var n = r[t], i = 0; i < n.length; ) {
      var a = n[i], o = n[i + 1];
      n[i++] = e[0] * a + e[2] * o + e[4], n[i++] = e[1] * a + e[3] * o + e[5];
    }
}
function CS(r, e) {
  var t = r.getUpdatedPathProxy(), n = e.getUpdatedPathProxy(), i = mk(sd(t), sd(n)), a = i[0], o = i[1], s = r.getComputedTransform(), l = e.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && by(a, s), l && by(o, l), Uu(e, "updateTransform", { replace: u }), e.transform = null;
  var f = Sk(a, o, 10, Math.PI), c = [];
  Uu(e, "buildPath", { replace: function(h) {
    for (var v = e.__morphT, d = 1 - v, g = [], p = 0; p < f.length; p++) {
      var m = f[p], y = m.from, _ = m.to, S = m.rotation * v, b = m.fromCp, w = m.toCp, x = Math.sin(S), C = Math.cos(S);
      Gl(g, b, w, v);
      for (var T = 0; T < y.length; T += 2) {
        var E = y[T], D = y[T + 1], I = _[T], L = _[T + 1], N = E * d + I * v, P = D * d + L * v;
        c[T] = N * C - P * x + g[0], c[T + 1] = N * x + P * C + g[1];
      }
      var R = c[0], z = c[1];
      h.moveTo(R, z);
      for (var T = 2; T < y.length; ) {
        var I = c[T++], L = c[T++], O = c[T++], B = c[T++], H = c[T++], q = c[T++];
        R === I && z === L && O === H && B === q ? h.lineTo(H, q) : h.bezierCurveTo(I, L, O, B, H, q), R = H, z = q;
      }
    }
  } });
}
function V0(r, e, t) {
  if (!r || !e)
    return e;
  var n = t.done, i = t.during;
  CS(r, e), e.__morphT = 0;
  function a() {
    Ko(e, "buildPath"), Ko(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape();
  }
  return e.animateTo({
    __morphT: 1
  }, dist_se({
    during: function(o) {
      e.dirtyShape(), i && i(o);
    },
    done: function() {
      a(), n && n();
    }
  }, t)), e;
}
function wk(r, e, t, n, i, a) {
  var o = 16;
  r = i === t ? 0 : Math.round(32767 * (r - t) / (i - t)), e = a === n ? 0 : Math.round(32767 * (e - n) / (a - n));
  for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
    var f = 0, c = 0;
    (r & u) > 0 && (f = 1), (e & u) > 0 && (c = 1), s += u * u * (3 * f ^ c), c === 0 && (f === 1 && (r = u - 1 - r, e = u - 1 - e), l = r, r = e, e = l);
  }
  return s;
}
function Yu(r) {
  var e = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0, a = dist_$(r, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), f = l.x + l.width / 2 + (u ? u[4] : 0), c = l.y + l.height / 2 + (u ? u[5] : 0);
    return e = Math.min(f, e), t = Math.min(c, t), n = Math.max(f, n), i = Math.max(c, i), [f, c];
  }), o = dist_$(a, function(s, l) {
    return {
      cp: s,
      z: wk(s[0], s[1], e, t, n, i),
      path: r[l]
    };
  });
  return o.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function TS(r) {
  return pk(r.path, r.count);
}
function ud() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function bk(r, e, t) {
  var n = [];
  function i(b) {
    for (var w = 0; w < b.length; w++) {
      var x = b[w];
      Wu(x) ? i(x.childrenRef()) : x instanceof fe && n.push(x);
    }
  }
  i(r);
  var a = n.length;
  if (!a)
    return ud();
  var o = t.dividePath || TS, s = o({
    path: e,
    count: a
  });
  if (s.length !== a)
    return ud();
  n = Yu(n), s = Yu(s);
  for (var l = t.done, u = t.during, f = t.individualDelay, c = new Fr(), h = 0; h < a; h++) {
    var v = n[h], d = s[h];
    d.parent = e, d.copyTransform(c), f || CS(v, d);
  }
  e.__isCombineMorphing = !0, e.childrenRef = function() {
    return s;
  };
  function g(b) {
    for (var w = 0; w < s.length; w++)
      s[w].addSelfToZr(b);
  }
  Uu(e, "addSelfToZr", {
    after: function(b) {
      g(b);
    }
  }), Uu(e, "removeSelfFromZr", {
    after: function(b) {
      for (var w = 0; w < s.length; w++)
        s[w].removeSelfFromZr(b);
    }
  });
  function p() {
    e.__isCombineMorphing = !1, e.__morphT = -1, e.childrenRef = null, Ko(e, "addSelfToZr"), Ko(e, "removeSelfFromZr");
  }
  var m = s.length;
  if (f)
    for (var y = m, _ = function() {
      y--, y === 0 && (p(), l && l());
    }, h = 0; h < m; h++) {
      var S = f ? dist_se({
        delay: (t.delay || 0) + f(h, m, n[h], s[h]),
        done: _
      }, t) : t;
      V0(n[h], s[h], S);
    }
  else
    e.__morphT = 0, e.animateTo({
      __morphT: 1
    }, dist_se({
      during: function(b) {
        for (var w = 0; w < m; w++) {
          var x = s[w];
          x.__morphT = e.__morphT, x.dirtyShape();
        }
        u && u(b);
      },
      done: function() {
        p();
        for (var b = 0; b < r.length; b++)
          Ko(r[b], "updateTransform");
        l && l();
      }
    }, t));
  return e.__zr && g(e.__zr), {
    fromIndividuals: n,
    toIndividuals: s,
    count: m
  };
}
function xk(r, e, t) {
  var n = e.length, i = [], a = t.dividePath || TS;
  function o(v) {
    for (var d = 0; d < v.length; d++) {
      var g = v[d];
      Wu(g) ? o(g.childrenRef()) : g instanceof fe && i.push(g);
    }
  }
  if (Wu(r)) {
    o(r.childrenRef());
    var s = i.length;
    if (s < n)
      for (var l = 0, u = s; u < n; u++)
        i.push(Fd(i[l++ % s]));
    i.length = n;
  } else {
    i = a({ path: r, count: n });
    for (var f = r.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(f);
    if (i.length !== n)
      return ud();
  }
  i = Yu(i), e = Yu(e);
  for (var c = t.individualDelay, u = 0; u < n; u++) {
    var h = c ? dist_se({
      delay: (t.delay || 0) + c(u, n, i[u], e[u])
    }, t) : t;
    V0(i[u], e[u], h);
  }
  return {
    fromIndividuals: i,
    toIndividuals: e,
    count: e.length
  };
}
function xy(r) {
  return dist_F(r[0]);
}
function Cy(r, e) {
  for (var t = [], n = r.length, i = 0; i < n; i++)
    t.push({
      one: r[i],
      many: []
    });
  for (var i = 0; i < e.length; i++) {
    var a = e[i].length, o = void 0;
    for (o = 0; o < a; o++)
      t[o % n].many.push(e[i][o]);
  }
  for (var s = 0, i = n - 1; i >= 0; i--)
    if (!t[i].many.length) {
      var l = t[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return t;
      var a = l.length, u = Math.ceil(a / 2);
      t[i].many = l.slice(u, a), t[s].many = l.slice(0, u), s++;
    }
  return t;
}
var Ck = {
  clone: function(r) {
    for (var e = [], t = 1 - Math.pow(1 - r.path.style.opacity, 1 / r.count), n = 0; n < r.count; n++) {
      var i = Fd(r.path);
      i.setStyle("opacity", t), e.push(i);
    }
    return e;
  },
  // Use the default divider
  split: null
};
function Bh(r, e, t, n, i, a) {
  if (!r.length || !e.length)
    return;
  var o = df("update", n, i);
  if (!(o && o.duration > 0))
    return;
  var s = n.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, o), u, f;
  xy(r) && (u = r, f = e), xy(e) && (u = e, f = r);
  function c(m, y, _, S, b) {
    var w = m.many, x = m.one;
    if (w.length === 1 && !b) {
      var C = y ? w[0] : x, T = y ? x : w[0];
      if (Wu(C))
        c({
          many: [C],
          one: T
        }, !0, _, S, !0);
      else {
        var E = s ? dist_se({
          delay: s(_, S)
        }, l) : l;
        V0(C, T, E), a(C, T, C, T, E);
      }
    } else
      for (var D = dist_se({
        dividePath: Ck[t],
        individualDelay: s && function(z, O, B, H) {
          return s(z + _, S);
        }
      }, l), I = y ? bk(w, x, D) : xk(x, w, D), L = I.fromIndividuals, N = I.toIndividuals, P = L.length, R = 0; R < P; R++) {
        var E = s ? dist_se({
          delay: s(R, P)
        }, l) : l;
        a(L[R], N[R], y ? w[R] : m.one, y ? m.one : w[R], E);
      }
  }
  for (var h = u ? u === r : r.length > e.length, v = u ? Cy(f, u) : Cy(h ? e : r, [h ? r : e]), d = 0, g = 0; g < v.length; g++)
    d += v[g].many.length;
  for (var p = 0, g = 0; g < v.length; g++)
    c(v[g], h, p, d), p += v[g].many.length;
}
function Si(r) {
  if (!r)
    return [];
  if (dist_F(r)) {
    for (var e = [], t = 0; t < r.length; t++)
      e.push(Si(r[t]));
    return e;
  }
  var n = [];
  return r.traverse(function(i) {
    i instanceof fe && !i.disableMorphing && !i.invisible && !i.ignore && n.push(i);
  }), n;
}
var MS = 1e4, Tk = 0, Ty = 1, My = 2, Mk = Me();
function Dk(r, e) {
  for (var t = r.dimensions, n = 0; n < t.length; n++) {
    var i = r.getDimensionInfo(t[n]);
    if (i && i.otherDims[e] === 0)
      return t[n];
  }
}
function Ek(r, e, t) {
  var n = r.getDimensionInfo(t), i = n && n.ordinalMeta;
  if (n) {
    var a = r.get(n.name, e);
    return i && i.categories[a] || a + "";
  }
}
function Dy(r, e, t, n) {
  var i = n ? "itemChildGroupId" : "itemGroupId", a = Dk(r, i);
  if (a) {
    var o = Ek(r, e, a);
    return o;
  }
  var s = r.getRawDataItem(e), l = n ? "childGroupId" : "groupId";
  if (s && s[l])
    return s[l] + "";
  if (!n)
    return t || r.getId(e);
}
function Ey(r) {
  var e = [];
  return dist_M(r, function(t) {
    var n = t.data, i = t.dataGroupId;
    if (n.count() > MS) {
       false && 0;
      return;
    }
    for (var a = n.getIndices(), o = 0; o < a.length; o++)
      e.push({
        data: n,
        groupId: Dy(n, o, i, !1),
        childGroupId: Dy(n, o, i, !0),
        divide: t.divide,
        dataIndex: o
      });
  }), e;
}
function Fh(r, e, t) {
  r.traverse(function(n) {
    n instanceof fe && Ze(n, {
      style: {
        opacity: 0
      }
    }, e, {
      dataIndex: t,
      isFrom: !0
    });
  });
}
function zh(r) {
  if (r.parent) {
    var e = r.getComputedTransform();
    r.setLocalTransform(e), r.parent.remove(r);
  }
}
function pa(r) {
  r.stopAnimation(), r.isGroup && r.traverse(function(e) {
    e.stopAnimation();
  });
}
function Ak(r, e, t) {
  var n = df("update", t, e);
  n && r.traverse(function(i) {
    if (i instanceof Wn) {
      var a = D8(i);
      a && i.animateFrom({
        style: a
      }, n);
    }
  });
}
function Ik(r, e) {
  var t = r.length;
  if (t !== e.length)
    return !1;
  for (var n = 0; n < t; n++) {
    var i = r[n], a = e[n];
    if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex))
      return !1;
  }
  return !0;
}
function DS(r, e, t) {
  var n = Ey(r), i = Ey(e);
  function a(_, S, b, w, x) {
    (b || _) && S.animateFrom({
      style: b && b !== _ ? dist_V(dist_V({}, b.style), _.style) : _.style
    }, x);
  }
  var o = !1, s = Tk, l = dist_W(), u = dist_W();
  n.forEach(function(_) {
    _.groupId && l.set(_.groupId, !0), _.childGroupId && u.set(_.childGroupId, !0);
  });
  for (var f = 0; f < i.length; f++) {
    var c = i[f].groupId;
    if (u.get(c)) {
      s = Ty;
      break;
    }
    var h = i[f].childGroupId;
    if (h && l.get(h)) {
      s = My;
      break;
    }
  }
  function v(_, S) {
    return function(b) {
      var w = b.data, x = b.dataIndex;
      return S ? w.getId(x) : _ ? s === Ty ? b.childGroupId : b.groupId : s === My ? b.childGroupId : b.groupId;
    };
  }
  var d = Ik(n, i), g = {};
  if (!d)
    for (var f = 0; f < i.length; f++) {
      var p = i[f], m = p.data.getItemGraphicEl(p.dataIndex);
      m && (g[m.id] = !0);
    }
  function y(_, S) {
    var b = n[S], w = i[_], x = w.data.hostModel, C = b.data.getItemGraphicEl(b.dataIndex), T = w.data.getItemGraphicEl(w.dataIndex);
    if (C === T) {
      T && Ak(T, w.dataIndex, x);
      return;
    }
    // We can't use the elements that already being morphed
    C && g[C.id] || T && (pa(T), C ? (pa(C), zh(C), o = !0, Bh(Si(C), Si(T), w.divide, x, _, a)) : Fh(T, x, _));
  }
  new Fv(n, i, v(!0, d), v(!1, d), null, "multiple").update(y).updateManyToOne(function(_, S) {
    var b = i[_], w = b.data, x = w.hostModel, C = w.getItemGraphicEl(b.dataIndex), T = ke(dist_$(S, function(E) {
      return n[E].data.getItemGraphicEl(n[E].dataIndex);
    }), function(E) {
      return E && E !== C && !g[E.id];
    });
    C && (pa(C), T.length ? (dist_M(T, function(E) {
      pa(E), zh(E);
    }), o = !0, Bh(Si(T), Si(C), b.divide, x, _, a)) : Fh(C, x, b.dataIndex));
  }).updateOneToMany(function(_, S) {
    var b = n[S], w = b.data.getItemGraphicEl(b.dataIndex);
    if (!(w && g[w.id])) {
      var x = ke(dist_$(_, function(T) {
        return i[T].data.getItemGraphicEl(i[T].dataIndex);
      }), function(T) {
        return T && T !== w;
      }), C = i[_[0]].data.hostModel;
      x.length && (dist_M(x, function(T) {
        return pa(T);
      }), w ? (pa(w), zh(w), o = !0, Bh(
        Si(w),
        Si(x),
        b.divide,
        // Use divide on old.
        C,
        _[0],
        a
      )) : dist_M(x, function(T) {
        return Fh(T, C, _[0]);
      }));
    }
  }).updateManyToMany(function(_, S) {
    new Fv(S, _, function(b) {
      return n[b].data.getId(n[b].dataIndex);
    }, function(b) {
      return i[b].data.getId(i[b].dataIndex);
    }).update(function(b, w) {
      y(_[b], S[w]);
    }).execute();
  }).execute(), o && dist_M(e, function(_) {
    var S = _.data, b = S.hostModel, w = b && t.getViewOfSeriesModel(b), x = df("update", b, 0);
    w && b.isAnimationEnabled() && x && x.duration > 0 && w.group.traverse(function(C) {
      C instanceof fe && !C.animators.length && C.animateFrom({
        style: {
          opacity: 0
        }
      }, x);
    });
  });
}
function Ay(r) {
  var e = r.getModel("universalTransition").get("seriesKey");
  return e || r.id;
}
function Iy(r) {
  return dist_F(r) ? r.sort().join(",") : r;
}
function Dn(r) {
  if (r.hostModel)
    return r.hostModel.getModel("universalTransition").get("divideShape");
}
function Lk(r, e) {
  var t = dist_W(), n = dist_W(), i = dist_W();
  dist_M(r.oldSeries, function(o, s) {
    var l = r.oldDataGroupIds[s], u = r.oldData[s], f = Ay(o), c = Iy(f);
    n.set(c, {
      dataGroupId: l,
      data: u
    }), dist_F(f) && dist_M(f, function(h) {
      i.set(h, {
        key: c,
        dataGroupId: l,
        data: u
      });
    });
  });
  function a(o) {
    t.get(o) && Ve("Duplicated seriesKey in universalTransition " + o);
  }
  return dist_M(e.updatedSeries, function(o) {
    if (o.isUniversalTransitionEnabled() && o.isAnimationEnabled()) {
      var s = o.get("dataGroupId"), l = o.getData(), u = Ay(o), f = Iy(u), c = n.get(f);
      if (c)
         false && 0, t.set(f, {
          oldSeries: [{
            dataGroupId: c.dataGroupId,
            divide: Dn(c.data),
            data: c.data
          }],
          newSeries: [{
            dataGroupId: s,
            divide: Dn(l),
            data: l
          }]
        });
      else if (dist_F(u)) {
         false && 0;
        var h = [];
        dist_M(u, function(g) {
          var p = n.get(g);
          p.data && h.push({
            dataGroupId: p.dataGroupId,
            divide: Dn(p.data),
            data: p.data
          });
        }), h.length && t.set(f, {
          oldSeries: h,
          newSeries: [{
            dataGroupId: s,
            data: l,
            divide: Dn(l)
          }]
        });
      } else {
        var v = i.get(u);
        if (v) {
          var d = t.get(v.key);
          d || (d = {
            oldSeries: [{
              dataGroupId: v.dataGroupId,
              data: v.data,
              divide: Dn(v.data)
            }],
            newSeries: []
          }, t.set(v.key, d)), d.newSeries.push({
            dataGroupId: s,
            data: l,
            divide: Dn(l)
          });
        }
      }
    }
  }), t;
}
function Ly(r, e) {
  for (var t = 0; t < r.length; t++) {
    var n = e.seriesIndex != null && e.seriesIndex === r[t].seriesIndex || e.seriesId != null && e.seriesId === r[t].id;
    if (n)
      return t;
  }
}
function Nk(r, e, t, n) {
  var i = [], a = [];
  dist_M(Ae(r.from), function(o) {
    var s = Ly(e.oldSeries, o);
    s >= 0 && i.push({
      dataGroupId: e.oldDataGroupIds[s],
      data: e.oldData[s],
      // TODO can specify divideShape in transition.
      divide: Dn(e.oldData[s]),
      groupIdDim: o.dimension
    });
  }), dist_M(Ae(r.to), function(o) {
    var s = Ly(t.updatedSeries, o);
    if (s >= 0) {
      var l = t.updatedSeries[s].getData();
      a.push({
        dataGroupId: e.oldDataGroupIds[s],
        data: l,
        divide: Dn(l),
        groupIdDim: o.dimension
      });
    }
  }), i.length > 0 && a.length > 0 && DS(i, a, n);
}
function Pk(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(e, t, n) {
    dist_M(Ae(n.seriesTransition), function(i) {
      dist_M(Ae(i.to), function(a) {
        for (var o = n.updatedSeries, s = 0; s < o.length; s++)
          (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][Jl] = !0);
      });
    });
  }), r.registerUpdateLifecycle("series:transition", function(e, t, n) {
    var i = Mk(t);
    if (i.oldSeries && n.updatedSeries && n.optionChanged) {
      var a = n.seriesTransition;
      if (a)
        dist_M(Ae(a), function(v) {
          Nk(v, i, n, t);
        });
      else {
        var o = Lk(i, n);
        dist_M(o.keys(), function(v) {
          var d = o.get(v);
          DS(d.oldSeries, d.newSeries, t);
        });
      }
      dist_M(n.updatedSeries, function(v) {
        v[Jl] && (v[Jl] = !1);
      });
    }
    for (var s = e.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], f = i.oldData = [], c = 0; c < s.length; c++) {
      var h = s[c].getData();
      h.count() < MS && (l.push(s[c]), u.push(s[c].get("dataGroupId")), f.push(h));
    }
  });
}
function Ny(r, e, t) {
  var n = Ha.createCanvas(), i = e.getWidth(), a = e.getHeight(), o = n.style;
  return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = i + "px", o.height = a + "px", n.setAttribute("data-zr-dom-id", r)), n.width = i * t, n.height = a * t, n;
}
var Rk = function(r) {
  dist_k(e, r);
  function e(t, n, i) {
    var a = r.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var o;
    i = i || hu, typeof t == "string" ? o = Ny(t, n, i) : dist_X(t) && (o = t, t = o.id), a.id = t, a.dom = o;
    var s = o.style;
    return s && (b3(o), o.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = n, a.dpr = i, a;
  }
  return e.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, e.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, e.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, e.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, e.prototype.createBackBuffer = function() {
    var t = this.dpr;
    this.domBack = Ny("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t);
  }, e.prototype.createRepaintRects = function(t, n, i, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var o = [], s = this.maxRepaintRectCount, l = !1, u = new dist_ae(0, 0, 0, 0);
    function f(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (o.length === 0) {
          var _ = new dist_ae(0, 0, 0, 0);
          _.copy(y), o.push(_);
        } else {
          for (var S = !1, b = 1 / 0, w = 0, x = 0; x < o.length; ++x) {
            var C = o[x];
            if (C.intersect(y)) {
              var T = new dist_ae(0, 0, 0, 0);
              T.copy(C), T.union(y), o[x] = T, S = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(C);
              var E = y.width * y.height, D = C.width * C.height, I = u.width * u.height, L = I - E - D;
              L < b && (b = L, w = x);
            }
          }
          if (l && (o[w].union(y), S = !0), !S) {
            var _ = new dist_ae(0, 0, 0, 0);
            _.copy(y), o.push(_);
          }
          l || (l = o.length >= s);
        }
    }
    for (var c = this.__startIndex; c < this.__endIndex; ++c) {
      var h = t[c];
      if (h) {
        var v = h.shouldBePainted(i, a, !0, !0), d = h.__isRendered && (h.__dirty & Et || !v) ? h.getPrevPaintRect() : null;
        d && f(d);
        var g = v && (h.__dirty & Et || !h.__isRendered) ? h.getPaintRect() : null;
        g && f(g);
      }
    }
    for (var c = this.__prevStartIndex; c < this.__prevEndIndex; ++c) {
      var h = n[c], v = h && h.shouldBePainted(i, a, !0, !0);
      if (h && (!v || !h.__zr) && h.__isRendered) {
        var d = h.getPrevPaintRect();
        d && f(d);
      }
    }
    var p;
    do {
      p = !1;
      for (var c = 0; c < o.length; ) {
        if (o[c].isZero()) {
          o.splice(c, 1);
          continue;
        }
        for (var m = c + 1; m < o.length; )
          o[c].intersect(o[m]) ? (p = !0, o[c].union(o[m]), o.splice(m, 1)) : m++;
        c++;
      }
    } while (p);
    return this._paintRects = o, o;
  }, e.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, e.prototype.resize = function(t, n) {
    var i = this.dpr, a = this.dom, o = a.style, s = this.domBack;
    o && (o.width = t + "px", o.height = n + "px"), a.width = t * i, a.height = n * i, s && (s.width = t * i, s.height = n * i, i !== 1 && this.ctxBack.scale(i, i));
  }, e.prototype.clear = function(t, n, i) {
    var a = this.dom, o = this.ctx, s = a.width, l = a.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !t, f = this.lastFrameAlpha, c = this.dpr, h = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / c, l / c));
    var v = this.domBack;
    function d(g, p, m, y) {
      if (o.clearRect(g, p, m, y), n && n !== "transparent") {
        var _ = void 0;
        if (ef(n)) {
          var S = n.global || n.__width === m && n.__height === y;
          _ = S && n.__canvasGradient || Rv(o, n, {
            x: 0,
            y: 0,
            width: m,
            height: y
          }), n.__canvasGradient = _, n.__width = m, n.__height = y;
        } else
          Xx(n) && (n.scaleX = n.scaleX || c, n.scaleY = n.scaleY || c, _ = Ov(o, n, {
            dirty: function() {
              h.setUnpainted(), h.painter.refresh();
            }
          }));
        o.save(), o.fillStyle = _ || n, o.fillRect(g, p, m, y), o.restore();
      }
      u && (o.save(), o.globalAlpha = f, o.drawImage(v, g, p, m, y), o.restore());
    }
    !i || u ? d(0, 0, s, l) : i.length && dist_M(i, function(g) {
      d(g.x * c, g.y * c, g.width * c, g.height * c);
    });
  }, e;
}(vr);
const Gh = Rk;
var Py = 1e5, gi = 314159, kl = 0.01, Ok = 1e-3;
function kk(r) {
  return r ? r.__builtin__ ? !0 : !(typeof r.resize != "function" || typeof r.refresh != "function") : !1;
}
function Vk(r, e) {
  var t = document.createElement("div");
  return t.style.cssText = [
    "position:relative",
    "width:" + r + "px",
    "height:" + e + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", t;
}
var Bk = function() {
  function r(e, t, n, i) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = dist_V({}, n || {}), this.dpr = n.devicePixelRatio || hu, this._singleCanvas = a, this.root = e;
    var o = e.style;
    o && (b3(e), e.innerHTML = ""), this.storage = t;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var f = e, c = f.width, h = f.height;
      n.width != null && (c = n.width), n.height != null && (h = n.height), this.dpr = n.devicePixelRatio || 1, f.width = c * this.dpr, f.height = h * this.dpr, this._width = c, this._height = h;
      var v = new Gh(f, this, this.dpr);
      v.__builtin__ = !0, v.initContext(), l[gi] = v, v.zlevel = gi, s.push(gi), this._domRoot = e;
    } else {
      this._width = pl(e, 0, n), this._height = pl(e, 1, n);
      var u = this._domRoot = Vk(this._width, this._height);
      e.appendChild(u);
    }
  }
  return r.prototype.getType = function() {
    return "canvas";
  }, r.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, r.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, r.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, r.prototype.refresh = function(e) {
    var t = this.storage.getDisplayList(!0), n = this._prevDisplayList, i = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(t, n, e, this._redrawId);
    for (var a = 0; a < i.length; a++) {
      var o = i[a], s = this._layers[o];
      if (!s.__builtin__ && s.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this;
  }, r.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, r.prototype._paintHoverList = function(e) {
    var t = e.length, n = this._hoverlayer;
    if (n && n.clear(), !!t) {
      for (var i = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, o = 0; o < t; o++) {
        var s = e[o];
        s.__inHover && (n || (n = this._hoverlayer = this.getLayer(Py)), a || (a = n.ctx, a.save()), Di(a, s, i, o === t - 1));
      }
      a && a.restore();
    }
  }, r.prototype.getHoverLayer = function() {
    return this.getLayer(Py);
  }, r.prototype.paintOne = function(e, t) {
    n6(e, t);
  }, r.prototype._paintList = function(e, t, n, i) {
    if (this._redrawId === i) {
      n = n || !1, this._updateLayerStatus(e);
      var a = this._doPaintList(e, t, n), o = a.finished, s = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), o)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        nv(function() {
          l._paintList(e, t, n, i);
        });
      }
    }
  }, r.prototype._compositeManually = function() {
    var e = this.getLayer(gi).ctx, t = this._domRoot.width, n = this._domRoot.height;
    e.clearRect(0, 0, t, n), this.eachBuiltinLayer(function(i) {
      i.virtual && e.drawImage(i.dom, 0, 0, t, n);
    });
  }, r.prototype._doPaintList = function(e, t, n) {
    for (var i = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
    }
    for (var f = !0, c = !1, h = function(g) {
      var p = a[g], m = p.ctx, y = o && p.createRepaintRects(e, t, v._width, v._height), _ = n ? p.__startIndex : p.__drawIndex, S = !n && p.incremental && Date.now, b = S && Date.now(), w = p.zlevel === v._zlevelList[0] ? v._backgroundColor : null;
      if (p.__startIndex === p.__endIndex)
        p.clear(!1, w, y);
      else if (_ === p.__startIndex) {
        var x = e[_];
        (!x.incremental || !x.notClear || n) && p.clear(!1, w, y);
      }
      _ === -1 && (_ = p.__startIndex);
      var C, T = function(L) {
        var N = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: i._width,
          viewHeight: i._height
        };
        for (C = _; C < p.__endIndex; C++) {
          var P = e[C];
          if (P.__inHover && (c = !0), i._doPaintEl(P, p, o, L, N, C === p.__endIndex - 1), S) {
            var R = Date.now() - b;
            if (R > 15)
              break;
          }
        }
        N.prevElClipPaths && m.restore();
      };
      if (y)
        if (y.length === 0)
          C = p.__endIndex;
        else
          for (var E = v.dpr, D = 0; D < y.length; ++D) {
            var I = y[D];
            m.save(), m.beginPath(), m.rect(I.x * E, I.y * E, I.width * E, I.height * E), m.clip(), T(I), m.restore();
          }
      else
        m.save(), T(), m.restore();
      p.__drawIndex = C, p.__drawIndex < p.__endIndex && (f = !1);
    }, v = this, d = 0; d < a.length; d++)
      h(d);
    return dist_ee.wxa && dist_M(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: f,
      needsRefreshHover: c
    };
  }, r.prototype._doPaintEl = function(e, t, n, i, a, o) {
    var s = t.ctx;
    if (n) {
      var l = e.getPaintRect();
      (!i || l && l.intersect(i)) && (Di(s, e, a, o), e.setPrevPaintRect(l));
    } else
      Di(s, e, a, o);
  }, r.prototype.getLayer = function(e, t) {
    this._singleCanvas && !this._needsManuallyCompositing && (e = gi);
    var n = this._layers[e];
    return n || (n = new Gh("zr_" + e, this, this.dpr), n.zlevel = e, n.__builtin__ = !0, this._layerConfig[e] ? he(n, this._layerConfig[e], !0) : this._layerConfig[e - kl] && he(n, this._layerConfig[e - kl], !0), t && (n.virtual = t), this.insertLayer(e, n), n.initContext()), n;
  }, r.prototype.insertLayer = function(e, t) {
    var n = this._layers, i = this._zlevelList, a = i.length, o = this._domRoot, s = null, l = -1;
    if (n[e]) {
       false && 0;
      return;
    }
    if (!kk(t)) {
       false && 0;
      return;
    }
    if (a > 0 && e > i[0]) {
      for (l = 0; l < a - 1 && !(i[l] < e && i[l + 1] > e); l++)
        ;
      s = n[i[l]];
    }
    if (i.splice(l + 1, 0, e), n[e] = t, !t.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? o.insertBefore(t.dom, u.nextSibling) : o.appendChild(t.dom);
      } else
        o.firstChild ? o.insertBefore(t.dom, o.firstChild) : o.appendChild(t.dom);
    t.painter || (t.painter = this);
  }, r.prototype.eachLayer = function(e, t) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i];
      e.call(t, this._layers[a], a);
    }
  }, r.prototype.eachBuiltinLayer = function(e, t) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i], o = this._layers[a];
      o.__builtin__ && e.call(t, o, a);
    }
  }, r.prototype.eachOtherLayer = function(e, t) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i], o = this._layers[a];
      o.__builtin__ || e.call(t, o, a);
    }
  }, r.prototype.getLayers = function() {
    return this._layers;
  }, r.prototype._updateLayerStatus = function(e) {
    this.eachBuiltinLayer(function(c, h) {
      c.__dirty = c.__used = !1;
    });
    function t(c) {
      a && (a.__endIndex !== c && (a.__dirty = !0), a.__endIndex = c);
    }
    if (this._singleCanvas)
      for (var n = 1; n < e.length; n++) {
        var i = e[n];
        if (i.zlevel !== e[n - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, o = 0, s, l;
    for (l = 0; l < e.length; l++) {
      var i = e[l], u = i.zlevel, f = void 0;
      s !== u && (s = u, o = 0), i.incremental ? (f = this.getLayer(u + Ok, this._needsManuallyCompositing), f.incremental = !0, o = 1) : f = this.getLayer(u + (o > 0 ? kl : 0), this._needsManuallyCompositing), f.__builtin__ || Ei("ZLevel " + u + " has been used by unkown layer " + f.id), f !== a && (f.__used = !0, f.__startIndex !== l && (f.__dirty = !0), f.__startIndex = l, f.incremental ? f.__drawIndex = -1 : f.__drawIndex = l, t(l), a = f), i.__dirty & Et && !i.__inHover && (f.__dirty = !0, f.incremental && f.__drawIndex < 0 && (f.__drawIndex = l));
    }
    t(l), this.eachBuiltinLayer(function(c, h) {
      !c.__used && c.getElementCount() > 0 && (c.__dirty = !0, c.__startIndex = c.__endIndex = c.__drawIndex = 0), c.__dirty && c.__drawIndex < 0 && (c.__drawIndex = c.__startIndex);
    });
  }, r.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, r.prototype._clearLayer = function(e) {
    e.clear();
  }, r.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e, dist_M(this._layers, function(t) {
      t.setUnpainted();
    });
  }, r.prototype.configLayer = function(e, t) {
    if (t) {
      var n = this._layerConfig;
      n[e] ? he(n[e], t, !0) : n[e] = t;
      for (var i = 0; i < this._zlevelList.length; i++) {
        var a = this._zlevelList[i];
        if (a === e || a === e + kl) {
          var o = this._layers[a];
          he(o, n[e], !0);
        }
      }
    }
  }, r.prototype.delLayer = function(e) {
    var t = this._layers, n = this._zlevelList, i = t[e];
    i && (i.dom.parentNode.removeChild(i.dom), delete t[e], n.splice(ye(n, e), 1));
  }, r.prototype.resize = function(e, t) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var i = this._opts, a = this.root;
      if (e != null && (i.width = e), t != null && (i.height = t), e = pl(a, 0, i), t = pl(a, 1, i), n.style.display = "", this._width !== e || t !== this._height) {
        n.style.width = e + "px", n.style.height = t + "px";
        for (var o in this._layers)
          this._layers.hasOwnProperty(o) && this._layers[o].resize(e, t);
        this.refresh(!0);
      }
      this._width = e, this._height = t;
    } else {
      if (e == null || t == null)
        return;
      this._width = e, this._height = t, this.getLayer(gi).resize(e, t);
    }
    return this;
  }, r.prototype.clearLayer = function(e) {
    var t = this._layers[e];
    t && t.clear();
  }, r.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, r.prototype.getRenderedCanvas = function(e) {
    if (e = e || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[gi].dom;
    var t = new Gh("image", this, e.pixelRatio || this.dpr);
    t.initContext(), t.clear(!1, e.backgroundColor || this._backgroundColor);
    var n = t.ctx;
    if (e.pixelRatio <= this.dpr) {
      this.refresh();
      var i = t.dom.width, a = t.dom.height;
      this.eachLayer(function(c) {
        c.__builtin__ ? n.drawImage(c.dom, 0, 0, i, a) : c.renderToCanvas && (n.save(), c.renderToCanvas(n), n.restore());
      });
    } else
      for (var o = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var f = s[l];
        Di(n, f, o, l === u - 1);
      }
    return t.dom;
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r;
}();
const Fk = Bk;
function zk(r) {
  r.registerPainter("canvas", Fk);
}
Rt([
  jP,
  PO,
  EO,
  KR,
  ok,
  nk,
  TL,
  FL,
  FI,
  Pk,
  zk,
  XO,
  iR,
  dP,
  lL,
  wR,
  W9,
  m9
]);
function GB(r) {
  const { className: e, style: t, options: n, initCharFn: i } = r;
  let a, o;
  return ws(() => {
    try {
      a && (o = y6(a), o || (o = jE(a)), i && i(o), o.setOption(n), window.addEventListener("resize", function() {
        o.resize();
      }));
    } catch {
    }
  }, [n]), A.createElement("div", { className: dist_Y(e), style: t, ref: (s) => a = s });
}
const Ry = "position: absolute;transform-origin: 0 0; overflow: visible;width: 100%;";
function ga(r, e, t = 1) {
  return Math.abs(r - e) < t;
}
function Oy(r) {
  const { name: e, nodes: t = [] } = r, n = "au-flow-chart-" + e, i = document.querySelector(`.${n}`);
  if (dist_ue(i) || !wt(t))
    return;
  const a = i.getBoundingClientRect(), { x: o, y: s } = a, l = {}, u = [];
  t.forEach((c) => {
    const { id: h, link: v } = c;
    if (dist_ue(h))
      return;
    lr(v) && u.push({ form: h, to: v }), wt(v) && v.forEach((p) => u.push({ form: h, to: p }));
    const d = document.querySelector(`.${n}>.au-flow-chart-item-${h}`);
    if (dist_ue(d))
      return;
    const g = d.getBoundingClientRect();
    l[h] = g;
  });
  function f(c, h) {
    const { left: v, right: d, x: g, y: p, width: m, height: y } = l[c] || {}, { left: _, right: S, x: b, y: w, width: x, height: C } = l[h] || {};
    if (Qo(v) || Qo(_))
      return;
    const T = `.arrow-${e}-${c}-${h}`, E = document.querySelector(T), D = document.querySelector(`${T}>svg`), I = document.querySelector(`${T}>svg>path`);
    if (!(!E || !D || !I)) {
      if (Math.abs(m - x) > 1) {
        if ((d > S || ga(d, S)) && p > w && Math.abs(g - b) > 1) {
          let L = g - o - 6 + m / 2 - x / 2;
          const N = p - s, P = p - w - C, R = 12;
          m !== x && m > x && (L = b - o - 6 + x / 2);
          const z = `position: absolute;transform-origin: 0 0;width:${P}px;height: ${R}px;left:${L}px;top:${N}px;transform: rotate(-90deg);`;
          E.setAttribute("style", z), D.setAttribute("viewBox", `0 0 ${P} ${R}`), I.setAttribute("d", `M0,6 ${P},${R / 2}`);
          return;
        }
        if (p < w && g !== b && (d > S || ga(d, S))) {
          let L = g - o + 6 + m / 2;
          const N = p - s + y, P = w - p - y, R = 12;
          m !== x && m > x && (L = b - o + 6 + x / 2);
          const z = `position: absolute;transform-origin: 0 0;width:${P}px;height: ${R}px;left:${L}px;top:${N}px;transform: rotate(90deg);`;
          E.setAttribute("style", z), D.setAttribute("viewBox", `0 0 ${P} ${R}`), I.setAttribute("d", `M0,6 ${P},${R / 2}`);
          return;
        }
      }
      if (ga(g, b) && p > w) {
        let L = g - o - 6 + m / 2;
        const N = p - s, P = p - w - C, R = 12;
        m !== x && m > x && (L = b - o - 6 + x / 2);
        const z = `position: absolute;transform-origin: 0 0;width:${P}px;height: ${R}px;left:${L}px;top:${N}px;transform: rotate(-90deg);`;
        E.setAttribute("style", z), D.setAttribute("viewBox", `0 0 ${P} ${R}`), I.setAttribute("d", `M0,6 ${P},${R / 2}`);
        return;
      }
      if (g < b && p > w) {
        const L = d - o, N = p - s - 6, R = Ry + `height: 12px;left:${L}px;top:${N}px;transform: rotateX(180deg);`;
        E.setAttribute("style", R), D.removeAttribute("viewBox"), I.setAttribute("d", `M0,-6 ${_ - d},${p - w - C - 6}`);
        return;
      }
      if (ga(p, w) && g < b) {
        const L = d - o, N = p + y / 2 - 6 - s, P = _ - d, R = 12, z = `position: absolute;transform-origin: 0 0;width:${P}px;height: ${R}px;left:${L}px;top:${N}px;`;
        E.setAttribute("style", z), D.setAttribute("viewBox", `0 0 ${P} ${R}`), I.setAttribute("d", `M0,6 ${P},${R / 2}`);
        return;
      }
      if (g < b && p < w) {
        const L = g - o + m, N = p - s + y - 6, R = `position: absolute;transform-origin: 0 0;width: 100%;height: 12px;left:${L}px;top:${N}px;`;
        E.setAttribute("style", R), D.removeAttribute("viewBox"), I.setAttribute("d", `M0,6 ${_ - d},${w - p - y + 6}`);
        return;
      }
      if (ga(g, b) && p < w) {
        let L = g - o + 6 + m / 2;
        const N = p - s + y, P = w - p - y, R = 12;
        m !== x && m > x && (L = b - o + 6 + x / 2);
        const z = `position: absolute;transform-origin: 0 0;width:${P}px;height: ${R}px;left:${L}px;top:${N}px;transform: rotate(90deg);`;
        E.setAttribute("style", z), D.setAttribute("viewBox", `0 0 ${P} ${R}`), I.setAttribute("d", `M0,6 ${P},${R / 2}`);
        return;
      }
      if (g > b && p < w) {
        const L = g - o, N = p - s + y - 6, R = `position: absolute;transform-origin: 0 0;width: 100%;height: 12px;left:${L}px;top:${N}px;`;
        E.setAttribute("style", R), D.removeAttribute("viewBox"), I.setAttribute("d", `M0,6 ${S - v},${w - p - y + 6}`);
        return;
      }
      if (ga(p, w) && g > b) {
        const L = g - o, N = p + y / 2 + 6 - s, P = v - S, R = 12, z = `position: absolute;transform-origin: 0 0;width:${P}px;height: ${R}px;left:${L}px;top:${N}px;transform: rotate(180deg);`;
        E.setAttribute("style", z), D.setAttribute("viewBox", `0 0 ${P} ${R}`), I.setAttribute("d", `M0,6 ${P},${R / 2}`);
        return;
      }
      if (g > b && p > w) {
        const L = v - o, N = p - s - 6, R = Ry + `height: 12px;left:${L}px;top:${N}px;transform: rotateX(180deg);`;
        E.setAttribute("style", R), D.removeAttribute("viewBox"), I.setAttribute("d", `M0,-6 ${_ - v + x},${p - w - C - 6}`);
        return;
      }
    }
  }
  u.forEach((c) => {
    const { form: h, to: v } = c;
    f(h, v);
  });
}
function ky(r) {
  const { name: e, nodeWidth: t, dottedProps: n = { strokeDasharray: "5 5", strokeDashoffset: "5" }, nodes: i = [], count: a = 4, className: o, columnGap: s = 80, rowGap: l = 30, style: u = {}, ...f } = r, h = {
    gridTemplateColumns: (() => {
      let d = "auto";
      return lr(t) && (d = t, t === "auto" && (d = "auto"), t === "equal" && (d = "1fr")), it(t) && (d = t + "px"), new Array(a).fill(d).join(" ");
    })(),
    gap: `0 ${s}px`,
    ...u
  }, v = "au-flow-chart-" + e;
  return ws(() => {
    Oy(r);
    const d = document.querySelector(`.${v}`), g = new ResizeObserver(vd(() => {
      Oy(r);
    }, 50));
    if (d)
      return g.observe(d), () => {
        g.unobserve(d);
      };
  }, [i.length, r]), A.createElement("div", { className: dist_Y("au-flow-chart", v, o), style: h, ...f }, i.map((d, g) => {
    const { span: p = 1, label: m, align: y = "center", style: _ = {}, status: S = "prohibit", id: b, link: w, dottedLine: x = !1, series: C = {} } = d;
    p === 0 && (_.display = "none"), p > 1 && (_.gridColumn = `auto / ${p} span`), y === "start" && (_.justifyContent = "start"), y === "end" && (_.justifyContent = "end");
    const T = [];
    dist_ue(b) || (lr(w) && T.push({ form: b, to: w }), wt(w) && w.forEach((D) => T.push({ form: b, to: D })));
    const E = m && b;
    return A.createElement(
      A.Fragment,
      { key: g },
      A.createElement("div", { className: dist_Y({
        [`au-flow-chart-item-${b}`]: b,
        "au-flow-chart-item-label": E,
        [`au-flow-chart-status-${S}`]: E
      }), style: { marginBottom: l, ..._ } }, m),
      T.map((D, I) => {
        const { form: L, to: N } = D, { dottedLine: P = x, lineStyle: R = {} } = C[N] || {}, z = `${e}-${L}-${N}`;
        let O = {
          d: "M0,6 88,6",
          stroke: "currentColor",
          strokeWidth: "2",
          fill: "none",
          markerEnd: `url(#arrow${z})`
        };
        return P && (O = { ...O, ...n }), A.createElement(
          "div",
          { style: { position: "absolute", width: 0 }, className: dist_Y(`arrow-${e}-${L}-${N}`, { [`au-flow-link-status-${S}`]: E }), key: `${L}-${N}` + I },
          A.createElement(
            "svg",
            { style: { width: "100%", overflow: "visible", ...R } },
            A.createElement(
              "defs",
              null,
              A.createElement(
                "marker",
                { id: `arrow${z}`, markerWidth: "10", markerHeight: "6", refX: "8", refY: "3", orient: "auto" },
                A.createElement("path", { d: "M0,0 L0,6 L9,3 z", fill: "currentColor" })
              )
            ),
            A.createElement("path", { ...O })
          )
        );
      })
    );
  }));
}
function HB(r) {
  const { type: e = "grid", ...t } = r;
  return e === "grid" ? A.createElement(ky, { ...t }) : A.createElement(ky, { ...t });
}
const B0 = [
  "James",
  "John",
  "Robert",
  "Michael",
  "William",
  "David",
  "Richard",
  "Charles",
  "Joseph",
  "Thomas",
  "Christopher",
  "Daniel",
  "Paul",
  "Mark",
  "Donald",
  "George",
  "Kenneth",
  "Steven",
  "Edward",
  "Brian",
  "Ronald",
  "Anthony",
  "Kevin",
  "Jason",
  "Matthew",
  "Gary",
  "Timothy",
  "Ruihuag",
  "Jose",
  "Larry",
  "Jeffrey",
  "Frank",
  "Scott",
  "Eric"
], Gk = [
  "Mary",
  "Patricia",
  "Linda",
  "Barbara",
  "Elizabeth",
  "Jennifer",
  "Maria",
  "Susan",
  "Margaret",
  "Dorothy",
  "Lisa",
  "Nancy",
  "Karen",
  "Betty",
  "Helen",
  "Sandra",
  "Donna",
  "Carol",
  "Ruth",
  "Sharon",
  "Michelle",
  "Laura",
  "Sarah",
  "Kimberly",
  "Deborah",
  "Jessica",
  "Shirley",
  "Cynthia",
  "Angela",
  "Melissa",
  "Brenda",
  "Amy",
  "Anna"
], Hk = [
  "王",
  "李",
  "张",
  "刘",
  "陈",
  "杨",
  "赵",
  "黄",
  "周",
  "吴",
  "徐",
  "孙",
  "胡",
  "朱",
  "高",
  "林",
  "何",
  "郭",
  "马",
  "罗",
  "梁",
  "宋",
  "郑",
  "谢",
  "韩",
  "唐",
  "冯",
  "于",
  "董",
  "萧",
  "程",
  "曹",
  "袁",
  "邓",
  "许",
  "傅",
  "沈",
  "曾",
  "彭",
  "吕",
  "苏",
  "卢",
  "蒋",
  "蔡",
  "贾",
  "丁",
  "魏",
  "薛",
  "叶",
  "阎",
  "余",
  "潘",
  "杜",
  "戴",
  "夏",
  "锺",
  "汪",
  "田",
  "任",
  "姜",
  "范",
  "方",
  "石",
  "姚",
  "谭",
  "廖",
  "邹",
  "熊",
  "金",
  "陆",
  "郝",
  "孔",
  "白",
  "崔",
  "康",
  "毛",
  "邱",
  "秦",
  "江",
  "史",
  "顾",
  "侯",
  "邵",
  "孟",
  "龙",
  "万",
  "段",
  "雷",
  "钱",
  "汤",
  "尹",
  "黎",
  "关",
  "易",
  "常",
  "武",
  "乔",
  "贺",
  "赖",
  "龚",
  "文",
  "关"
], $k = [
  "伟",
  "芳",
  "娜",
  "秀英",
  "敏",
  "静",
  "丽",
  "强",
  "磊",
  "军",
  "洋",
  "勇",
  "艳",
  "杰",
  "娟",
  "涛",
  "明",
  "超",
  "瑞华",
  "秀兰",
  "霞",
  "平",
  "刚",
  "桂英",
  "飞"
];
var Vy = {
  11e4: "北京",
  110100: "北京市",
  110101: "东城区",
  110102: "西城区",
  110105: "朝阳区",
  110106: "丰台区",
  110107: "石景山区",
  110108: "海淀区",
  110109: "门头沟区",
  110111: "房山区",
  110112: "通州区",
  110113: "顺义区",
  110114: "昌平区",
  110115: "大兴区",
  110116: "怀柔区",
  110117: "平谷区",
  110228: "密云县",
  110229: "延庆县",
  110230: "其它区",
  12e4: "天津",
  120100: "天津市",
  120101: "和平区",
  120102: "河东区",
  120103: "河西区",
  120104: "南开区",
  120105: "河北区",
  120106: "红桥区",
  120110: "东丽区",
  120111: "西青区",
  120112: "津南区",
  120113: "北辰区",
  120114: "武清区",
  120115: "宝坻区",
  120116: "滨海新区",
  120221: "宁河县",
  120223: "静海县",
  120225: "蓟县",
  120226: "其它区",
  13e4: "河北省",
  130100: "石家庄市",
  130102: "长安区",
  130103: "桥东区",
  130104: "桥西区",
  130105: "新华区",
  130107: "井陉矿区",
  130108: "裕华区",
  130121: "井陉县",
  130123: "正定县",
  130124: "栾城县",
  130125: "行唐县",
  130126: "灵寿县",
  130127: "高邑县",
  130128: "深泽县",
  130129: "赞皇县",
  130130: "无极县",
  130131: "平山县",
  130132: "元氏县",
  130133: "赵县",
  130181: "辛集市",
  130182: "藁城市",
  130183: "晋州市",
  130184: "新乐市",
  130185: "鹿泉市",
  130186: "其它区",
  130200: "唐山市",
  130202: "路南区",
  130203: "路北区",
  130204: "古冶区",
  130205: "开平区",
  130207: "丰南区",
  130208: "丰润区",
  130223: "滦县",
  130224: "滦南县",
  130225: "乐亭县",
  130227: "迁西县",
  130229: "玉田县",
  130230: "曹妃甸区",
  130281: "遵化市",
  130283: "迁安市",
  130284: "其它区",
  130300: "秦皇岛市",
  130302: "海港区",
  130303: "山海关区",
  130304: "北戴河区",
  130321: "青龙满族自治县",
  130322: "昌黎县",
  130323: "抚宁县",
  130324: "卢龙县",
  130398: "其它区",
  130400: "邯郸市",
  130402: "邯山区",
  130403: "丛台区",
  130404: "复兴区",
  130406: "峰峰矿区",
  130421: "邯郸县",
  130423: "临漳县",
  130424: "成安县",
  130425: "大名县",
  130426: "涉县",
  130427: "磁县",
  130428: "肥乡县",
  130429: "永年县",
  130430: "邱县",
  130431: "鸡泽县",
  130432: "广平县",
  130433: "馆陶县",
  130434: "魏县",
  130435: "曲周县",
  130481: "武安市",
  130482: "其它区",
  130500: "邢台市",
  130502: "桥东区",
  130503: "桥西区",
  130521: "邢台县",
  130522: "临城县",
  130523: "内丘县",
  130524: "柏乡县",
  130525: "隆尧县",
  130526: "任县",
  130527: "南和县",
  130528: "宁晋县",
  130529: "巨鹿县",
  130530: "新河县",
  130531: "广宗县",
  130532: "平乡县",
  130533: "威县",
  130534: "清河县",
  130535: "临西县",
  130581: "南宫市",
  130582: "沙河市",
  130583: "其它区",
  130600: "保定市",
  130602: "新市区",
  130603: "北市区",
  130604: "南市区",
  130621: "满城县",
  130622: "清苑县",
  130623: "涞水县",
  130624: "阜平县",
  130625: "徐水县",
  130626: "定兴县",
  130627: "唐县",
  130628: "高阳县",
  130629: "容城县",
  130630: "涞源县",
  130631: "望都县",
  130632: "安新县",
  130633: "易县",
  130634: "曲阳县",
  130635: "蠡县",
  130636: "顺平县",
  130637: "博野县",
  130638: "雄县",
  130681: "涿州市",
  130682: "定州市",
  130683: "安国市",
  130684: "高碑店市",
  130699: "其它区",
  130700: "张家口市",
  130702: "桥东区",
  130703: "桥西区",
  130705: "宣化区",
  130706: "下花园区",
  130721: "宣化县",
  130722: "张北县",
  130723: "康保县",
  130724: "沽源县",
  130725: "尚义县",
  130726: "蔚县",
  130727: "阳原县",
  130728: "怀安县",
  130729: "万全县",
  130730: "怀来县",
  130731: "涿鹿县",
  130732: "赤城县",
  130733: "崇礼县",
  130734: "其它区",
  130800: "承德市",
  130802: "双桥区",
  130803: "双滦区",
  130804: "鹰手营子矿区",
  130821: "承德县",
  130822: "兴隆县",
  130823: "平泉县",
  130824: "滦平县",
  130825: "隆化县",
  130826: "丰宁满族自治县",
  130827: "宽城满族自治县",
  130828: "围场满族蒙古族自治县",
  130829: "其它区",
  130900: "沧州市",
  130902: "新华区",
  130903: "运河区",
  130921: "沧县",
  130922: "青县",
  130923: "东光县",
  130924: "海兴县",
  130925: "盐山县",
  130926: "肃宁县",
  130927: "南皮县",
  130928: "吴桥县",
  130929: "献县",
  130930: "孟村回族自治县",
  130981: "泊头市",
  130982: "任丘市",
  130983: "黄骅市",
  130984: "河间市",
  130985: "其它区",
  131e3: "廊坊市",
  131002: "安次区",
  131003: "广阳区",
  131022: "固安县",
  131023: "永清县",
  131024: "香河县",
  131025: "大城县",
  131026: "文安县",
  131028: "大厂回族自治县",
  131081: "霸州市",
  131082: "三河市",
  131083: "其它区",
  131100: "衡水市",
  131102: "桃城区",
  131121: "枣强县",
  131122: "武邑县",
  131123: "武强县",
  131124: "饶阳县",
  131125: "安平县",
  131126: "故城县",
  131127: "景县",
  131128: "阜城县",
  131181: "冀州市",
  131182: "深州市",
  131183: "其它区",
  14e4: "山西省",
  140100: "太原市",
  140105: "小店区",
  140106: "迎泽区",
  140107: "杏花岭区",
  140108: "尖草坪区",
  140109: "万柏林区",
  140110: "晋源区",
  140121: "清徐县",
  140122: "阳曲县",
  140123: "娄烦县",
  140181: "古交市",
  140182: "其它区",
  140200: "大同市",
  140202: "城区",
  140203: "矿区",
  140211: "南郊区",
  140212: "新荣区",
  140221: "阳高县",
  140222: "天镇县",
  140223: "广灵县",
  140224: "灵丘县",
  140225: "浑源县",
  140226: "左云县",
  140227: "大同县",
  140228: "其它区",
  140300: "阳泉市",
  140302: "城区",
  140303: "矿区",
  140311: "郊区",
  140321: "平定县",
  140322: "盂县",
  140323: "其它区",
  140400: "长治市",
  140421: "长治县",
  140423: "襄垣县",
  140424: "屯留县",
  140425: "平顺县",
  140426: "黎城县",
  140427: "壶关县",
  140428: "长子县",
  140429: "武乡县",
  140430: "沁县",
  140431: "沁源县",
  140481: "潞城市",
  140482: "城区",
  140483: "郊区",
  140485: "其它区",
  140500: "晋城市",
  140502: "城区",
  140521: "沁水县",
  140522: "阳城县",
  140524: "陵川县",
  140525: "泽州县",
  140581: "高平市",
  140582: "其它区",
  140600: "朔州市",
  140602: "朔城区",
  140603: "平鲁区",
  140621: "山阴县",
  140622: "应县",
  140623: "右玉县",
  140624: "怀仁县",
  140625: "其它区",
  140700: "晋中市",
  140702: "榆次区",
  140721: "榆社县",
  140722: "左权县",
  140723: "和顺县",
  140724: "昔阳县",
  140725: "寿阳县",
  140726: "太谷县",
  140727: "祁县",
  140728: "平遥县",
  140729: "灵石县",
  140781: "介休市",
  140782: "其它区",
  140800: "运城市",
  140802: "盐湖区",
  140821: "临猗县",
  140822: "万荣县",
  140823: "闻喜县",
  140824: "稷山县",
  140825: "新绛县",
  140826: "绛县",
  140827: "垣曲县",
  140828: "夏县",
  140829: "平陆县",
  140830: "芮城县",
  140881: "永济市",
  140882: "河津市",
  140883: "其它区",
  140900: "忻州市",
  140902: "忻府区",
  140921: "定襄县",
  140922: "五台县",
  140923: "代县",
  140924: "繁峙县",
  140925: "宁武县",
  140926: "静乐县",
  140927: "神池县",
  140928: "五寨县",
  140929: "岢岚县",
  140930: "河曲县",
  140931: "保德县",
  140932: "偏关县",
  140981: "原平市",
  140982: "其它区",
  141e3: "临汾市",
  141002: "尧都区",
  141021: "曲沃县",
  141022: "翼城县",
  141023: "襄汾县",
  141024: "洪洞县",
  141025: "古县",
  141026: "安泽县",
  141027: "浮山县",
  141028: "吉县",
  141029: "乡宁县",
  141030: "大宁县",
  141031: "隰县",
  141032: "永和县",
  141033: "蒲县",
  141034: "汾西县",
  141081: "侯马市",
  141082: "霍州市",
  141083: "其它区",
  141100: "吕梁市",
  141102: "离石区",
  141121: "文水县",
  141122: "交城县",
  141123: "兴县",
  141124: "临县",
  141125: "柳林县",
  141126: "石楼县",
  141127: "岚县",
  141128: "方山县",
  141129: "中阳县",
  141130: "交口县",
  141181: "孝义市",
  141182: "汾阳市",
  141183: "其它区",
  15e4: "内蒙古自治区",
  150100: "呼和浩特市",
  150102: "新城区",
  150103: "回民区",
  150104: "玉泉区",
  150105: "赛罕区",
  150121: "土默特左旗",
  150122: "托克托县",
  150123: "和林格尔县",
  150124: "清水河县",
  150125: "武川县",
  150126: "其它区",
  150200: "包头市",
  150202: "东河区",
  150203: "昆都仑区",
  150204: "青山区",
  150205: "石拐区",
  150206: "白云鄂博矿区",
  150207: "九原区",
  150221: "土默特右旗",
  150222: "固阳县",
  150223: "达尔罕茂明安联合旗",
  150224: "其它区",
  150300: "乌海市",
  150302: "海勃湾区",
  150303: "海南区",
  150304: "乌达区",
  150305: "其它区",
  150400: "赤峰市",
  150402: "红山区",
  150403: "元宝山区",
  150404: "松山区",
  150421: "阿鲁科尔沁旗",
  150422: "巴林左旗",
  150423: "巴林右旗",
  150424: "林西县",
  150425: "克什克腾旗",
  150426: "翁牛特旗",
  150428: "喀喇沁旗",
  150429: "宁城县",
  150430: "敖汉旗",
  150431: "其它区",
  150500: "通辽市",
  150502: "科尔沁区",
  150521: "科尔沁左翼中旗",
  150522: "科尔沁左翼后旗",
  150523: "开鲁县",
  150524: "库伦旗",
  150525: "奈曼旗",
  150526: "扎鲁特旗",
  150581: "霍林郭勒市",
  150582: "其它区",
  150600: "鄂尔多斯市",
  150602: "东胜区",
  150621: "达拉特旗",
  150622: "准格尔旗",
  150623: "鄂托克前旗",
  150624: "鄂托克旗",
  150625: "杭锦旗",
  150626: "乌审旗",
  150627: "伊金霍洛旗",
  150628: "其它区",
  150700: "呼伦贝尔市",
  150702: "海拉尔区",
  150703: "扎赉诺尔区",
  150721: "阿荣旗",
  150722: "莫力达瓦达斡尔族自治旗",
  150723: "鄂伦春自治旗",
  150724: "鄂温克族自治旗",
  150725: "陈巴尔虎旗",
  150726: "新巴尔虎左旗",
  150727: "新巴尔虎右旗",
  150781: "满洲里市",
  150782: "牙克石市",
  150783: "扎兰屯市",
  150784: "额尔古纳市",
  150785: "根河市",
  150786: "其它区",
  150800: "巴彦淖尔市",
  150802: "临河区",
  150821: "五原县",
  150822: "磴口县",
  150823: "乌拉特前旗",
  150824: "乌拉特中旗",
  150825: "乌拉特后旗",
  150826: "杭锦后旗",
  150827: "其它区",
  150900: "乌兰察布市",
  150902: "集宁区",
  150921: "卓资县",
  150922: "化德县",
  150923: "商都县",
  150924: "兴和县",
  150925: "凉城县",
  150926: "察哈尔右翼前旗",
  150927: "察哈尔右翼中旗",
  150928: "察哈尔右翼后旗",
  150929: "四子王旗",
  150981: "丰镇市",
  150982: "其它区",
  152200: "兴安盟",
  152201: "乌兰浩特市",
  152202: "阿尔山市",
  152221: "科尔沁右翼前旗",
  152222: "科尔沁右翼中旗",
  152223: "扎赉特旗",
  152224: "突泉县",
  152225: "其它区",
  152500: "锡林郭勒盟",
  152501: "二连浩特市",
  152502: "锡林浩特市",
  152522: "阿巴嘎旗",
  152523: "苏尼特左旗",
  152524: "苏尼特右旗",
  152525: "东乌珠穆沁旗",
  152526: "西乌珠穆沁旗",
  152527: "太仆寺旗",
  152528: "镶黄旗",
  152529: "正镶白旗",
  152530: "正蓝旗",
  152531: "多伦县",
  152532: "其它区",
  152900: "阿拉善盟",
  152921: "阿拉善左旗",
  152922: "阿拉善右旗",
  152923: "额济纳旗",
  152924: "其它区",
  21e4: "辽宁省",
  210100: "沈阳市",
  210102: "和平区",
  210103: "沈河区",
  210104: "大东区",
  210105: "皇姑区",
  210106: "铁西区",
  210111: "苏家屯区",
  210112: "东陵区",
  210113: "新城子区",
  210114: "于洪区",
  210122: "辽中县",
  210123: "康平县",
  210124: "法库县",
  210181: "新民市",
  210184: "沈北新区",
  210185: "其它区",
  210200: "大连市",
  210202: "中山区",
  210203: "西岗区",
  210204: "沙河口区",
  210211: "甘井子区",
  210212: "旅顺口区",
  210213: "金州区",
  210224: "长海县",
  210281: "瓦房店市",
  210282: "普兰店市",
  210283: "庄河市",
  210298: "其它区",
  210300: "鞍山市",
  210302: "铁东区",
  210303: "铁西区",
  210304: "立山区",
  210311: "千山区",
  210321: "台安县",
  210323: "岫岩满族自治县",
  210381: "海城市",
  210382: "其它区",
  210400: "抚顺市",
  210402: "新抚区",
  210403: "东洲区",
  210404: "望花区",
  210411: "顺城区",
  210421: "抚顺县",
  210422: "新宾满族自治县",
  210423: "清原满族自治县",
  210424: "其它区",
  210500: "本溪市",
  210502: "平山区",
  210503: "溪湖区",
  210504: "明山区",
  210505: "南芬区",
  210521: "本溪满族自治县",
  210522: "桓仁满族自治县",
  210523: "其它区",
  210600: "丹东市",
  210602: "元宝区",
  210603: "振兴区",
  210604: "振安区",
  210624: "宽甸满族自治县",
  210681: "东港市",
  210682: "凤城市",
  210683: "其它区",
  210700: "锦州市",
  210702: "古塔区",
  210703: "凌河区",
  210711: "太和区",
  210726: "黑山县",
  210727: "义县",
  210781: "凌海市",
  210782: "北镇市",
  210783: "其它区",
  210800: "营口市",
  210802: "站前区",
  210803: "西市区",
  210804: "鲅鱼圈区",
  210811: "老边区",
  210881: "盖州市",
  210882: "大石桥市",
  210883: "其它区",
  210900: "阜新市",
  210902: "海州区",
  210903: "新邱区",
  210904: "太平区",
  210905: "清河门区",
  210911: "细河区",
  210921: "阜新蒙古族自治县",
  210922: "彰武县",
  210923: "其它区",
  211e3: "辽阳市",
  211002: "白塔区",
  211003: "文圣区",
  211004: "宏伟区",
  211005: "弓长岭区",
  211011: "太子河区",
  211021: "辽阳县",
  211081: "灯塔市",
  211082: "其它区",
  211100: "盘锦市",
  211102: "双台子区",
  211103: "兴隆台区",
  211121: "大洼县",
  211122: "盘山县",
  211123: "其它区",
  211200: "铁岭市",
  211202: "银州区",
  211204: "清河区",
  211221: "铁岭县",
  211223: "西丰县",
  211224: "昌图县",
  211281: "调兵山市",
  211282: "开原市",
  211283: "其它区",
  211300: "朝阳市",
  211302: "双塔区",
  211303: "龙城区",
  211321: "朝阳县",
  211322: "建平县",
  211324: "喀喇沁左翼蒙古族自治县",
  211381: "北票市",
  211382: "凌源市",
  211383: "其它区",
  211400: "葫芦岛市",
  211402: "连山区",
  211403: "龙港区",
  211404: "南票区",
  211421: "绥中县",
  211422: "建昌县",
  211481: "兴城市",
  211482: "其它区",
  22e4: "吉林省",
  220100: "长春市",
  220102: "南关区",
  220103: "宽城区",
  220104: "朝阳区",
  220105: "二道区",
  220106: "绿园区",
  220112: "双阳区",
  220122: "农安县",
  220181: "九台市",
  220182: "榆树市",
  220183: "德惠市",
  220188: "其它区",
  220200: "吉林市",
  220202: "昌邑区",
  220203: "龙潭区",
  220204: "船营区",
  220211: "丰满区",
  220221: "永吉县",
  220281: "蛟河市",
  220282: "桦甸市",
  220283: "舒兰市",
  220284: "磐石市",
  220285: "其它区",
  220300: "四平市",
  220302: "铁西区",
  220303: "铁东区",
  220322: "梨树县",
  220323: "伊通满族自治县",
  220381: "公主岭市",
  220382: "双辽市",
  220383: "其它区",
  220400: "辽源市",
  220402: "龙山区",
  220403: "西安区",
  220421: "东丰县",
  220422: "东辽县",
  220423: "其它区",
  220500: "通化市",
  220502: "东昌区",
  220503: "二道江区",
  220521: "通化县",
  220523: "辉南县",
  220524: "柳河县",
  220581: "梅河口市",
  220582: "集安市",
  220583: "其它区",
  220600: "白山市",
  220602: "浑江区",
  220621: "抚松县",
  220622: "靖宇县",
  220623: "长白朝鲜族自治县",
  220625: "江源区",
  220681: "临江市",
  220682: "其它区",
  220700: "松原市",
  220702: "宁江区",
  220721: "前郭尔罗斯蒙古族自治县",
  220722: "长岭县",
  220723: "乾安县",
  220724: "扶余市",
  220725: "其它区",
  220800: "白城市",
  220802: "洮北区",
  220821: "镇赉县",
  220822: "通榆县",
  220881: "洮南市",
  220882: "大安市",
  220883: "其它区",
  222400: "延边朝鲜族自治州",
  222401: "延吉市",
  222402: "图们市",
  222403: "敦化市",
  222404: "珲春市",
  222405: "龙井市",
  222406: "和龙市",
  222424: "汪清县",
  222426: "安图县",
  222427: "其它区",
  23e4: "黑龙江省",
  230100: "哈尔滨市",
  230102: "道里区",
  230103: "南岗区",
  230104: "道外区",
  230106: "香坊区",
  230108: "平房区",
  230109: "松北区",
  230111: "呼兰区",
  230123: "依兰县",
  230124: "方正县",
  230125: "宾县",
  230126: "巴彦县",
  230127: "木兰县",
  230128: "通河县",
  230129: "延寿县",
  230181: "阿城区",
  230182: "双城市",
  230183: "尚志市",
  230184: "五常市",
  230186: "其它区",
  230200: "齐齐哈尔市",
  230202: "龙沙区",
  230203: "建华区",
  230204: "铁锋区",
  230205: "昂昂溪区",
  230206: "富拉尔基区",
  230207: "碾子山区",
  230208: "梅里斯达斡尔族区",
  230221: "龙江县",
  230223: "依安县",
  230224: "泰来县",
  230225: "甘南县",
  230227: "富裕县",
  230229: "克山县",
  230230: "克东县",
  230231: "拜泉县",
  230281: "讷河市",
  230282: "其它区",
  230300: "鸡西市",
  230302: "鸡冠区",
  230303: "恒山区",
  230304: "滴道区",
  230305: "梨树区",
  230306: "城子河区",
  230307: "麻山区",
  230321: "鸡东县",
  230381: "虎林市",
  230382: "密山市",
  230383: "其它区",
  230400: "鹤岗市",
  230402: "向阳区",
  230403: "工农区",
  230404: "南山区",
  230405: "兴安区",
  230406: "东山区",
  230407: "兴山区",
  230421: "萝北县",
  230422: "绥滨县",
  230423: "其它区",
  230500: "双鸭山市",
  230502: "尖山区",
  230503: "岭东区",
  230505: "四方台区",
  230506: "宝山区",
  230521: "集贤县",
  230522: "友谊县",
  230523: "宝清县",
  230524: "饶河县",
  230525: "其它区",
  230600: "大庆市",
  230602: "萨尔图区",
  230603: "龙凤区",
  230604: "让胡路区",
  230605: "红岗区",
  230606: "大同区",
  230621: "肇州县",
  230622: "肇源县",
  230623: "林甸县",
  230624: "杜尔伯特蒙古族自治县",
  230625: "其它区",
  230700: "伊春市",
  230702: "伊春区",
  230703: "南岔区",
  230704: "友好区",
  230705: "西林区",
  230706: "翠峦区",
  230707: "新青区",
  230708: "美溪区",
  230709: "金山屯区",
  230710: "五营区",
  230711: "乌马河区",
  230712: "汤旺河区",
  230713: "带岭区",
  230714: "乌伊岭区",
  230715: "红星区",
  230716: "上甘岭区",
  230722: "嘉荫县",
  230781: "铁力市",
  230782: "其它区",
  230800: "佳木斯市",
  230803: "向阳区",
  230804: "前进区",
  230805: "东风区",
  230811: "郊区",
  230822: "桦南县",
  230826: "桦川县",
  230828: "汤原县",
  230833: "抚远县",
  230881: "同江市",
  230882: "富锦市",
  230883: "其它区",
  230900: "七台河市",
  230902: "新兴区",
  230903: "桃山区",
  230904: "茄子河区",
  230921: "勃利县",
  230922: "其它区",
  231e3: "牡丹江市",
  231002: "东安区",
  231003: "阳明区",
  231004: "爱民区",
  231005: "西安区",
  231024: "东宁县",
  231025: "林口县",
  231081: "绥芬河市",
  231083: "海林市",
  231084: "宁安市",
  231085: "穆棱市",
  231086: "其它区",
  231100: "黑河市",
  231102: "爱辉区",
  231121: "嫩江县",
  231123: "逊克县",
  231124: "孙吴县",
  231181: "北安市",
  231182: "五大连池市",
  231183: "其它区",
  231200: "绥化市",
  231202: "北林区",
  231221: "望奎县",
  231222: "兰西县",
  231223: "青冈县",
  231224: "庆安县",
  231225: "明水县",
  231226: "绥棱县",
  231281: "安达市",
  231282: "肇东市",
  231283: "海伦市",
  231284: "其它区",
  232700: "大兴安岭地区",
  232702: "松岭区",
  232703: "新林区",
  232704: "呼中区",
  232721: "呼玛县",
  232722: "塔河县",
  232723: "漠河县",
  232724: "加格达奇区",
  232725: "其它区",
  31e4: "上海",
  310100: "上海市",
  310101: "黄浦区",
  310104: "徐汇区",
  310105: "长宁区",
  310106: "静安区",
  310107: "普陀区",
  310108: "闸北区",
  310109: "虹口区",
  310110: "杨浦区",
  310112: "闵行区",
  310113: "宝山区",
  310114: "嘉定区",
  310115: "浦东新区",
  310116: "金山区",
  310117: "松江区",
  310118: "青浦区",
  310120: "奉贤区",
  310230: "崇明县",
  310231: "其它区",
  32e4: "江苏省",
  320100: "南京市",
  320102: "玄武区",
  320104: "秦淮区",
  320105: "建邺区",
  320106: "鼓楼区",
  320111: "浦口区",
  320113: "栖霞区",
  320114: "雨花台区",
  320115: "江宁区",
  320116: "六合区",
  320124: "溧水区",
  320125: "高淳区",
  320126: "其它区",
  320200: "无锡市",
  320202: "崇安区",
  320203: "南长区",
  320204: "北塘区",
  320205: "锡山区",
  320206: "惠山区",
  320211: "滨湖区",
  320281: "江阴市",
  320282: "宜兴市",
  320297: "其它区",
  320300: "徐州市",
  320302: "鼓楼区",
  320303: "云龙区",
  320305: "贾汪区",
  320311: "泉山区",
  320321: "丰县",
  320322: "沛县",
  320323: "铜山区",
  320324: "睢宁县",
  320381: "新沂市",
  320382: "邳州市",
  320383: "其它区",
  320400: "常州市",
  320402: "天宁区",
  320404: "钟楼区",
  320405: "戚墅堰区",
  320411: "新北区",
  320412: "武进区",
  320481: "溧阳市",
  320482: "金坛市",
  320483: "其它区",
  320500: "苏州市",
  320505: "虎丘区",
  320506: "吴中区",
  320507: "相城区",
  320508: "姑苏区",
  320581: "常熟市",
  320582: "张家港市",
  320583: "昆山市",
  320584: "吴江区",
  320585: "太仓市",
  320596: "其它区",
  320600: "南通市",
  320602: "崇川区",
  320611: "港闸区",
  320612: "通州区",
  320621: "海安县",
  320623: "如东县",
  320681: "启东市",
  320682: "如皋市",
  320684: "海门市",
  320694: "其它区",
  320700: "连云港市",
  320703: "连云区",
  320705: "新浦区",
  320706: "海州区",
  320721: "赣榆县",
  320722: "东海县",
  320723: "灌云县",
  320724: "灌南县",
  320725: "其它区",
  320800: "淮安市",
  320802: "清河区",
  320803: "淮安区",
  320804: "淮阴区",
  320811: "清浦区",
  320826: "涟水县",
  320829: "洪泽县",
  320830: "盱眙县",
  320831: "金湖县",
  320832: "其它区",
  320900: "盐城市",
  320902: "亭湖区",
  320903: "盐都区",
  320921: "响水县",
  320922: "滨海县",
  320923: "阜宁县",
  320924: "射阳县",
  320925: "建湖县",
  320981: "东台市",
  320982: "大丰市",
  320983: "其它区",
  321e3: "扬州市",
  321002: "广陵区",
  321003: "邗江区",
  321023: "宝应县",
  321081: "仪征市",
  321084: "高邮市",
  321088: "江都区",
  321093: "其它区",
  321100: "镇江市",
  321102: "京口区",
  321111: "润州区",
  321112: "丹徒区",
  321181: "丹阳市",
  321182: "扬中市",
  321183: "句容市",
  321184: "其它区",
  321200: "泰州市",
  321202: "海陵区",
  321203: "高港区",
  321281: "兴化市",
  321282: "靖江市",
  321283: "泰兴市",
  321284: "姜堰区",
  321285: "其它区",
  321300: "宿迁市",
  321302: "宿城区",
  321311: "宿豫区",
  321322: "沭阳县",
  321323: "泗阳县",
  321324: "泗洪县",
  321325: "其它区",
  33e4: "浙江省",
  330100: "杭州市",
  330102: "上城区",
  330103: "下城区",
  330104: "江干区",
  330105: "拱墅区",
  330106: "西湖区",
  330108: "滨江区",
  330109: "萧山区",
  330110: "余杭区",
  330122: "桐庐县",
  330127: "淳安县",
  330182: "建德市",
  330183: "富阳市",
  330185: "临安市",
  330186: "其它区",
  330200: "宁波市",
  330203: "海曙区",
  330204: "江东区",
  330205: "江北区",
  330206: "北仑区",
  330211: "镇海区",
  330212: "鄞州区",
  330225: "象山县",
  330226: "宁海县",
  330281: "余姚市",
  330282: "慈溪市",
  330283: "奉化市",
  330284: "其它区",
  330300: "温州市",
  330302: "鹿城区",
  330303: "龙湾区",
  330304: "瓯海区",
  330322: "洞头县",
  330324: "永嘉县",
  330326: "平阳县",
  330327: "苍南县",
  330328: "文成县",
  330329: "泰顺县",
  330381: "瑞安市",
  330382: "乐清市",
  330383: "其它区",
  330400: "嘉兴市",
  330402: "南湖区",
  330411: "秀洲区",
  330421: "嘉善县",
  330424: "海盐县",
  330481: "海宁市",
  330482: "平湖市",
  330483: "桐乡市",
  330484: "其它区",
  330500: "湖州市",
  330502: "吴兴区",
  330503: "南浔区",
  330521: "德清县",
  330522: "长兴县",
  330523: "安吉县",
  330524: "其它区",
  330600: "绍兴市",
  330602: "越城区",
  330621: "绍兴县",
  330624: "新昌县",
  330681: "诸暨市",
  330682: "上虞市",
  330683: "嵊州市",
  330684: "其它区",
  330700: "金华市",
  330702: "婺城区",
  330703: "金东区",
  330723: "武义县",
  330726: "浦江县",
  330727: "磐安县",
  330781: "兰溪市",
  330782: "义乌市",
  330783: "东阳市",
  330784: "永康市",
  330785: "其它区",
  330800: "衢州市",
  330802: "柯城区",
  330803: "衢江区",
  330822: "常山县",
  330824: "开化县",
  330825: "龙游县",
  330881: "江山市",
  330882: "其它区",
  330900: "舟山市",
  330902: "定海区",
  330903: "普陀区",
  330921: "岱山县",
  330922: "嵊泗县",
  330923: "其它区",
  331e3: "台州市",
  331002: "椒江区",
  331003: "黄岩区",
  331004: "路桥区",
  331021: "玉环县",
  331022: "三门县",
  331023: "天台县",
  331024: "仙居县",
  331081: "温岭市",
  331082: "临海市",
  331083: "其它区",
  331100: "丽水市",
  331102: "莲都区",
  331121: "青田县",
  331122: "缙云县",
  331123: "遂昌县",
  331124: "松阳县",
  331125: "云和县",
  331126: "庆元县",
  331127: "景宁畲族自治县",
  331181: "龙泉市",
  331182: "其它区",
  34e4: "安徽省",
  340100: "合肥市",
  340102: "瑶海区",
  340103: "庐阳区",
  340104: "蜀山区",
  340111: "包河区",
  340121: "长丰县",
  340122: "肥东县",
  340123: "肥西县",
  340192: "其它区",
  340200: "芜湖市",
  340202: "镜湖区",
  340203: "弋江区",
  340207: "鸠江区",
  340208: "三山区",
  340221: "芜湖县",
  340222: "繁昌县",
  340223: "南陵县",
  340224: "其它区",
  340300: "蚌埠市",
  340302: "龙子湖区",
  340303: "蚌山区",
  340304: "禹会区",
  340311: "淮上区",
  340321: "怀远县",
  340322: "五河县",
  340323: "固镇县",
  340324: "其它区",
  340400: "淮南市",
  340402: "大通区",
  340403: "田家庵区",
  340404: "谢家集区",
  340405: "八公山区",
  340406: "潘集区",
  340421: "凤台县",
  340422: "其它区",
  340500: "马鞍山市",
  340503: "花山区",
  340504: "雨山区",
  340506: "博望区",
  340521: "当涂县",
  340522: "其它区",
  340600: "淮北市",
  340602: "杜集区",
  340603: "相山区",
  340604: "烈山区",
  340621: "濉溪县",
  340622: "其它区",
  340700: "铜陵市",
  340702: "铜官山区",
  340703: "狮子山区",
  340711: "郊区",
  340721: "铜陵县",
  340722: "其它区",
  340800: "安庆市",
  340802: "迎江区",
  340803: "大观区",
  340811: "宜秀区",
  340822: "怀宁县",
  340823: "枞阳县",
  340824: "潜山县",
  340825: "太湖县",
  340826: "宿松县",
  340827: "望江县",
  340828: "岳西县",
  340881: "桐城市",
  340882: "其它区",
  341e3: "黄山市",
  341002: "屯溪区",
  341003: "黄山区",
  341004: "徽州区",
  341021: "歙县",
  341022: "休宁县",
  341023: "黟县",
  341024: "祁门县",
  341025: "其它区",
  341100: "滁州市",
  341102: "琅琊区",
  341103: "南谯区",
  341122: "来安县",
  341124: "全椒县",
  341125: "定远县",
  341126: "凤阳县",
  341181: "天长市",
  341182: "明光市",
  341183: "其它区",
  341200: "阜阳市",
  341202: "颍州区",
  341203: "颍东区",
  341204: "颍泉区",
  341221: "临泉县",
  341222: "太和县",
  341225: "阜南县",
  341226: "颍上县",
  341282: "界首市",
  341283: "其它区",
  341300: "宿州市",
  341302: "埇桥区",
  341321: "砀山县",
  341322: "萧县",
  341323: "灵璧县",
  341324: "泗县",
  341325: "其它区",
  341400: "巢湖市",
  341421: "庐江县",
  341422: "无为县",
  341423: "含山县",
  341424: "和县",
  341500: "六安市",
  341502: "金安区",
  341503: "裕安区",
  341521: "寿县",
  341522: "霍邱县",
  341523: "舒城县",
  341524: "金寨县",
  341525: "霍山县",
  341526: "其它区",
  341600: "亳州市",
  341602: "谯城区",
  341621: "涡阳县",
  341622: "蒙城县",
  341623: "利辛县",
  341624: "其它区",
  341700: "池州市",
  341702: "贵池区",
  341721: "东至县",
  341722: "石台县",
  341723: "青阳县",
  341724: "其它区",
  341800: "宣城市",
  341802: "宣州区",
  341821: "郎溪县",
  341822: "广德县",
  341823: "泾县",
  341824: "绩溪县",
  341825: "旌德县",
  341881: "宁国市",
  341882: "其它区",
  35e4: "福建省",
  350100: "福州市",
  350102: "鼓楼区",
  350103: "台江区",
  350104: "仓山区",
  350105: "马尾区",
  350111: "晋安区",
  350121: "闽侯县",
  350122: "连江县",
  350123: "罗源县",
  350124: "闽清县",
  350125: "永泰县",
  350128: "平潭县",
  350181: "福清市",
  350182: "长乐市",
  350183: "其它区",
  350200: "厦门市",
  350203: "思明区",
  350205: "海沧区",
  350206: "湖里区",
  350211: "集美区",
  350212: "同安区",
  350213: "翔安区",
  350214: "其它区",
  350300: "莆田市",
  350302: "城厢区",
  350303: "涵江区",
  350304: "荔城区",
  350305: "秀屿区",
  350322: "仙游县",
  350323: "其它区",
  350400: "三明市",
  350402: "梅列区",
  350403: "三元区",
  350421: "明溪县",
  350423: "清流县",
  350424: "宁化县",
  350425: "大田县",
  350426: "尤溪县",
  350427: "沙县",
  350428: "将乐县",
  350429: "泰宁县",
  350430: "建宁县",
  350481: "永安市",
  350482: "其它区",
  350500: "泉州市",
  350502: "鲤城区",
  350503: "丰泽区",
  350504: "洛江区",
  350505: "泉港区",
  350521: "惠安县",
  350524: "安溪县",
  350525: "永春县",
  350526: "德化县",
  350527: "金门县",
  350581: "石狮市",
  350582: "晋江市",
  350583: "南安市",
  350584: "其它区",
  350600: "漳州市",
  350602: "芗城区",
  350603: "龙文区",
  350622: "云霄县",
  350623: "漳浦县",
  350624: "诏安县",
  350625: "长泰县",
  350626: "东山县",
  350627: "南靖县",
  350628: "平和县",
  350629: "华安县",
  350681: "龙海市",
  350682: "其它区",
  350700: "南平市",
  350702: "延平区",
  350721: "顺昌县",
  350722: "浦城县",
  350723: "光泽县",
  350724: "松溪县",
  350725: "政和县",
  350781: "邵武市",
  350782: "武夷山市",
  350783: "建瓯市",
  350784: "建阳市",
  350785: "其它区",
  350800: "龙岩市",
  350802: "新罗区",
  350821: "长汀县",
  350822: "永定县",
  350823: "上杭县",
  350824: "武平县",
  350825: "连城县",
  350881: "漳平市",
  350882: "其它区",
  350900: "宁德市",
  350902: "蕉城区",
  350921: "霞浦县",
  350922: "古田县",
  350923: "屏南县",
  350924: "寿宁县",
  350925: "周宁县",
  350926: "柘荣县",
  350981: "福安市",
  350982: "福鼎市",
  350983: "其它区",
  36e4: "江西省",
  360100: "南昌市",
  360102: "东湖区",
  360103: "西湖区",
  360104: "青云谱区",
  360105: "湾里区",
  360111: "青山湖区",
  360121: "南昌县",
  360122: "新建县",
  360123: "安义县",
  360124: "进贤县",
  360128: "其它区",
  360200: "景德镇市",
  360202: "昌江区",
  360203: "珠山区",
  360222: "浮梁县",
  360281: "乐平市",
  360282: "其它区",
  360300: "萍乡市",
  360302: "安源区",
  360313: "湘东区",
  360321: "莲花县",
  360322: "上栗县",
  360323: "芦溪县",
  360324: "其它区",
  360400: "九江市",
  360402: "庐山区",
  360403: "浔阳区",
  360421: "九江县",
  360423: "武宁县",
  360424: "修水县",
  360425: "永修县",
  360426: "德安县",
  360427: "星子县",
  360428: "都昌县",
  360429: "湖口县",
  360430: "彭泽县",
  360481: "瑞昌市",
  360482: "其它区",
  360483: "共青城市",
  360500: "新余市",
  360502: "渝水区",
  360521: "分宜县",
  360522: "其它区",
  360600: "鹰潭市",
  360602: "月湖区",
  360622: "余江县",
  360681: "贵溪市",
  360682: "其它区",
  360700: "赣州市",
  360702: "章贡区",
  360721: "赣县",
  360722: "信丰县",
  360723: "大余县",
  360724: "上犹县",
  360725: "崇义县",
  360726: "安远县",
  360727: "龙南县",
  360728: "定南县",
  360729: "全南县",
  360730: "宁都县",
  360731: "于都县",
  360732: "兴国县",
  360733: "会昌县",
  360734: "寻乌县",
  360735: "石城县",
  360781: "瑞金市",
  360782: "南康市",
  360783: "其它区",
  360800: "吉安市",
  360802: "吉州区",
  360803: "青原区",
  360821: "吉安县",
  360822: "吉水县",
  360823: "峡江县",
  360824: "新干县",
  360825: "永丰县",
  360826: "泰和县",
  360827: "遂川县",
  360828: "万安县",
  360829: "安福县",
  360830: "永新县",
  360881: "井冈山市",
  360882: "其它区",
  360900: "宜春市",
  360902: "袁州区",
  360921: "奉新县",
  360922: "万载县",
  360923: "上高县",
  360924: "宜丰县",
  360925: "靖安县",
  360926: "铜鼓县",
  360981: "丰城市",
  360982: "樟树市",
  360983: "高安市",
  360984: "其它区",
  361e3: "抚州市",
  361002: "临川区",
  361021: "南城县",
  361022: "黎川县",
  361023: "南丰县",
  361024: "崇仁县",
  361025: "乐安县",
  361026: "宜黄县",
  361027: "金溪县",
  361028: "资溪县",
  361029: "东乡县",
  361030: "广昌县",
  361031: "其它区",
  361100: "上饶市",
  361102: "信州区",
  361121: "上饶县",
  361122: "广丰县",
  361123: "玉山县",
  361124: "铅山县",
  361125: "横峰县",
  361126: "弋阳县",
  361127: "余干县",
  361128: "鄱阳县",
  361129: "万年县",
  361130: "婺源县",
  361181: "德兴市",
  361182: "其它区",
  37e4: "山东省",
  370100: "济南市",
  370102: "历下区",
  370103: "市中区",
  370104: "槐荫区",
  370105: "天桥区",
  370112: "历城区",
  370113: "长清区",
  370124: "平阴县",
  370125: "济阳县",
  370126: "商河县",
  370181: "章丘市",
  370182: "其它区",
  370200: "青岛市",
  370202: "市南区",
  370203: "市北区",
  370211: "黄岛区",
  370212: "崂山区",
  370213: "李沧区",
  370214: "城阳区",
  370281: "胶州市",
  370282: "即墨市",
  370283: "平度市",
  370285: "莱西市",
  370286: "其它区",
  370300: "淄博市",
  370302: "淄川区",
  370303: "张店区",
  370304: "博山区",
  370305: "临淄区",
  370306: "周村区",
  370321: "桓台县",
  370322: "高青县",
  370323: "沂源县",
  370324: "其它区",
  370400: "枣庄市",
  370402: "市中区",
  370403: "薛城区",
  370404: "峄城区",
  370405: "台儿庄区",
  370406: "山亭区",
  370481: "滕州市",
  370482: "其它区",
  370500: "东营市",
  370502: "东营区",
  370503: "河口区",
  370521: "垦利县",
  370522: "利津县",
  370523: "广饶县",
  370591: "其它区",
  370600: "烟台市",
  370602: "芝罘区",
  370611: "福山区",
  370612: "牟平区",
  370613: "莱山区",
  370634: "长岛县",
  370681: "龙口市",
  370682: "莱阳市",
  370683: "莱州市",
  370684: "蓬莱市",
  370685: "招远市",
  370686: "栖霞市",
  370687: "海阳市",
  370688: "其它区",
  370700: "潍坊市",
  370702: "潍城区",
  370703: "寒亭区",
  370704: "坊子区",
  370705: "奎文区",
  370724: "临朐县",
  370725: "昌乐县",
  370781: "青州市",
  370782: "诸城市",
  370783: "寿光市",
  370784: "安丘市",
  370785: "高密市",
  370786: "昌邑市",
  370787: "其它区",
  370800: "济宁市",
  370802: "市中区",
  370811: "任城区",
  370826: "微山县",
  370827: "鱼台县",
  370828: "金乡县",
  370829: "嘉祥县",
  370830: "汶上县",
  370831: "泗水县",
  370832: "梁山县",
  370881: "曲阜市",
  370882: "兖州市",
  370883: "邹城市",
  370884: "其它区",
  370900: "泰安市",
  370902: "泰山区",
  370903: "岱岳区",
  370921: "宁阳县",
  370923: "东平县",
  370982: "新泰市",
  370983: "肥城市",
  370984: "其它区",
  371e3: "威海市",
  371002: "环翠区",
  371081: "文登市",
  371082: "荣成市",
  371083: "乳山市",
  371084: "其它区",
  371100: "日照市",
  371102: "东港区",
  371103: "岚山区",
  371121: "五莲县",
  371122: "莒县",
  371123: "其它区",
  371200: "莱芜市",
  371202: "莱城区",
  371203: "钢城区",
  371204: "其它区",
  371300: "临沂市",
  371302: "兰山区",
  371311: "罗庄区",
  371312: "河东区",
  371321: "沂南县",
  371322: "郯城县",
  371323: "沂水县",
  371324: "苍山县",
  371325: "费县",
  371326: "平邑县",
  371327: "莒南县",
  371328: "蒙阴县",
  371329: "临沭县",
  371330: "其它区",
  371400: "德州市",
  371402: "德城区",
  371421: "陵县",
  371422: "宁津县",
  371423: "庆云县",
  371424: "临邑县",
  371425: "齐河县",
  371426: "平原县",
  371427: "夏津县",
  371428: "武城县",
  371481: "乐陵市",
  371482: "禹城市",
  371483: "其它区",
  371500: "聊城市",
  371502: "东昌府区",
  371521: "阳谷县",
  371522: "莘县",
  371523: "茌平县",
  371524: "东阿县",
  371525: "冠县",
  371526: "高唐县",
  371581: "临清市",
  371582: "其它区",
  371600: "滨州市",
  371602: "滨城区",
  371621: "惠民县",
  371622: "阳信县",
  371623: "无棣县",
  371624: "沾化县",
  371625: "博兴县",
  371626: "邹平县",
  371627: "其它区",
  371700: "菏泽市",
  371702: "牡丹区",
  371721: "曹县",
  371722: "单县",
  371723: "成武县",
  371724: "巨野县",
  371725: "郓城县",
  371726: "鄄城县",
  371727: "定陶县",
  371728: "东明县",
  371729: "其它区",
  41e4: "河南省",
  410100: "郑州市",
  410102: "中原区",
  410103: "二七区",
  410104: "管城回族区",
  410105: "金水区",
  410106: "上街区",
  410108: "惠济区",
  410122: "中牟县",
  410181: "巩义市",
  410182: "荥阳市",
  410183: "新密市",
  410184: "新郑市",
  410185: "登封市",
  410188: "其它区",
  410200: "开封市",
  410202: "龙亭区",
  410203: "顺河回族区",
  410204: "鼓楼区",
  410205: "禹王台区",
  410211: "金明区",
  410221: "杞县",
  410222: "通许县",
  410223: "尉氏县",
  410224: "开封县",
  410225: "兰考县",
  410226: "其它区",
  410300: "洛阳市",
  410302: "老城区",
  410303: "西工区",
  410304: "瀍河回族区",
  410305: "涧西区",
  410306: "吉利区",
  410307: "洛龙区",
  410322: "孟津县",
  410323: "新安县",
  410324: "栾川县",
  410325: "嵩县",
  410326: "汝阳县",
  410327: "宜阳县",
  410328: "洛宁县",
  410329: "伊川县",
  410381: "偃师市",
  410400: "平顶山市",
  410402: "新华区",
  410403: "卫东区",
  410404: "石龙区",
  410411: "湛河区",
  410421: "宝丰县",
  410422: "叶县",
  410423: "鲁山县",
  410425: "郏县",
  410481: "舞钢市",
  410482: "汝州市",
  410483: "其它区",
  410500: "安阳市",
  410502: "文峰区",
  410503: "北关区",
  410505: "殷都区",
  410506: "龙安区",
  410522: "安阳县",
  410523: "汤阴县",
  410526: "滑县",
  410527: "内黄县",
  410581: "林州市",
  410582: "其它区",
  410600: "鹤壁市",
  410602: "鹤山区",
  410603: "山城区",
  410611: "淇滨区",
  410621: "浚县",
  410622: "淇县",
  410623: "其它区",
  410700: "新乡市",
  410702: "红旗区",
  410703: "卫滨区",
  410704: "凤泉区",
  410711: "牧野区",
  410721: "新乡县",
  410724: "获嘉县",
  410725: "原阳县",
  410726: "延津县",
  410727: "封丘县",
  410728: "长垣县",
  410781: "卫辉市",
  410782: "辉县市",
  410783: "其它区",
  410800: "焦作市",
  410802: "解放区",
  410803: "中站区",
  410804: "马村区",
  410811: "山阳区",
  410821: "修武县",
  410822: "博爱县",
  410823: "武陟县",
  410825: "温县",
  410881: "济源市",
  410882: "沁阳市",
  410883: "孟州市",
  410884: "其它区",
  410900: "濮阳市",
  410902: "华龙区",
  410922: "清丰县",
  410923: "南乐县",
  410926: "范县",
  410927: "台前县",
  410928: "濮阳县",
  410929: "其它区",
  411e3: "许昌市",
  411002: "魏都区",
  411023: "许昌县",
  411024: "鄢陵县",
  411025: "襄城县",
  411081: "禹州市",
  411082: "长葛市",
  411083: "其它区",
  411100: "漯河市",
  411102: "源汇区",
  411103: "郾城区",
  411104: "召陵区",
  411121: "舞阳县",
  411122: "临颍县",
  411123: "其它区",
  411200: "三门峡市",
  411202: "湖滨区",
  411221: "渑池县",
  411222: "陕县",
  411224: "卢氏县",
  411281: "义马市",
  411282: "灵宝市",
  411283: "其它区",
  411300: "南阳市",
  411302: "宛城区",
  411303: "卧龙区",
  411321: "南召县",
  411322: "方城县",
  411323: "西峡县",
  411324: "镇平县",
  411325: "内乡县",
  411326: "淅川县",
  411327: "社旗县",
  411328: "唐河县",
  411329: "新野县",
  411330: "桐柏县",
  411381: "邓州市",
  411382: "其它区",
  411400: "商丘市",
  411402: "梁园区",
  411403: "睢阳区",
  411421: "民权县",
  411422: "睢县",
  411423: "宁陵县",
  411424: "柘城县",
  411425: "虞城县",
  411426: "夏邑县",
  411481: "永城市",
  411482: "其它区",
  411500: "信阳市",
  411502: "浉河区",
  411503: "平桥区",
  411521: "罗山县",
  411522: "光山县",
  411523: "新县",
  411524: "商城县",
  411525: "固始县",
  411526: "潢川县",
  411527: "淮滨县",
  411528: "息县",
  411529: "其它区",
  411600: "周口市",
  411602: "川汇区",
  411621: "扶沟县",
  411622: "西华县",
  411623: "商水县",
  411624: "沈丘县",
  411625: "郸城县",
  411626: "淮阳县",
  411627: "太康县",
  411628: "鹿邑县",
  411681: "项城市",
  411682: "其它区",
  411700: "驻马店市",
  411702: "驿城区",
  411721: "西平县",
  411722: "上蔡县",
  411723: "平舆县",
  411724: "正阳县",
  411725: "确山县",
  411726: "泌阳县",
  411727: "汝南县",
  411728: "遂平县",
  411729: "新蔡县",
  411730: "其它区",
  42e4: "湖北省",
  420100: "武汉市",
  420102: "江岸区",
  420103: "江汉区",
  420104: "硚口区",
  420105: "汉阳区",
  420106: "武昌区",
  420107: "青山区",
  420111: "洪山区",
  420112: "东西湖区",
  420113: "汉南区",
  420114: "蔡甸区",
  420115: "江夏区",
  420116: "黄陂区",
  420117: "新洲区",
  420118: "其它区",
  420200: "黄石市",
  420202: "黄石港区",
  420203: "西塞山区",
  420204: "下陆区",
  420205: "铁山区",
  420222: "阳新县",
  420281: "大冶市",
  420282: "其它区",
  420300: "十堰市",
  420302: "茅箭区",
  420303: "张湾区",
  420321: "郧县",
  420322: "郧西县",
  420323: "竹山县",
  420324: "竹溪县",
  420325: "房县",
  420381: "丹江口市",
  420383: "其它区",
  420500: "宜昌市",
  420502: "西陵区",
  420503: "伍家岗区",
  420504: "点军区",
  420505: "猇亭区",
  420506: "夷陵区",
  420525: "远安县",
  420526: "兴山县",
  420527: "秭归县",
  420528: "长阳土家族自治县",
  420529: "五峰土家族自治县",
  420581: "宜都市",
  420582: "当阳市",
  420583: "枝江市",
  420584: "其它区",
  420600: "襄阳市",
  420602: "襄城区",
  420606: "樊城区",
  420607: "襄州区",
  420624: "南漳县",
  420625: "谷城县",
  420626: "保康县",
  420682: "老河口市",
  420683: "枣阳市",
  420684: "宜城市",
  420685: "其它区",
  420700: "鄂州市",
  420702: "梁子湖区",
  420703: "华容区",
  420704: "鄂城区",
  420705: "其它区",
  420800: "荆门市",
  420802: "东宝区",
  420804: "掇刀区",
  420821: "京山县",
  420822: "沙洋县",
  420881: "钟祥市",
  420882: "其它区",
  420900: "孝感市",
  420902: "孝南区",
  420921: "孝昌县",
  420922: "大悟县",
  420923: "云梦县",
  420981: "应城市",
  420982: "安陆市",
  420984: "汉川市",
  420985: "其它区",
  421e3: "荆州市",
  421002: "沙市区",
  421003: "荆州区",
  421022: "公安县",
  421023: "监利县",
  421024: "江陵县",
  421081: "石首市",
  421083: "洪湖市",
  421087: "松滋市",
  421088: "其它区",
  421100: "黄冈市",
  421102: "黄州区",
  421121: "团风县",
  421122: "红安县",
  421123: "罗田县",
  421124: "英山县",
  421125: "浠水县",
  421126: "蕲春县",
  421127: "黄梅县",
  421181: "麻城市",
  421182: "武穴市",
  421183: "其它区",
  421200: "咸宁市",
  421202: "咸安区",
  421221: "嘉鱼县",
  421222: "通城县",
  421223: "崇阳县",
  421224: "通山县",
  421281: "赤壁市",
  421283: "其它区",
  421300: "随州市",
  421302: "曾都区",
  421321: "随县",
  421381: "广水市",
  421382: "其它区",
  422800: "恩施土家族苗族自治州",
  422801: "恩施市",
  422802: "利川市",
  422822: "建始县",
  422823: "巴东县",
  422825: "宣恩县",
  422826: "咸丰县",
  422827: "来凤县",
  422828: "鹤峰县",
  422829: "其它区",
  429004: "仙桃市",
  429005: "潜江市",
  429006: "天门市",
  429021: "神农架林区",
  43e4: "湖南省",
  430100: "长沙市",
  430102: "芙蓉区",
  430103: "天心区",
  430104: "岳麓区",
  430105: "开福区",
  430111: "雨花区",
  430121: "长沙县",
  430122: "望城区",
  430124: "宁乡县",
  430181: "浏阳市",
  430182: "其它区",
  430200: "株洲市",
  430202: "荷塘区",
  430203: "芦淞区",
  430204: "石峰区",
  430211: "天元区",
  430221: "株洲县",
  430223: "攸县",
  430224: "茶陵县",
  430225: "炎陵县",
  430281: "醴陵市",
  430282: "其它区",
  430300: "湘潭市",
  430302: "雨湖区",
  430304: "岳塘区",
  430321: "湘潭县",
  430381: "湘乡市",
  430382: "韶山市",
  430383: "其它区",
  430400: "衡阳市",
  430405: "珠晖区",
  430406: "雁峰区",
  430407: "石鼓区",
  430408: "蒸湘区",
  430412: "南岳区",
  430421: "衡阳县",
  430422: "衡南县",
  430423: "衡山县",
  430424: "衡东县",
  430426: "祁东县",
  430481: "耒阳市",
  430482: "常宁市",
  430483: "其它区",
  430500: "邵阳市",
  430502: "双清区",
  430503: "大祥区",
  430511: "北塔区",
  430521: "邵东县",
  430522: "新邵县",
  430523: "邵阳县",
  430524: "隆回县",
  430525: "洞口县",
  430527: "绥宁县",
  430528: "新宁县",
  430529: "城步苗族自治县",
  430581: "武冈市",
  430582: "其它区",
  430600: "岳阳市",
  430602: "岳阳楼区",
  430603: "云溪区",
  430611: "君山区",
  430621: "岳阳县",
  430623: "华容县",
  430624: "湘阴县",
  430626: "平江县",
  430681: "汨罗市",
  430682: "临湘市",
  430683: "其它区",
  430700: "常德市",
  430702: "武陵区",
  430703: "鼎城区",
  430721: "安乡县",
  430722: "汉寿县",
  430723: "澧县",
  430724: "临澧县",
  430725: "桃源县",
  430726: "石门县",
  430781: "津市市",
  430782: "其它区",
  430800: "张家界市",
  430802: "永定区",
  430811: "武陵源区",
  430821: "慈利县",
  430822: "桑植县",
  430823: "其它区",
  430900: "益阳市",
  430902: "资阳区",
  430903: "赫山区",
  430921: "南县",
  430922: "桃江县",
  430923: "安化县",
  430981: "沅江市",
  430982: "其它区",
  431e3: "郴州市",
  431002: "北湖区",
  431003: "苏仙区",
  431021: "桂阳县",
  431022: "宜章县",
  431023: "永兴县",
  431024: "嘉禾县",
  431025: "临武县",
  431026: "汝城县",
  431027: "桂东县",
  431028: "安仁县",
  431081: "资兴市",
  431082: "其它区",
  431100: "永州市",
  431102: "零陵区",
  431103: "冷水滩区",
  431121: "祁阳县",
  431122: "东安县",
  431123: "双牌县",
  431124: "道县",
  431125: "江永县",
  431126: "宁远县",
  431127: "蓝山县",
  431128: "新田县",
  431129: "江华瑶族自治县",
  431130: "其它区",
  431200: "怀化市",
  431202: "鹤城区",
  431221: "中方县",
  431222: "沅陵县",
  431223: "辰溪县",
  431224: "溆浦县",
  431225: "会同县",
  431226: "麻阳苗族自治县",
  431227: "新晃侗族自治县",
  431228: "芷江侗族自治县",
  431229: "靖州苗族侗族自治县",
  431230: "通道侗族自治县",
  431281: "洪江市",
  431282: "其它区",
  431300: "娄底市",
  431302: "娄星区",
  431321: "双峰县",
  431322: "新化县",
  431381: "冷水江市",
  431382: "涟源市",
  431383: "其它区",
  433100: "湘西土家族苗族自治州",
  433101: "吉首市",
  433122: "泸溪县",
  433123: "凤凰县",
  433124: "花垣县",
  433125: "保靖县",
  433126: "古丈县",
  433127: "永顺县",
  433130: "龙山县",
  433131: "其它区",
  44e4: "广东省",
  440100: "广州市",
  440103: "荔湾区",
  440104: "越秀区",
  440105: "海珠区",
  440106: "天河区",
  440111: "白云区",
  440112: "黄埔区",
  440113: "番禺区",
  440114: "花都区",
  440115: "南沙区",
  440116: "萝岗区",
  440183: "增城市",
  440184: "从化市",
  440189: "其它区",
  440200: "韶关市",
  440203: "武江区",
  440204: "浈江区",
  440205: "曲江区",
  440222: "始兴县",
  440224: "仁化县",
  440229: "翁源县",
  440232: "乳源瑶族自治县",
  440233: "新丰县",
  440281: "乐昌市",
  440282: "南雄市",
  440283: "其它区",
  440300: "深圳市",
  440303: "罗湖区",
  440304: "福田区",
  440305: "南山区",
  440306: "宝安区",
  440307: "龙岗区",
  440308: "盐田区",
  440309: "其它区",
  440320: "光明新区",
  440321: "坪山新区",
  440322: "大鹏新区",
  440323: "龙华新区",
  440400: "珠海市",
  440402: "香洲区",
  440403: "斗门区",
  440404: "金湾区",
  440488: "其它区",
  440500: "汕头市",
  440507: "龙湖区",
  440511: "金平区",
  440512: "濠江区",
  440513: "潮阳区",
  440514: "潮南区",
  440515: "澄海区",
  440523: "南澳县",
  440524: "其它区",
  440600: "佛山市",
  440604: "禅城区",
  440605: "南海区",
  440606: "顺德区",
  440607: "三水区",
  440608: "高明区",
  440609: "其它区",
  440700: "江门市",
  440703: "蓬江区",
  440704: "江海区",
  440705: "新会区",
  440781: "台山市",
  440783: "开平市",
  440784: "鹤山市",
  440785: "恩平市",
  440786: "其它区",
  440800: "湛江市",
  440802: "赤坎区",
  440803: "霞山区",
  440804: "坡头区",
  440811: "麻章区",
  440823: "遂溪县",
  440825: "徐闻县",
  440881: "廉江市",
  440882: "雷州市",
  440883: "吴川市",
  440884: "其它区",
  440900: "茂名市",
  440902: "茂南区",
  440903: "茂港区",
  440923: "电白县",
  440981: "高州市",
  440982: "化州市",
  440983: "信宜市",
  440984: "其它区",
  441200: "肇庆市",
  441202: "端州区",
  441203: "鼎湖区",
  441223: "广宁县",
  441224: "怀集县",
  441225: "封开县",
  441226: "德庆县",
  441283: "高要市",
  441284: "四会市",
  441285: "其它区",
  441300: "惠州市",
  441302: "惠城区",
  441303: "惠阳区",
  441322: "博罗县",
  441323: "惠东县",
  441324: "龙门县",
  441325: "其它区",
  441400: "梅州市",
  441402: "梅江区",
  441421: "梅县",
  441422: "大埔县",
  441423: "丰顺县",
  441424: "五华县",
  441426: "平远县",
  441427: "蕉岭县",
  441481: "兴宁市",
  441482: "其它区",
  441500: "汕尾市",
  441502: "城区",
  441521: "海丰县",
  441523: "陆河县",
  441581: "陆丰市",
  441582: "其它区",
  441600: "河源市",
  441602: "源城区",
  441621: "紫金县",
  441622: "龙川县",
  441623: "连平县",
  441624: "和平县",
  441625: "东源县",
  441626: "其它区",
  441700: "阳江市",
  441702: "江城区",
  441721: "阳西县",
  441723: "阳东县",
  441781: "阳春市",
  441782: "其它区",
  441800: "清远市",
  441802: "清城区",
  441821: "佛冈县",
  441823: "阳山县",
  441825: "连山壮族瑶族自治县",
  441826: "连南瑶族自治县",
  441827: "清新区",
  441881: "英德市",
  441882: "连州市",
  441883: "其它区",
  441900: "东莞市",
  442e3: "中山市",
  442101: "东沙群岛",
  445100: "潮州市",
  445102: "湘桥区",
  445121: "潮安区",
  445122: "饶平县",
  445186: "其它区",
  445200: "揭阳市",
  445202: "榕城区",
  445221: "揭东区",
  445222: "揭西县",
  445224: "惠来县",
  445281: "普宁市",
  445285: "其它区",
  445300: "云浮市",
  445302: "云城区",
  445321: "新兴县",
  445322: "郁南县",
  445323: "云安县",
  445381: "罗定市",
  445382: "其它区",
  45e4: "广西壮族自治区",
  450100: "南宁市",
  450102: "兴宁区",
  450103: "青秀区",
  450105: "江南区",
  450107: "西乡塘区",
  450108: "良庆区",
  450109: "邕宁区",
  450122: "武鸣县",
  450123: "隆安县",
  450124: "马山县",
  450125: "上林县",
  450126: "宾阳县",
  450127: "横县",
  450128: "其它区",
  450200: "柳州市",
  450202: "城中区",
  450203: "鱼峰区",
  450204: "柳南区",
  450205: "柳北区",
  450221: "柳江县",
  450222: "柳城县",
  450223: "鹿寨县",
  450224: "融安县",
  450225: "融水苗族自治县",
  450226: "三江侗族自治县",
  450227: "其它区",
  450300: "桂林市",
  450302: "秀峰区",
  450303: "叠彩区",
  450304: "象山区",
  450305: "七星区",
  450311: "雁山区",
  450321: "阳朔县",
  450322: "临桂区",
  450323: "灵川县",
  450324: "全州县",
  450325: "兴安县",
  450326: "永福县",
  450327: "灌阳县",
  450328: "龙胜各族自治县",
  450329: "资源县",
  450330: "平乐县",
  450331: "荔浦县",
  450332: "恭城瑶族自治县",
  450333: "其它区",
  450400: "梧州市",
  450403: "万秀区",
  450405: "长洲区",
  450406: "龙圩区",
  450421: "苍梧县",
  450422: "藤县",
  450423: "蒙山县",
  450481: "岑溪市",
  450482: "其它区",
  450500: "北海市",
  450502: "海城区",
  450503: "银海区",
  450512: "铁山港区",
  450521: "合浦县",
  450522: "其它区",
  450600: "防城港市",
  450602: "港口区",
  450603: "防城区",
  450621: "上思县",
  450681: "东兴市",
  450682: "其它区",
  450700: "钦州市",
  450702: "钦南区",
  450703: "钦北区",
  450721: "灵山县",
  450722: "浦北县",
  450723: "其它区",
  450800: "贵港市",
  450802: "港北区",
  450803: "港南区",
  450804: "覃塘区",
  450821: "平南县",
  450881: "桂平市",
  450882: "其它区",
  450900: "玉林市",
  450902: "玉州区",
  450903: "福绵区",
  450921: "容县",
  450922: "陆川县",
  450923: "博白县",
  450924: "兴业县",
  450981: "北流市",
  450982: "其它区",
  451e3: "百色市",
  451002: "右江区",
  451021: "田阳县",
  451022: "田东县",
  451023: "平果县",
  451024: "德保县",
  451025: "靖西县",
  451026: "那坡县",
  451027: "凌云县",
  451028: "乐业县",
  451029: "田林县",
  451030: "西林县",
  451031: "隆林各族自治县",
  451032: "其它区",
  451100: "贺州市",
  451102: "八步区",
  451119: "平桂管理区",
  451121: "昭平县",
  451122: "钟山县",
  451123: "富川瑶族自治县",
  451124: "其它区",
  451200: "河池市",
  451202: "金城江区",
  451221: "南丹县",
  451222: "天峨县",
  451223: "凤山县",
  451224: "东兰县",
  451225: "罗城仫佬族自治县",
  451226: "环江毛南族自治县",
  451227: "巴马瑶族自治县",
  451228: "都安瑶族自治县",
  451229: "大化瑶族自治县",
  451281: "宜州市",
  451282: "其它区",
  451300: "来宾市",
  451302: "兴宾区",
  451321: "忻城县",
  451322: "象州县",
  451323: "武宣县",
  451324: "金秀瑶族自治县",
  451381: "合山市",
  451382: "其它区",
  451400: "崇左市",
  451402: "江州区",
  451421: "扶绥县",
  451422: "宁明县",
  451423: "龙州县",
  451424: "大新县",
  451425: "天等县",
  451481: "凭祥市",
  451482: "其它区",
  46e4: "海南省",
  460100: "海口市",
  460105: "秀英区",
  460106: "龙华区",
  460107: "琼山区",
  460108: "美兰区",
  460109: "其它区",
  460200: "三亚市",
  460300: "三沙市",
  460321: "西沙群岛",
  460322: "南沙群岛",
  460323: "中沙群岛的岛礁及其海域",
  469001: "五指山市",
  469002: "琼海市",
  469003: "儋州市",
  469005: "文昌市",
  469006: "万宁市",
  469007: "东方市",
  469025: "定安县",
  469026: "屯昌县",
  469027: "澄迈县",
  469028: "临高县",
  469030: "白沙黎族自治县",
  469031: "昌江黎族自治县",
  469033: "乐东黎族自治县",
  469034: "陵水黎族自治县",
  469035: "保亭黎族苗族自治县",
  469036: "琼中黎族苗族自治县",
  471005: "其它区",
  5e5: "重庆",
  500100: "重庆市",
  500101: "万州区",
  500102: "涪陵区",
  500103: "渝中区",
  500104: "大渡口区",
  500105: "江北区",
  500106: "沙坪坝区",
  500107: "九龙坡区",
  500108: "南岸区",
  500109: "北碚区",
  500110: "万盛区",
  500111: "双桥区",
  500112: "渝北区",
  500113: "巴南区",
  500114: "黔江区",
  500115: "长寿区",
  500222: "綦江区",
  500223: "潼南县",
  500224: "铜梁县",
  500225: "大足区",
  500226: "荣昌县",
  500227: "璧山县",
  500228: "梁平县",
  500229: "城口县",
  500230: "丰都县",
  500231: "垫江县",
  500232: "武隆县",
  500233: "忠县",
  500234: "开县",
  500235: "云阳县",
  500236: "奉节县",
  500237: "巫山县",
  500238: "巫溪县",
  500240: "石柱土家族自治县",
  500241: "秀山土家族苗族自治县",
  500242: "酉阳土家族苗族自治县",
  500243: "彭水苗族土家族自治县",
  500381: "江津区",
  500382: "合川区",
  500383: "永川区",
  500384: "南川区",
  500385: "其它区",
  51e4: "四川省",
  510100: "成都市",
  510104: "锦江区",
  510105: "青羊区",
  510106: "金牛区",
  510107: "武侯区",
  510108: "成华区",
  510112: "龙泉驿区",
  510113: "青白江区",
  510114: "新都区",
  510115: "温江区",
  510121: "金堂县",
  510122: "双流县",
  510124: "郫县",
  510129: "大邑县",
  510131: "蒲江县",
  510132: "新津县",
  510181: "都江堰市",
  510182: "彭州市",
  510183: "邛崃市",
  510184: "崇州市",
  510185: "其它区",
  510300: "自贡市",
  510302: "自流井区",
  510303: "贡井区",
  510304: "大安区",
  510311: "沿滩区",
  510321: "荣县",
  510322: "富顺县",
  510323: "其它区",
  510400: "攀枝花市",
  510402: "东区",
  510403: "西区",
  510411: "仁和区",
  510421: "米易县",
  510422: "盐边县",
  510423: "其它区",
  510500: "泸州市",
  510502: "江阳区",
  510503: "纳溪区",
  510504: "龙马潭区",
  510521: "泸县",
  510522: "合江县",
  510524: "叙永县",
  510525: "古蔺县",
  510526: "其它区",
  510600: "德阳市",
  510603: "旌阳区",
  510623: "中江县",
  510626: "罗江县",
  510681: "广汉市",
  510682: "什邡市",
  510683: "绵竹市",
  510684: "其它区",
  510700: "绵阳市",
  510703: "涪城区",
  510704: "游仙区",
  510722: "三台县",
  510723: "盐亭县",
  510724: "安县",
  510725: "梓潼县",
  510726: "北川羌族自治县",
  510727: "平武县",
  510781: "江油市",
  510782: "其它区",
  510800: "广元市",
  510802: "利州区",
  510811: "昭化区",
  510812: "朝天区",
  510821: "旺苍县",
  510822: "青川县",
  510823: "剑阁县",
  510824: "苍溪县",
  510825: "其它区",
  510900: "遂宁市",
  510903: "船山区",
  510904: "安居区",
  510921: "蓬溪县",
  510922: "射洪县",
  510923: "大英县",
  510924: "其它区",
  511e3: "内江市",
  511002: "市中区",
  511011: "东兴区",
  511024: "威远县",
  511025: "资中县",
  511028: "隆昌县",
  511029: "其它区",
  511100: "乐山市",
  511102: "市中区",
  511111: "沙湾区",
  511112: "五通桥区",
  511113: "金口河区",
  511123: "犍为县",
  511124: "井研县",
  511126: "夹江县",
  511129: "沐川县",
  511132: "峨边彝族自治县",
  511133: "马边彝族自治县",
  511181: "峨眉山市",
  511182: "其它区",
  511300: "南充市",
  511302: "顺庆区",
  511303: "高坪区",
  511304: "嘉陵区",
  511321: "南部县",
  511322: "营山县",
  511323: "蓬安县",
  511324: "仪陇县",
  511325: "西充县",
  511381: "阆中市",
  511382: "其它区",
  511400: "眉山市",
  511402: "东坡区",
  511421: "仁寿县",
  511422: "彭山县",
  511423: "洪雅县",
  511424: "丹棱县",
  511425: "青神县",
  511426: "其它区",
  511500: "宜宾市",
  511502: "翠屏区",
  511521: "宜宾县",
  511522: "南溪区",
  511523: "江安县",
  511524: "长宁县",
  511525: "高县",
  511526: "珙县",
  511527: "筠连县",
  511528: "兴文县",
  511529: "屏山县",
  511530: "其它区",
  511600: "广安市",
  511602: "广安区",
  511603: "前锋区",
  511621: "岳池县",
  511622: "武胜县",
  511623: "邻水县",
  511681: "华蓥市",
  511683: "其它区",
  511700: "达州市",
  511702: "通川区",
  511721: "达川区",
  511722: "宣汉县",
  511723: "开江县",
  511724: "大竹县",
  511725: "渠县",
  511781: "万源市",
  511782: "其它区",
  511800: "雅安市",
  511802: "雨城区",
  511821: "名山区",
  511822: "荥经县",
  511823: "汉源县",
  511824: "石棉县",
  511825: "天全县",
  511826: "芦山县",
  511827: "宝兴县",
  511828: "其它区",
  511900: "巴中市",
  511902: "巴州区",
  511903: "恩阳区",
  511921: "通江县",
  511922: "南江县",
  511923: "平昌县",
  511924: "其它区",
  512e3: "资阳市",
  512002: "雁江区",
  512021: "安岳县",
  512022: "乐至县",
  512081: "简阳市",
  512082: "其它区",
  513200: "阿坝藏族羌族自治州",
  513221: "汶川县",
  513222: "理县",
  513223: "茂县",
  513224: "松潘县",
  513225: "九寨沟县",
  513226: "金川县",
  513227: "小金县",
  513228: "黑水县",
  513229: "马尔康县",
  513230: "壤塘县",
  513231: "阿坝县",
  513232: "若尔盖县",
  513233: "红原县",
  513234: "其它区",
  513300: "甘孜藏族自治州",
  513321: "康定县",
  513322: "泸定县",
  513323: "丹巴县",
  513324: "九龙县",
  513325: "雅江县",
  513326: "道孚县",
  513327: "炉霍县",
  513328: "甘孜县",
  513329: "新龙县",
  513330: "德格县",
  513331: "白玉县",
  513332: "石渠县",
  513333: "色达县",
  513334: "理塘县",
  513335: "巴塘县",
  513336: "乡城县",
  513337: "稻城县",
  513338: "得荣县",
  513339: "其它区",
  513400: "凉山彝族自治州",
  513401: "西昌市",
  513422: "木里藏族自治县",
  513423: "盐源县",
  513424: "德昌县",
  513425: "会理县",
  513426: "会东县",
  513427: "宁南县",
  513428: "普格县",
  513429: "布拖县",
  513430: "金阳县",
  513431: "昭觉县",
  513432: "喜德县",
  513433: "冕宁县",
  513434: "越西县",
  513435: "甘洛县",
  513436: "美姑县",
  513437: "雷波县",
  513438: "其它区",
  52e4: "贵州省",
  520100: "贵阳市",
  520102: "南明区",
  520103: "云岩区",
  520111: "花溪区",
  520112: "乌当区",
  520113: "白云区",
  520121: "开阳县",
  520122: "息烽县",
  520123: "修文县",
  520151: "观山湖区",
  520181: "清镇市",
  520182: "其它区",
  520200: "六盘水市",
  520201: "钟山区",
  520203: "六枝特区",
  520221: "水城县",
  520222: "盘县",
  520223: "其它区",
  520300: "遵义市",
  520302: "红花岗区",
  520303: "汇川区",
  520321: "遵义县",
  520322: "桐梓县",
  520323: "绥阳县",
  520324: "正安县",
  520325: "道真仡佬族苗族自治县",
  520326: "务川仡佬族苗族自治县",
  520327: "凤冈县",
  520328: "湄潭县",
  520329: "余庆县",
  520330: "习水县",
  520381: "赤水市",
  520382: "仁怀市",
  520383: "其它区",
  520400: "安顺市",
  520402: "西秀区",
  520421: "平坝县",
  520422: "普定县",
  520423: "镇宁布依族苗族自治县",
  520424: "关岭布依族苗族自治县",
  520425: "紫云苗族布依族自治县",
  520426: "其它区",
  522200: "铜仁市",
  522201: "碧江区",
  522222: "江口县",
  522223: "玉屏侗族自治县",
  522224: "石阡县",
  522225: "思南县",
  522226: "印江土家族苗族自治县",
  522227: "德江县",
  522228: "沿河土家族自治县",
  522229: "松桃苗族自治县",
  522230: "万山区",
  522231: "其它区",
  522300: "黔西南布依族苗族自治州",
  522301: "兴义市",
  522322: "兴仁县",
  522323: "普安县",
  522324: "晴隆县",
  522325: "贞丰县",
  522326: "望谟县",
  522327: "册亨县",
  522328: "安龙县",
  522329: "其它区",
  522400: "毕节市",
  522401: "七星关区",
  522422: "大方县",
  522423: "黔西县",
  522424: "金沙县",
  522425: "织金县",
  522426: "纳雍县",
  522427: "威宁彝族回族苗族自治县",
  522428: "赫章县",
  522429: "其它区",
  522600: "黔东南苗族侗族自治州",
  522601: "凯里市",
  522622: "黄平县",
  522623: "施秉县",
  522624: "三穗县",
  522625: "镇远县",
  522626: "岑巩县",
  522627: "天柱县",
  522628: "锦屏县",
  522629: "剑河县",
  522630: "台江县",
  522631: "黎平县",
  522632: "榕江县",
  522633: "从江县",
  522634: "雷山县",
  522635: "麻江县",
  522636: "丹寨县",
  522637: "其它区",
  522700: "黔南布依族苗族自治州",
  522701: "都匀市",
  522702: "福泉市",
  522722: "荔波县",
  522723: "贵定县",
  522725: "瓮安县",
  522726: "独山县",
  522727: "平塘县",
  522728: "罗甸县",
  522729: "长顺县",
  522730: "龙里县",
  522731: "惠水县",
  522732: "三都水族自治县",
  522733: "其它区",
  53e4: "云南省",
  530100: "昆明市",
  530102: "五华区",
  530103: "盘龙区",
  530111: "官渡区",
  530112: "西山区",
  530113: "东川区",
  530121: "呈贡区",
  530122: "晋宁县",
  530124: "富民县",
  530125: "宜良县",
  530126: "石林彝族自治县",
  530127: "嵩明县",
  530128: "禄劝彝族苗族自治县",
  530129: "寻甸回族彝族自治县",
  530181: "安宁市",
  530182: "其它区",
  530300: "曲靖市",
  530302: "麒麟区",
  530321: "马龙县",
  530322: "陆良县",
  530323: "师宗县",
  530324: "罗平县",
  530325: "富源县",
  530326: "会泽县",
  530328: "沾益县",
  530381: "宣威市",
  530382: "其它区",
  530400: "玉溪市",
  530402: "红塔区",
  530421: "江川县",
  530422: "澄江县",
  530423: "通海县",
  530424: "华宁县",
  530425: "易门县",
  530426: "峨山彝族自治县",
  530427: "新平彝族傣族自治县",
  530428: "元江哈尼族彝族傣族自治县",
  530429: "其它区",
  530500: "保山市",
  530502: "隆阳区",
  530521: "施甸县",
  530522: "腾冲县",
  530523: "龙陵县",
  530524: "昌宁县",
  530525: "其它区",
  530600: "昭通市",
  530602: "昭阳区",
  530621: "鲁甸县",
  530622: "巧家县",
  530623: "盐津县",
  530624: "大关县",
  530625: "永善县",
  530626: "绥江县",
  530627: "镇雄县",
  530628: "彝良县",
  530629: "威信县",
  530630: "水富县",
  530631: "其它区",
  530700: "丽江市",
  530702: "古城区",
  530721: "玉龙纳西族自治县",
  530722: "永胜县",
  530723: "华坪县",
  530724: "宁蒗彝族自治县",
  530725: "其它区",
  530800: "普洱市",
  530802: "思茅区",
  530821: "宁洱哈尼族彝族自治县",
  530822: "墨江哈尼族自治县",
  530823: "景东彝族自治县",
  530824: "景谷傣族彝族自治县",
  530825: "镇沅彝族哈尼族拉祜族自治县",
  530826: "江城哈尼族彝族自治县",
  530827: "孟连傣族拉祜族佤族自治县",
  530828: "澜沧拉祜族自治县",
  530829: "西盟佤族自治县",
  530830: "其它区",
  530900: "临沧市",
  530902: "临翔区",
  530921: "凤庆县",
  530922: "云县",
  530923: "永德县",
  530924: "镇康县",
  530925: "双江拉祜族佤族布朗族傣族自治县",
  530926: "耿马傣族佤族自治县",
  530927: "沧源佤族自治县",
  530928: "其它区",
  532300: "楚雄彝族自治州",
  532301: "楚雄市",
  532322: "双柏县",
  532323: "牟定县",
  532324: "南华县",
  532325: "姚安县",
  532326: "大姚县",
  532327: "永仁县",
  532328: "元谋县",
  532329: "武定县",
  532331: "禄丰县",
  532332: "其它区",
  532500: "红河哈尼族彝族自治州",
  532501: "个旧市",
  532502: "开远市",
  532522: "蒙自市",
  532523: "屏边苗族自治县",
  532524: "建水县",
  532525: "石屏县",
  532526: "弥勒市",
  532527: "泸西县",
  532528: "元阳县",
  532529: "红河县",
  532530: "金平苗族瑶族傣族自治县",
  532531: "绿春县",
  532532: "河口瑶族自治县",
  532533: "其它区",
  532600: "文山壮族苗族自治州",
  532621: "文山市",
  532622: "砚山县",
  532623: "西畴县",
  532624: "麻栗坡县",
  532625: "马关县",
  532626: "丘北县",
  532627: "广南县",
  532628: "富宁县",
  532629: "其它区",
  532800: "西双版纳傣族自治州",
  532801: "景洪市",
  532822: "勐海县",
  532823: "勐腊县",
  532824: "其它区",
  532900: "大理白族自治州",
  532901: "大理市",
  532922: "漾濞彝族自治县",
  532923: "祥云县",
  532924: "宾川县",
  532925: "弥渡县",
  532926: "南涧彝族自治县",
  532927: "巍山彝族回族自治县",
  532928: "永平县",
  532929: "云龙县",
  532930: "洱源县",
  532931: "剑川县",
  532932: "鹤庆县",
  532933: "其它区",
  533100: "德宏傣族景颇族自治州",
  533102: "瑞丽市",
  533103: "芒市",
  533122: "梁河县",
  533123: "盈江县",
  533124: "陇川县",
  533125: "其它区",
  533300: "怒江傈僳族自治州",
  533321: "泸水县",
  533323: "福贡县",
  533324: "贡山独龙族怒族自治县",
  533325: "兰坪白族普米族自治县",
  533326: "其它区",
  533400: "迪庆藏族自治州",
  533421: "香格里拉县",
  533422: "德钦县",
  533423: "维西傈僳族自治县",
  533424: "其它区",
  54e4: "西藏自治区",
  540100: "拉萨市",
  540102: "城关区",
  540121: "林周县",
  540122: "当雄县",
  540123: "尼木县",
  540124: "曲水县",
  540125: "堆龙德庆县",
  540126: "达孜县",
  540127: "墨竹工卡县",
  540128: "其它区",
  542100: "昌都地区",
  542121: "昌都县",
  542122: "江达县",
  542123: "贡觉县",
  542124: "类乌齐县",
  542125: "丁青县",
  542126: "察雅县",
  542127: "八宿县",
  542128: "左贡县",
  542129: "芒康县",
  542132: "洛隆县",
  542133: "边坝县",
  542134: "其它区",
  542200: "山南地区",
  542221: "乃东县",
  542222: "扎囊县",
  542223: "贡嘎县",
  542224: "桑日县",
  542225: "琼结县",
  542226: "曲松县",
  542227: "措美县",
  542228: "洛扎县",
  542229: "加查县",
  542231: "隆子县",
  542232: "错那县",
  542233: "浪卡子县",
  542234: "其它区",
  542300: "日喀则地区",
  542301: "日喀则市",
  542322: "南木林县",
  542323: "江孜县",
  542324: "定日县",
  542325: "萨迦县",
  542326: "拉孜县",
  542327: "昂仁县",
  542328: "谢通门县",
  542329: "白朗县",
  542330: "仁布县",
  542331: "康马县",
  542332: "定结县",
  542333: "仲巴县",
  542334: "亚东县",
  542335: "吉隆县",
  542336: "聂拉木县",
  542337: "萨嘎县",
  542338: "岗巴县",
  542339: "其它区",
  542400: "那曲地区",
  542421: "那曲县",
  542422: "嘉黎县",
  542423: "比如县",
  542424: "聂荣县",
  542425: "安多县",
  542426: "申扎县",
  542427: "索县",
  542428: "班戈县",
  542429: "巴青县",
  542430: "尼玛县",
  542431: "其它区",
  542432: "双湖县",
  542500: "阿里地区",
  542521: "普兰县",
  542522: "札达县",
  542523: "噶尔县",
  542524: "日土县",
  542525: "革吉县",
  542526: "改则县",
  542527: "措勤县",
  542528: "其它区",
  542600: "林芝地区",
  542621: "林芝县",
  542622: "工布江达县",
  542623: "米林县",
  542624: "墨脱县",
  542625: "波密县",
  542626: "察隅县",
  542627: "朗县",
  542628: "其它区",
  61e4: "陕西省",
  610100: "西安市",
  610102: "新城区",
  610103: "碑林区",
  610104: "莲湖区",
  610111: "灞桥区",
  610112: "未央区",
  610113: "雁塔区",
  610114: "阎良区",
  610115: "临潼区",
  610116: "长安区",
  610122: "蓝田县",
  610124: "周至县",
  610125: "户县",
  610126: "高陵县",
  610127: "其它区",
  610200: "铜川市",
  610202: "王益区",
  610203: "印台区",
  610204: "耀州区",
  610222: "宜君县",
  610223: "其它区",
  610300: "宝鸡市",
  610302: "渭滨区",
  610303: "金台区",
  610304: "陈仓区",
  610322: "凤翔县",
  610323: "岐山县",
  610324: "扶风县",
  610326: "眉县",
  610327: "陇县",
  610328: "千阳县",
  610329: "麟游县",
  610330: "凤县",
  610331: "太白县",
  610332: "其它区",
  610400: "咸阳市",
  610402: "秦都区",
  610403: "杨陵区",
  610404: "渭城区",
  610422: "三原县",
  610423: "泾阳县",
  610424: "乾县",
  610425: "礼泉县",
  610426: "永寿县",
  610427: "彬县",
  610428: "长武县",
  610429: "旬邑县",
  610430: "淳化县",
  610431: "武功县",
  610481: "兴平市",
  610482: "其它区",
  610500: "渭南市",
  610502: "临渭区",
  610521: "华县",
  610522: "潼关县",
  610523: "大荔县",
  610524: "合阳县",
  610525: "澄城县",
  610526: "蒲城县",
  610527: "白水县",
  610528: "富平县",
  610581: "韩城市",
  610582: "华阴市",
  610583: "其它区",
  610600: "延安市",
  610602: "宝塔区",
  610621: "延长县",
  610622: "延川县",
  610623: "子长县",
  610624: "安塞县",
  610625: "志丹县",
  610626: "吴起县",
  610627: "甘泉县",
  610628: "富县",
  610629: "洛川县",
  610630: "宜川县",
  610631: "黄龙县",
  610632: "黄陵县",
  610633: "其它区",
  610700: "汉中市",
  610702: "汉台区",
  610721: "南郑县",
  610722: "城固县",
  610723: "洋县",
  610724: "西乡县",
  610725: "勉县",
  610726: "宁强县",
  610727: "略阳县",
  610728: "镇巴县",
  610729: "留坝县",
  610730: "佛坪县",
  610731: "其它区",
  610800: "榆林市",
  610802: "榆阳区",
  610821: "神木县",
  610822: "府谷县",
  610823: "横山县",
  610824: "靖边县",
  610825: "定边县",
  610826: "绥德县",
  610827: "米脂县",
  610828: "佳县",
  610829: "吴堡县",
  610830: "清涧县",
  610831: "子洲县",
  610832: "其它区",
  610900: "安康市",
  610902: "汉滨区",
  610921: "汉阴县",
  610922: "石泉县",
  610923: "宁陕县",
  610924: "紫阳县",
  610925: "岚皋县",
  610926: "平利县",
  610927: "镇坪县",
  610928: "旬阳县",
  610929: "白河县",
  610930: "其它区",
  611e3: "商洛市",
  611002: "商州区",
  611021: "洛南县",
  611022: "丹凤县",
  611023: "商南县",
  611024: "山阳县",
  611025: "镇安县",
  611026: "柞水县",
  611027: "其它区",
  62e4: "甘肃省",
  620100: "兰州市",
  620102: "城关区",
  620103: "七里河区",
  620104: "西固区",
  620105: "安宁区",
  620111: "红古区",
  620121: "永登县",
  620122: "皋兰县",
  620123: "榆中县",
  620124: "其它区",
  620200: "嘉峪关市",
  620300: "金昌市",
  620302: "金川区",
  620321: "永昌县",
  620322: "其它区",
  620400: "白银市",
  620402: "白银区",
  620403: "平川区",
  620421: "靖远县",
  620422: "会宁县",
  620423: "景泰县",
  620424: "其它区",
  620500: "天水市",
  620502: "秦州区",
  620503: "麦积区",
  620521: "清水县",
  620522: "秦安县",
  620523: "甘谷县",
  620524: "武山县",
  620525: "张家川回族自治县",
  620526: "其它区",
  620600: "武威市",
  620602: "凉州区",
  620621: "民勤县",
  620622: "古浪县",
  620623: "天祝藏族自治县",
  620624: "其它区",
  620700: "张掖市",
  620702: "甘州区",
  620721: "肃南裕固族自治县",
  620722: "民乐县",
  620723: "临泽县",
  620724: "高台县",
  620725: "山丹县",
  620726: "其它区",
  620800: "平凉市",
  620802: "崆峒区",
  620821: "泾川县",
  620822: "灵台县",
  620823: "崇信县",
  620824: "华亭县",
  620825: "庄浪县",
  620826: "静宁县",
  620827: "其它区",
  620900: "酒泉市",
  620902: "肃州区",
  620921: "金塔县",
  620922: "瓜州县",
  620923: "肃北蒙古族自治县",
  620924: "阿克塞哈萨克族自治县",
  620981: "玉门市",
  620982: "敦煌市",
  620983: "其它区",
  621e3: "庆阳市",
  621002: "西峰区",
  621021: "庆城县",
  621022: "环县",
  621023: "华池县",
  621024: "合水县",
  621025: "正宁县",
  621026: "宁县",
  621027: "镇原县",
  621028: "其它区",
  621100: "定西市",
  621102: "安定区",
  621121: "通渭县",
  621122: "陇西县",
  621123: "渭源县",
  621124: "临洮县",
  621125: "漳县",
  621126: "岷县",
  621127: "其它区",
  621200: "陇南市",
  621202: "武都区",
  621221: "成县",
  621222: "文县",
  621223: "宕昌县",
  621224: "康县",
  621225: "西和县",
  621226: "礼县",
  621227: "徽县",
  621228: "两当县",
  621229: "其它区",
  622900: "临夏回族自治州",
  622901: "临夏市",
  622921: "临夏县",
  622922: "康乐县",
  622923: "永靖县",
  622924: "广河县",
  622925: "和政县",
  622926: "东乡族自治县",
  622927: "积石山保安族东乡族撒拉族自治县",
  622928: "其它区",
  623e3: "甘南藏族自治州",
  623001: "合作市",
  623021: "临潭县",
  623022: "卓尼县",
  623023: "舟曲县",
  623024: "迭部县",
  623025: "玛曲县",
  623026: "碌曲县",
  623027: "夏河县",
  623028: "其它区",
  63e4: "青海省",
  630100: "西宁市",
  630102: "城东区",
  630103: "城中区",
  630104: "城西区",
  630105: "城北区",
  630121: "大通回族土族自治县",
  630122: "湟中县",
  630123: "湟源县",
  630124: "其它区",
  632100: "海东市",
  632121: "平安县",
  632122: "民和回族土族自治县",
  632123: "乐都区",
  632126: "互助土族自治县",
  632127: "化隆回族自治县",
  632128: "循化撒拉族自治县",
  632129: "其它区",
  632200: "海北藏族自治州",
  632221: "门源回族自治县",
  632222: "祁连县",
  632223: "海晏县",
  632224: "刚察县",
  632225: "其它区",
  632300: "黄南藏族自治州",
  632321: "同仁县",
  632322: "尖扎县",
  632323: "泽库县",
  632324: "河南蒙古族自治县",
  632325: "其它区",
  632500: "海南藏族自治州",
  632521: "共和县",
  632522: "同德县",
  632523: "贵德县",
  632524: "兴海县",
  632525: "贵南县",
  632526: "其它区",
  632600: "果洛藏族自治州",
  632621: "玛沁县",
  632622: "班玛县",
  632623: "甘德县",
  632624: "达日县",
  632625: "久治县",
  632626: "玛多县",
  632627: "其它区",
  632700: "玉树藏族自治州",
  632721: "玉树市",
  632722: "杂多县",
  632723: "称多县",
  632724: "治多县",
  632725: "囊谦县",
  632726: "曲麻莱县",
  632727: "其它区",
  632800: "海西蒙古族藏族自治州",
  632801: "格尔木市",
  632802: "德令哈市",
  632821: "乌兰县",
  632822: "都兰县",
  632823: "天峻县",
  632824: "其它区",
  64e4: "宁夏回族自治区",
  640100: "银川市",
  640104: "兴庆区",
  640105: "西夏区",
  640106: "金凤区",
  640121: "永宁县",
  640122: "贺兰县",
  640181: "灵武市",
  640182: "其它区",
  640200: "石嘴山市",
  640202: "大武口区",
  640205: "惠农区",
  640221: "平罗县",
  640222: "其它区",
  640300: "吴忠市",
  640302: "利通区",
  640303: "红寺堡区",
  640323: "盐池县",
  640324: "同心县",
  640381: "青铜峡市",
  640382: "其它区",
  640400: "固原市",
  640402: "原州区",
  640422: "西吉县",
  640423: "隆德县",
  640424: "泾源县",
  640425: "彭阳县",
  640426: "其它区",
  640500: "中卫市",
  640502: "沙坡头区",
  640521: "中宁县",
  640522: "海原县",
  640523: "其它区",
  65e4: "新疆维吾尔自治区",
  650100: "乌鲁木齐市",
  650102: "天山区",
  650103: "沙依巴克区",
  650104: "新市区",
  650105: "水磨沟区",
  650106: "头屯河区",
  650107: "达坂城区",
  650109: "米东区",
  650121: "乌鲁木齐县",
  650122: "其它区",
  650200: "克拉玛依市",
  650202: "独山子区",
  650203: "克拉玛依区",
  650204: "白碱滩区",
  650205: "乌尔禾区",
  650206: "其它区",
  652100: "吐鲁番地区",
  652101: "吐鲁番市",
  652122: "鄯善县",
  652123: "托克逊县",
  652124: "其它区",
  652200: "哈密地区",
  652201: "哈密市",
  652222: "巴里坤哈萨克自治县",
  652223: "伊吾县",
  652224: "其它区",
  652300: "昌吉回族自治州",
  652301: "昌吉市",
  652302: "阜康市",
  652323: "呼图壁县",
  652324: "玛纳斯县",
  652325: "奇台县",
  652327: "吉木萨尔县",
  652328: "木垒哈萨克自治县",
  652329: "其它区",
  652700: "博尔塔拉蒙古自治州",
  652701: "博乐市",
  652702: "阿拉山口市",
  652722: "精河县",
  652723: "温泉县",
  652724: "其它区",
  652800: "巴音郭楞蒙古自治州",
  652801: "库尔勒市",
  652822: "轮台县",
  652823: "尉犁县",
  652824: "若羌县",
  652825: "且末县",
  652826: "焉耆回族自治县",
  652827: "和静县",
  652828: "和硕县",
  652829: "博湖县",
  652830: "其它区",
  652900: "阿克苏地区",
  652901: "阿克苏市",
  652922: "温宿县",
  652923: "库车县",
  652924: "沙雅县",
  652925: "新和县",
  652926: "拜城县",
  652927: "乌什县",
  652928: "阿瓦提县",
  652929: "柯坪县",
  652930: "其它区",
  653e3: "克孜勒苏柯尔克孜自治州",
  653001: "阿图什市",
  653022: "阿克陶县",
  653023: "阿合奇县",
  653024: "乌恰县",
  653025: "其它区",
  653100: "喀什地区",
  653101: "喀什市",
  653121: "疏附县",
  653122: "疏勒县",
  653123: "英吉沙县",
  653124: "泽普县",
  653125: "莎车县",
  653126: "叶城县",
  653127: "麦盖提县",
  653128: "岳普湖县",
  653129: "伽师县",
  653130: "巴楚县",
  653131: "塔什库尔干塔吉克自治县",
  653132: "其它区",
  653200: "和田地区",
  653201: "和田市",
  653221: "和田县",
  653222: "墨玉县",
  653223: "皮山县",
  653224: "洛浦县",
  653225: "策勒县",
  653226: "于田县",
  653227: "民丰县",
  653228: "其它区",
  654e3: "伊犁哈萨克自治州",
  654002: "伊宁市",
  654003: "奎屯市",
  654021: "伊宁县",
  654022: "察布查尔锡伯自治县",
  654023: "霍城县",
  654024: "巩留县",
  654025: "新源县",
  654026: "昭苏县",
  654027: "特克斯县",
  654028: "尼勒克县",
  654029: "其它区",
  654200: "塔城地区",
  654201: "塔城市",
  654202: "乌苏市",
  654221: "额敏县",
  654223: "沙湾县",
  654224: "托里县",
  654225: "裕民县",
  654226: "和布克赛尔蒙古自治县",
  654227: "其它区",
  654300: "阿勒泰地区",
  654301: "阿勒泰市",
  654321: "布尔津县",
  654322: "富蕴县",
  654323: "福海县",
  654324: "哈巴河县",
  654325: "青河县",
  654326: "吉木乃县",
  654327: "其它区",
  659001: "石河子市",
  659002: "阿拉尔市",
  659003: "图木舒克市",
  659004: "五家渠市",
  71e4: "台湾",
  710100: "台北市",
  710101: "中正区",
  710102: "大同区",
  710103: "中山区",
  710104: "松山区",
  710105: "大安区",
  710106: "万华区",
  710107: "信义区",
  710108: "士林区",
  710109: "北投区",
  710110: "内湖区",
  710111: "南港区",
  710112: "文山区",
  710113: "其它区",
  710200: "高雄市",
  710201: "新兴区",
  710202: "前金区",
  710203: "芩雅区",
  710204: "盐埕区",
  710205: "鼓山区",
  710206: "旗津区",
  710207: "前镇区",
  710208: "三民区",
  710209: "左营区",
  710210: "楠梓区",
  710211: "小港区",
  710212: "其它区",
  710241: "苓雅区",
  710242: "仁武区",
  710243: "大社区",
  710244: "冈山区",
  710245: "路竹区",
  710246: "阿莲区",
  710247: "田寮区",
  710248: "燕巢区",
  710249: "桥头区",
  710250: "梓官区",
  710251: "弥陀区",
  710252: "永安区",
  710253: "湖内区",
  710254: "凤山区",
  710255: "大寮区",
  710256: "林园区",
  710257: "鸟松区",
  710258: "大树区",
  710259: "旗山区",
  710260: "美浓区",
  710261: "六龟区",
  710262: "内门区",
  710263: "杉林区",
  710264: "甲仙区",
  710265: "桃源区",
  710266: "那玛夏区",
  710267: "茂林区",
  710268: "茄萣区",
  710300: "台南市",
  710301: "中西区",
  710302: "东区",
  710303: "南区",
  710304: "北区",
  710305: "安平区",
  710306: "安南区",
  710307: "其它区",
  710339: "永康区",
  710340: "归仁区",
  710341: "新化区",
  710342: "左镇区",
  710343: "玉井区",
  710344: "楠西区",
  710345: "南化区",
  710346: "仁德区",
  710347: "关庙区",
  710348: "龙崎区",
  710349: "官田区",
  710350: "麻豆区",
  710351: "佳里区",
  710352: "西港区",
  710353: "七股区",
  710354: "将军区",
  710355: "学甲区",
  710356: "北门区",
  710357: "新营区",
  710358: "后壁区",
  710359: "白河区",
  710360: "东山区",
  710361: "六甲区",
  710362: "下营区",
  710363: "柳营区",
  710364: "盐水区",
  710365: "善化区",
  710366: "大内区",
  710367: "山上区",
  710368: "新市区",
  710369: "安定区",
  710400: "台中市",
  710401: "中区",
  710402: "东区",
  710403: "南区",
  710404: "西区",
  710405: "北区",
  710406: "北屯区",
  710407: "西屯区",
  710408: "南屯区",
  710409: "其它区",
  710431: "太平区",
  710432: "大里区",
  710433: "雾峰区",
  710434: "乌日区",
  710435: "丰原区",
  710436: "后里区",
  710437: "石冈区",
  710438: "东势区",
  710439: "和平区",
  710440: "新社区",
  710441: "潭子区",
  710442: "大雅区",
  710443: "神冈区",
  710444: "大肚区",
  710445: "沙鹿区",
  710446: "龙井区",
  710447: "梧栖区",
  710448: "清水区",
  710449: "大甲区",
  710450: "外埔区",
  710451: "大安区",
  710500: "金门县",
  710507: "金沙镇",
  710508: "金湖镇",
  710509: "金宁乡",
  710510: "金城镇",
  710511: "烈屿乡",
  710512: "乌坵乡",
  710600: "南投县",
  710614: "南投市",
  710615: "中寮乡",
  710616: "草屯镇",
  710617: "国姓乡",
  710618: "埔里镇",
  710619: "仁爱乡",
  710620: "名间乡",
  710621: "集集镇",
  710622: "水里乡",
  710623: "鱼池乡",
  710624: "信义乡",
  710625: "竹山镇",
  710626: "鹿谷乡",
  710700: "基隆市",
  710701: "仁爱区",
  710702: "信义区",
  710703: "中正区",
  710704: "中山区",
  710705: "安乐区",
  710706: "暖暖区",
  710707: "七堵区",
  710708: "其它区",
  710800: "新竹市",
  710801: "东区",
  710802: "北区",
  710803: "香山区",
  710804: "其它区",
  710900: "嘉义市",
  710901: "东区",
  710902: "西区",
  710903: "其它区",
  711100: "新北市",
  711130: "万里区",
  711131: "金山区",
  711132: "板桥区",
  711133: "汐止区",
  711134: "深坑区",
  711135: "石碇区",
  711136: "瑞芳区",
  711137: "平溪区",
  711138: "双溪区",
  711139: "贡寮区",
  711140: "新店区",
  711141: "坪林区",
  711142: "乌来区",
  711143: "永和区",
  711144: "中和区",
  711145: "土城区",
  711146: "三峡区",
  711147: "树林区",
  711148: "莺歌区",
  711149: "三重区",
  711150: "新庄区",
  711151: "泰山区",
  711152: "林口区",
  711153: "芦洲区",
  711154: "五股区",
  711155: "八里区",
  711156: "淡水区",
  711157: "三芝区",
  711158: "石门区",
  711200: "宜兰县",
  711214: "宜兰市",
  711215: "头城镇",
  711216: "礁溪乡",
  711217: "壮围乡",
  711218: "员山乡",
  711219: "罗东镇",
  711220: "三星乡",
  711221: "大同乡",
  711222: "五结乡",
  711223: "冬山乡",
  711224: "苏澳镇",
  711225: "南澳乡",
  711226: "钓鱼台",
  711300: "新竹县",
  711314: "竹北市",
  711315: "湖口乡",
  711316: "新丰乡",
  711317: "新埔镇",
  711318: "关西镇",
  711319: "芎林乡",
  711320: "宝山乡",
  711321: "竹东镇",
  711322: "五峰乡",
  711323: "横山乡",
  711324: "尖石乡",
  711325: "北埔乡",
  711326: "峨眉乡",
  711400: "桃园县",
  711414: "中坜市",
  711415: "平镇市",
  711416: "龙潭乡",
  711417: "杨梅市",
  711418: "新屋乡",
  711419: "观音乡",
  711420: "桃园市",
  711421: "龟山乡",
  711422: "八德市",
  711423: "大溪镇",
  711424: "复兴乡",
  711425: "大园乡",
  711426: "芦竹乡",
  711500: "苗栗县",
  711519: "竹南镇",
  711520: "头份镇",
  711521: "三湾乡",
  711522: "南庄乡",
  711523: "狮潭乡",
  711524: "后龙镇",
  711525: "通霄镇",
  711526: "苑里镇",
  711527: "苗栗市",
  711528: "造桥乡",
  711529: "头屋乡",
  711530: "公馆乡",
  711531: "大湖乡",
  711532: "泰安乡",
  711533: "铜锣乡",
  711534: "三义乡",
  711535: "西湖乡",
  711536: "卓兰镇",
  711700: "彰化县",
  711727: "彰化市",
  711728: "芬园乡",
  711729: "花坛乡",
  711730: "秀水乡",
  711731: "鹿港镇",
  711732: "福兴乡",
  711733: "线西乡",
  711734: "和美镇",
  711735: "伸港乡",
  711736: "员林镇",
  711737: "社头乡",
  711738: "永靖乡",
  711739: "埔心乡",
  711740: "溪湖镇",
  711741: "大村乡",
  711742: "埔盐乡",
  711743: "田中镇",
  711744: "北斗镇",
  711745: "田尾乡",
  711746: "埤头乡",
  711747: "溪州乡",
  711748: "竹塘乡",
  711749: "二林镇",
  711750: "大城乡",
  711751: "芳苑乡",
  711752: "二水乡",
  711900: "嘉义县",
  711919: "番路乡",
  711920: "梅山乡",
  711921: "竹崎乡",
  711922: "阿里山乡",
  711923: "中埔乡",
  711924: "大埔乡",
  711925: "水上乡",
  711926: "鹿草乡",
  711927: "太保市",
  711928: "朴子市",
  711929: "东石乡",
  711930: "六脚乡",
  711931: "新港乡",
  711932: "民雄乡",
  711933: "大林镇",
  711934: "溪口乡",
  711935: "义竹乡",
  711936: "布袋镇",
  712100: "云林县",
  712121: "斗南镇",
  712122: "大埤乡",
  712123: "虎尾镇",
  712124: "土库镇",
  712125: "褒忠乡",
  712126: "东势乡",
  712127: "台西乡",
  712128: "仑背乡",
  712129: "麦寮乡",
  712130: "斗六市",
  712131: "林内乡",
  712132: "古坑乡",
  712133: "莿桐乡",
  712134: "西螺镇",
  712135: "二仑乡",
  712136: "北港镇",
  712137: "水林乡",
  712138: "口湖乡",
  712139: "四湖乡",
  712140: "元长乡",
  712400: "屏东县",
  712434: "屏东市",
  712435: "三地门乡",
  712436: "雾台乡",
  712437: "玛家乡",
  712438: "九如乡",
  712439: "里港乡",
  712440: "高树乡",
  712441: "盐埔乡",
  712442: "长治乡",
  712443: "麟洛乡",
  712444: "竹田乡",
  712445: "内埔乡",
  712446: "万丹乡",
  712447: "潮州镇",
  712448: "泰武乡",
  712449: "来义乡",
  712450: "万峦乡",
  712451: "崁顶乡",
  712452: "新埤乡",
  712453: "南州乡",
  712454: "林边乡",
  712455: "东港镇",
  712456: "琉球乡",
  712457: "佳冬乡",
  712458: "新园乡",
  712459: "枋寮乡",
  712460: "枋山乡",
  712461: "春日乡",
  712462: "狮子乡",
  712463: "车城乡",
  712464: "牡丹乡",
  712465: "恒春镇",
  712466: "满州乡",
  712500: "台东县",
  712517: "台东市",
  712518: "绿岛乡",
  712519: "兰屿乡",
  712520: "延平乡",
  712521: "卑南乡",
  712522: "鹿野乡",
  712523: "关山镇",
  712524: "海端乡",
  712525: "池上乡",
  712526: "东河乡",
  712527: "成功镇",
  712528: "长滨乡",
  712529: "金峰乡",
  712530: "大武乡",
  712531: "达仁乡",
  712532: "太麻里乡",
  712600: "花莲县",
  712615: "花莲市",
  712616: "新城乡",
  712617: "太鲁阁",
  712618: "秀林乡",
  712619: "吉安乡",
  712620: "寿丰乡",
  712621: "凤林镇",
  712622: "光复乡",
  712623: "丰滨乡",
  712624: "瑞穗乡",
  712625: "万荣乡",
  712626: "玉里镇",
  712627: "卓溪乡",
  712628: "富里乡",
  712700: "澎湖县",
  712707: "马公市",
  712708: "西屿乡",
  712709: "望安乡",
  712710: "七美乡",
  712711: "白沙乡",
  712712: "湖西乡",
  712800: "连江县",
  712805: "南竿乡",
  712806: "北竿乡",
  712807: "莒光乡",
  712808: "东引乡",
  81e4: "香港特别行政区",
  810100: "香港岛",
  810101: "中西区",
  810102: "湾仔",
  810103: "东区",
  810104: "南区",
  810200: "九龙",
  810201: "九龙城区",
  810202: "油尖旺区",
  810203: "深水埗区",
  810204: "黄大仙区",
  810205: "观塘区",
  810300: "新界",
  810301: "北区",
  810302: "大埔区",
  810303: "沙田区",
  810304: "西贡区",
  810305: "元朗区",
  810306: "屯门区",
  810307: "荃湾区",
  810308: "葵青区",
  810309: "离岛区",
  82e4: "澳门特别行政区",
  820100: "澳门半岛",
  820200: "离岛",
  99e4: "海外",
  990100: "海外"
};
const By = ["东北", "华北", "华东", "华中", "华南", "西南", "西北", "港澳台", "海外"];
function Wk(r) {
  const e = {};
  for (let n = 0, i; n < r.length; n++)
    i = r[n], !(!i || !i.id) && (e[i.id] = i);
  const t = [];
  for (let n = 0, i; n < r.length; n++) {
    if (i = r[n], !i)
      continue;
    if (i.pid == null && i.parentId == null) {
      t.push(i);
      continue;
    }
    const a = e[i.pid] || e[i.parentId];
    a && (a.children || (a.children = []), a.children.push(i));
  }
  return t;
}
const Uk = function() {
  const r = [];
  for (const e in Vy) {
    const t = e.slice(2, 6) === "0000" ? void 0 : e.slice(4, 6) == "00" ? e.slice(0, 2) + "0000" : e.slice(0, 4) + "00";
    r.push({
      id: e,
      pid: t,
      name: Vy[e]
    });
  }
  return Wk(r);
}();
function Yk(r) {
  return r == null || r != r;
}
function Xk(r) {
  return typeof r == "object" && !Yk(r) && /Iterator\]$/.test(r.toString());
}
function Ka(r) {
  try {
    if (Xk(r))
      return "Iterator";
    const e = Object.prototype.toString.call(r).match(/\[object (\w+)\]/)[1];
    return e === "Number" && isNaN(r) ? "NaN" : e;
  } catch {
    return "Undefined";
  }
}
function Zk(r, e = !1) {
  return e ? typeof r == "function" : Ka(r) === "Function";
}
function mt(r, e = 0, t) {
  if (!/^[0-9]*$/.test(String(r)))
    return new Array(e).fill("0").join("");
  const n = r.toString(), i = n.length;
  return i > t ? n.slice(i - t) : i < e ? new Array(e - i).fill("0").join("") + n : n;
}
function qk(r = "", e = []) {
  for (let t = 0; t < e.length; t++) {
    const { reg: n, value: i } = e[t];
    r = r.replace(n, i);
  }
  return r;
}
function F0(r = /* @__PURE__ */ new Date(), e = "YYYY-MM-DD") {
  Ka(r) === "Number" && r.toString().length === 10 && (r += "000");
  const t = new Date(r), n = t.getFullYear();
  if (isNaN(n))
    return "Invalid Date";
  const i = t.getMonth() + 1, a = t.getDate(), o = t.getHours(), s = t.getMinutes(), l = t.getSeconds();
  return qk(e, [{ reg: /[Y|y]{4}/, value: mt(n, 4, 4) }, { reg: /[Y|y]{2}/, value: mt(n, 2, 2) }, { reg: /[M]{2}/, value: mt(i, 2, 2) }, { reg: /[M]{1}/, value: mt(i, 1, 2) }, { reg: /[D|d]{2}/, value: mt(a, 2, 2) }, { reg: /[D|d]{1}/, value: mt(a, 1, 2) }, { reg: /[H]{2}/, value: mt(o, 2, 2) }, { reg: /[H]{1}/, value: mt(o, 1, 2) }, { reg: /[h]{2}/, value: mt(o % 12, 2, 2) }, { reg: /[h]{1}/, value: mt(o % 12, 1, 2) }, { reg: /[m]{2}/, value: mt(s, 2, 2) }, { reg: /[m]{1}/, value: mt(s, 1, 2) }, { reg: /[s]{2}/, value: mt(l, 2, 2) }, { reg: /[s]{1}/, value: mt(l, 1, 2) }]);
}
function Fy(r) {
  return r % 1 != 0;
}
function Kk(r = 0, e = 1, t = 0) {
  if (r === 0 && e === 1)
    return Math.random();
  (Fy(e) || Fy(r)) && t === 0 && (t = e > r ? e : r);
  const n = r + Math.random() * (e - r);
  return t ? function(i, a = 1) {
    return Number(i.toFixed(a));
  }(n, t) : Math.ceil(n);
}
function kf(r, e, t) {
  t > r.length && (t = r.length - 1);
  let n = Kk(e, t) || 0;
  const i = [];
  let a = 0;
  for (; n--; )
    a = ~~(Math.random() * r.length), i.push(r[a]), r.splice(a, 1);
  return i;
}
function Fn(r = [], e) {
  const t = r.length;
  return t === 0 ? null : e || e === 0 ? e > t ? r[e % t] : e > -1 ? r[e] : e < 0 ? r[r.length + e % t] : null : r[~~(Math.random() * r.length)];
}
function zs(r) {
  return r[Math.floor(Math.random() * r.length)];
}
function ES(...r) {
  let e = [];
  if (r && r.length > 0) {
    const t = r.length;
    let n = 0;
    for (; n < t; )
      Array.isArray(r[n]) ? e = e.concat(r[n]) : e.push(r[n]), n++;
  }
  return e;
}
const jk = () => zs(B0.concat(Gk)), Jk = () => zs(B0), Qk = () => zs(B0), AS = () => zs(Hk), dist_IS = () => zs($k), eV = () => AS() + dist_IS();
function zy(r) {
  return r % 1 !== 0;
}
function tV(r, e = 1) {
  return Number(r.toFixed(e));
}
function nu(r, e = 0) {
  return Math.ceil(r * 10 ** e) * 10 ** -e;
}
function qe(r = 0, e = 1, t = 0) {
  if (r === 0 && e === 1)
    return Math.random();
  if (zy(e) || zy(r)) {
    const i = e > r ? e : r;
    t === 0 && (t = i);
  }
  const n = r + Math.random() * (e - r);
  return t ? tV(n, t) : Math.ceil(n);
}
var z0 = {
  GUID: 1,
  RE_KEY: /(.+)\|(?:\+(\d+)|([\+\-]?\d+-?[\+\-]?\d*)?(?:\.(\d+-?\d*))?)/,
  RE_Object_KEY: /(.+)(&|&&)(.+,)?/,
  RE_Object_str_KEY: /(.+)&&(.+,)?/,
  RE_RANGE: /([\+\-]?\d+)-?([\+\-]?\d+)?/,
  RE_PLACEHOLDER: /\\*@([^@#%&()\?\s]+)(?:\((.*?)\))?/g,
  VARCHARS: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
  CHARS: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()[]",
  CHINESE: "的一是在不了有和人这中大为上个国我以要他时来用们生到作地于出就分对成会可主发年动同工也能下过子说产种面而方后多定行学法所民得经十三之进着等部度家电力里如水化高自二理起小物现实加量都两体制机当使点从业本去把性好应开它合还因由其些然前外天政四日那社义事平形相全表间样与关各重新线内数正心反你明看原又么利比或但质气第向道命此变条只没结解问意建月公无系军很情者最立代想已通并提直题党程展五果料象员革位入常文总次品式活设及管特件长求老头基资边流路级少图山统接知较将组见计别她手角期根论运农指几九区强放决西被干做必战先回则任取据处队南给色光门即保治北造百规热领七海口东导器压志世金增争济阶油思术极交受联什认六共权收证改清己美再采转更单风切打白教速花带安场身车例真务具万每目至达走积示议声报斗完类八离华名确才科张信马节话米整空元况今集温传土许步群广石记需段研界拉林律叫且究观越织装影算低持音众书布复容儿须际商非验连断深难近矿千周委素技备半办青省列习响约支般史感劳便团往酸历市克何除消构府称太准精值号率族维划选标写存候毛亲快效斯院查江型眼王按格养易置派层片始却专状育厂京识适属圆包火住调满县局照参红细引听该铁价严龙飞"
};
const rV = 200, nV = 100, { CHARS: iV } = z0;
function fd() {
  return Fn(iV.split("")) || "";
}
function aV(r = "0", e = "10") {
  let t = fd(), n = qe(Number(r), Number(e), 0);
  for (; --n; )
    t += fd();
  return t;
}
function oV() {
  return Math.random() >= 0.5;
}
function sV() {
  return Math.random().toString().slice(2);
}
function lV(r) {
  const e = r || "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx";
  let t = (/* @__PURE__ */ new Date()).getTime();
  return e.replace(/[xy]/g, function(n) {
    const i = (t + Math.random() * 16) % 16 | 0;
    return t = Math.floor(t / 16), (n === "x" ? i : i & 3 | 8).toString(16);
  });
}
const { CHINESE: uV } = z0;
function LS() {
  return Fn(uV.split(""));
}
function fV(r = "3", e = "5") {
  let t = "", n = qe(Number(r), Number(e));
  for (; n--; )
    t += LS();
  return t;
}
function jo(r, e) {
  const t = () => String.fromCharCode(qe(97, 122));
  let n = qe(r, e), i = "";
  for (; n--; )
    i += t();
  return i;
}
function cV(r) {
  const e = Number((Number(r.slice(0, 2)) / 10).toFixed()) - 1;
  return isNaN(e) || e < 0 || e > By.length ? cd() : By[e] || cd();
}
function cd() {
  return Gs("RR");
}
function hV(r = "1") {
  return Gs("PP");
}
function vV(r = "1") {
  return Gs("CC");
}
function dV(r = "1") {
  return Gs("DD");
}
function Gs(r = "PPCCDD") {
  const e = Fn(Uk) || {}, t = cV(e.id) || "", n = Fn(e.children || []) || {}, i = Fn(n.children || []) || {};
  return r = r.replace("RR", t).replace("PP", e.name || "").replace("CC", n.name || "").replace("DD", i.name || ""), r;
}
function pV() {
  const r = () => qe(1, 254);
  return `${r()}.${r()}.${r()}.${r()}`;
}
function gV(r = 7, e = 3) {
  return r < 3 && (r = 7), e < 2 && (e = 3), jo(3, r) + "." + jo(2, e);
}
function mV() {
  const r = () => qe(1, 65535).toString(16);
  let e = `${r()}`, t = 7;
  for (; t--; )
    e += `:${r()}`;
  return e;
}
function yV() {
  return `${jo(6, 13)}@${jo(2, 6)}.${jo(2, 5)}`;
}
function _V(r = "http") {
  r || (r = "http");
  const e = () => kf(z0.VARCHARS.split(""), 3, 12).join("");
  return `${r}://${e()}.${e()}/${e()}`;
}
function SV(r = "0", e = "10") {
  return qe(Number(r), Number(e));
}
function wV(r = "0", e = "10") {
  return qe(Number(r), Number(e));
}
function bV(r = "", e = "200x200", t = "000", n = "fff", i = "") {
  return "http://dummyimage.com/" + e + (t ? "/" + t : "") + (n ? "/" + n : "") + (i ? "." + i : "") + (r ? "&text=" + r : "");
}
function G0() {
  return new Date((/* @__PURE__ */ new Date()).getTime() - 1e3 * 60 * 60 * 2 * Math.floor(Math.random() * 1e4));
}
function xV(r = "HH:mm:ss") {
  return F0(G0(), r);
}
function CV(r = "YYYY-MM-DD") {
  return F0(G0(), r);
}
function TV(r = "YYYY-MM-DD HH:mm:ss") {
  return F0(/* @__PURE__ */ new Date(), r);
}
function MV() {
  return G0().getTime();
}
function DV() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var H0 = {}, Kr = {};
Object.defineProperty(Kr, "__esModule", {
  value: !0
});
Kr.FORMAT_PLAIN = Kr.FORMAT_HTML = Kr.FORMATS = void 0;
var NS = "html";
Kr.FORMAT_HTML = NS;
var PS = "plain";
Kr.FORMAT_PLAIN = PS;
var EV = [NS, PS];
Kr.FORMATS = EV;
var rt = {};
Object.defineProperty(rt, "__esModule", {
  value: !0
});
rt.UNIT_WORDS = rt.UNIT_WORD = rt.UNIT_SENTENCES = rt.UNIT_SENTENCE = rt.UNIT_PARAGRAPHS = rt.UNIT_PARAGRAPH = rt.UNITS = void 0;
var RS = "words";
rt.UNIT_WORDS = RS;
var OS = "word";
rt.UNIT_WORD = OS;
var kS = "sentences";
rt.UNIT_SENTENCES = kS;
var VS = "sentence";
rt.UNIT_SENTENCE = VS;
var BS = "paragraphs";
rt.UNIT_PARAGRAPHS = BS;
var FS = "paragraph";
rt.UNIT_PARAGRAPH = FS;
var AV = [RS, OS, kS, VS, BS, FS];
rt.UNITS = AV;
var Hs = {};
Object.defineProperty(Hs, "__esModule", {
  value: !0
});
Hs.WORDS = void 0;
var IV = ["ad", "adipisicing", "aliqua", "aliquip", "amet", "anim", "aute", "cillum", "commodo", "consectetur", "consequat", "culpa", "cupidatat", "deserunt", "do", "dolor", "dolore", "duis", "ea", "eiusmod", "elit", "enim", "esse", "est", "et", "eu", "ex", "excepteur", "exercitation", "fugiat", "id", "in", "incididunt", "ipsum", "irure", "labore", "laboris", "laborum", "Lorem", "magna", "minim", "mollit", "nisi", "non", "nostrud", "nulla", "occaecat", "officia", "pariatur", "proident", "qui", "quis", "reprehenderit", "sint", "sit", "sunt", "tempor", "ullamco", "ut", "velit", "veniam", "voluptate"];
Hs.WORDS = IV;
var zS = {}, Vf = {};
Object.defineProperty(Vf, "__esModule", {
  value: !0
});
Vf.LINE_ENDINGS = void 0;
var LV = {
  POSIX: `
`,
  WIN32: `\r
`
};
Vf.LINE_ENDINGS = LV;
var GS = {}, $0 = {}, HS = {};
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = void 0;
  var e = function(i) {
    var a = i.trim();
    return a.charAt(0).toUpperCase() + a.slice(1);
  }, t = e;
  r.default = t;
})(HS);
var Xu = {}, NV = {
  get exports() {
    return Xu;
  },
  set exports(r) {
    Xu = r;
  }
};
(function(r, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = void 0;
  var t = function() {
    return !!r.exports;
  }, n = t;
  e.default = n;
})(NV, Xu);
var $S = {};
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = void 0;
  var e = function() {
    var i = !1;
    try {
      i = navigator.product === "ReactNative";
    } catch {
      i = !1;
    }
    return i;
  }, t = e;
  r.default = t;
})($S);
var WS = {}, Bf = {};
Object.defineProperty(Bf, "__esModule", {
  value: !0
});
Bf.SUPPORTED_PLATFORMS = void 0;
var PV = {
  DARWIN: "darwin",
  LINUX: "linux",
  WIN32: "win32"
};
Bf.SUPPORTED_PLATFORMS = PV;
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = void 0;
  var e = Bf, t = function() {
    var a = !1;
    try {
      a = process.platform === e.SUPPORTED_PLATFORMS.WIN32;
    } catch {
      a = !1;
    }
    return a;
  }, n = t;
  r.default = n;
})(WS);
var W0 = {};
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = void 0;
  var e = function() {
    var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return Array.apply(null, Array(i)).map(function(a, o) {
      return o;
    });
  }, t = e;
  r.default = t;
})(W0);
var US = {};
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = void 0;
  var e = t(W0);
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var n = function(o, s) {
    var l = (0, e.default)(o);
    return l.map(function() {
      return s();
    });
  }, i = n;
  r.default = i;
})(US);
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), Object.defineProperty(r, "capitalize", {
    enumerable: !0,
    get: function() {
      return e.default;
    }
  }), Object.defineProperty(r, "isNode", {
    enumerable: !0,
    get: function() {
      return t.default;
    }
  }), Object.defineProperty(r, "isReactNative", {
    enumerable: !0,
    get: function() {
      return n.default;
    }
  }), Object.defineProperty(r, "isWindows", {
    enumerable: !0,
    get: function() {
      return i.default;
    }
  }), Object.defineProperty(r, "makeArrayOfLength", {
    enumerable: !0,
    get: function() {
      return a.default;
    }
  }), Object.defineProperty(r, "makeArrayOfStrings", {
    enumerable: !0,
    get: function() {
      return o.default;
    }
  });
  var e = s(HS), t = s(Xu), n = s($S), i = s(WS), a = s(W0), o = s(US);
  function s(l) {
    return l && l.__esModule ? l : { default: l };
  }
})($0);
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = void 0;
  var e = Hs, t = $0;
  function n(u, f) {
    if (!(u instanceof f))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(u, f) {
    for (var c = 0; c < f.length; c++) {
      var h = f[c];
      h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(u, h.key, h);
    }
  }
  function a(u, f, c) {
    return f && i(u.prototype, f), c && i(u, c), Object.defineProperty(u, "prototype", { writable: !1 }), u;
  }
  function o(u, f, c) {
    return f in u ? Object.defineProperty(u, f, { value: c, enumerable: !0, configurable: !0, writable: !0 }) : u[f] = c, u;
  }
  var s = /* @__PURE__ */ function() {
    function u() {
      var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = f.sentencesPerParagraph, h = c === void 0 ? {
        max: 7,
        min: 3
      } : c, v = f.wordsPerSentence, d = v === void 0 ? {
        max: 15,
        min: 5
      } : v, g = f.random;
      f.seed;
      var p = f.words, m = p === void 0 ? e.WORDS : p;
      if (n(this, u), o(this, "sentencesPerParagraph", void 0), o(this, "wordsPerSentence", void 0), o(this, "random", void 0), o(this, "words", void 0), h.min > h.max)
        throw new Error("Minimum number of sentences per paragraph (".concat(h.min, ") cannot exceed maximum (").concat(h.max, ")."));
      if (d.min > d.max)
        throw new Error("Minimum number of words per sentence (".concat(d.min, ") cannot exceed maximum (").concat(d.max, ")."));
      this.sentencesPerParagraph = h, this.words = m, this.wordsPerSentence = d, this.random = g || Math.random;
    }
    return a(u, [{
      key: "generateRandomInteger",
      value: function(c, h) {
        return Math.floor(this.random() * (h - c + 1) + c);
      }
    }, {
      key: "generateRandomWords",
      value: function(c) {
        var h = this, v = this.wordsPerSentence, d = v.min, g = v.max, p = c || this.generateRandomInteger(d, g);
        return (0, t.makeArrayOfLength)(p).reduce(function(m, y) {
          return "".concat(h.pluckRandomWord(), " ").concat(m);
        }, "").trim();
      }
    }, {
      key: "generateRandomSentence",
      value: function(c) {
        return "".concat((0, t.capitalize)(this.generateRandomWords(c)), ".");
      }
    }, {
      key: "generateRandomParagraph",
      value: function(c) {
        var h = this, v = this.sentencesPerParagraph, d = v.min, g = v.max, p = c || this.generateRandomInteger(d, g);
        return (0, t.makeArrayOfLength)(p).reduce(function(m, y) {
          return "".concat(h.generateRandomSentence(), " ").concat(m);
        }, "").trim();
      }
    }, {
      key: "pluckRandomWord",
      value: function() {
        var c = 0, h = this.words.length - 1, v = this.generateRandomInteger(c, h);
        return this.words[v];
      }
    }]), u;
  }(), l = s;
  r.default = l;
})(GS);
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = void 0;
  var e = Kr, t = Vf, n = a(GS), i = $0;
  function a(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function o(h, v) {
    if (!(h instanceof v))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(h, v) {
    for (var d = 0; d < v.length; d++) {
      var g = v[d];
      g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(h, g.key, g);
    }
  }
  function l(h, v, d) {
    return v && s(h.prototype, v), d && s(h, d), Object.defineProperty(h, "prototype", { writable: !1 }), h;
  }
  function u(h, v, d) {
    return v in h ? Object.defineProperty(h, v, { value: d, enumerable: !0, configurable: !0, writable: !0 }) : h[v] = d, h;
  }
  var f = /* @__PURE__ */ function() {
    function h() {
      var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.FORMAT_PLAIN, g = arguments.length > 2 ? arguments[2] : void 0;
      if (o(this, h), this.format = d, this.suffix = g, u(this, "generator", void 0), e.FORMATS.indexOf(d.toLowerCase()) === -1)
        throw new Error("".concat(d, " is an invalid format. Please use ").concat(e.FORMATS.join(" or "), "."));
      this.generator = new n.default(v);
    }
    return l(h, [{
      key: "getLineEnding",
      value: function() {
        return this.suffix ? this.suffix : !(0, i.isReactNative)() && (0, i.isNode)() && (0, i.isWindows)() ? t.LINE_ENDINGS.WIN32 : t.LINE_ENDINGS.POSIX;
      }
    }, {
      key: "formatString",
      value: function(d) {
        return this.format === e.FORMAT_HTML ? "<p>".concat(d, "</p>") : d;
      }
    }, {
      key: "formatStrings",
      value: function(d) {
        var g = this;
        return d.map(function(p) {
          return g.formatString(p);
        });
      }
    }, {
      key: "generateWords",
      value: function(d) {
        return this.formatString(this.generator.generateRandomWords(d));
      }
    }, {
      key: "generateSentences",
      value: function(d) {
        return this.formatString(this.generator.generateRandomParagraph(d));
      }
    }, {
      key: "generateParagraphs",
      value: function(d) {
        var g = this.generator.generateRandomParagraph.bind(this.generator);
        return this.formatStrings((0, i.makeArrayOfStrings)(d, g)).join(this.getLineEnding());
      }
    }]), h;
  }(), c = f;
  r.default = c;
})(zS);
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), Object.defineProperty(r, "LoremIpsum", {
    enumerable: !0,
    get: function() {
      return i.default;
    }
  }), r.loremIpsum = void 0;
  var e = Kr, t = rt, n = Hs, i = a(zS);
  function a(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var o = function() {
    var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = l.count, f = u === void 0 ? 1 : u, c = l.format, h = c === void 0 ? e.FORMAT_PLAIN : c, v = l.paragraphLowerBound, d = v === void 0 ? 3 : v, g = l.paragraphUpperBound, p = g === void 0 ? 7 : g, m = l.random, y = l.sentenceLowerBound, _ = y === void 0 ? 5 : y, S = l.sentenceUpperBound, b = S === void 0 ? 15 : S, w = l.units, x = w === void 0 ? t.UNIT_SENTENCES : w, C = l.words, T = C === void 0 ? n.WORDS : C, E = l.suffix, D = E === void 0 ? "" : E, I = {
      random: m,
      sentencesPerParagraph: {
        max: p,
        min: d
      },
      words: T,
      wordsPerSentence: {
        max: b,
        min: _
      }
    }, L = new i.default(I, h, D);
    switch (x) {
      case t.UNIT_PARAGRAPHS:
      case t.UNIT_PARAGRAPH:
        return L.generateParagraphs(f);
      case t.UNIT_SENTENCES:
      case t.UNIT_SENTENCE:
        return L.generateSentences(f);
      case t.UNIT_WORDS:
      case t.UNIT_WORD:
        return L.generateWords(f);
      default:
        return "";
    }
  };
  r.loremIpsum = o;
})(H0);
function YS(r, e) {
  return new H0.LoremIpsum().generateSentences(Math.min(parseInt(r || "1"), parseInt(e) || rV));
}
function RV(r, e) {
  return YS(r, e);
}
function XS(r, e) {
  return new H0.LoremIpsum().generateParagraphs(Math.min(parseInt(r || "1"), parseInt(e) || nV));
}
function OV(r, e) {
  return XS(r, e);
}
const kV = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`, VV = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`, BV = () => `rgb(${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)})`, FV = () => [
  Math.floor(Math.random() * 255),
  Math.floor(Math.random() * 255),
  Math.floor(Math.random() * 255)
];
var Gy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  first: jk,
  last: Jk,
  name: Qk,
  cfirst: AS,
  clast: dist_IS,
  cname: eV,
  char: fd,
  string: aV,
  boolean: oV,
  id: sV,
  uuid: lV,
  cword: LS,
  title: fV,
  region: cd,
  province: hV,
  city: vV,
  district: dV,
  address: Gs,
  ip: pV,
  domain: gV,
  ip6: mV,
  email: yV,
  url: _V,
  num: SV,
  number: wV,
  image: bV,
  time: xV,
  date: CV,
  now: TV,
  timeStamp: MV,
  nowTimeStamp: DV,
  sentence: YS,
  sent: RV,
  paragraph: XS,
  para: OV,
  hex: kV,
  color: VV,
  rgb: BV,
  rgb2: FV
});
const xa = /* @__PURE__ */ new Map();
xa.set("JsonString", JSON.stringify);
const Mo = (r) => {
  if (r === void 0)
    return;
  const e = Number(r);
  if (!isNaN(e))
    return e;
};
function zV(r) {
  let e, t = !1;
  const [n, i] = r.split("."), [a, o] = n && n.split("-") || [void 0, void 0], [s, l] = i && i.split("-") || [void 0, void 0];
  return o === void 0 && a !== void 0 && (e = a), Number(o) < Number(a) && (e = a), a && a.indexOf("+") === 0 && (t = !0), {
    random: t,
    min: Mo(a),
    max: Mo(o),
    dmin: Mo(s),
    dmax: Mo(l),
    count: Mo(e)
  };
}
function GV(r, e) {
  const t = {
    name: "",
    valueType: Ka(e),
    rule: void 0,
    min: void 0,
    max: void 0,
    dmin: void 0,
    dmax: void 0,
    count: void 0,
    random: !1,
    multKey: void 0,
    handler: void 0,
    _this: void 0
  }, n = r.split("|");
  if (!(!n || n.length < 1))
    return n[0] !== void 0 && (t.name = n[0]), n[1] !== void 0 && (t.rule = n[1], Object.assign(t, zV(n[1]))), n[2] !== void 0 && (t.multKey = n[2].split(",")), n[3] !== void 0 && (t.handler = xa.get(n[3])), t;
}
function HV(r, e) {
  const { valueType: t, name: n, min: i, max: a, dmin: o, dmax: s } = e, l = qe(i, a || i), u = qe(o, s || o);
  let f = qe(10 ** u - 10 ** (u - 1), 10 ** u - 1);
  const c = String(f);
  c[c.length - 1] === "0" && ++f, t === "Number" && (r[n] = parseFloat(`${l}.${f}`));
}
function $V(r, e, t) {
  const { valueType: n, name: i, min: a, max: o } = e, s = ja.bind(r);
  if (Array.isArray(t)) {
    const u = nu(o / t.length);
    if (u === 1) {
      r[i] = [s(t[0])];
      return;
    }
    const f = ES(...new Array(u).fill(void 0).map(() => s(t)));
    r[i] = kf(f, a, o < f.length ? o : f.length);
    return;
  }
  if (n === "Number") {
    let u = qe(a, o);
    a === 0 && o === void 0 && (u = 0), a === 1 && o === void 0 && (u = r[i]), r[i] = u;
    return;
  }
  const l = qe(a, o);
  if (n === "String") {
    r[i] = new Array(nu(l)).fill("").map(() => s(t)).join("");
    return;
  }
  r[i] = new Array(nu(l)).fill("").map(() => s(t));
}
function WV(r, e, t) {
  const n = ja.bind(r), { name: i, min: a, max: o, handler: s, valueType: l } = e;
  Array.isArray(t) ? (a === 1 && (r[i] = Fn(n(t))), a > 1 && (r[i] = kf(n(t), a, a))) : l === "Number" ? r[i] = qe(t, t ** (a + 1)) : l === "String" ? r[i] = new Array(qe(a, o)).fill("").map(() => n(t)).join("") : r[i] = n(t), s && (r[i] = s(r[i]));
}
function UV(r, e, t) {
  const { valueType: n, name: i, count: a } = e, o = ja.bind(r), s = o(t);
  if (a < 1 && (r[i] = void 0), n === "Number") {
    r[i] = qe(a, a ** 3);
    return;
  }
  if (n === "Array") {
    a === 1 && (r[i] = Fn(s)), a > 1 && (r[i] = kf(ES(...new Array(nu(a / s.length)).fill(void 0).map(() => o(t))), a, a));
    return;
  }
  if (n === "Object") {
    let u = (Object.keys(s) || []).length;
    for (; u > a; ) {
      const f = Fn(Object.keys(s));
      f && (delete s[f], u--);
    }
    r[i] = s;
    return;
  }
  r[i] = new Array(a).fill("").map(() => o(t)).join("");
}
function ZS(r, e, t) {
  const n = GV(e, t), { rule: i = "", valueType: a, name: o, min: s, max: l, dmin: u, multKey: f = [], count: c, handler: h } = n;
  if (f.length > 0) {
    r[o] = {}, f.forEach((v) => {
      ZS(r[o], v + "|" + i, t);
    }), h && (r[o] = h(r[o]));
    return;
  }
  if (a === "Boolean") {
    r[o] = qe(s, l || (s + 1) * 3 || 3) % 2 === 0, h && (r[o] = h(r[o]));
    return;
  }
  if (n.random) {
    WV(r, n, t), h && (r[o] = h(r[o]));
    return;
  }
  if (s !== void 0) {
    if (u !== void 0 && a === "Number") {
      HV(r, n), h && (r[o] = h(r[o]));
      return;
    }
    if (l !== void 0) {
      $V(r, n, t), h && (r[o] = h(r[o]));
      return;
    }
    if (c !== void 0) {
      UV(r, n, t), h && (r[o] = h(r[o]));
      return;
    }
  }
  h && (r[o] = h(r[o]));
}
function YV(r) {
  if (typeof r == "string") {
    if (r[0] !== "@")
      return r;
    const [, e, ...t] = r.split(/@|\(|\)|,/) || [];
    if (xa.has(e))
      return Ka(xa.get(e)) === "Function" ? xa.get(e).bind(this)(...t) : xa.get(e);
    if (Zk(Gy[e]))
      return Gy[e](...t);
  }
  return "";
}
function XV(r) {
  const e = {};
  for (const t in r) {
    if (t.indexOf("|") < 0) {
      e[t] = ja(r[t]);
      continue;
    }
    ZS(e, t, r[t]);
  }
  return e;
}
function ZV(r) {
  return typeof r == "function" && Ka(r) === "Function" ? r.bind(this)(r) : "";
}
function qV(r) {
  return Array.isArray(r) ? r.map((e) => ja(e)) : [];
}
function ja(r) {
  try {
    switch (Ka(r)) {
      case "Object":
        return XV.bind(this)(r);
      case "String":
        return YV.bind(this)(r);
      case "Array":
        return qV.bind(this)(r);
      case "Function":
        return ZV.bind(this)(r);
      default:
        return r;
    }
  } catch {
    return r;
  }
}
function KV(r) {
  const { name: e, nodes: t = [] } = r, n = document.querySelector(`.${e}`);
  if (!n || t.length === 0)
    return {};
  const i = t.length, a = 15 * i, { width: o } = n.getBoundingClientRect(), s = n.getAttribute("style") || "", l = [a, a];
  let u = a * 2;
  t.map((f, c) => {
    const { id: h } = f, v = `${e}-${h}`, d = document.querySelector(`.${v}`);
    if (!d)
      return;
    const g = d == null ? void 0 : d.getBoundingClientRect(), { width: p } = g, m = d.getAttribute("style") || "";
    let y = 0, _ = 0;
    c === 0 && (l[0] = (o - p) / 2);
    const S = 2 * Math.PI * (c / i);
    y = Math.sin(S) * a + l[0], _ = -Math.cos(S) * a + l[1], _ > u && (u = _), d.setAttribute("style", `${m}left: ${y}px; top: ${_}px;`), n.setAttribute("style", `${s} height: ${u + 80}px;`);
  });
}
function jV(r) {
  const { name: e, links: t = [] } = r;
  KV(r);
  const n = document.querySelector(`.${e}`), i = document.querySelector(`.${e}-bg`);
  if (!n || !i || !wt(t))
    return;
  const { left: a, top: o } = n.getBoundingClientRect(), s = (l) => {
    const u = `${e}-${l}`, f = document.querySelector(`.${u}`);
    if (!f)
      return;
    const { left: c, top: h, width: v, height: d } = f.getBoundingClientRect();
    return [
      c + v / 2 - a,
      h + d / 2 - o
    ];
  };
  t.forEach((l) => {
    const { form: u = "", to: f = "" } = l, c = s(u), h = s(f);
    if (!c || !h)
      return;
    const [v, d] = c, [g, p] = h, m = `${e}${u}-${f}-arrow`, y = document.querySelector(`svg>.${m}`);
    y && y.setAttribute("d", `M ${v},${d} ${g},${p}`);
  });
}
function $B(r) {
  const { name: e = "flow-circular-" + ja("@id"), style: t = {}, nodeStyle: n = {}, linkStyle: i = {}, links: a = [], nodes: o = [], nodeClick: s, linkClick: l } = r;
  return A.useEffect(() => {
    const u = document.querySelector(`.${e}`), f = new ResizeObserver(vd(() => {
      jV({ name: e, links: a, nodes: o });
    }, 50));
    if (u)
      return f.observe(u), () => {
        f.unobserve(u);
      };
  }, []), A.createElement(
    "div",
    { className: dist_Y(e), style: {
      position: "relative",
      width: "100%",
      background: "transparent",
      overflow: "hidden",
      ...t
    } },
    o.map((u, f) => {
      const { id: c = "" } = u, h = `${e}-${c}`;
      return A.createElement("div", { className: h, style: {
        display: "inline-flex",
        position: "absolute",
        cursor: "pointer",
        zIndex: 10,
        justifyContent: "center",
        alignItems: "center",
        ...n
      }, onClick: () => {
        s && s(u);
      }, key: f }, c);
    }),
    A.createElement("svg", { className: `${e}-bg`, style: {
      width: "100%",
      height: "100%",
      zIndex: 1
    } }, a.map((u, f) => {
      const { form: c, to: h } = u, v = `${e}${c}-${h}-arrow`;
      return A.createElement("path", { style: {
        cursor: "pointer",
        zIndex: 1,
        ...i
      }, stroke: "black", strokeWidth: "3", onClick: () => {
        l && l(u);
      }, key: v + f, className: v, d: "M 0,0 0,0" });
    }))
  );
}
function WB(r) {
  const { prefixCls: e, defaultValue: t, value: n, onChange: i, className: a, items: o = [], ...s } = r, l = () => n ? [n, (c) => {
  }] : react.useState(t ?? o[0].key), [u, f] = l();
  return react.createElement(
    "div",
    { className: dist_Y("au-tab", a), ...s },
    react.createElement("div", { className: "header" }, o.map((c, h) => {
      const { title: v, key: d } = c;
      return react.createElement("div", { key: h, className: dist_Y({ select: d === u }), onClick: () => {
        i && i(d), n === void 0 && f(d);
      }, style: {
        cursor: "pointer"
      } }, v);
    })),
    react.createElement("div", { className: "content" }, o.map((c, h) => {
      const { key: v, children: d } = c;
      return react.createElement("div", { key: h, style: { display: u === v ? "block" : "none" } }, d);
    }))
  );
}
function JV(r, e, t) {
  if (t <= 9)
    return new Array(t).fill(null).map((l, u) => u + 1);
  const n = Math.ceil(e / 2), i = e - n;
  let a = r > n ? r - n : 0;
  r + i > t && (a = t - e);
  const o = new Array(e).fill(null).map((l, u) => a + u + 1);
  o[0] !== 1 && (o.unshift(-1), o.unshift(1));
  const s = o[o.length - 1];
  return s !== t && (s !== t - 1 && o.push(-2), o.push(t)), o;
}
function UB(r) {
  const { className: e, showPageNum: t = 5, current: n, defaultCurrent: i = 1, total: a = 0, pageSize: o, defaultPageSize: s, pageSizeOptions: l = [10, 20, 50], onChange: u, ...f } = r, [c, h] = Le(""), [v, d] = Le(n === void 0 ? i : n), [g, p] = Le(o === void 0 ? s || l[0] || 10 : o), m = Math.ceil(a / g), y = (S, b) => {
    S < 1 || (S > m && (S = m), d(S), b !== void 0 && p(b), u && u(S, b));
  }, _ = JV(v, t, m);
  return A.createElement(
    "div",
    { className: dist_Y("paging", e), ...f },
    A.createElement(
      "div",
      { className: "total" },
      "Total: ",
      a
    ),
    A.createElement(
      "div",
      { onClick: () => y(v - 1, o) },
      A.createElement(At, { type: "leftArrow", size: 10 })
    ),
    _.map((S) => S === -1 ? A.createElement(
      "div",
      { key: S, className: "jump-prev", onClick: () => y(v - 5, o) },
      A.createElement(At, { size: 8, type: "ellipsis", fill: "#d9d9d9" })
    ) : S === -2 ? A.createElement(
      "div",
      { key: S, className: "jump-next", onClick: () => y(v + 5, o) },
      A.createElement(At, { size: 8, type: "ellipsis", fill: "#d9d9d9" })
    ) : A.createElement("div", { key: S, className: dist_Y({
      selected: v === S
    }), onClick: () => y(S, o) }, S)),
    A.createElement(
      "div",
      { onClick: () => y(v + 1, o) },
      A.createElement(At, { size: 10, type: "rightArrow" })
    ),
    A.createElement(
      "div",
      { className: "pageSize-select" },
      A.createElement(Qy, { value: o == null ? void 0 : o.toString(), options: l.map((S) => ({
        value: S.toString(),
        label: S.toString() + "/page"
      })) })
    ),
    A.createElement(
      "div",
      { className: "goto" },
      A.createElement("div", null, "Goto"),
      A.createElement(Zw, { value: c, readOnly: !1, onChange: (S) => {
        const { keyCode: b, target: w } = S;
        b === 13 && it(Number(w.value)) ? (h(""), y(Number(w.value), o)) : h(w.value);
      }, onKeyDown: (S) => {
        const { keyCode: b, target: w } = S;
        b === 13 && it(Number(w.value)) && (h(""), y(Number(w.value), o));
      } })
    )
  );
}
function YB(r) {
  return A.createElement(
    "div",
    null,
    A.createElement(
      "div",
      null,
      A.createElement("progress", { value: "56", max: "100" })
    ),
    A.createElement(
      "div",
      null,
      A.createElement("meter", { min: "0", max: "100", value: "56", low: 25, high: 75, optimum: 50 })
    )
  );
}
const QV = {
  wait: react.createElement(At, { type: "block" }),
  process: react.createElement("div", { style: {
    width: 30,
    height: 30,
    background: "var(--disabled-color)",
    borderRadius: "50%",
    border: "none"
  } }),
  finish: react.createElement(At, { type: "yes" }),
  error: react.createElement(At, { type: "no" })
}, eB = "au-step-item", Vl = (r) => `${eB}${dist_ue(r) ? "" : "-" + r}`;
function qS(r) {
  const { status: e = "process", __first__: t = !1, children: n } = r;
  return react.createElement(
    react.Fragment,
    null,
    !t && react.createElement("div", { className: dist_Y(Vl("line")) }),
    react.createElement(
      "div",
      { className: dist_Y(Vl()) },
      react.createElement("div", { className: Vl("icon") }, QV[e]),
      react.createElement("div", { className: Vl("content") }, n)
    )
  );
}
function tB(r) {
  const { className: e, children: t, style: n, ...i } = r, a = react.Children.count(t), o = {
    gridTemplateColumns: `auto ${new Array(a - 1).fill("1fr auto").join(" ")}`,
    ...n
  };
  return react.createElement("div", { className: dist_Y(e, "au-step"), style: o, ...i }, react.Children.map(t, (s, l) => {
    const { className: u, children: f, ...c } = s.props || {};
    return react.createElement(qS, { __first__: l === 0, className: dist_Y(u), key: l, ...c }, f);
  }));
}
tB.Item = qS;
function XB(r) {
  const { noBorder: e = !1, serialNumber: t = !1, rowSelection: n, columns: i = [], dataSource: a = [], marge: o = {}, className: s, style: l, ...u } = r, f = dist_Y("au-table", s);
  return A.createElement(
    "div",
    { className: f, style: {
      "--border": e ? "none" : "1px solid #e9e9e9",
      "--border-radius": e ? "0" : "12px",
      ...l
    }, ...u },
    A.createElement(
      "table",
      { cellSpacing: 0 },
      A.createElement(
        "thead",
        null,
        A.createElement(
          "tr",
          null,
          n && A.createElement(
            "th",
            null,
            A.createElement("input", { type: "checkbox" })
          ),
          t && A.createElement("th", null, "No."),
          i.map((c, h) => {
            const { title: v = "", key: d = h } = c;
            return A.createElement("th", { key: d }, v);
          })
        )
      ),
      A.createElement("tbody", null, a.map((c, h) => {
        const { key: v = h, ...d } = c;
        return A.createElement(
          "tr",
          { key: jy(v) },
          n && A.createElement(
            "td",
            { style: { width: 30 } },
            A.createElement("input", { type: "checkbox" })
          ),
          t && A.createElement("td", { style: { width: 30 } }, h + 1),
          i.map((g, p) => {
            const { dataIndex: m, render: y, key: _ = p } = g, S = {}, { col: b, row: w } = o[`${h}-${p}`] || {};
            it(b) && (S.colSpan = b), it(w) && (S.rowSpan = w);
            const x = y ? y(d[m], c, h) : d[m];
            return A.createElement("td", { key: _, ...S }, x);
          })
        );
      }))
    )
  );
}
const rB = (0,react.forwardRef)(({ containerHeight: r, getItemHeight: e, itemCount: t, itemData: n, children: i }, a) => {
  a.current = {
    resetHeight: () => {
      c(u());
    }
  };
  const o = i, [s, l] = (0,react.useState)(0), u = () => {
    const m = [];
    m[0] = e(0);
    for (let y = 1; y < t; y++)
      m[y] = e(y) + m[y - 1];
    return m;
  }, [f, c] = (0,react.useState)(() => u());
  let h = f.findIndex((m) => m > s), v = f.findIndex((m) => m > s + r);
  v === -1 && (v = t);
  const d = 2;
  h = Math.max(h - d, 0), v = Math.min(v + d, t - 1);
  const g = f[f.length - 1], p = [];
  for (let m = h; m <= v; m++) {
    const y = m === 0 ? 0 : f[m - 1], _ = m === 0 ? f[0] : f[m] - f[m - 1];
    p.push(react.createElement(o, { key: m, index: m, style: {
      position: "absolute",
      left: 0,
      top: y,
      width: "100%",
      height: _
    }, data: n }));
  }
  return react.createElement(
    "div",
    { style: {
      height: r,
      overflow: "auto",
      position: "relative"
    }, onScroll: (m) => {
      (0,react_dom.flushSync)(() => {
        l(m.target.scrollTop);
      });
    } },
    react.createElement("div", { style: { height: g } }, p)
  );
});
function nB({ index: r, data: e, setHeight: t }) {
  const n = Oi();
  return A.createElement("div", { ref: n, style: {
    height: "100%",
    backgroundColor: r % 2 === 0 ? "burlywood" : "cadetblue"
  } }, e[r]);
}
function ZB(r) {
  const e = new Array(1e3).fill(0).map((s, l) => "aaa " + l), t = Oi(), n = Oi(new Array(100)), i = 40, a = (s) => n.current[s] ?? i, o = (s, l) => {
    n.current[s] !== l && (n.current[s] = l, t.current.resetHeight());
  };
  return A.createElement(rB, { ref: t, containerHeight: 400, itemCount: e.length, getItemHeight: a, itemData: e }, ({ index: s, style: l, data: u }) => A.createElement(
    "div",
    { style: l },
    A.createElement(nB, { index: s, data: u, setHeight: o })
  ));
}
const iB = (r, e) => {
  const t = [
    [-r * 2, 0],
    [-r, 0],
    [0, 0],
    [r, 0],
    [r * 2, 0],
    [r * 2, e],
    [r, e],
    [0, e],
    [-r, e],
    [-r * 2, e]
  ];
  return (n) => n < 0 ? t[n + 10] : n >= t.length ? t[n % 10] : t[n];
}, aB = (r) => r > 0 ? r < 10 ? r : r % 10 : 0, Hy = Yy("au-simple-scroll");
function oB(r) {
  const { className: e, value: t = 0, style: n = {}, itemStyle: i = {}, ...a } = r, o = aB(t), s = 60, l = 30, u = iB(s, l), f = Array.from({ length: 10 }, (c, h) => {
    const [v, d] = u(h - o + 2), g = {
      top: v,
      left: d,
      width: l,
      height: s,
      lineHeight: s + "px",
      color: "#fff",
      ...i
    };
    return {
      value: h,
      style: g
    };
  });
  return A.createElement("div", { className: dist_Y(Hy(), e), style: {
    width: l,
    height: s,
    ...n
  }, ...a }, f.map((c, h) => {
    const { value: v, style: d } = c;
    return A.createElement("div", { className: Hy("item"), style: d, key: h }, v);
  }));
}
function sB(r, e = 4) {
  if (r > 0) {
    const t = Number(Array.from({ length: e }, () => 9).join(""));
    return r > t ? t : r;
  }
  return 0;
}
const lB = Yy("au-number-scroll");
function qB(r) {
  const { className: e, value: t = 0, maxLength: n = 4, rootStyle: i = {}, style: a = {}, itemStyle: o = {}, ...s } = r, u = sB(t, n).toString(), f = Tw(u, n);
  return A.createElement("div", { className: dist_Y(lB(), e), style: {
    gridTemplateColumns: `repeat(${n}, 30px)`,
    ...i
  }, ...s }, Array.from({ length: n }, (c, h) => {
    const v = Number(f[h]), d = it(v) ? v : 0;
    return A.createElement(oB, { style: a, itemStyle: o, key: h, value: d });
  }));
}

//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./src/views/package/components/NPMCmd.tsx



const NPM = ["npm", "cnpm", "yarn", "pnpm"];
function NPMCmd(props) {
  const { name } = props;
  return /* @__PURE__ */ react.createElement(
    WB,
    {
      items: NPM.map((cmd, i) => {
        const installCmd = `${cmd} ${["pnpm", "yarn"].includes(cmd) ? "add" : "install"} ${name}`;
        return {
          key: cmd,
          title: cmd,
          children: /* @__PURE__ */ react.createElement("div", { key: i, className: "cmd" }, /* @__PURE__ */ react.createElement("span", null, installCmd), /* @__PURE__ */ react.createElement(
            "svg",
            {
              onClick: () => b(installCmd),
              focusable: "false",
              role: "img",
              width: "1em",
              height: "1em",
              fill: "currentColor",
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 448 512"
            },
            /* @__PURE__ */ react.createElement("path", { d: "M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z" })
          ))
        };
      })
    }
  );
}

;// CONCATENATED MODULE: ./src/views/package/components/index.tsx


// EXTERNAL MODULE: ./node_modules/.store/css-loader@6.11.0/node_modules/css-loader/dist/cjs.js!./node_modules/.store/less-loader@11.1.4/node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/views/package/index.less
var views_package = __webpack_require__(759);
;// CONCATENATED MODULE: ./src/views/package/index.less

      
      
      
      
      
      
      
      
      

var package_options = {};

package_options.styleTagTransform = (styleTagTransform_default());
package_options.setAttributes = (setAttributesWithoutAttributes_default());

      package_options.insert = insertBySelector_default().bind(null, "head");
    
package_options.domAPI = (styleDomAPI_default());
package_options.insertStyleElement = (insertStyleElement_default());

var package_update = injectStylesIntoStyleTag_default()(views_package/* default */.A, package_options);




       /* harmony default export */ const src_views_package = (views_package/* default */.A && views_package/* default */.A.locals ? views_package/* default */.A.locals : undefined);

;// CONCATENATED MODULE: ./src/views/package/conf.tsx
const pkgConf = [
  {
    name: "vuetify",
    label: "vuetify",
    logo: "vuetifyjs.com",
    desc: "Vue UI\u7EC4\u4EF6\u5E93",
    github: "vuetifyjs/vuetify",
    home: "https://vuetifyjs.com/zh-Hans/components/all/#section-5bb956687ec44ef6-containment",
    licensePath: "https://github.com/vuetifyjs/vuetify/blob/master/LICENSE.md",
    tags: [
      "javascript",
      "ui-design",
      "semantic",
      "vuejs",
      "typescript",
      "ui",
      "vue",
      "material",
      "material-design",
      "vue-components",
      "material-components",
      "ui-kit",
      "material-theme",
      "ui-components",
      "vue-material",
      "vuetify",
      "ui-library",
      "vuetifyjs",
      "vuejs3"
    ]
  },
  {
    name: "@observablehq/plot",
    label: "plot",
    logo: "observablehq.com",
    desc: "\u53EF\u89C6\u5316\u56FE\u8868\u5E93",
    github: "observablehq/plot",
    home: "https://observablehq.com/plot/getting-started",
    license: "ISC License",
    licensePath: "https://github.com/observablehq/plot/blob/main/LICENSE",
    tags: ["visualization", "d3", "svg", "charts", "data-visualization"]
  },
  {
    name: "@antv/g6",
    label: "g6",
    logo: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*7svFR6wkPMoAAAAAAAAAAAAADmJ7AQ/original",
    desc: "\u53EF\u89C6\u5316\u56FE\u8868\u5E93",
    github: "antvis/g6",
    home: "https://g6.antv.antgroup.com/zh/examples/case/treeDemos#customFlow",
    licensePath: "https://github.com/antvis/G6/blob/v5/LICENSE",
    tags: [
      "visualization",
      "tree",
      "graph",
      "network",
      "data-visualization",
      "graph-visualization",
      "graph-analytics",
      "visual-analytics",
      "graph-drawing"
    ]
  },
  {
    name: "echarts",
    label: "Echarts",
    logo: "echarts.apache.org",
    desc: "\u53EF\u89C6\u5316\u56FE\u8868\u5E93",
    github: "apache/echarts",
    home: "https://echarts.apache.org/examples/zh/index.html",
    license: "Apache License 2.0",
    licensePath: "https://github.com/apache/echarts/blob/master/LICENSE",
    tags: [
      "isualization",
      "svg",
      "charts",
      "canvas",
      "charting-library",
      "apache",
      "data-visualization",
      "data-viz",
      "echarts"
    ]
  },
  {
    name: "animejs",
    label: "animejs",
    logo: "animejs.com",
    desc: "Vue 2\u548C3\u7684\u57FA\u672CVue\u5408\u6210\u5B9E\u7528\u7A0B\u5E8F\u96C6\u5408 ",
    github: "juliangarnier/anime",
    home: "https://animejs.com/documentation/#cssSelector",
    licensePath: "https://github.com/juliangarnier/anime/blob/master/LICENSE.md",
    tags: [
      "javascript",
      "css",
      "svg",
      "canvas",
      "anime",
      "animation",
      "javascript-library"
    ]
  },
  {
    name: "@vueuse/core",
    label: "vueuse",
    logo: "vueuse.org",
    desc: "Vue 2\u548C3\u7684\u57FA\u672CVue\u5408\u6210\u5B9E\u7528\u7A0B\u5E8F\u96C6\u5408 ",
    github: "vueuse/vueuse",
    home: "https://vueuse.org/functions.html",
    tags: [
      "vue",
      "vue2",
      "vue3",
      "hook",
      "vue",
      "utility-library",
      "composable",
      "vue-use",
      "vue3",
      "vue-composition-api",
      "vue-next"
    ]
  },
  {
    name: "commander",
    label: "Commander.js",
    desc: "\u7F16\u5199\u4EE3\u7801\u6765\u63CF\u8FF0\u4F60\u7684\u547D\u4EE4\u884C\u754C\u9762",
    github: "tj/commander.js",
    licensePath: "https://github.com/tj/commander.js/blob/master/LICENSE",
    home: "https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md",
    tags: ["commander", "js", "\u547D\u4EE4", "command"]
  },
  {
    name: "puppeteer",
    label: "Puppeteer",
    desc: "\u53EF\u5728\u6D4F\u89C8\u5668\u4E2D\u624B\u52A8\u6267\u884C\u7684\u5927\u591A\u6570\u64CD\u4F5C",
    github: "puppeteer/puppeteer/tree/main",
    license: "Apache License 2.0",
    licensePath: "https://github.com/puppeteer/puppeteer/blob/main/LICENSE",
    home: "https://pptr.nodejs.cn/guides/what-is-puppeteer",
    tags: ["cron", "cron-libraries", "cron-expression", "quartz-scheduler"]
  },
  {
    name: "cronstrue",
    label: "cronstrue",
    desc: "\u901A\u8FC7\u6B63\u5219 \u751F\u6210\u5BF9\u5E94\u89C4\u5219\u5B50\u4E32",
    github: "bradymholt/cronstrue",
    home: "https://github.com/bradymholt/cronstrue",
    tags: ["cron", "cron-libraries", "cron-expression", "quartz-scheduler"]
  },
  {
    name: "vuedraggable",
    label: "Vue.Draggable",
    desc: "vue \u62D6\u62FD\u7EC4\u4EF6",
    github: "SortableJS/Vue.Draggable",
    home: "https://sortablejs.github.io/Vue.Draggable/#/simple",
    tags: ["component", "vue", "drag-and-drop"]
  },
  {
    name: "vue-draggable-plus",
    label: "vue-draggable-plus",
    desc: "vue \u62D6\u62FD\u7EC4\u4EF6",
    github: "Alfred-Skyblue/vue-draggable-plus",
    home: "https://vue-draggable-plus.pages.dev/",
    tags: [
      "pescript",
      "vue",
      "drag-and-drop",
      "drag",
      "vue2",
      "draggable",
      "sortablejs",
      "vue3",
      "composition-api"
    ]
  },
  {
    name: "GSAP",
    label: "GSAP",
    desc: "\u5DE5\u5177\u65B9\u6CD5\u5305",
    type: "Non-Open-Source",
    install: false,
    home: "https://gsap.com/",
    tags: ["Web\u52A8\u753B\u5E93", "animate", "Non-Open-Source"]
  },
  {
    name: "lodash",
    label: "lodash",
    desc: "\u5DE5\u5177\u65B9\u6CD5\u5305",
    github: "lodash/lodash",
    home: "https://www.lodashjs.com/",
    license: "MIT",
    tags: ["javascript", "modules", "utilities", "lodash"]
  },
  {
    name: "http-server",
    label: "http-server",
    desc: "\u96F6\u914D\u7F6E\u547D\u4EE4\u884C\u9759\u6001HTTP\u670D\u52A1\u5668",
    github: "http-party/http-server",
    tags: ["http", "server", "http-server"]
  },
  {
    name: "zustand",
    label: "zustand",
    desc: "React \u72B6\u6001\u7BA1\u7406",
    github: "pmndrs/zustand",
    home: "https://docs.pmnd.rs/zustand/getting-started/introduction",
    tags: [
      "react",
      "redux",
      "hooks",
      "state-management",
      "reactjs",
      "hacktoberfest",
      "react-context"
    ]
  },
  {
    name: "abandonjs",
    label: "abandonjs",
    github: "abandonjs/abandonjs",
    desc: "\u5DE5\u5177\u65B9\u6CD5\u5305",
    tags: [
      "javascript",
      "typescript",
      "js",
      "npm-package",
      "ts",
      "method",
      "utilities"
    ]
  }
];

;// CONCATENATED MODULE: ./src/views/package/utils.ts
const adapter = (_) => {
  if (_.logo && _.logo.indexOf("http") === -1) {
    _.logo = "http://www.google.com/s2/favicons?domain=" + _.logo;
  }
  if (_.name) {
    const shields = _.shields || [];
    if (_.type === "Non-Open-Source") {
      shields.push({
        type: "Non-Open-Source",
        url: "Non-Open-Source",
        logo: "Non-Open-Source"
      });
    } else {
      shields.push({
        url: `https://www.npmjs.com/package/${_.name}`,
        logo: `https://img.shields.io/npm/v/${_.name}.svg?style=flat`
      });
      if (_.github) {
        shields.push({
          url: "https://github.com/" + _.github,
          logo: `https://img.shields.io/badge/github-blue.svg`
        });
        shields.push({
          url: _.licensePath || `https://github.com/${_.github}/blob/main/LICENSE`,
          logo: `https://img.shields.io/badge/license-${_.license !== "MIT" && _.license ? _.license + "-orange" : "MIT-green"}`
        });
      }
    }
    _.shields = shields;
  }
  return _;
};

;// CONCATENATED MODULE: ./src/views/package/index.tsx
var package_defProp = Object.defineProperty;
var package_getOwnPropSymbols = Object.getOwnPropertySymbols;
var package_hasOwnProp = Object.prototype.hasOwnProperty;
var package_propIsEnum = Object.prototype.propertyIsEnumerable;
var package_defNormalProp = (obj, key, value) => key in obj ? package_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var package_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (package_hasOwnProp.call(b, prop))
      package_defNormalProp(a, prop, b[prop]);
  if (package_getOwnPropSymbols)
    for (var prop of package_getOwnPropSymbols(b)) {
      if (package_propIsEnum.call(b, prop))
        package_defNormalProp(a, prop, b[prop]);
    }
  return a;
};







const handleClick = (item) => {
  if (item.home) {
    window.open(item.home, "_blank");
    return;
  }
  window.open(`https://www.npmjs.com/package/${item.name}`, "_blank");
};
const Logo = (props) => {
  const [status, setStatus] = react.useState(false);
  const { logo, label } = props;
  return /* @__PURE__ */ react.createElement("div", { className: "logo-layout" }, /* @__PURE__ */ react.createElement("span", { className: index_esm_A("logo-layout-label", { hidden: status }) }, label.slice(0, 1).toUpperCase()), /* @__PURE__ */ react.createElement("span", { className: index_esm_A("logo-layout-img", { hidden: !status }) }, logo && /* @__PURE__ */ react.createElement("img", { src: logo, alt: "logo", onLoad: () => setStatus(true) })));
};
function Pkg() {
  return /* @__PURE__ */ react.createElement("div", { className: "package" }, /* @__PURE__ */ react.createElement("div", { className: "layout" }, pkgConf.map((unit, i) => {
    const _ = adapter(unit);
    return /* @__PURE__ */ react.createElement("div", { className: "card", key: i }, /* @__PURE__ */ react.createElement("div", { className: "header", onClick: () => handleClick(_) }, /* @__PURE__ */ react.createElement("div", { className: "logo" }, /* @__PURE__ */ react.createElement(Logo, package_spreadValues({}, _))), /* @__PURE__ */ react.createElement("div", { className: "label" }, _.label)), _.desc && /* @__PURE__ */ react.createElement("div", { className: "desc" }, _.desc), _.install !== false && _.name && /* @__PURE__ */ react.createElement("div", { className: "install" }, /* @__PURE__ */ react.createElement(NPMCmd, { name: _.name })), isEffectArray(_.shields) && /* @__PURE__ */ react.createElement("div", { className: "shields" }, _.shields.map((item, i2) => {
      if (item.type === "Non-Open-Source") {
        return /* @__PURE__ */ react.createElement("span", { key: i2, className: "Non-Open-Source" }, "Non-Open-Source");
      }
      return /* @__PURE__ */ react.createElement("a", { key: i2, href: item.url, target: "_blank" }, /* @__PURE__ */ react.createElement("img", { src: item.logo }));
    })), isEffectArray(_.tags) && /* @__PURE__ */ react.createElement("div", { className: "tags" }, _.tags.map((tag, i2) => /* @__PURE__ */ react.createElement("div", { className: "tag", key: "tag" + i2 }, tag))));
  })));
}

// EXTERNAL MODULE: ./node_modules/.store/css-loader@6.11.0/node_modules/css-loader/dist/cjs.js!./node_modules/.store/less-loader@11.1.4/node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/layout/index.less
var layout = __webpack_require__(444);
;// CONCATENATED MODULE: ./src/layout/index.less

      
      
      
      
      
      
      
      
      

var layout_options = {};

layout_options.styleTagTransform = (styleTagTransform_default());
layout_options.setAttributes = (setAttributesWithoutAttributes_default());

      layout_options.insert = insertBySelector_default().bind(null, "head");
    
layout_options.domAPI = (styleDomAPI_default());
layout_options.insertStyleElement = (insertStyleElement_default());

var layout_update = injectStylesIntoStyleTag_default()(layout/* default */.A, layout_options);




       /* harmony default export */ const src_layout = (layout/* default */.A && layout/* default */.A.locals ? layout/* default */.A.locals : undefined);

;// CONCATENATED MODULE: ./src/layout/index.tsx



function Layout(props) {
  return /* @__PURE__ */ react.createElement("div", { className: "layout" }, /* @__PURE__ */ react.createElement(Outlet, null));
}

// EXTERNAL MODULE: ./node_modules/.store/css-loader@6.11.0/node_modules/css-loader/dist/cjs.js!./node_modules/.store/less-loader@11.1.4/node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/views/home/index.less
var home = __webpack_require__(434);
;// CONCATENATED MODULE: ./src/views/home/index.less

      
      
      
      
      
      
      
      
      

var home_options = {};

home_options.styleTagTransform = (styleTagTransform_default());
home_options.setAttributes = (setAttributesWithoutAttributes_default());

      home_options.insert = insertBySelector_default().bind(null, "head");
    
home_options.domAPI = (styleDomAPI_default());
home_options.insertStyleElement = (insertStyleElement_default());

var home_update = injectStylesIntoStyleTag_default()(home/* default */.A, home_options);




       /* harmony default export */ const views_home = (home/* default */.A && home/* default */.A.locals ? home/* default */.A.locals : undefined);

;// CONCATENATED MODULE: ./src/views/home/index.tsx



function Home() {
  const nav = dist_useNavigate();
  const list = [
    {
      name: "note",
      label: "Note"
    },
    {
      name: "pkg",
      label: "Package"
    }
  ];
  const handleClick = (item) => {
    nav(item.name);
  };
  return /* @__PURE__ */ react.createElement("div", { className: "home" }, /* @__PURE__ */ react.createElement("div", { className: "layout" }, list.map((item, i) => {
    return /* @__PURE__ */ react.createElement("div", { className: "card", key: i, onClick: () => handleClick(item) }, /* @__PURE__ */ react.createElement("div", { className: "logo" }, item.label.slice(0, 1)), /* @__PURE__ */ react.createElement("div", { className: "name" }, item.label));
  })));
}

// EXTERNAL MODULE: ./node_modules/.store/css-loader@6.11.0/node_modules/css-loader/dist/cjs.js!./node_modules/.store/aurad@1.4.2/node_modules/aurad/dist/style.css
var style = __webpack_require__(16);
;// CONCATENATED MODULE: ./node_modules/.store/aurad@1.4.2/node_modules/aurad/dist/style.css

      
      
      
      
      
      
      
      
      

var style_options = {};

style_options.styleTagTransform = (styleTagTransform_default());
style_options.setAttributes = (setAttributesWithoutAttributes_default());

      style_options.insert = insertBySelector_default().bind(null, "head");
    
style_options.domAPI = (styleDomAPI_default());
style_options.insertStyleElement = (insertStyleElement_default());

var style_update = injectStylesIntoStyleTag_default()(style/* default */.A, style_options);




       /* harmony default export */ const dist_style = (style/* default */.A && style/* default */.A.locals ? style/* default */.A.locals : undefined);

;// CONCATENATED MODULE: ./src/index.tsx








const routes = [
  {
    path: "/",
    element: /* @__PURE__ */ react.createElement(Layout, null),
    children: [
      {
        index: true,
        element: /* @__PURE__ */ react.createElement(Home, null)
      },
      {
        path: "/note",
        element: /* @__PURE__ */ react.createElement(Note, null)
      },
      {
        path: "/pkg",
        element: /* @__PURE__ */ react.createElement(Pkg, null)
      }
    ]
  }
];
function App() {
  return /* @__PURE__ */ react.createElement(dist_RouterProvider, { router: createHashRouter(routes) });
}
(0,client/* createRoot */.H)(document.getElementById("root")).render(/* @__PURE__ */ react.createElement(App, null));

/******/ })()
;